<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Version 2.0.9.RELEASE">
<title>Spring Data JPA 参考文档</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Spring Data JPA 参考文档</h1>
<div class="details">
<span id="author" class="author">Version 2.0.9.RELEASE</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#project">1. 项目信息</a></li>
<li><a href="#new-features">2. 新特性和值得注意的东西</a>
<ul class="sectlevel2">
<li><a href="#new-features.1-11-0">2.1. Spring Data JPA 1.11中的新功能</a></li>
<li><a href="#new-features.1-10-0">2.2. Spring Data JPA 1.10中的新功能</a></li>
<li><a href="#dependencies.spring-boot">2.3. Spring Boot的依赖管理</a></li>
<li><a href="#dependencies.spring-framework">2.4. Spring框架</a></li>
</ul>
</li>
<li><a href="#repositories">3. 使用Spring Data存储库</a>
<ul class="sectlevel2">
<li><a href="#repositories.core-concepts">3.1. 核心概念</a></li>
<li><a href="#repositories.query-methods">3.2. 查询方法</a></li>
<li><a href="#repositories.definition">3.3. 定义存储库接口</a>
<ul class="sectlevel3">
<li><a href="#repositories.definition-tuning">3.3.1. 微调存储库定义</a></li>
<li><a href="#repositories.nullability">3.3.2. 存储库方法的null处理</a></li>
<li><a href="#repositories.multiple-modules">3.3.3. 使用具有多个Spring Data模块的存储库</a></li>
</ul>
</li>
<li><a href="#repositories.query-methods.details">3.4. 定义查询方法</a>
<ul class="sectlevel3">
<li><a href="#repositories.query-methods.query-lookup-strategies">3.4.1. 查询查找策略</a></li>
<li><a href="#repositories.query-methods.query-creation">3.4.2. 查询创建</a></li>
<li><a href="#repositories.query-methods.query-property-expressions">3.4.3. 属性表达式</a></li>
<li><a href="#repositories.special-parameters">3.4.4. 特殊参数处理</a></li>
<li><a href="#repositories.limit-query-result">3.4.5. 限制查询结果</a></li>
<li><a href="#repositories.query-streaming">3.4.6. 流式查询结果</a></li>
<li><a href="#repositories.query-async">3.4.7. 异步查询结果</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances">3.5. 创建存储库实例</a>
<ul class="sectlevel3">
<li><a href="#repositories.create-instances.spring">3.5.1. XML配置</a></li>
<li><a href="#repositories.create-instances.java-config">3.5.2. Java配置</a></li>
<li><a href="#repositories.create-instances.standalone">3.5.3. 独立使用</a></li>
</ul>
</li>
<li><a href="#repositories.custom-implementations">3.6. Spring Data Repositories的自定义实现</a>
<ul class="sectlevel3">
<li><a href="#repositories.single-repository-behavior">3.6.1. 自定义单个存储库</a></li>
<li><a href="#repositories.customize-base-repository">3.6.2. 自定义基础Repository</a></li>
</ul>
</li>
<li><a href="#core.domain-events">3.7. 从聚合根发布事件</a></li>
<li><a href="#core.extensions">3.8. Spring Data扩展</a>
<ul class="sectlevel3">
<li><a href="#core.extensions.querydsl">3.8.1. Querydsl扩展</a></li>
<li><a href="#core.web">3.8.2. Web支持</a></li>
<li><a href="#core.repository-populators">3.8.3. 存储库填充</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.repositories">4. JPA存储库</a>
<ul class="sectlevel2">
<li><a href="#jpa.introduction">4.1. 介绍</a>
<ul class="sectlevel3">
<li><a href="#jpa.namespace">4.1.1. Spring命名空间</a></li>
<li><a href="#jpa.java-config">4.1.2. 基于注解的配置</a></li>
</ul>
</li>
<li><a href="#jpa.entity-persistence">4.2. 持久化实体</a>
<ul class="sectlevel3">
<li><a href="#jpa.entity-persistence.saving-entites">4.2.1. 保存实体</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods">4.3. 查询方法</a>
<ul class="sectlevel3">
<li><a href="#jpa.sample-app.finders.strategies">4.3.1. 查询查找策略</a></li>
<li><a href="#jpa.query-methods.query-creation">4.3.2. 查询创建</a></li>
<li><a href="#jpa.query-methods.named-queries">4.3.3. 使用JPA命名查询</a></li>
<li><a href="#jpa.query-methods.at-query">4.3.4. 使用 <code>@Query</code></a></li>
<li><a href="#jpa.query-methods.sorting">4.3.5. 使用排序</a></li>
<li><a href="#jpa.named-parameters">4.3.6. 使用命名参数</a></li>
<li><a href="#jpa.query.spel-expressions">4.3.7. 使用SpEL表达式</a></li>
<li><a href="#jpa.modifying-queries">4.3.8. 修改查询</a></li>
<li><a href="#jpa.query-hints">4.3.9. 应用查询提示</a></li>
<li><a href="#jpa.entity-graph">4.3.10. 配置Fetch-和LoadGraphs</a></li>
<li><a href="#projections">4.3.11. 投影</a></li>
</ul>
</li>
<li><a href="#jpa.stored-procedures">4.4. 存储过程</a></li>
<li><a href="#specifications">4.5. 规范</a></li>
<li><a href="#query-by-example">4.6. 按示例查询</a>
<ul class="sectlevel3">
<li><a href="#query-by-example.introduction">4.6.1. 介绍</a></li>
<li><a href="#query-by-example.usage">4.6.2. 用法</a></li>
<li><a href="#query-by-example.matchers">4.6.3. 示例匹配器</a></li>
<li><a href="#query-by-example.execution">4.6.4. 执行示例</a></li>
</ul>
</li>
<li><a href="#transactions">4.7. 事务</a>
<ul class="sectlevel3">
<li><a href="#transactional-query-methods">4.7.1. 事务性查询方法</a></li>
</ul>
</li>
<li><a href="#locking">4.8. 锁</a></li>
<li><a href="#auditing">4.9. 审计</a>
<ul class="sectlevel3">
<li><a href="#auditing.basics">4.9.1. 基础</a></li>
<li><a href="#jpa.auditing">4.9.2. JPA审计</a></li>
</ul>
</li>
<li><a href="#jpa.misc">4.10. 其他考虑因素</a>
<ul class="sectlevel3">
<li><a href="#jpa.misc.jpa-context">4.10.1. 在自定义实现中使用 <code>JpaContext</code></a></li>
<li><a href="#jpa.misc.merging-persistence-units">4.10.2. 合并持久性单元</a></li>
<li><a href="#jpd.misc.cdi-integration">4.10.3. CDI集成</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix">5. 附录</a>
<ul class="sectlevel2">
<li><a href="#repositories.namespace-reference">5.1. 命名空间参考</a>
<ul class="sectlevel3">
<li><a href="#__code_repositories_code_元素">5.1.1. <code>&lt;repositories/&gt;</code> 元素</a></li>
</ul>
</li>
<li><a href="#populator.namespace-reference">5.2. Populators命名空间参考</a>
<ul class="sectlevel3">
<li><a href="#__code_populator_code_元素">5.2.1. <code>&lt;populator/&gt;</code> 元素</a></li>
</ul>
</li>
<li><a href="#repository-query-keywords">5.3. 存储库查询关键字</a>
<ul class="sectlevel3">
<li><a href="#_支持的查询关键字">5.3.1. 支持的查询关键字</a></li>
</ul>
</li>
<li><a href="#repository-query-return-types">5.4. 存储库查询返回类型</a>
<ul class="sectlevel3">
<li><a href="#_支持的查询返回类型">5.4.1. 支持的查询返回类型</a></li>
</ul>
</li>
<li><a href="#faq">5.5. FAQ</a>
<ul class="sectlevel3">
<li><a href="#_常见">5.5.1. 常见</a></li>
<li><a href="#_基础设施">5.5.2. 基础设施</a></li>
<li><a href="#_审计">5.5.3. 审计</a></li>
</ul>
</li>
<li><a href="#glossary">5.6. 词汇表</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>前言</p>
</div>
<div class="paragraph">
<p>Spring Data JPA为Java Persistence API（JPA）提供存储库支持。它使访问JPA数据源的应用程序开发变得更加简单。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="project">1. 项目信息</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>版本控制 - <a href="http://github.com/spring-projects/spring-data-jpa" class="bare">http://github.com/spring-projects/spring-data-jpa</a></p>
</li>
<li>
<p>Bug追踪 - <a href="https://jira.spring.io/browse/DATAJPA" class="bare">https://jira.spring.io/browse/DATAJPA</a></p>
</li>
<li>
<p>发行版仓库 - <a href="https://repo.spring.io/libs-release" class="bare">https://repo.spring.io/libs-release</a></p>
</li>
<li>
<p>里程碑版仓库 - <a href="https://repo.spring.io/libs-milestone" class="bare">https://repo.spring.io/libs-milestone</a></p>
</li>
<li>
<p>快照版仓库 - <a href="https://repo.spring.io/libs-snapshot" class="bare">https://repo.spring.io/libs-snapshot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features">2. 新特性和值得注意的东西</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="new-features.1-11-0">2.1. Spring Data JPA 1.11中的新功能</h3>
<div class="ulist">
<ul>
<li>
<p>改进了与Hibernate 5.2的兼容性。</p>
</li>
<li>
<p>支持 <a href="#query-by-example">按示例查询</a>的任意匹配模式。</p>
</li>
<li>
<p>分页查询执行优化。</p>
</li>
<li>
<p>支持存储库查询派生中的 <code>exists</code> 投影。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.1-10-0">2.2. Spring Data JPA 1.10中的新功能</h3>
<div class="ulist">
<ul>
<li>
<p>支持存储库查询方法中的 <a href="#projections">投影</a>。</p>
</li>
<li>
<p>支持 <a href="#query-by-example">按示例查询</a>。</p>
</li>
<li>
<p>已启用以下注解以构建组合注解：<code>@EntityGraph</code>, <code>@Lock</code>, <code>@Modifying</code>, <code>@Query</code>, <code>@QueryHints</code> 和 <code>@Procedure</code>。</p>
</li>
<li>
<p>支持集合表达式上的 <code>Contains</code> 关键字。</p>
</li>
<li>
<p>增加JSR-310和ThreeTenBP的 <code>ZoneId</code> 的 <code>AttributeConverter</code> 实现。</p>
</li>
<li>
<p>升级到Querydsl 4，Hibernate 5，OpenJPA 2.4和EclipseLink 2.6.1。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于各个Spring Data模块的创建日期不同，因此大多数模块都带有不同的主，次要版本号。找到兼容版本的最简单方法是依赖我们
提供的Spring Data Release Train BOM。在Maven项目中，你将在POM的 <code>&lt;dependencyManagement/&gt;</code> 部分中声明此依赖项，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. 使用Spring Data Release Train BOM</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencyManagement&gt;</span>
  <span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
      <span class="tag">&lt;groupId&gt;</span>org.springframework.data<span class="tag">&lt;/groupId&gt;</span>
      <span class="tag">&lt;artifactId&gt;</span>spring-data-releasetrain<span class="tag">&lt;/artifactId&gt;</span>
      <span class="tag">&lt;version&gt;</span>${release-train}<span class="tag">&lt;/version&gt;</span>
      <span class="tag">&lt;scope&gt;</span>import<span class="tag">&lt;/scope&gt;</span>
      <span class="tag">&lt;type&gt;</span>pom<span class="tag">&lt;/type&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
  <span class="tag">&lt;/dependencies&gt;</span>
<span class="tag">&lt;/dependencyManagement&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>目前的发布版本是 <code>Kay-SR9</code>。列车名称按字母顺序上升，此处列出了当前可用的列车。
版本名称遵循以下模式：<code>${name}-${release}</code>，其中release可以是以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BUILD-SNAPSHOT: 当前快照版</p>
</li>
<li>
<p>M1, M2等：里程碑版</p>
</li>
<li>
<p>RC1, RC2等：发行版候选人</p>
</li>
<li>
<p>RELEASE: GA发行版</p>
</li>
<li>
<p>SR1, SR2等：服务发行版</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以在 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data示例存储库</a>中找到使用BOM的工作示例。
有了这个，你可以在 <code>&lt;dependencies/&gt;</code> 块中声明你想要使用的Spring Data模块而不需要版本，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. 声明对Spring Data模块的依赖</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependencies&gt;</span>
  <span class="tag">&lt;dependency&gt;</span>
    <span class="tag">&lt;groupId&gt;</span>org.springframework.data<span class="tag">&lt;/groupId&gt;</span>
    <span class="tag">&lt;artifactId&gt;</span>spring-data-jpa<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;dependencies&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-boot">2.3. Spring Boot的依赖管理</h3>
<div class="paragraph">
<p>Spring Boot为你选择最新版本的Spring Data模块。如果你仍想升级到更新版本，请将属性 <code>spring-data-releasetrain.version</code>
配置为你要使用的列车名称和迭代版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-framework">2.4. Spring框架</h3>
<div class="paragraph">
<p>当前版本的Spring Data模块需要版本5.0.8.RELEASE或更高版本的Spring框架。这些模块也可以使用该次要版本的旧版本。
但是，强烈建议使用该代中的最新版本。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repositories">3. 使用Spring Data存储库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data存储库抽象的目标是 <strong>显着减少为各种持久性存储实现数据访问层所需的样板代码量</strong>。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Data存储库文档和你的模块。</p>
</div>
<div class="paragraph">
<p>本章介绍Spring Data存储库的核心概念和接口。本章中的信息来自Spring Data Commons模块。
它使用Java Persistence API（JPA）模块的配置和代码示例。
你应该将XML名称空间声明和要扩展的类型调整为你所使用的特定模块的等效项。
<a href="#repositories.namespace-reference">命名空间参考</a> 涵盖了XML配置参考，支持存储库API的所有Spring Data模块都支持XML配置。
<a href="#repository-query-keywords">存储库查询关键字</a> 涵盖了存储库抽象支持的查询方法关键字。有关模块特定功能的详细信息，请参阅本文档该模块的章节。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="repositories.core-concepts">3.1. 核心概念</h3>
<div class="paragraph">
<p>Spring Data存储库抽象中的中央接口是 <code>Repository</code>。它将域类以及域类的ID类型作为类型参数进行管理。
此接口主要用作标记接口，用于捕获要使用的类型，并帮助你发现实现它的接口。
<code>CrudRepository</code> 为正在管理的实体类提供复杂的CRUD功能。</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. <code>CrudRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">CrudRepository</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt;
  <span class="directive">extends</span> Repository&lt;T, ID&gt; {

  &lt;S <span class="directive">extends</span> T&gt; S save(S entity);      <i class="conum" data-value="1"></i><b>(1)</b>

  Optional&lt;T&gt; findById(ID primaryKey); <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="predefined-type">Iterable</span>&lt;T&gt; findAll();               <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="type">long</span> count();                        <i class="conum" data-value="4"></i><b>(4)</b>

  <span class="type">void</span> delete(T entity);               <i class="conum" data-value="5"></i><b>(5)</b>

  <span class="type">boolean</span> existsById(ID primaryKey);   <i class="conum" data-value="6"></i><b>(6)</b>

  <span class="comment">// … 省略了更多功能</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>保存给定的实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回由给定ID标识的实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回所有实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回实体数量。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>删除给定的实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>指示给定ID的实体是否存在。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们还提供特定于持久性技术的抽象，例如 <code>JpaRepository</code> 或 <code>MongoRepository</code>。
除了相当通用的持久性技术无关的接口（如 <code>CrudRepository</code> ）之外，
这些接口还扩展了 <code>CrudRepository</code> 并公开了特定于底层持久性技术的功能。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 <code>CrudRepository</code> 之上，有一个 <code>PagingAndSortingRepository</code> 抽象，它添加了额外的方法来简化对实体的分页访问：</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. <code>PagingAndSortingRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">PagingAndSortingRepository</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt;
  <span class="directive">extends</span> CrudRepository&lt;T, ID&gt; {

  <span class="predefined-type">Iterable</span>&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(<span class="predefined-type">Pageable</span> pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要访问 <code>User</code> 的第二页且每页20个，你可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">PagingAndSortingRepository&lt;User, <span class="predefined-type">Long</span>&gt; repository = <span class="comment">// … 获得对bean的访问权限</span>
Page&lt;User&gt; users = repository.findAll(<span class="keyword">new</span> PageRequest(<span class="integer">1</span>, <span class="integer">20</span>)); <span class="comment">// 注意第一页从0开始</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除查询方法外，还可以使用计数和删除查询的查询派生。</p>
</div>
<div class="paragraph">
<p>以下列表显示派生计数查询的接口定义：</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. 派生计数查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="type">long</span> countByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下列表显示了派生删除查询的接口定义：</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 派生删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="type">long</span> deleteByLastname(<span class="predefined-type">String</span> lastname);

  <span class="predefined-type">List</span>&lt;User&gt; removeByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods">3.2. 查询方法</h3>
<div class="paragraph">
<p>标准CRUD功能存储库通常对底层数据存储库进行查询。使用Spring Data，声明这些查询将分为四个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>声明继承 <code>Repository</code> 或其子接口之一的接口，并键入它应处理的域类和ID类型，如以下示例所示：</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">Long</span>&gt; { <span class="error">…</span> }</code></pre>
</div>
</div>
</li>
<li>
<p>在接口中声明查询方法。</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">Long</span>&gt; {
  <span class="predefined-type">List</span>&lt;Person&gt; findByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</li>
<li>
<p>设置Spring以使用 <a href="#repositories.create-instances.java-config">Java配置</a> 或
<a href="#repositories.create-instances">XML配置</a> 为这些接口创建代理实例。</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>要使用Java配置，请创建类似于以下内容的类：</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">org.springframework.data.jpa.repository.config.EnableJpaRepositories</span>;

<span class="annotation">@EnableJpaRepositories</span>
<span class="type">class</span> <span class="class">Config</span> {}</code></pre>
</div>
</div>
</li>
<li>
<p>要使用XML配置，请定义类似于以下内容的bean：</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">xmlns:jpa</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/data/jpa</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
     <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
     <span class="content">http://www.springframework.org/schema/data/jpa</span>
     <span class="content">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

   <span class="tag">&lt;jpa:repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>在此示例中使用JPA命名空间。如果对任何其他存储使用存储库抽象，则需要将其声明为特定于存储模块的相应命名空间。
换句话说，例如你使用MongoDB则需要将 <code>jpa</code> 更改为 <code>mongodb</code>。</p>
</div>
<div class="paragraph">
<p>+
另请注意，JavaConfig配置未显式设置包，因为默认情况下使用带该注解的类的包。
要自定义要扫描的包，请使用特定于数据存储库的 <code>@Enable${store}Repositories</code> 注解的 <code>basePackage</code> 属性。</p>
</div>
</li>
<li>
<p>注入存储库实例并使用它，如以下示例所示：</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">SomeClient</span> {

  <span class="directive">private</span> <span class="directive">final</span> PersonRepository repository;

  SomeClient(PersonRepository repository) {
    <span class="local-variable">this</span>.repository = repository;
  }

  <span class="type">void</span> doSomething() {
    <span class="predefined-type">List</span>&lt;Person&gt; persons = repository.findByLastname(<span class="string"><span class="delimiter">&quot;</span><span class="content">Matthews</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下各节详细说明了每个步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#repositories.definition">定义存储库接口</a></p>
</li>
<li>
<p><a href="#repositories.query-methods.details">定义查询方法</a></p>
</li>
<li>
<p><a href="#repositories.create-instances">创建存储库实例</a></p>
</li>
<li>
<p><a href="#repositories.custom-implementations">Spring Data Repositories的自定义实现</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="repositories.definition">3.3. 定义存储库接口</h3>
<div class="paragraph">
<p>首先，定义特定于域类的存储库接口。接口必须扩展 <code>Repository</code> 并键入域类和ID类型。如果要公开该域类型的CRUD方法，请扩展 <code>CrudRepository</code> 而不是 <code>Repository</code>。</p>
</div>
<div class="sect3">
<h4 id="repositories.definition-tuning">3.3.1. 微调存储库定义</h4>
<div class="paragraph">
<p>通常，存储库接口扩展了 <code>Repository</code>，<code>CrudRepository</code> 或 <code>PagingAndSortingRepository</code>。或者，如果你不想扩展Spring Data接口，还可以使用 <code>@RepositoryDe​​finition</code> 标注存储库接口。扩展 <code>CrudRepository</code> 暴露了一整套操作实体的方法。如果你希望对所公开的方法有选择性，请将要从
<code>CrudRepository</code> 公开的方法复制到域存储库中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这样做可以让你在提供的Spring Data Repositories功能之上定义自己的抽象存储库。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何有选择地公开CRUD方法（在本例中为 <code>findById</code> 和 <code>save</code>）：</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. 有选择地暴露CRUD方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@NoRepositoryBean</span>
<span class="type">interface</span> <span class="class">MyBaseRepository</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt; <span class="directive">extends</span> Repository&lt;T, ID&gt; {

  Optional&lt;T&gt; findById(ID id);

  &lt;S <span class="directive">extends</span> T&gt; S save(S entity);
}

<span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> MyBaseRepository&lt;User, <span class="predefined-type">Long</span>&gt; {
  User findByEmailAddress(EmailAddress emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，你为所有域存储库定义了一个公共基本接口，并公开了 <code>findById(&#8230;&#8203;)</code> 以及 <code>save(&#8230;&#8203;)</code>。这些方法被路由到Spring Data提供的所选存储的基本存储库实现中（例如，如果你使用JPA，则实现是SimpleJpaRepository），因为它们与 <code>CrudRepository</code> 中的方法签名匹配。因此，<code>UserRepository</code> 现在可以保存用户，按ID查找单个用户，通过电子邮件地址查找用户。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
中间存储库接口需要添加 <code>@NoRepositoryBean</code> 注解。它会确保Spring Data不应在运行时创建该存储库接口的实例。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.nullability">3.3.2. 存储库方法的null处理</h4>
<div class="paragraph">
<p>从Spring Data 2.0开始，可以使用Java 8的 <code>Optional</code> 来指示存储库的CRUD方法所返回单个实例可能缺少值。
除此之外，Spring Data支持在查询方法上返回以下包装类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.google.common.base.Optional</code></p>
</li>
<li>
<p><code>scala.Option</code></p>
</li>
<li>
<p><code>io.vavr.control.Option</code></p>
</li>
<li>
<p><code>javaslang.control.Option</code> (已弃用，不推荐使用Javaslang)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>或者，查询方法可以选择根本不使用包装类型。然后通过返回 <code>null</code> 来指示缺少查询结果。
保证返回集合，集合替代，包装器和流的存储库方法永远不会返回 <code>null</code>，而是返回相应的空表示。
有关详细信息，请参阅 “<a href="#repository-query-return-types">存储库查询返回类型</a>”。</p>
</div>
<div class="sect4">
<h5 id="repositories.nullability.annotations">可空性注解</h5>
<div class="paragraph">
<p>你可以使用 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/core.html#null-safety">Spring Framework的可空性注解</a> 来表达存储库方法的可空性约束。
它们在运行时提供了一种 <strong>工具友好</strong> 的方法和opt-in <code>null</code> 检查，如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: 在包级别上使用，
以声明参数和返回值的默认行为是不接受或生成 <code>null</code> 值。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>: 用于不能为 <code>null</code> 的参数或返回值
（对于 <code>@NonNullApi</code> 适用的参数和返回值则不需要再加）。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: 用于可以为 <code>null</code> 的参数或返回值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring注解是使用 <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注解进行元注释的（一种隐匿的但广泛传播的JSR）。
JSR 305元注释允许 <a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>，
<a href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a>和
<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a>
等工具供应商以通用方式提供null安全支持，而无需对Spring注解进行硬编码支持。要为查询方法启用运行时检查可空性约束，
需要在 <code>package-info.java</code> 中使用Spring的 <code>@NonNullApi</code> 来激活包级别的非可空性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. 在package-info.java中声明不可为空性</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@org</span>.springframework.lang.NonNullApi
<span class="keyword">package</span> <span class="namespace">com.acme</span>;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦存在非空默认，就会在运行时验证存储库查询方法调用的可空性约束。如果查询执行结果违反了定义的约束，则抛出异常。
这种情况发生在当方法返回null但声明为非可空时（默认情况下，在存储库所在的包中定义了注解）。
如果你想再次选择使某方法可以返回为 <code>null</code> 的结果，请在该方法上选择使用 <code>@Nullable</code>。使用本节开头提到的结果包装器类型
则继续按预期工作：将空结果转换为表示缺席的 <code>Optional</code> 值。</p>
</div>
<div class="paragraph">
<p>以下示例显示了刚才描述的许多技术：</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. 使用不同的可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.acme</span>;                                                       <i class="conum" data-value="1"></i><b>(1)</b>

<span class="keyword">import</span> <span class="include">org.springframework.lang.Nullable</span>;

<span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  User getByEmailAddress(EmailAddress emailAddress);                    <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="annotation">@Nullable</span>
  User findByEmailAddress(<span class="annotation">@Nullable</span> EmailAddress emailAdress);          <i class="conum" data-value="3"></i><b>(3)</b>

  Optional&lt;User&gt; findOptionalByEmailAddress(EmailAddress emailAddress); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>存储库包（或子包）中，我们已定义了非空行为。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当执行的查询未产生结果时，抛出 <code>EmptyResultDataAccessException</code>。
当传递给方法的 <code>emailAddress</code> 为 <code>null</code> 时，抛出 <code>IllegalArgumentException</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当执行的查询未产生结果时返回 <code>null</code>。同时接受 <code>null</code> 作为 <code>emailAddress</code> 的值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>当执行的查询没有产生结果时返回 <code>Optional.empty()</code>。当传递给方法的 <code>emailAddress</code> 为 <code>null</code> 时，抛出 <code>IllegalArgumentException</code>。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.nullability.kotlin">基于Kotlin的存储库中的可空性</h5>
<div class="paragraph">
<p>Kotlin对语言中的可空性约束进行了定义。Kotlin代码编译为字节码，它不通过方法签名表达可空性约束，而是通过编译元数据表达。
确保在项目中包含 <code>kotlin-reflect</code> JAR，以便对Kotlin的可空性约束进行内省。
Spring Data存储库使用语言机制来定义这些约束以应用相同的运行时检查，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. 在Kotlin存储库中使用可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="kotlin">interface UserRepository : Repository&lt;User, String&gt; {

  fun findByUsername(username: String): User     <i class="conum" data-value="1"></i><b>(1)</b>

  fun findByFirstname(firstname: String?): User? <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该方法将参数和结果都定义为非可空（Kotlin默认值）。Kotlin编译器拒绝将 <code>null</code> 传递给方法以进行方法调用。
如果查询执行产生空结果，则抛出 <code>EmptyResultDataAccessException</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>此方法对firstname参数接受 <code>null</code>，如果查询执行不生成结果，则返回 <code>null</code>。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.multiple-modules">3.3.3. 使用具有多个Spring Data模块的存储库</h4>
<div class="paragraph">
<p>在应用程序中使用唯一的Spring Data模块会使事情变得简单，因为定义范围内的所有存储库接口都绑定到该Spring Data模块。
有时，应用程序需要使用多个Spring Data模块。在这种情况下，存储库定义必须区分持久性技术。
当它在类路径上检测到多种存储库工厂时，Spring Data进入严格的存储库配置模式。
严格配置使用存储库或域类的详细信息来确定存储库定义的Spring Data模块绑定：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果存储库定义 <a href="#repositories.multiple-modules.types">继承了特定于模块的存储库</a>，那么它是特定Spring Data模块的有效候选者。</p>
</li>
<li>
<p>如果使用 <a href="#repositories.multiple-modules.annotations">特定于模块的类型注解</a> 对域类进行注释，则它是特定Spring Data模块的有效候选者。Spring Data模块接受第三方注解
（例如JPA的 <code>@Entity</code>）或存储库已提供的自定义注解（例如Spring Data MongoDB和Spring Data Elasticsearch的 <code>@Document</code>）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示了使用特定于模块的接口的存储库（在本例中为JPA）：</p>
</div>
<div id="repositories.multiple-modules.types" class="exampleblock">
<div class="title">Example 11. 使用特定于模块的接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">MyRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; { }

<span class="annotation">@NoRepositoryBean</span>
<span class="type">interface</span> <span class="class">MyBaseRepository</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt; <span class="directive">extends</span> JpaRepository&lt;T, ID&gt; {
  <span class="error">…</span>
}

<span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> MyBaseRepository&lt;User, <span class="predefined-type">Long</span>&gt; {
  <span class="error">…</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MyRepository</code> 和 <code>UserRepository</code> 在其类型层次结构中继承 <code>JpaRepository</code>，因此它们是Spring Data JPA模块的有效候选者。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用通用接口的存储库：</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. 使用通用接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">AmbiguousRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {
 <span class="error">…</span>
}

<span class="annotation">@NoRepositoryBean</span>
<span class="type">interface</span> <span class="class">MyBaseRepository</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt; <span class="directive">extends</span> CrudRepository&lt;T, ID&gt; {
  <span class="error">…</span>
}

<span class="type">interface</span> <span class="class">AmbiguousUserRepository</span> <span class="directive">extends</span> MyBaseRepository&lt;User, <span class="predefined-type">Long</span>&gt; {
  <span class="error">…</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AmbiguousRepository</code> 和 <code>AmbiguousUserRepository</code> 在其类型层次结构中继承 <code>Repository</code> 和 <code>CrudRepository</code>。
虽然在使用单一的Spring Data模块时这是完全正常的，但是多个模块时无法区分这些存储库应该绑定到哪个特定的Spring Data。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用带注解的域类的存储库：</p>
</div>
<div id="repositories.multiple-modules.annotations" class="exampleblock">
<div class="title">Example 13. 使用带注解的域类的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">Long</span>&gt; {
 <span class="error">…</span>
}

<span class="annotation">@Entity</span>
<span class="type">class</span> <span class="class">Person</span> {
  <span class="error">…</span>
}

<span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {
 <span class="error">…</span>
}

<span class="annotation">@Document</span>
<span class="type">class</span> <span class="class">User</span> {
  <span class="error">…</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PersonRepository</code> 引用 <code>Person</code>，它使用JPA <code>@Entity</code> 注解进行批注，因此该存储库显然属于Spring Data JPA。
<code>UserRepository</code> 引用 <code>User</code>，它使用Spring Data MongoDB的 <code>@Document</code> 注解进行注释。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下错误示例显示了使用具有混合注解的域类的存储库：</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. 使用具有混合注解的域类的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">JpaPersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">Long</span>&gt; {
 <span class="error">…</span>
}

<span class="type">interface</span> <span class="class">MongoDBPersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">Long</span>&gt; {
 <span class="error">…</span>
}

<span class="annotation">@Entity</span>
<span class="annotation">@Document</span>
<span class="type">class</span> <span class="class">Person</span> {
  <span class="error">…</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例显示了使用JPA和Spring Data MongoDB注释的域类。它定义了两个存储库，<code>JpaPersonRepository</code> 和 <code>MongoDBPersonRepository</code>。
一个用于JPA，另一个用于MongoDB用法。Spring Data不再能够将存储库分开，从而导致未定义的行为。</p>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#repositories.multiple-modules.types">存储库类型详细信息</a> 和 <a href="#repositories.multiple-modules.annotations">区分域类注释</a>
用于严格存储库配置，以识别特定Spring Data模块的存储库候选。在同一域类型上使用多个持久性技术特定的注解是可能的，
并允许跨多种持久性技术重用域类型。但是，Spring Data不再能够确定用于绑定存储库的唯一模块。</p>
</div>
<div class="paragraph">
<p>区分存储库的最后一种方法是使用存储库基础包。基础包定义了扫描存储库接口定义的起点，这意味着你需要手动将存储库定义放在相应的包中。
默认情况下，基于注解驱动的配置使用该配置类的包，但 <a href="#repositories.create-instances.spring">基于XML的配置</a> 中的基本包是必需手动配置的。</p>
</div>
<div class="paragraph">
<p>以下示例显示了注解驱动的基础包配置：</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. 注解驱动的基础包配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@EnableJpaRepositories</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories.jpa</span><span class="delimiter">&quot;</span></span>)
<span class="annotation">@EnableMongoRepositories</span>(basePackages = <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories.mongo</span><span class="delimiter">&quot;</span></span>)
<span class="type">interface</span> <span class="class">Configuration</span> { }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods.details">3.4. 定义查询方法</h3>
<div class="paragraph">
<p>存储库代理有两种方法可以从方法名称派生特定于仓储的查询：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从方法名称派生查询。</p>
</li>
<li>
<p>使用手动定义的查询。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可用选项取决于实际仓储。但是，必须有一个策略来决定如何创建实际查询。下一节将介绍可用策略选项。</p>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-lookup-strategies">3.4.1. 查询查找策略</h4>
<div class="paragraph">
<p>存储库基础结构可以使用以下策略来解析查询。使用XML配置，你可以通过 <code>query-lookup-strategy</code> 属性在命名空间配置策略。
对于Java配置，你可以使用 <code>Enable${store}Repositories</code> 注解的 <code>queryLookupStrategy</code> 属性。特定仓储可能不支持某些策略。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> 尝试从查询方法名称构造特定于仓储的查询。一般方法是从方法名称中删除一组已知的前缀，并解析方法的其余部分。
你可以在 <a href="#repositories.query-methods.query-creation">查询创建</a> 中阅读有关查询构造的更多信息。</p>
</li>
<li>
<p><code>USE_DECLARED_QUERY</code> 尝试查找声明的查询，如果找不到，则抛出异常。查询可以通过声明注解来定义，也可以通过其他方式声明。
查阅特定仓储的文档以查找该仓储​​存储的可用选项。如果存储库基础结构在引导时未找到该方法的声明查询，则启动将失败。</p>
</li>
<li>
<p><code>CREATE_IF_NOT_FOUND</code>（默认）结合 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>。它首先查找声明的查询，如果没有找到声明的查询，
它会创建一个基于自定义方法名称的查询。这是默认的查找策略，因此，如果你未明确配置任何内容，则使用此策略。
它允许通过方法名称快速查询，还可以根据需要引入声明的查询来自定义这些查询。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-creation">3.4.2. 查询创建</h4>
<div class="paragraph">
<p>Spring Data存储库基础结构中的查询构建器机制对于构建对存储库实体的约束查询很有用。该机制剥离来自于方法的前缀
<code>find&#8230;&#8203;By</code>，<code>read&#8230;&#8203;By</code>，<code>query&#8230;&#8203;By</code>，<code>count&#8230;&#8203;By</code>，和 <code>get&#8230;&#8203;By</code> 并解析其余部分。
introduction子句可以包含更多表达式，例如 <code>Distinct</code> 在要创建的查询上设置去重标志。但是，
第一个 <code>By</code> 用作分隔符来指示实际条件的开始。在最基本的层面上，你可以在实体属性上定义条件，并将它们与 <code>And</code> 和 <code>Or</code> 连接起来。
以下示例显示了如何创建大量查询：</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. 从方法名称创建查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="predefined-type">List</span>&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, <span class="predefined-type">String</span> lastname);

  <span class="comment">// 为查询启用distinct标志</span>
  <span class="predefined-type">List</span>&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">String</span> firstname);
  <span class="predefined-type">List</span>&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">String</span> firstname);

  <span class="comment">// 启用忽略单个属性的大小写</span>
  <span class="predefined-type">List</span>&lt;Person&gt; findByLastnameIgnoreCase(<span class="predefined-type">String</span> lastname);
  <span class="comment">// 启用忽略所有合适属性的大小写</span>
  <span class="predefined-type">List</span>&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(<span class="predefined-type">String</span> lastname, <span class="predefined-type">String</span> firstname);

  <span class="comment">// 为查询启用静态ORDER BY</span>
  <span class="predefined-type">List</span>&lt;Person&gt; findByLastnameOrderByFirstnameAsc(<span class="predefined-type">String</span> lastname);
  <span class="predefined-type">List</span>&lt;Person&gt; findByLastnameOrderByFirstnameDesc(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解析方法的实际结果取决于你为其创建查询的持久性存储。但是，有一些一般要注意的事项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表达式通常是属性遍历与可以连接的运算符相结合。你可以将属性表达式与 <code>AND</code> 和 <code>OR</code> 组合使用。
对于属性表达式，你还可以获得诸如 <code>Between</code>，<code>LessThan</code>，<code>GreaterThan</code> 和 <code>Like</code> 之类的运算符的支持。
支持的运算符可能因仓储而异，因此请参阅参考文档的相应部分。</p>
</li>
<li>
<p>方法解析器支持为各个属性设置 <code>IgnoreCase</code> 标志（例如，<code>findByLastnameIgnoreCase(&#8230;&#8203;)</code>）或支持忽略大小写的类型的所有属性
（通常是String实例 - 例如，<code>findByLastnameAndFirstnameAllIgnoreCase(&#8230;&#8203;)</code>）。是否支持忽略大小写可能因仓储而异，
因此请参阅参考文档中有关特定于仓储的查询方法的相关章节。</p>
</li>
<li>
<p>你可以通过将 <code>OrderBy</code> 子句附加到查询方法的引用属性以提供排序方向（<code>Asc</code> 或 <code>Desc</code>）来应用静态排序。
要创建支持动态排序的查询方法，请参阅 <a href="#repositories.special-parameters">特殊参数处理</a>。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-property-expressions">3.4.3. 属性表达式</h4>
<div class="paragraph">
<p>属性表达式只能引用被管理实体的直接属性，如前面的例子所示。在创建查询时，你已确保已解析的属性是托管域类的属性。
但是，你也可以通过遍历嵌套属性来定义约束。请考虑以下方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设 <code>Person</code> 有一个带 <code>ZipCode</code> 的 <code>Address</code>。在这种情况下，该方法创建属性遍历 <code>x.address.zipCode</code>。
解析算法首先将整个部分（<code>AddressZipCode</code>）解释为属性，并检查域类中是否具有该名称的属性（未大写）。如果查找成功，则使用该属性。
如果没有，算法 <strong>自右向左</strong> 在方法签名属性的驼峰处进行切割，分成头部和尾部，并试图找到相应的属性 -
在我们的示例中是 <code>AddressZip</code> 和 <code>Code</code>。如果算法找到具有该头部的属性，则会采用尾部并继续从那里构建查询树（以刚才描述的方式将尾部分开）。
如果第一个分割不匹配，算法会将分割点左移（Address，ZipCode）并继续检测。</p>
</div>
<div class="paragraph">
<p>虽然这适用于大多数情况，算法有可能选择错误的属性。假设 <code>Person</code> 类也有一个 <code>addressZip</code> 属性。
算法将在第一轮拆分中命中并选择错误的属性，然后失败（因为 <code>addressZip</code> 的类型可能没有 <code>code</code> 属性）。</p>
</div>
<div class="paragraph">
<p>要解决这种歧义，可以在方法名称中使用 <code>_</code> 来手动定义遍历点。所以我们的方法名称如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为我们将下划线字符视为保留字符，因此我们强烈建议你遵循标准的Java命名约定（即，不在属性名称中使用下划线，而使用驼峰）。</p>
</div>
</div>
<div class="sect3">
<h4 id="repositories.special-parameters">3.4.4. 特殊参数处理</h4>
<div class="paragraph">
<p>要处理查询中的参数，请定义方法参数，如前面示例中所示。除此之外，基础结构还可识别某些特定类型（如 <code>Pageable</code> 和 <code>Sort</code>），
以动态地对查询应用分页和排序。以下示例演示了这些功能：</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 在查询方法中使用 <code>Pageable</code>，<code>Slice</code> 和 <code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Page&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);

Slice&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);

<span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, Sort sort);

<span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一种方法允许你将 <code>org.springframework.data.domain.Pageable</code> 实例传递给查询方法，以动态地将分页添加到静态定义的查询中。
<code>Page</code> 知道可用的总元素数和总页数。内部通过触发 <code>count</code> 查询来实现计算总数。由于这可能很昂贵（取决于所使用的仓储），
你可以改为返回 <code>Slice</code>。<code>Slice</code> 只知道是否还有下一个 <code>Slice</code> 可用，这在遍历更大的结果集时可能就足够了。</p>
</div>
<div class="paragraph">
<p>排序选项也通过 <code>Pageable</code> 实例处理。如果只需要排序，请在方法中添加 <code>org.springframework.data.domain.Sort</code> 参数。
如你所见，也可以返回 <code>List</code>。在这种情况下，不会创建构建实际分页实例所需的其他元数据（这反过来意味着它不会发出必要的附加计数查询）。
相反，它限制查询仅查找给定范围的实体。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要了解实体究竟有多少页，你必须触发额外的计数查询。默认情况下，此查询是从你实际触发的查询派生的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.limit-query-result">3.4.5. 限制查询结果</h4>
<div class="paragraph">
<p>查询方法的结果可以通过使用 <code>first</code> 或 <code>top</code> 关键字来限制，这些关键字可以互换使用。
可选的数值可以附加到 <code>top</code> 或 <code>first</code>，以指定要返回的最大结果集的大小。如果省略该数字，则假定结果大小为1。
以下示例显示如何限制查询大小：</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. 使用Top和First限制查询的结果大小</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page&lt;User&gt; queryFirst10ByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);

Slice&lt;User&gt; findTop3ByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);

<span class="predefined-type">List</span>&lt;User&gt; findFirst10ByLastname(<span class="predefined-type">String</span> lastname, Sort sort);

<span class="predefined-type">List</span>&lt;User&gt; findTop10ByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>限制表达式也支持 <code>Distinct</code> 关键字。此外，对于将结果集限制为一个实例的查询，支持使用 <code>Optional</code> 关键字将结果包装。</p>
</div>
<div class="paragraph">
<p>如果将分页或切片应用于限制查询分页（以及可用页数的计算），则将其应用于已限制的结果集中。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过使用 <code>Sort</code> 参数将结果与动态排序结合使用，可以用于表达最小“K”个元素以及最大“K”个元素的查询方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-streaming">3.4.6. 流式查询结果</h4>
<div class="paragraph">
<p>可以使用Java 8 <code>Stream&lt;T&gt;</code> 作为返回类型以递增方式处理查询方法的结果，而不是将查询结果包装在 <code>Stream</code> 中，
使用数据存储的特定方法执行流式处理，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. 使用Java 8 <code>Stream&lt;T&gt;</code> 流式传输查询结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u</span><span class="delimiter">&quot;</span></span>)
Stream&lt;User&gt; findAllByCustomQueryAndStream();

Stream&lt;User&gt; readAllByFirstnameNotNull();

<span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u</span><span class="delimiter">&quot;</span></span>)
Stream&lt;User&gt; streamAllPaged(<span class="predefined-type">Pageable</span> pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Stream</code> 可能会包装基础数据存储特定的资源，因此必须在使用后关闭。
你可以使用 <code>close</code> 方法或使用Java 7 <code>try-with-resources</code> 块手动关闭 <code>Stream</code>，如以下示例所示：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 20. 使用try-with-resources块关闭 <code>Stream&lt;T&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) {
  stream.forEach(<span class="error">…</span>);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前并非所有Spring Data模块都支持 <code>Stream&lt;T&gt;</code> 作为返回类型。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-async">3.4.7. 异步查询结果</h4>
<div class="paragraph">
<p>可以使用 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/integration.html#scheduling">Spring的异步方法执行功能</a>
异步运行存储库查询。这意味着该方法在调用时立即返回，而实际的查询执行发生在已提交给Spring <code>TaskExecutor</code> 的任务中。
异步查询执行与响应式查询执行不同，不应混合使用。有关响应式查询支持的更多详细信息，请参阅特定于存储库的文档。
以下示例显示了一些异步查询：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Async</span>
<span class="predefined-type">Future</span>&lt;User&gt; findByFirstname(<span class="predefined-type">String</span> firstname);               <i class="conum" data-value="1"></i><b>(1)</b>

<span class="annotation">@Async</span>
CompletableFuture&lt;User&gt; findOneByFirstname(<span class="predefined-type">String</span> firstname); <i class="conum" data-value="2"></i><b>(2)</b>

<span class="annotation">@Async</span>
ListenableFuture&lt;User&gt; findOneByLastname(<span class="predefined-type">String</span> lastname);    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>java.util.concurrent.Future</code> 作为返回类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用Java 8 <code>java.util.concurrent.CompletableFuture</code> 作为返回类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>org.springframework.util.concurrent.ListenableFuture</code> 作为返回类型。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.create-instances">3.5. 创建存储库实例</h3>
<div class="paragraph">
<p>在本节中，你将为定义的存储库接口创建实例和bean定义。一种方法是使用随每个支持存储库机制的Spring Data模块一起提供的Spring命名空间，
尽管我们通常建议使用Java配置。</p>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.spring">3.5.1. XML配置</h4>
<div class="paragraph">
<p>每个Spring Data模块都包含一个存储库元素，允许你定义Spring扫描的基础包，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. 通过XML启用Spring Data存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans:beans</span> <span class="attribute-name">xmlns:beans</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/data/jpa</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
    <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
    <span class="content">http://www.springframework.org/schema/data/jpa</span>
    <span class="content">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;/beans:beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，指示Spring扫描 <code>com.acme.repositories</code> 及其所有子包，以查找继承 <code>Repository</code> 或其子接口的接口。
对于找到的每个接口，基础结构都会注册特定于持久性技术的 <code>FactoryBean</code>，以创建相应代理去处理查询方法调用。
每个bean都以接口名称命名（首字母小写），因此 <code>UserRepository</code> 的接口将在 <code>userRepository</code> 下注册。
<code>base-package</code> 属性允许使用通配符，以便你可以定义扫描包的模式。</p>
</div>
<div class="sect4">
<h5 id="_使用过滤器">使用过滤器</h5>
<div class="paragraph">
<p>默认情况下，基础结构会选择位于已配置的基本包下，继承特定于持久性技术的 <code>Repository</code> 子接口的每个接口，并为其创建一个bean实例。
但是，你可能希望对某些接口为其创建bean实例，进行更细粒度的控制。为此，请在 <code>&lt;repositories/&gt;</code> 元素中使用
<code>&lt;include-filter/&gt;</code> 和 <code>&lt;exclude-filter/&gt;</code> 元素。语义完全等同于Spring的上下文命名空间中的元素。
有关详细信息，请参阅这些元素的 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">Spring参考文档</a>。</p>
</div>
<div class="paragraph">
<p>例如，要排除某些接口从而不实例化为存储库bean，可以使用以下配置：</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. 使用exclude-filter元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;context:exclude-filter</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">regex</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">expression</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">.*SomeRepository</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="tag">&lt;/repositories&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例排除了以 <code>SomeRepository</code> 结尾的所有接口的实例化。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.java-config">3.5.2. Java配置</h4>
<div class="paragraph">
<p>还可以通过在JavaConfig类上使用特定于仓储的 <code>@Enable${store}Repositories</code> 注解来启用某种存储库基础设施。
有关Spring容器的基于Java的配置的介绍，请参阅 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/core.html#beans-java">Spring参考文档中的JavaConfig</a>。</p>
</div>
<div class="paragraph">
<p>启用S​​pring Data存储库的示例配置类似于以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. 基于注解的存储库配置示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableJpaRepositories</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">ApplicationConfiguration</span> {

  <span class="annotation">@Bean</span>
  EntityManagerFactory entityManagerFactory() {
    <span class="comment">// …</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上面的示例使用特定JPA的注解，你可以根据实际使用的存储库模块进行更改。这同样适用于 <code>EntityManagerFactory</code> bean的定义。
请参阅有关特定于仓储的配置的部分。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.standalone">3.5.3. 独立使用</h4>
<div class="paragraph">
<p>你还可以在Spring容器之外使用存储库基础结构 - 例如，在CDI环境中。你仍然需要在类路径中使用一些Spring库，
但通常也可以通过编程方式设置存储库。提供存储库支持的Spring Data模块提供了一个特定于持久性技术的 <code>RepositoryFactory</code>，
你可以按如下方式使用它：</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. 存储库工厂的独立使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">RepositoryFactorySupport factory = <span class="error">…</span> <span class="comment">// 在这里实例化工厂</span>
UserRepository repository = factory.getRepository(UserRepository.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.custom-implementations">3.6. Spring Data Repositories的自定义实现</h3>
<div class="paragraph">
<p>本节介绍存储库自定义以及片段如何构成复合存储库。</p>
</div>
<div class="paragraph">
<p>当查询方法需要不同的行为或无法通过查询派生实现时，则需要提供自定义实现。
Spring Data存储库允许你提供自定义存储库代码，并将其与通用CRUD抽象和查询方法功能集成。</p>
</div>
<div class="sect3">
<h4 id="repositories.single-repository-behavior">3.6.1. 自定义单个存储库</h4>
<div class="paragraph">
<p>要使用自定义功能丰富存储库，必须首先定义片段接口和自定义功能的实现，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 自定义存储库功能的片段接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">CustomizedUserRepository</span> {
  <span class="type">void</span> someCustomMethod(User user);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后，你可以让存储库接口继承片段接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. 自定义存储库功能的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">CustomizedUserRepositoryImpl</span> <span class="directive">implements</span> CustomizedUserRepository {

  <span class="directive">public</span> <span class="type">void</span> someCustomMethod(User user) {
    <span class="comment">// 你的自定义实现</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为片段接口实现类的名字添加 <code>Impl</code> 后缀很重要。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>实现本身不依赖于Spring Data，可以是常规的Spring bean。因此，你可以使用标准依赖项注入行为来注入对其他bean
（例如JdbcTemplate）的引用等等。</p>
</div>
<div class="paragraph">
<p>你可以让存储库接口继承自片段接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 存储库接口的更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt;, CustomizedUserRepository {

  <span class="comment">// 在这里声明查询方法</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用存储库接口继承片段接口可以组合CRUD和自定义功能，并使其可供客户端使用。</p>
</div>
<div class="paragraph">
<p>Spring Data存储库通过使用构成存储库组合的片段来实现。片段是基本存储库，特定功能方面（如 <a href="#core.extensions.querydsl">QueryDsl</a>），
自定义接口及其实现。每次向存储库接口添加接口时，都可以通过添加片段来增强组合。每个Spring Data模块都提供了基本存储库和存储库方面的实现。</p>
</div>
<div class="paragraph">
<p>以下示例显示了自定义接口及其实现：</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. 片段与它们的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">HumanRepository</span> {
  <span class="type">void</span> someHumanMethod(User user);
}

<span class="type">class</span> <span class="class">HumanRepositoryImpl</span> <span class="directive">implements</span> HumanRepository {

  <span class="directive">public</span> <span class="type">void</span> someHumanMethod(User user) {
    <span class="comment">// 你的自定义实现</span>
  }
}

<span class="type">interface</span> <span class="class">ContactRepository</span> {

  <span class="type">void</span> someContactMethod(User user);

  User anotherContactMethod(User user);
}

<span class="type">class</span> <span class="class">ContactRepositoryImpl</span> <span class="directive">implements</span> ContactRepository {

  <span class="directive">public</span> <span class="type">void</span> someContactMethod(User user) {
    <span class="comment">// 你的自定义实现</span>
  }

  <span class="directive">public</span> User anotherContactMethod(User user) {
    <span class="comment">// 你的自定义实现</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了继承 <code>CrudRepository</code> 的自定义存储库的接口：</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. 存储库接口的更改</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt;, HumanRepository, ContactRepository {

  <span class="comment">// 在这里声明查询方法</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>存储库可以由多个自定义实现组成，这些实现按其声明的顺序导入。自定义实现的优先级高于基本实现和存储库方面实现。
如果两个片段提供相同的方法签名，则此排序机制允许你覆盖基本存储库和存储库方面的方法并解决歧义。
存储库片段不限于在单个存储库接口中使用。多个存储库可以使用相同的片段接口，以便你在不同的存储库中重用自定义功能。</p>
</div>
<div class="paragraph">
<p>以下示例显示了存储库片段及其实现：</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. 片段覆盖 <code>save(&#8230;&#8203;)</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">CustomizedSave</span>&lt;T&gt; {
  &lt;S <span class="directive">extends</span> T&gt; S save(S entity);
}

<span class="type">class</span> <span class="class">CustomizedSaveImpl</span>&lt;T&gt; <span class="directive">implements</span> CustomizedSave&lt;T&gt; {

  <span class="directive">public</span> &lt;S <span class="directive">extends</span> T&gt; S save(S entity) {
    <span class="comment">// 你的自定义实现</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用前面的存储库片段的存储库：</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. 自定义存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt;, CustomizedSave&lt;User&gt; {
}

<span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> CrudRepository&lt;Person, <span class="predefined-type">Long</span>&gt;, CustomizedSave&lt;Person&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_配置">配置</h5>
<div class="paragraph">
<p>如果使用命名空间配置，则存储库基础结构会通过尝试扫描其找到存储库的包下面的类来自动检测片段的自定义实现。
这些类需要遵循命名约定 - 将命名空间元素配置的 <code>repository-impl-postfix</code> 属性值，后缀到片段接口实现类的名称。
此后缀默认为 <code>Impl</code>。以下示例显示了使用默认后缀的存储库以及为后缀设置自定义值的存储库：</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. 配置示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repository</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repository</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">repository-impl-postfix</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">MyPostfix</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中的第一个配置尝试查找名为 <code>com.acme.repository.CustomizedUserRepositoryImpl</code> 的类，以充当自定义存储库实现。
第二个示例则尝试查找 <code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>。</p>
</div>
<div class="sect5">
<h6 id="repositories.single-repository-behaviour.ambiguity">解决歧义</h6>
<div class="paragraph">
<p>如果在不同的包中找到具有匹配类名的多个实现，则Spring Data使用bean名来标识要使用的bean。</p>
</div>
<div class="paragraph">
<p>给定前面显示的 <code>CustomizedUserRepository</code> 的以下两个自定义实现，则会选择使用第一个实现。
它的bean名称是 <code>customizedUserRepositoryImpl</code>，它与片段接口（<code>CustomizedUserRepository</code> + <code>Impl</code> 后缀）的名称相匹配。</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. 解决有歧义的多个实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.acme.impl.one</span>;

<span class="type">class</span> <span class="class">CustomizedUserRepositoryImpl</span> <span class="directive">implements</span> CustomizedUserRepository {

  <span class="comment">// 你的自定义实现</span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">com.acme.impl.two</span>;

<span class="annotation">@Component</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">specialCustomImpl</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">CustomizedUserRepositoryImpl</span> <span class="directive">implements</span> CustomizedUserRepository {

  <span class="comment">// 你的自定义实现</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>@Component("specialCustom")</code> 注解 <code>UserRepository</code> 接口，那么，bean名称加上 <code>Impl</code> 将与 <code>com.acme.impl.two</code>
中为存储库实现定义的名称相匹配，而不再使用第一个名称。</p>
</div>
</div>
<div class="sect5">
<h6 id="repositories.manual-wiring">手动接线</h6>
<div class="paragraph">
<p>如果你的自定义实现仅使用基于注解的配置和自动装配，则前面展示的方法效果很好，因为它被视为任何其他Spring bean。
如果你的实现片段bean需要特殊布线，你可以声明bean并根据 <a href="#repositories.single-repository-behaviour.ambiguity">前一节</a>
中描述的约定对其进行命名。然后，基础结构按名称引用手动定义的bean定义，而不是自己创建一个。
以下示例显示如何手动接线自定义实现：</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. 手动接线自定义实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repository</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;beans:bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">userRepositoryImpl</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">…</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="comment">&lt;!-- 进一步配置 --&gt;</span>
<span class="tag">&lt;/beans:bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.customize-base-repository">3.6.2. 自定义基础Repository</h4>
<div class="paragraph">
<p>当你要自定义基本存储库行为以便所有存储库都受到影响时，<a href="#repositories.manual-wiring">上一节</a> 中描述的方法需要自定义每个存储库接口。
要改为更改所有存储库的行为，可以创建一个继承特定于持久性技术的存储库基类的实现。然后，此类充当存储库代理的自定义基类，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. 自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyRepositoryImpl</span>&lt;T, ID <span class="directive">extends</span> <span class="predefined-type">Serializable</span>&gt;
  <span class="directive">extends</span> SimpleJpaRepository&lt;T, ID&gt; {

  <span class="directive">private</span> <span class="directive">final</span> EntityManager entityManager;

  MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    <span class="local-variable">super</span>(entityInformation, entityManager);

    <span class="comment">// 持有EntityManager可以使用新引入的方法</span>
    <span class="local-variable">this</span>.entityManager = entityManager;
  }

  <span class="annotation">@Transactional</span>
  <span class="directive">public</span> &lt;S <span class="directive">extends</span> T&gt; S save(S entity) {
    <span class="comment">// 在这里实施自定义</span>
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
该类需要具有特定于存储库工厂实现中，所使用的超类的构造函数。如果存储库基类具有多个构造函数，
则覆盖含有 <code>EntityInformation</code> 和存储特定基础结构对象的构造函数（例如 <code>EntityManager</code> 或模板类）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后一步是使Spring Data基础结构了解你自定义的存储库基类。在Java配置中，你可以使用 <code>@Enable${store}Repositories</code> 注解的
<code>repositoryBaseClass</code> 属性来执行此操作，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. 使用JavaConfig配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl.class)
<span class="type">class</span> <span class="class">ApplicationConfiguration</span> { <span class="error">…</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>XML命名空间中提供了相应的属性，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. 使用XML配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repository</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">base-class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">….MyRepositoryImpl</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core.domain-events">3.7. 从聚合根发布事件</h3>
<div class="paragraph">
<p>由存储库管理的实体是聚合根。在域驱动设计应用程序中，这些聚合根通常会发布域事件。
Spring Data提供了一个名为 <code>@DomainEvents</code> 的注解，你可以在聚合根的方法上使用它来使该发布尽可能简单，如下示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. 公开来自聚合根的域事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">AnAggregateRoot</span> {

    <span class="annotation">@DomainEvents</span>                <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Object</span>&gt; domainEvents() {
        <span class="comment">// … 返回要在此处发布的事件</span>
    }

    <span class="annotation">@AfterDomainEventPublication</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="type">void</span> callbackMethod() {
       <span class="comment">// … 可能会清理域事件列表</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>@DomainEvents</code> 的方法可以返回单个事件实例或事件集合。它不能携带任何参数。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在所有事件发布后，我们有一个使用 <code>@AfterDomainEventPublication</code> 注解的方法。
它可用于潜在地清除要发布的事件列表（以及其他用途）。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>每次调用一个Spring Data存储库 <code>save(&#8230;&#8203;)</code> 方法时都会调用这些方法。</p>
</div>
</div>
<div class="sect2">
<h3 id="core.extensions">3.8. Spring Data扩展</h3>
<div class="paragraph">
<p>本节介绍了一组Spring Data扩展，它们可以在各种上下文中使用Spring Data。目前，大多数集成都针对Spring MVC。</p>
</div>
<div class="sect3">
<h4 id="core.extensions.querydsl">3.8.1. Querydsl扩展</h4>
<div class="paragraph">
<p><a href="http://www.querydsl.com/">Querydsl</a>是一个框架，可以通过其流式API构建静态类型的SQL类查询。</p>
</div>
<div class="paragraph">
<p>几个Spring Data模块通过 <code>QuerydslPredicateExecutor</code> 提供与Querydsl的集成，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. QuerydslPredicateExecutor接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">QuerydslPredicateExecutor</span>&lt;T&gt; {

  Optional&lt;T&gt; findById(<span class="predefined-type">Predicate</span> predicate);  <i class="conum" data-value="1"></i><b>(1)</b>

  <span class="predefined-type">Iterable</span>&lt;T&gt; findAll(<span class="predefined-type">Predicate</span> predicate);   <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="type">long</span> count(<span class="predefined-type">Predicate</span> predicate);            <i class="conum" data-value="3"></i><b>(3)</b>

  <span class="type">boolean</span> exists(<span class="predefined-type">Predicate</span> predicate);        <i class="conum" data-value="4"></i><b>(4)</b>

  <span class="comment">// … 省略了更多功能</span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的单个实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的所有实体。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回与 <code>Predicate</code> 匹配的实体数。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回是否存在与 <code>Predicate</code> 匹配的实体。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用Querydsl支持，请在存储库接口上扩展 <code>QuerydslPredicateExecutor</code>，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. 在存储库中集成Querydsl</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt;, QuerydslPredicateExecutor&lt;User&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例允许你使用Querydsl <code>Predicate</code> 实例编写类型安全查询，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Predicate</span> predicate = user.firstname.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">dave</span><span class="delimiter">&quot;</span></span>)
        .and(user.lastname.startsWithIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">mathews</span><span class="delimiter">&quot;</span></span>));

userRepository.findAll(predicate);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.web">3.8.2. Web支持</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本节包含Spring Data web支持的文档，因为它在Spring Data Commons的当前（及更高版本）版本中已实现。
由于新引入的支持更改了许多内容，因此我们在 <a href="#web.legacy">web 遗留</a> 中保留了以前行为的文档。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>支持存储库编程模型的Spring Data模块具有各种Web支持。与Web相关的组件需要Spring MVC JAR位于类路径上。
其中一些甚至提供与 <a href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a>的集成。
通常，通过在JavaConfig配置类中使用 <code>@EnableSpringDataWebSupport</code> 注解来启用集成支持，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. 启用S​​pring Data Web支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableWebMvc</span>
<span class="annotation">@EnableSpringDataWebSupport</span>
<span class="type">class</span> <span class="class">WebConfiguration</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@EnableSpringDataWebSupport</code> 注解注册了一些我们稍后会讨论的组件。它还将检测类路径上的Spring HATEOAS，
并为它注册集成组件（如果存在）。</p>
</div>
<div class="paragraph">
<p>或者，如果使用XML配置，请将 <code>SpringDataWebConfiguration</code> 或 <code>HateoasAwareSpringDataWebConfiguration</code> 注册为Spring bean，
如以下示例所示（对于 <code>SpringDataWebConfiguration</code>）：</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. 以XML配置启用Spring Data Web支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.data.web.config.SpringDataWebConfiguration</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="comment">&lt;!-- 如果你使用Spring HATEOAS，请注册这个而不是前者 --&gt;</span>
<span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.basic">基本Web支持</h5>
<div class="paragraph">
<p><a href="#core.web">上一节</a> 中显示的配置注册了一些基本组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 <code>DomainClassConverter</code> 让Spring MVC从请求参数或路径变量中解析存储库管理的域类实例。</p>
</li>
<li>
<p><code>HandlerMethodArgumentResolver</code> 实现让Spring MVC从请求参数中解析 <code>Pageable</code> 和 <code>Sort</code> 实例。</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="core.web.basic.domain-class-converter">DomainClassConverter</h6>
<div class="paragraph">
<p><code>DomainClassConverter</code> 允许你直接在Spring MVC控制器方法签名中使用域类型，这样你就不需要通过存储库手动查找实例，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. 在方法签名中使用域类型的Spring MVC控制器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/users</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">UserController</span> {

  <span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/{id}</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">String</span> showUserForm(<span class="annotation">@PathVariable</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>) User user, Model model) {

    model.addAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>, user);
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">userForm</span><span class="delimiter">&quot;</span></span>;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如你所见，该方法直接接收 <code>User</code> 实例，无需进一步查找。可以通过让Spring MVC首先将路径变量转换为域类的id类型来解析实例，
并最终通过在为域类型注册的存储库实例上调用 <code>findById(&#8230;&#8203;)</code> 来访问实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
目前，存储库必须实现 <code>CrudRepository</code> 才有资格被发现并进行转换。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="core.web.basic.paging-and-sorting">为了分页和排序的 <code>HandlerMethodArgumentResolvers</code></h6>
<div class="paragraph">
<p><a href="#core.web.basic.domain-class-converter">上一节</a> 中显示的配置代码段还注册了 <code>PageableHandlerMethodArgumentResolver</code>
以及 <code>SortHandlerMethodArgumentResolver</code> 的实例。注册启用 <code>Pageable</code> 和 <code>Sort</code> 作为有效的控制器方法参数，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. 使用 <code>Pageable</code> 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="annotation">@RequestMapping</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/users</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">UserController</span> {

  <span class="directive">private</span> <span class="directive">final</span> UserRepository repository;

  UserController(UserRepository repository) {
    <span class="local-variable">this</span>.repository = repository;
  }

  <span class="annotation">@RequestMapping</span>
  <span class="predefined-type">String</span> showUsers(Model model, <span class="predefined-type">Pageable</span> pageable) {

    model.addAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>, repository.findAll(pageable));
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的方法签名导致Spring MVC尝试使用以下默认配置从请求参数派生 <code>Pageable</code> 实例：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. 为 <code>Pageable</code> 实例评估请求参数</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">page</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要检索的页码。0索引开始并默认为0。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要检索的每页元素数。默认为20。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应按格式 <code>property,property(,ASC|DESC)</code> 排序的属性。默认排序方向是升序。
如果要切换方向，请使用多个 <code>sort</code> 参数 - 例如，<code>?sort=firstname&amp;sort=lastname,asc</code>。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义此行为，请分别注册实现 <code>PageableHandlerMethodArgumentResolverCustomizer</code> 接口或
<code>SortHandlerMethodArgumentResolverCustomizer</code> 接口的bean。调用其 <code>customize()</code> 方法，让你更改设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Bean</span> SortHandlerMethodArgumentResolverCustomizer sortCustomizer() {
    <span class="keyword">return</span> s -&gt; s.setPropertyDelimiter(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;--&gt;</span><span class="delimiter">&quot;</span></span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果设置现有 <code>MethodArgumentResolver</code> 的属性不足以满足你的需要，继承 <code>SpringDataWebConfiguration</code> 或启用HATEOAS的等效项，
覆盖 <code>pageableResolver()</code> 或 <code>sortResolver()</code> 方法，并导入自定义配置文件，而不是使用 <code>@Enable</code> 注解。</p>
</div>
<div class="paragraph">
<p>如果你需要从请求中解析多个 <code>Pageable</code> 或 <code>Sort</code> 实例（例如，对于多个表），你可以使用Spring的 <code>@Qualifier</code> 注解来区分彼此。
然后，请求参数必须以 <code>${qualifier}_</code> 为前缀。以下示例显示了生成的方法签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> showUsers(Model model,
      <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">thing1</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">Pageable</span> first,
      <span class="annotation">@Qualifier</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">thing2</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">Pageable</span> second) { <span class="error">…</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你必须填充 <code>thing1_page</code> 和 <code>thing2_page</code> 等等。</p>
</div>
<div class="paragraph">
<p>传递给方法的默认 <code>Pageable</code> 相当于 <code>new PageRequest(0,20)</code>，但可以通过在 <code>Pageable</code> 参数上使用 <code>@PageableDefault</code>
注解进行自定义。</p>
</div>
</div>
<div class="sect5">
<h6 id="core.web.pageables">对 <code>Pageables</code> 的超媒体支持</h6>
<div class="paragraph">
<p>Spring HATEOAS附带了一个表示模型类（<code>PagedResources</code>），它允许使用必要的 <code>Page</code> 元数据丰富 <code>Page</code> 实例的内容以生成允许客户端
轻松浏览页面的链接。将 <code>Page</code> 转换为 <code>PagedResources</code> 是通过Spring HATEOAS <code>ResourceAssembler</code> 接口的实现完成的，
该接口称为 <code>PagedResourcesAssembler</code>。以下示例显示如何将 <code>PagedResourcesAssembler</code> 用作控制器方法参数：</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. 使用 <code>PagedResourcesAssembler</code> 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="type">class</span> <span class="class">PersonController</span> {

  <span class="annotation">@Autowired</span> PersonRepository repository;

  <span class="annotation">@RequestMapping</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">/persons</span><span class="delimiter">&quot;</span></span>, method = RequestMethod.GET)
  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(<span class="predefined-type">Pageable</span> pageable,
    PagedResourcesAssembler assembler) {

    Page&lt;Person&gt; persons = repository.findAll(pageable);
    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上例所示启用配置，可以将 <code>PagedResourcesAssembler</code> 用作控制器方法参数。在其上调用 <code>toResources(…)</code> 具有以下效果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Page</code> 的内容成为 <code>PagedResources</code> 实例的内容。</p>
</li>
<li>
<p><code>PagedResources</code> 对象获取一个附加的 <code>PageMetadata</code> 实例，并使用来自 <code>Page</code> 和底层 <code>PageRequest</code> 的信息填充它。</p>
</li>
<li>
<p>根据页面的状态，<code>PagedResources</code> 可能会显示并附加下一页的链接。链接指向方法映射到的URI。添加到方法的分页参数与
<code>PageableHandlerMethodArgumentResolver</code> 的设置相匹配，以确保稍后可以解析链接。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>假设我们在数据库中有30个 <code>Person</code> 实例。你现在可以触发请求（<code>GET <a href="http://localhost:8080/persons" class="bare">http://localhost:8080/persons</a></code>）并查看到
类似于以下内容的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">links</span><span class="delimiter">&quot;</span></span> : [
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">rel</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">next</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">href</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/persons?page=1&amp;size=20
    }
  ],
  </span><span class="delimiter">&quot;</span></span><span class="error">c</span><span class="error">o</span><span class="error">n</span><span class="error">t</span><span class="error">e</span><span class="error">n</span><span class="error">t</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : [
     … // 此处呈现20个Person实例
  ],
  </span><span class="delimiter">&quot;</span></span><span class="error">p</span><span class="error">a</span><span class="error">g</span><span class="error">e</span><span class="error">M</span><span class="error">e</span><span class="error">t</span><span class="error">a</span><span class="error">d</span><span class="error">a</span><span class="error">t</span><span class="error">a</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : {
    </span><span class="delimiter">&quot;</span></span><span class="error">s</span><span class="error">i</span><span class="error">z</span><span class="error">e</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : 20,
    </span><span class="delimiter">&quot;</span></span><span class="error">t</span><span class="error">o</span><span class="error">t</span><span class="error">a</span><span class="error">l</span><span class="error">E</span><span class="error">l</span><span class="error">e</span><span class="error">m</span><span class="error">e</span><span class="error">n</span><span class="error">t</span><span class="error">s</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : 30,
    </span><span class="delimiter">&quot;</span></span><span class="error">t</span><span class="error">o</span><span class="error">t</span><span class="error">a</span><span class="error">l</span><span class="error">P</span><span class="error">a</span><span class="error">g</span><span class="error">e</span><span class="error">s</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : 2,
    </span><span class="delimiter">&quot;</span></span><span class="error">n</span><span class="error">u</span><span class="error">m</span><span class="error">b</span><span class="error">e</span><span class="error">r</span><span class="string"><span class="delimiter">&quot;</span><span class="content"> : 0
  }
}</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>你会看到组装者生成了正确的URI，并且还选择了默认配置以将参数解析为即将发出的请求的 <code>Pageable</code>。
这意味着，如果更改该配置，链接将遵循设置自动更改。默认情况下，组装者指向它所调用的控制器方法，
但可以通过交换自定义链接来自定义链接以构建分页链接，这会用到重载的 <code>PagedResourcesAssembler.toResource(&#8230;&#8203;)</code> 方法。</p>
</div>
</div>
<div class="sect5">
<h6 id="core.web.binding">Web数据绑定支持</h6>
<div class="paragraph">
<p>Spring Data投影（在<a href="#projections">Projections</a>中描述）可用于通过使用 <a href="http://goessner.net/articles/JsonPath/">JSONPath</a>
表达式来绑定传入的请求有效载荷（需要 <a href="https://github.com/json-path/JsonPath">Jayway JsonPath</a>或
<a href="https://www.w3.org/TR/xpath-31/">XPath</a>表达式（需要 <a href="https://xmlbeam.org/">XmlBeam</a>），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. 使用JSONPath或XPath表达式绑定HTTP有效载荷</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ProjectedPayload</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">UserPayload</span> {

  <span class="annotation">@XBRead</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">//firstname</span><span class="delimiter">&quot;</span></span>)
  <span class="annotation">@JsonPath</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">$..firstname</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">String</span> getFirstname();

  <span class="annotation">@XBRead</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/lastname</span><span class="delimiter">&quot;</span></span>)
  <span class="annotation">@JsonPath</span>({ <span class="string"><span class="delimiter">&quot;</span><span class="content">$.lastname</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">$.user.lastname</span><span class="delimiter">&quot;</span></span> })
  <span class="predefined-type">String</span> getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中显示的类型可以用作Spring MVC处理程序方法参数，也可以在 <code>RestTemplate</code> 方法之一上使用 <code>ParameterizedTypeReference</code>。
前面的方法声明将尝试在给定文档中的任何位置查找 <code>firstname</code>。<code>lastname</code> XML查找在传入文档的顶级执行。
JSON变体首先尝试顶级 <code>lastname</code>，但如果前者没有返回值，也会尝试查找嵌套在 <code>user</code> 子文档中的 <code>lastname</code>。
这样，可以轻松地减轻源文档结构的变化，而无需客户端调用公开的方法（通常是基于类的有效负载绑定的缺点）。</p>
</div>
<div class="paragraph">
<p>如<a href="#projections">Projections</a>中所述，支持嵌套投影。如果方法返回复杂的非接口类型，则使用Jackson <code>ObjectMapper</code> 映射最终值。</p>
</div>
<div class="paragraph">
<p>对于Spring MVC，只要开启 <code>@EnableSpringDataWebSupport</code> 注解，就会自动注册必要的转换器，并且类路径上可以使用所需的依赖项。
要与 <code>RestTemplate</code> 一起使用，请手动注册 <code>ProjectingJackson2HttpMessageConverter</code>（JSON）或 <code>XmlBeamHttpMessageConverter</code>。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 <a href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples</a>典范存储库中的
<a href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">Web投影示例</a>。</p>
</div>
</div>
<div class="sect5">
<h6 id="core.web.type-safe">Querydsl Web支持</h6>
<div class="paragraph">
<p>对于那些具有 <a href="http://www.querydsl.com/">QueryDSL</a>集成的仓储，可以从 <code>Request</code> 查询字符串中包含的属性派生查询。</p>
</div>
<div class="paragraph">
<p>请考虑以下查询字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">?firstname=Dave&amp;lastname=Matthews</code></pre>
</div>
</div>
<div class="paragraph">
<p>给定前面示例中的 <code>User</code> 对象，可以使用 <code>QuerydslPredicateArgumentResolver</code> 将查询字符串解析为以下值:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在类路径中找到Querydsl时，将自动启用该功能以及 <code>@EnableSpringDataWebSupport</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 <code>@QuerydslPredicate</code> 添加到方法签名提供了一个可立即使用的谓词，可以使用 <code>QuerydslPredicateExecutor</code> 运行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
通常从方法的返回类型中解析类型信息。由于该信息不一定与域类型匹配，因此使用QuerydslPredicate的root属性可能是个好主意。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何在方法签名中使用 <code>@QuerydslPredicate</code>：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Controller</span>
<span class="type">class</span> <span class="class">UserController</span> {

  <span class="annotation">@Autowired</span> UserRepository repository;

  <span class="annotation">@RequestMapping</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>, method = RequestMethod.GET)
  <span class="predefined-type">String</span> index(Model model, <span class="annotation">@QuerydslPredicate</span>(root = User.class) <span class="predefined-type">Predicate</span> predicate,    <i class="conum" data-value="1"></i><b>(1)</b>
          <span class="predefined-type">Pageable</span> pageable, <span class="annotation">@RequestParam</span> MultiValueMap&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; parameters) {

    model.addAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">users</span><span class="delimiter">&quot;</span></span>, repository.findAll(predicate, pageable));

    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>;
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将查询字符串参数解析为匹配 <code>User</code> 的 <code>Predicate</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认绑定如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object</code> 在简单属性上做 <code>eq</code>。</p>
</li>
<li>
<p><code>Object</code> 在集合是否有某属性上做 <code>contains</code>。</p>
</li>
<li>
<p><code>Collection</code> 在简单的属性上做 <code>in</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过 <code>@QuerydslPredicate</code> 的 <code>bindings</code> 属性或通过使用Java 8默认方法并将 <code>QuerydslBinderCustomizer</code>
方法添加到存储库接口来自定义这些绑定。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">String</span>&gt;,
                                 QuerydslPredicateExecutor&lt;User&gt;,                <i class="conum" data-value="1"></i><b>(1)</b>
                                 QuerydslBinderCustomizer&lt;QUser&gt; {               <i class="conum" data-value="2"></i><b>(2)</b>

  <span class="annotation">@Override</span>
  <span class="keyword">default</span> <span class="type">void</span> customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    <i class="conum" data-value="3"></i><b>(3)</b>
    bindings.bind(<span class="predefined-type">String</span>.class)
      .first((StringPath path, <span class="predefined-type">String</span> value) -&gt; path.containsIgnoreCase(value)); <i class="conum" data-value="4"></i><b>(4)</b>
    bindings.excluding(user.password);                                           <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuerydslPredicateExecutor</code> 提供对包含 <code>Predicate</code> 的特定查找器方法的访问。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>存储库接口上定义的 <code>QuerydslBinderCustomizer</code> 会自动获取并快捷方式 <code>@QuerydslPredicate(bindings=…​)</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将 <code>username</code> 属性的绑定定义为简单 <code>contains</code> 绑定。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将 <code>String</code> 属性的默认绑定定义为忽略大小写的 <code>contains</code> 匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>从 <code>Predicate</code> 解析中排除 <code>password</code> 属性。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.repository-populators">3.8.3. 存储库填充</h4>
<div class="paragraph">
<p>如果使用Spring JDBC模块，你可能熟悉使用SQL脚本填充 <code>DataSource</code> 的支持。虽然它不使用SQL作为数据定义语言，
但它在存储库级别上提供了类似的抽象，因为它必须与具体存储无关。因此，填充程序支持XML（通过Spring的OXM抽象）和JSON（通过Jackson）
来定义用于填充存储库的数据。</p>
</div>
<div class="paragraph">
<p>假设你有一个文件 <code>data.json</code>，其中包含以下内容：</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. 以JSON定义的数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">[
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_class</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.Person</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lastname</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Matthews</span><span class="delimiter">&quot;</span></span>
    },
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_class</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.Person</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Carter</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lastname</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">Beauford</span><span class="delimiter">&quot;</span></span>
    }
]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以使用Spring Data Commons中提供的存储库命名空间的 <code>populator</code> 元素来填充存储库。
要将前面的数据填充到 <code>PersonRepository</code>，请声明类似于以下内容的populator：</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. 声明Jackson存储库populator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:repository</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/data/repository</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
    <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
    <span class="content">http://www.springframework.org/schema/data/repository</span>
    <span class="content">http://www.springframework.org/schema/data/repository/spring-repository.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;repository:jackson2-populator</span> <span class="attribute-name">locations</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:data.json</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上述声明会导致由Jackson <code>ObjectMapper</code> 来读取和反序列化 <code>data.json</code> 文件。</p>
</div>
<div class="paragraph">
<p>通过检查JSON文档的 <code>\_class</code> 属性来解组JSON对象的类型。基础结构最终选择适当的存储库来处理反序列化后的对象。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>unmarshaller-populator</code> 元素声明使用XML来定义填充存储库的数据，可将其配置为使用Spring OXM中提供的
可选XML marshaller之一。有关详细信息，请参阅 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/data-access.html#oxm">Spring参考文档</a>。
以下示例说明如何使用JAXB解组存储库填充：</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. 使用JAXB解组的存储库populator</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:repository</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/data/repository</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:oxm</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/oxm</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
    <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
    <span class="content">http://www.springframework.org/schema/data/repository</span>
    <span class="content">http://www.springframework.org/schema/data/repository/spring-repository.xsd</span>
    <span class="content">http://www.springframework.org/schema/oxm</span>
    <span class="content">http://www.springframework.org/schema/oxm/spring-oxm.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;repository:unmarshaller-populator</span> <span class="attribute-name">locations</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">classpath:data.json</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">unmarshaller-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">unmarshaller</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

  <span class="tag">&lt;oxm:jaxb2-marshaller</span> <span class="attribute-name">contextPath</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.repositories">4. JPA存储库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章指出JPA存储库支持的特性。这建立在“<a href="#repositories">使用Spring Data存储库</a>”中解释的核心存储库支持的基础上。
确保你对那里解释的基本概念有充分的理解。</p>
</div>
<div class="sect2">
<h3 id="jpa.introduction">4.1. 介绍</h3>
<div class="paragraph">
<p>本节介绍通过以下任一方式配置Spring Data JPA的基础知识：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“<a href="#jpa.namespace">Spring命名空间</a>”（XML配置）</p>
</li>
<li>
<p>“<a href="#jpa.java-config">基于注解的配置</a>”（Java配置）</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jpa.namespace">4.1.1. Spring命名空间</h4>
<div class="paragraph">
<p>Spring Data的JPA模块包含一个允许定义存储库bean的自定义命名空间。它还包含JPA特有的某些功能和元素属性。
通常，可以使用 <code>repositories</code> 元素设置JPA存储库，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. 使用命名空间设置JPA存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;beans</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xmlns:jpa</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/data/jpa</span><span class="delimiter">&quot;</span></span>
  <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.springframework.org/schema/beans</span>
    <span class="content">http://www.springframework.org/schema/beans/spring-beans.xsd</span>
    <span class="content">http://www.springframework.org/schema/data/jpa</span>
    <span class="content">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;jpa:repositories</span> <span class="attribute-name">base-package</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.repositories</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>

<span class="tag">&lt;/beans&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>repositories</code> 元素查找Spring Data存储库，如“<a href="#repositories.create-instances">创建存储库实例</a>”中所述。
除此之外，它还激活了使用 <code>@Repository</code> 注解的所有bean的持久性异常转换，以便将JPA持久性提供程序所抛出的异常转换为Spring的
 <code>DataAccessException</code> 层次结构。</p>
</div>
<div class="sect4">
<h5 id="_自定义命名空间属性">自定义命名空间属性</h5>
<div class="paragraph">
<p>除了 <code>repositories</code> 元素的默认属性之外，JPA命名空间还提供了其他属性，使你可以更好地控制存储库的设置：</p>
</div>
<table class="tableblock frame-all grid-all">
<caption class="title">Table 2. <code>repositories</code> 元素的自定义JPA特定属性</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entity-manager-factory-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式声明要与 <code>repositories</code> 元素检测到的存储库一起使用的 <code>EntityManagerFactory</code>。
通常在应用程序中使用多个 <code>EntityManagerFactory</code> bean时使用。如果未配置，Spring Data会自动在 <code>ApplicationContext</code> 中查找名称为
 <code>entityManagerFactory</code> 的 <code>EntityManagerFactory</code> bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式声明要与 <code>repositories</code> 元素检测到的存储库一起使用的 <code>PlatformTransactionManager</code>。
通常仅在配置了多个事务管理器或 <code>EntityManagerFactory</code> bean时才需要。
默认为当前 <code>ApplicationContext</code> 中单个定义的 <code>PlatformTransactionManager</code>。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果没有定义显式的 <code>transaction-manager-ref</code>，Spring Data JPA需要一个名为 <code>transactionManager</code>
的 <code>PlatformTransactionManager</code> bean。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.java-config">4.1.2. 基于注解的配置</h4>
<div class="paragraph">
<p>Spring Data JPA存储库支持不仅可以通过XML命名空间激活，还可以通过JavaConfig使用注解来激活，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. 使用JavaConfig的Spring Data JPA存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableJpaRepositories</span>
<span class="annotation">@EnableTransactionManagement</span>
<span class="type">class</span> <span class="class">ApplicationConfig</span> {

  <span class="annotation">@Bean</span>
  <span class="directive">public</span> <span class="predefined-type">DataSource</span> dataSource() {
    EmbeddedDatabaseBuilder builder = <span class="keyword">new</span> EmbeddedDatabaseBuilder();
    <span class="keyword">return</span> builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  <span class="annotation">@Bean</span>
  <span class="directive">public</span> LocalContainerEntityManagerFactoryBean entityManagerFactory() {
    HibernateJpaVendorAdapter vendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(<span class="predefined-constant">true</span>);

    LocalContainerEntityManagerFactoryBean factory = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.domain</span><span class="delimiter">&quot;</span></span>);
    factory.setDataSource(dataSource());
    <span class="keyword">return</span> factory;
  }

  <span class="annotation">@Bean</span>
  <span class="directive">public</span> PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
    JpaTransactionManager txManager = <span class="keyword">new</span> JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    <span class="keyword">return</span> txManager;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你必须直接创建 <code>LocalContainerEntityManagerFactoryBean</code> 而不是 <code>EntityManagerFactory</code>，
因为除了创建 <code>EntityManagerFactory</code> 之外，前者还包含了异常转换机制。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上述配置类使用 <code>spring-jdbc</code> 的 <code>EmbeddedDatabaseBuilder</code> API设置数据源为嵌入式HSQL数据库。
然后Spring Data设置一个 <code>EntityManagerFactory</code> 并使用Hibernate作为样例的持久性提供程序。
这里声明的最后一个基础组件是 <code>JpaTransactionManager</code>。最后，该示例使用 <code>@EnableJpaRepositories</code> 注解激活Spring Data JPA存储库，
该注解基本上具有与XML命名空间相同的属性。如果未配置基础包，则使用配置类所在包作为基础包。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.entity-persistence">4.2. 持久化实体</h3>
<div class="paragraph">
<p>本节介绍如何使用Spring Data JPA持久化（保存）实体。</p>
</div>
<div class="sect3">
<h4 id="jpa.entity-persistence.saving-entites">4.2.1. 保存实体</h4>
<div class="paragraph">
<p>可以使用 <code>CrudRepository.save(&#8230;&#8203;)</code> 方法来保存实体。它通过使用基础JPA <code>EntityManager</code> 来持久化或合并给定实体。
如果实体尚未持久化，则Spring Data JPA会通过调用 <code>entityManager.persist(&#8230;&#8203;)</code> 方法来保存实体。否则，
它调用 <code>entityManager.merge(&#8230;&#8203;)</code> 方法。</p>
</div>
<div class="sect4">
<h5 id="_实体状态_检测策略">实体状态 - 检测策略</h5>
<div class="paragraph">
<p>Spring Data JPA提供以下策略来检测实体是否是新实体：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Id-属性检查（<strong>默认</strong>）：默认情况下，Spring Data JPA会检查给定实体的标识符属性。
如果id属性为 <code>null</code>，则假定该实体是新的。否则，它被认为不是新的。</p>
</li>
<li>
<p>实现 <code>Persistable</code>：如果实体实现了 <code>Persistable</code>，Spring Data JPA会将检测委托给实体的 <code>isNew(&#8230;&#8203;)</code> 方法。
有关详细信息，请参阅 <a href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a>。</p>
</li>
<li>
<p>实现 <code>EntityInformation</code>：你可以通过创建 <code>JpaRepositoryFactory</code> 的子类并相应地覆盖 <code>getEntityInformation(&#8230;&#8203;)</code> 方法来自定义
<code>SimpleJpaRepository</code> 实现中使用的 <code>EntityInformation</code> 抽象。然后，你必须将 <code>JpaRepositoryFactory</code> 的自定义实现注册为
Spring bean。请注意，这种方案很少是必要的。有关详细信息，请参阅
<a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a>。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods">4.3. 查询方法</h3>
<div class="paragraph">
<p>本节介绍使用Spring Data JPA创建查询的各种方法。</p>
</div>
<div class="sect3">
<h4 id="jpa.sample-app.finders.strategies">4.3.1. 查询查找策略</h4>
<div class="paragraph">
<p>JPA模块支持手动定义查询字符串或从方法名称派生查询。</p>
</div>
<div class="sect4">
<h5 id="_声明式查询">声明式查询</h5>
<div class="paragraph">
<p>尽管获取从方法名称派生的查询非常方便，但是可能面临这样的情况：方法名称解析器不支持要使用的关键字，或者方法名称会变得不必要地丑陋。
因此，你可以通过命名约定使用JPA命名查询（请参阅 <a href="#jpa.query-methods.named-queries">使用JPA命名查询</a> 获取更多信息），
或者使用 <code>@Query</code> 注解查询方法（有关详细信息，请参阅 <a href="#jpa.query-methods.at-query">使用 <code>@Query</code></a>）。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.query-creation">4.3.2. 查询创建</h4>
<div class="paragraph">
<p>通常，JPA的查询创建机制的工作方式如“<a href="#repositories.query-methods">查询方法</a>”中所述。以下示例显示了JPA查询方法转换为的内容：</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. 从方法名称创建查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="predefined-type">List</span>&lt;User&gt; findByEmailAddressAndLastname(<span class="predefined-type">String</span> emailAddress, <span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用JPA标准API创建一个查询，但实际上，这会转换为以下查询：<code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code>。
Spring Data JPA执行属性检查并遍历嵌套属性，如“<a href="#repositories.query-methods.query-property-expressions">属性表达式</a>”中所述。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了JPA支持的关键字以及包含该关键字的方法将转换为：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. 方法名称中支持的关键字</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">关键字</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">查询方法名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Java_Persistence_Query_Language">JPQL</a> 代码段</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameOrFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 or x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is,Equals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname = ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBetween</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate between ?1 and ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBefore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIsNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age is null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotNull,NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameNotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname not like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameStartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameEndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameContaining</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeOrderByLastnameDesc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age = ?1 order by x.lastname desc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameNot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname &lt;&gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveTrue()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveFalse()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameIgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where UPPER(x.firstame) = UPPER(?1)</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>In</code> 和 <code>NotIn</code> 也将 <code>Collection</code> 的任何子类作为参数以及数组或可变参数。
对于同一逻辑运算符的其他语法版本，请参阅“<a href="#repository-query-keywords">存储库查询关键字</a>”。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.named-queries">4.3.3. 使用JPA命名查询</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这些示例使用 <code>&lt;named-query/&gt;</code> 元素和 <code>@NamedQuery</code> 注解。必须在JPA查询语言中定义这些配置元素所对应的查询。
当然，你也可以使用 <code>&lt;named-native-query/&gt;</code> 或 <code>@NamedNativeQuery</code>。这两个元素允许你通过失去数据库平台独立性来定义本地查询SQL。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_xml命名查询定义">XML命名查询定义</h5>
<div class="paragraph">
<p>要使用XML配置，请将必要的 <code>&lt;named-query/&gt;</code> 元素添加到位于类路径的 <code>META-INF</code> 文件夹中的 <code>orm.xml</code> JPA配置文件中。
通过使用某些已定义的命名约定，可以自动调用命名查询。有关详细信息，请参阅下文。</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. XML命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;named-query</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">User.findByLastname</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;query&gt;</span>select u from User u where u.lastname = ?1<span class="tag">&lt;/query&gt;</span>
<span class="tag">&lt;/named-query&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询具有一个特殊名称，用于在运行时解析它。</p>
</div>
</div>
<div class="sect4">
<h5 id="_基于注解的配置">基于注解的配置</h5>
<div class="paragraph">
<p>基于注解的配置具有不需要编辑另一个配置文件的优点，从而降低了维护工作量。为此，你需要为每个新添加的查询声明重新编译域类。</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. 基于注解的命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Entity</span>
<span class="annotation">@NamedQuery</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">User.findByEmailAddress</span><span class="delimiter">&quot;</span></span>,
  query = <span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u where u.emailAddress = ?1</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> {

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_声明接口">声明接口</h5>
<div class="paragraph">
<p>要允许执行这些命名查询，请按下示指定 <code>UserRepository</code>：</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. 在 <code>UserRepository</code> 中声明查询方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname);

  User findByEmailAddress(<span class="predefined-type">String</span> emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Data尝试将对这些方法的调用解析为命名查询，从配置的域类的简单名称开始，后跟由点分隔的方法名称。
因此，前面的示例将使用在样例中定义的命名查询，而不是尝试从方法名称创建查询。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.at-query">4.3.4. 使用 <code>@Query</code></h4>
<div class="paragraph">
<p>使用命名查询来声明实体查询是一种有效的方法，适用于少量查询。由于查询本身与执行它们的Java方法相关联，
因此你实际上可以使用Spring Data JPA <code>@Query</code> 注解直接绑定它们，而不是将它们注释到域类。
这便于将域类从特定于持久性的信息中释放出来，并将查询与存储库接口放置在一起。</p>
</div>
<div class="paragraph">
<p>注释到查询方法的查询优先于使用 <code>@NamedQuery</code> 定义的查询或在 <code>orm.xml</code> 中声明的命名查询。</p>
</div>
<div class="paragraph">
<p>以下示例显示使用 <code>@Query</code> 注解创建的查询：</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. 使用 <code>@Query</code> 在查询方法中声明查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u where u.emailAddress = ?1</span><span class="delimiter">&quot;</span></span>)
  User findByEmailAddress(<span class="predefined-type">String</span> emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_使用高级like表达式">使用高级LIKE表达式</h5>
<div class="paragraph">
<p>使用 <code>@Query</code> 创建手动定义查询的查询执行机制，允许在查询定义中定义高级 <code>LIKE</code> 表达式，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. <code>@Query</code> 中的高级 <code>LIKE</code> 表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u where u.firstname like %?1</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">List</span>&lt;User&gt; findByFirstnameEndsWith(<span class="predefined-type">String</span> firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，将识别 <code>LIKE</code> 分隔符（<code>%</code>），并将查询转换为有效的JPQL查询（删除 <code>%</code>）。
在执行查询时，传递给方法调用的参数将使用之前识别的 <code>LIKE</code> 模式进行扩充。</p>
</div>
</div>
<div class="sect4">
<h5 id="_本地查询">本地查询</h5>
<div class="paragraph">
<p><code>@Query</code> 注解允许通过将 <code>nativeQuery</code> 标志设置为 <code>true</code> 来运行本地查询，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. 使用 <code>@Query</code> 在查询方法中声明本地查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1</span><span class="delimiter">&quot;</span></span>, nativeQuery = <span class="predefined-constant">true</span>)
  User findByEmailAddress(<span class="predefined-type">String</span> emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Data JPA目前不支持对本地查询进行动态排序，因为它必须操纵声明的实际查询，而对于本地SQL，它无法可靠地执行。
但是，你可以通过自己指定计数查询来使用本地查询进行分页，如以下示例所示：
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 59. 使用 <code>@Query</code> 在查询方法中声明分页的本地计数查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">SELECT * FROM USERS WHERE LASTNAME = ?1</span><span class="delimiter">&quot;</span></span>,
    countQuery = <span class="string"><span class="delimiter">&quot;</span><span class="content">SELECT count(*) FROM USERS WHERE LASTNAME = ?1</span><span class="delimiter">&quot;</span></span>,
    nativeQuery = <span class="predefined-constant">true</span>)
  Page&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类似的方法也适用于本地命名查询，方法是将 <code>.count</code> 后缀添加到复制的查询方法名中。但是，你可能需要为计数查询注册结果集映射。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.sorting">4.3.5. 使用排序</h4>
<div class="paragraph">
<p>可以通过提供 <code>PageRequest</code> 或直接使用 <code>Sort</code> 来进行排序。<code>Sort</code> 的 <code>Order</code> 实例中实际使用的属性需要与你的域模型匹配，
这意味着它们需要解析为查询中使用的属性或别名。JPQL将其定义为状态字段路径表达式。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用任何不可引用的路径表达式会导致 <code>Exception</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>但是，与 <a href="#jpa.query-methods.at-query"><code>@Query</code></a> 一起使用的 <code>Sort</code> 中可以潜入 <code>ORDER BY</code> 子句中包含函数的无需路径检查的 <code>Order</code> 实例。
这是可能的，因为 <code>Order</code> 被附加到给定的查询字符串。默认情况下，Spring Data JPA拒绝任何包含函数调用的 <code>Order</code> 实例，
但你可以使用 <code>JpaSort.unsafe</code> 明确添加可能并不安全的排序。</p>
</div>
<div class="paragraph">
<p>以下示例使用 <code>Sort</code> 和 <code>JpaSort</code>，包括 <code>JpaSort</code> 上的不安全选项：</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. 使用 <code>Sort</code> 和 <code>JpaSort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u where u.lastname like ?1%</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">List</span>&lt;User&gt; findByAndSort(<span class="predefined-type">String</span> lastname, Sort sort);

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">List</span>&lt;<span class="predefined-type">Object</span><span class="type">[]</span>&gt; findByAsArrayAndSort(<span class="predefined-type">String</span> lastname, Sort sort);
}

repo.findByAndSort(<span class="string"><span class="delimiter">&quot;</span><span class="content">lannister</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> Sort(<span class="string"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span>));               <i class="conum" data-value="1"></i><b>(1)</b>
repo.findByAndSort(<span class="string"><span class="delimiter">&quot;</span><span class="content">stark</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> Sort(<span class="string"><span class="delimiter">&quot;</span><span class="content">LENGTH(firstname)</span><span class="delimiter">&quot;</span></span>));           <i class="conum" data-value="2"></i><b>(2)</b>
repo.findByAndSort(<span class="string"><span class="delimiter">&quot;</span><span class="content">targaryen</span><span class="delimiter">&quot;</span></span>, JpaSort.unsafe(<span class="string"><span class="delimiter">&quot;</span><span class="content">LENGTH(firstname)</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="3"></i><b>(3)</b>
repo.findByAsArrayAndSort(<span class="string"><span class="delimiter">&quot;</span><span class="content">bolton</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> Sort(<span class="string"><span class="delimiter">&quot;</span><span class="content">fn_len</span><span class="delimiter">&quot;</span></span>));              <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>有效的 <code>Sort</code> 表达式指向域模型中的属性。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>包含函数调用的无效排序。抛出异常。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>有效的 <code>Sort</code> 明确包含 <em>不安全</em> 的 <code>Order</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>有效的 <code>Sort</code> 表达式指向别名函数。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.named-parameters">4.3.6. 使用命名参数</h4>
<div class="paragraph">
<p>默认情况下，Spring Data JPA使用基于位置的参数绑定，如前面所有示例中所述。这使得查询方法在重构参数位置时容易出错。
要解决此问题，可以使用 <code>@Param</code> 注解为方法参数指定具体名称并在查询中绑定名称，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. 使用命名参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from User u where u.firstname = :firstname or u.lastname = :lastname</span><span class="delimiter">&quot;</span></span>)
  User findByLastnameOrFirstname(<span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">lastname</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> lastname,
                                 <span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
方法参数根据定义查询中的顺序进行了调整。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从版本4开始，Spring完全支持基于 <code>-parameters</code> 编译器标志的Java 8参数名称发现。
通过在构建中使用此标志作为调试信息的替代方法，可以省略命名参数的 <code>@Param</code> 注解。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query.spel-expressions">4.3.7. 使用SpEL表达式</h4>
<div class="paragraph">
<p>从Spring Data JPA 1.4版开始，我们支持在使用 <code>@Query</code> 定义的手动定义查询中使用受限制的SpEL模板表达式。
在执行查询时，将根据预定义的变量集评估这些表达式。Spring Data JPA支持名为 <code>entityName</code> 的变量。
它的用法是 <code>select x from #{#entityName} x</code>。它插入与给定存储库关联的域类型的 <code>entityName</code>。
<code>entityName</code> 的解析如下：如果域类型在 <code>@Entity</code> 注释上设置了 <code>name</code> 属性，它会被使用。否则，使用域类型的简单类名。</p>
</div>
<div class="paragraph">
<p>以下示例演示了查询字符串中 <code>#{#entityName}</code> 表达式的一个使用场景，你希望使用查询方法和手动定义查询语句来定义存储库接口：</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. 在存储库查询方法中使用SpEL表达式 - <code>entityName</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Entity</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> {

  <span class="annotation">@Id</span>
  <span class="annotation">@GeneratedValue</span>
  <span class="predefined-type">Long</span> id;

  <span class="predefined-type">String</span> lastname;
}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User,<span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select u from #{#entityName} u where u.lastname = ?1</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要避免在 <code>@Query</code> 注解的查询字符串中声明实际实体名称，可以使用 <code>#{#entityName}</code> 变量。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
可以在 <code>@Entity</code> 注解中自定义 <code>entityName</code>。SpEL表达式不支持在 <code>orm.xml</code> 中自定义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然，你可以直接在查询声明中使用 <code>User</code>，但这也需要你更改查询。对 <code>#entityName</code> 的引用可以将 <code>User</code> 类重映射到另一个实体名称
（例如，使用 <code>@Entity(name = "MyUser"</code>），以防止未来重构类名。</p>
</div>
<div class="paragraph">
<p>查询字符串中 <code>#{#entityName}</code> 表达式的另一个使用场景是，如果要为具体域类型定义具有专用存储库接口的通用存储库接口。
要在具体接口上不重复自定义查询方法的定义，可以在通用存储库接口中的 <code>@Query</code> 注解的查询字符串中使用实体名称表达式，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. 在存储库查询方法中使用SpEL表达式 - 带继承的 <code>entityName</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@MappedSuperclass</span>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractMappedType</span> {
  <span class="error">…</span>
  <span class="predefined-type">String</span> attribute
}

<span class="annotation">@Entity</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ConcreteType</span> <span class="directive">extends</span> AbstractMappedType { <span class="error">…</span> }

<span class="annotation">@NoRepositoryBean</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">MappedTypeRepository</span>&lt;T <span class="directive">extends</span> AbstractMappedType&gt;
  <span class="directive">extends</span> Repository&lt;T, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">select t from #{#entityName} t where t.attribute = ?1</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">List</span>&lt;T&gt; findAllByAttribute(<span class="predefined-type">String</span> attribute);
}

<span class="directive">public</span> <span class="type">interface</span> <span class="class">ConcreteRepository</span>
  <span class="directive">extends</span> MappedTypeRepository&lt;ConcreteType&gt; { <span class="error">…</span> }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，<code>MappedTypeRepository</code> 接口是继承 <code>AbstractMappedType</code> 的几种域类型的公共父接口。
它还定义了通用的 <code>findAllByAttribute(&#8230;&#8203;)</code> 方法，该方法可用于专用存储库接口的实例。如果现在在 <code>ConcreteRepository</code> 上调用
<code>findAllByAttribute(&#8230;&#8203;)</code>，则对应的查询是 <code>select t from ConcreteType t where t.attribute = ?1</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.modifying-queries">4.3.8. 修改查询</h4>
<div class="paragraph">
<p>前面的所有部分都描述了如何声明查询以访问给定实体或实体集合。你可以使用“<a href="#repositories.custom-implementations">Spring Data Repositories的自定义实现</a>”
中描述的方法添加自定义修改行为。由于此方法对于全面的定制功能是可行的，因此你可以通过使用 <code>@Modifying</code>
注解查询方法来修改仅需要参数绑定的查询，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. 声明更新查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modifying</span>
<span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">update User u set u.firstname = ?1 where u.lastname = ?2</span><span class="delimiter">&quot;</span></span>)
<span class="type">int</span> setFixedFirstnameFor(<span class="predefined-type">String</span> firstname, <span class="predefined-type">String</span> lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样做会触发将方法注释为更新查询而不是选择查询。由于 <code>EntityManager</code> 在执行修改查询后可能包含过时的实体，
我们不会自动清除它（有关详细信息，请参阅 <code>EntityManager.clear()</code> 的 <a href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html">JavaDoc</a>），
因为这会有效地丢弃 <code>EntityManager</code> 中仍未处理的所有未刷新的更改。如果希望 <code>EntityManager</code> 自动清除，
可以将 <code>@Modifying</code> 注解的 <code>clearAutomatically</code> 属性设置为 <code>true</code>。</p>
</div>
<div class="sect4">
<h5 id="jpa.modifying-queries.derived-delete">派生删除查询</h5>
<div class="paragraph">
<p>Spring Data JPA还支持派生删除查询，使你可以避免显式声明JPQL查询，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. 使用派生的删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="type">void</span> deleteByRoleId(<span class="type">long</span> roleId);

  <span class="annotation">@Modifying</span>
  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">delete from User u where user.role.id = ?1</span><span class="delimiter">&quot;</span></span>)
  <span class="type">void</span> deleteInBulkByRoleId(<span class="type">long</span> roleId);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虽然 <code>deleteByRoleId(&#8230;&#8203;)</code> 方法看起来像与 <code>deleteInBulkByRoleId(&#8230;&#8203;)</code> 产生相同的结果，两个方法声明在执行方式上存在重要差异。
顾名思义，后一种方法针对数据库发出单个JPQL查询（在注解中定义的查询）。这意味着即使当前加载了User实例也看不到调用了它的生命周期回调。</p>
</div>
<div class="paragraph">
<p>为了确保实际调用生命周期查询，<code>deleteByRoleId(&#8230;&#8203;)</code> 的调用执行查询，然后逐个删除返回的实例，
这样持久性提供程序就可以在这些实体上调用 <code>@PreRemove</code> 回调。</p>
</div>
<div class="paragraph">
<p>实际上，派生删除查询是执行查询然后在结果上调用 <code>CrudRepository.delete(Iterable &lt;User&gt; users)</code>
并保持行为与 <code>CrudRepository</code> 中其他 <code>delete(&#8230;&#8203;)</code> 方法的实现同步的快捷方式。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-hints">4.3.9. 应用查询提示</h4>
<div class="paragraph">
<p>要将JPA查询提示应用于存储库接口中声明的查询，可以使用 <code>@QueryHints</code> 注解。它需要一组JPA <code>@QueryHint</code>
注解加上一个布尔标志来默认禁止在分页时需要调用的计数查询上使用查询提示，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. 使用 <code>QueryHints</code> 的存储库方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@QueryHints</span>(value = { <span class="annotation">@QueryHint</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, value = <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)},
              forCounting = <span class="predefined-constant">false</span>)
  Page&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Pageable</span> pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的声明将为实际查询应用已配置的 <code>@QueryHint</code>，但省略将其应用于触发的计数查询以计算总页数。</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.entity-graph">4.3.10. 配置Fetch-和LoadGraphs</h4>
<div class="paragraph">
<p>JPA 2.1规范引入了对指定Fetch-和LoadGraphs的支持，我们也提供了 <code>@EntityGraph</code> 注解，它允许你引用 <code>@NamedEntityGraph</code> 定义。
你可以在实体上使用该注解来配置生成查询的获取计划。可以使用 <code>@EntityGraph</code> 注解上的 <code>type</code> 属性配置获取的类型（<code>Fetch</code> 或 <code>Load</code>）。
有关更多参考，请参阅JPA 2.1 Spec 3.7.4。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在实体上定义命名实体图：</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. 在实体上定义命名实体图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Entity</span>
<span class="annotation">@NamedEntityGraph</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">GroupInfo.detail</span><span class="delimiter">&quot;</span></span>,
  attributeNodes = <span class="annotation">@NamedAttributeNode</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">members</span><span class="delimiter">&quot;</span></span>))
<span class="directive">public</span> <span class="type">class</span> <span class="class">GroupInfo</span> {

  <span class="comment">// 默认拉取模式是懒加载模式</span>
  <span class="annotation">@ManyToMany</span>
  <span class="predefined-type">List</span>&lt;GroupMember&gt; members = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;GroupMember&gt;();

  <span class="error">…</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在存储库查询方法上引用命名实体图：</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. 在存储库查询方法上引用命名实体图定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">GroupRepository</span> <span class="directive">extends</span> CrudRepository&lt;GroupInfo, <span class="predefined-type">String</span>&gt; {

  <span class="annotation">@EntityGraph</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">GroupInfo.detail</span><span class="delimiter">&quot;</span></span>, type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(<span class="predefined-type">String</span> name);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>@EntityGraph</code> 定义ad hoc实体图。提供的 <code>attributePaths</code> 将转换为相应的 <code>EntityGraph</code>，
而无需将 <code>@NamedEntityGraph</code> 显式添加到你的域类型中，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. 在存储库查询方法上使用AD-HOC实体图定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Repository</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">GroupRepository</span> <span class="directive">extends</span> CrudRepository&lt;GroupInfo, <span class="predefined-type">String</span>&gt; {

  <span class="annotation">@EntityGraph</span>(attributePaths = { <span class="string"><span class="delimiter">&quot;</span><span class="content">members</span><span class="delimiter">&quot;</span></span> })
  GroupInfo getByGroupName(<span class="predefined-type">String</span> name);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="projections">4.3.11. 投影</h4>
<div class="paragraph">
<p>Spring Data查询方法通常返回由存储库管理的聚合根的一个或多个实例。但是，有时可能需要根据这些类型的某些属性创建投影。
Spring Data允许建模专用返回类型，以更有选择地检索托管聚合的部分视图。</p>
</div>
<div class="paragraph">
<p>想象一下存储库和聚合根类型，例如以下示例：</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. 一个聚合根和存储库样本</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Person</span> {

  <span class="annotation">@Id</span> <span class="predefined-type">UUID</span> id;
  <span class="predefined-type">String</span> firstname, lastname;
  Address address;

  <span class="directive">static</span> <span class="type">class</span> <span class="class">Address</span> {
    <span class="predefined-type">String</span> zipCode, city, street;
  }
}

<span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">UUID</span>&gt; {

  <span class="predefined-type">Collection</span>&lt;Person&gt; findByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在假设我们只想检索人的姓名属性。Spring Data提供了什么方法来实现这一目标？本章的其余部分回答了这个问题。</p>
</div>
<div class="sect4">
<h5 id="projections.interfaces">基于接口的投影</h5>
<div class="paragraph">
<p>将查询结果限制为仅含名称属性的最简单方法是声明一个接口，该接口公开要读取的属性的访问器方法，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. 用于检索属性子集的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="predefined-type">String</span> getFirstname();
  <span class="predefined-type">String</span> getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里重要的一点是，此处定义的属性与聚合根中的属性完全匹配。这样做可以添加查询方法，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. 使用基于接口的投影和查询方法的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">UUID</span>&gt; {

  <span class="predefined-type">Collection</span>&lt;NamesOnly&gt; findByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例，并将对暴露方法的调用转发给目标对象。</p>
</div>
<div class="paragraph">
<p>可以递归使用投影。如果你还想包含一些地址信息，请为其创建一个投影接口，并在 <code>getAddress()</code> 声明中返回该接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. 用于检索属性子集的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonSummary</span> {

  <span class="predefined-type">String</span> getFirstname();
  <span class="predefined-type">String</span> getLastname();
  AddressSummary getAddress();

  <span class="type">interface</span> <span class="class">AddressSummary</span> {
    <span class="predefined-type">String</span> getCity();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在方法调用上，会获取目标实例的地址属性并依次包装到投影代理中。</p>
</div>
<div class="sect5">
<h6 id="projections.interfaces.closed">闭合投影</h6>
<div class="paragraph">
<p>其访问器方法都与目标聚合的属性匹配的投影接口被认为是封闭投影。以下示例（我们在本章前面也使用过）是一个封闭的投影：</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. 一个闭合投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="predefined-type">String</span> getFirstname();
  <span class="predefined-type">String</span> getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用闭合投影，Spring Data可以优化查询执行，因为我们知道支持投影代理所需的所有属性。有关详细信息，请参阅参考文档中特定于模块的部分。</p>
</div>
</div>
<div class="sect5">
<h6 id="projections.interfaces.open">开放投影</h6>
<div class="paragraph">
<p>投影接口中的访问器方法也可用于通过使用 <code>@Value</code> 注解计算新值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. 一个开放投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{target.firstname + ' ' + target.lastname}</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">String</span> getFullName();
  <span class="error">…</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>支持投影的聚合根在 <code>target</code> 变量中可以使用。使用 <code>@Value</code> 的投影接口是一个开放投影。在这种情况下，Spring Data无法应用查询执行优化，
因为SpEL表达式可以使用聚合根的任何属性。</p>
</div>
<div class="paragraph">
<p><code>@Value</code> 中使用的表达式不应该太复杂 - 你希望避免在 <code>String</code> 变量中编程。对于非常简单的表达式，
一个可选项是采用默认方法（在Java 8中引入），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. 使用默认方法进行自定义逻辑的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="predefined-type">String</span> getFirstname();
  <span class="predefined-type">String</span> getLastname();

  <span class="keyword">default</span> <span class="predefined-type">String</span> getFullName() {
    <span class="keyword">return</span> getFirstname.concat(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>).concat(getLastname());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法要求你只能够纯粹基于投影接口上公开的其他访问器方法来实现逻辑。
第二个更灵活的选项是在Spring bean中实现自定义逻辑，然后从SpEL表达式调用它，如以下示例所示：</p>
</div>
<div id="projections.interfaces.open.bean-reference" class="exampleblock">
<div class="title">Example 77. Person对象样例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Component</span>
<span class="type">class</span> <span class="class">MyBean</span> {

  <span class="predefined-type">String</span> getFullName(Person person) {
    <span class="error">…</span>
  }
}

<span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{@myBean.getFullName(target)}</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">String</span> getFullName();
  <span class="error">…</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>注意SpEL表达式如何引用 <code>myBean</code> 并调用 <code>getFullName(&#8230;&#8203;)</code> 方法并将投影目标转发为方法参数。
由SpEL表达式评估支持的方法也可以使用方法参数，然后可以从表达式引用它们。方法参数可通过名为 <code>args</code> 的 <code>Object</code> 数组获得。
以下示例显示如何从 <code>args</code> 数组获取方法参数：</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. Person对象样例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">NamesOnly</span> {

  <span class="annotation">@Value</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">#{args[0] + ' ' + target.firstname + '!'}</span><span class="delimiter">&quot;</span></span>)
  <span class="predefined-type">String</span> getSalutation(<span class="predefined-type">String</span> prefix);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样，对于更复杂的表达式，你应该使用Spring bean并通过表达式调用方法，如<a href="#projections.interfaces.open.bean-reference">前</a>所述。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="projections.dtos">基于类的投影（DTOs）</h5>
<div class="paragraph">
<p>定义投影的另一种方法是使用值类型DTOs（数据传输对象），它包含应该检索的字段的属性。
这些DTO类型可以与投影接口完全相同的方式使用，除了不发生代理并且不能应用嵌套投影。</p>
</div>
<div class="paragraph">
<p>如果存储通过限制要加载的字段来优化查询执行，则要加载的字段将根据公开的构造函数的参数名称确定。</p>
</div>
<div class="paragraph">
<p>以下示例显示了投影DTO：</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. 投影DTO</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">NamesOnly</span> {

  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span> firstname, lastname;

  NamesOnly(<span class="predefined-type">String</span> firstname, <span class="predefined-type">String</span> lastname) {

    <span class="local-variable">this</span>.firstname = firstname;
    <span class="local-variable">this</span>.lastname = lastname;
  }

  <span class="predefined-type">String</span> getFirstname() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.firstname;
  }

  <span class="predefined-type">String</span> getLastname() {
    <span class="keyword">return</span> <span class="local-variable">this</span>.lastname;
  }

  <span class="comment">// equals(…) 和 hashCode() 实现</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>避免投影DTOs的样板代码</p>
</div>
<div class="paragraph">
<p>你可以使用 <a href="https://projectlombok.org/">Project Lombok</a>大大简化DTO的代码，它提供了一个 <code>@Value</code> 注解
（不要与之前的接口示例中展示的Spring的 <code>@Value</code> 注解混淆）。如果使用Project Lombok的 <code>@Value</code> 注解，
前面显示的示例DTO将变为以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Value</span>
<span class="type">class</span> <span class="class">NamesOnly</span> {
        <span class="predefined-type">String</span> firstname, lastname;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，字段是 <code>private final</code>，并且该类公开一个构造函数，该构造函数接受所有字段，
而且也自动实现 <code>equals(&#8230;&#8203;)</code> 和 <code>hashCode()</code> 方法。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="projection.dynamic">动态投影</h6>
<div class="paragraph">
<p>到目前为止，我们已经使用投影类型作为集合的返回类型或元素类型。但是，你可能希望选择要在调用时使用的类型（这使其成为动态类型）。
要应用动态投影，请使用查询方法，如以下示例中所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. 使用动态投影参数的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> Repository&lt;Person, <span class="predefined-type">UUID</span>&gt; {

  &lt;T&gt; <span class="predefined-type">Collection</span>&lt;T&gt; findByLastname(<span class="predefined-type">String</span> lastname, <span class="predefined-type">Class</span>&lt;T&gt; type);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样，该方法可用于按原样或应用投影获取聚合结果，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. 使用具有动态投影的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> someMethod(PersonRepository people) {

  <span class="predefined-type">Collection</span>&lt;Person&gt; aggregates =
    people.findByLastname(<span class="string"><span class="delimiter">&quot;</span><span class="content">Matthews</span><span class="delimiter">&quot;</span></span>, Person.class);

  <span class="predefined-type">Collection</span>&lt;NamesOnly&gt; aggregates =
    people.findByLastname(<span class="string"><span class="delimiter">&quot;</span><span class="content">Matthews</span><span class="delimiter">&quot;</span></span>, NamesOnly.class);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.stored-procedures">4.4. 存储过程</h3>
<div class="paragraph">
<p>JPA 2.1规范引入了对使用JPA条件查询API调用存储过程的支持。我们引入了 <code>@Procedure</code> 注解，用于在存储库方法上声明存储过程元数据。</p>
</div>
<div class="paragraph">
<p>以下示例使用如下的存储过程：</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. HSQLDB中 <code>plus1inout</code> 存储过程的定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql">/;
<span class="class">DROP</span> <span class="type">procedure</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> plus1inout
/;
<span class="class">CREATE</span> <span class="type">procedure</span> plus1inout (<span class="keyword">IN</span> arg <span class="predefined-type">int</span>, OUT res <span class="predefined-type">int</span>)
<span class="class">BEGIN</span> ATOMIC
 <span class="class">set</span> res = arg + <span class="integer">1</span>;
<span class="keyword">END</span>
/;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用实体类型上的 <code>NamedStoredProcedureQuery</code> 注解来配置存储过程的元数据。</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. 实体上的 <code>StoredProcedure</code> 元数据定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Entity</span>
<span class="annotation">@NamedStoredProcedureQuery</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">User.plus1</span><span class="delimiter">&quot;</span></span>, procedureName = <span class="string"><span class="delimiter">&quot;</span><span class="content">plus1inout</span><span class="delimiter">&quot;</span></span>, parameters = {
  <span class="annotation">@StoredProcedureParameter</span>(mode = ParameterMode.IN, name = <span class="string"><span class="delimiter">&quot;</span><span class="content">arg</span><span class="delimiter">&quot;</span></span>, type = <span class="predefined-type">Integer</span>.class),
  <span class="annotation">@StoredProcedureParameter</span>(mode = ParameterMode.OUT, name = <span class="string"><span class="delimiter">&quot;</span><span class="content">res</span><span class="delimiter">&quot;</span></span>, type = <span class="predefined-type">Integer</span>.class) })
<span class="directive">public</span> <span class="type">class</span> <span class="class">User</span> {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以通过多种方式从存储库方法引用存储过程。要调用的存储过程可以使用 <code>@Procedure</code> 注解的 <code>value</code> 或 <code>procedureName</code> 属性直接定义，
也可以使用 <code>name</code> 属性间接定义。如果未配置名称，则将使用存储库方法的名称作为降级方案。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何显式引用存储过程：</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. 在数据库中显式引用名为“plus1inout”的存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Procedure</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">plus1inout</span><span class="delimiter">&quot;</span></span>)
<span class="predefined-type">Integer</span> explicitlyNamedPlus1inout(<span class="predefined-type">Integer</span> arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用 <code>procedureName</code> 别名隐式引用存储过程：</p>
</div>
<div class="exampleblock">
<div class="title">Example 85. 通过 <code>procedureName</code> 别名在数据库中隐式引用名为“plus1inout”的存储过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Procedure</span>(procedureName = <span class="string"><span class="delimiter">&quot;</span><span class="content">plus1inout</span><span class="delimiter">&quot;</span></span>)
<span class="predefined-type">Integer</span> plus1inout(<span class="predefined-type">Integer</span> arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在 <code>EntityManager</code> 中显式引用映射的存储过程：</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. 在 <code>EntityManager</code> 中显式引用映射的命名存储过程“User.plus1IO”。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Procedure</span>(name = <span class="string"><span class="delimiter">&quot;</span><span class="content">User.plus1IO</span><span class="delimiter">&quot;</span></span>)
<span class="predefined-type">Integer</span> entityAnnotatedCustomNamedProcedurePlus1IO(<span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">arg</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">Integer</span> arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例说明如何使用方法名称在 <code>EntityManager</code> 中隐式引用命名的存储过程：</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. 使用方法名称在 <code>EntityManager</code> 中隐式引用映射的命名存储过程“User.plus1”。</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Procedure</span>
<span class="predefined-type">Integer</span> plus1(<span class="annotation">@Param</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">arg</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">Integer</span> arg);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="specifications">4.5. 规范</h3>
<div class="paragraph">
<p>JPA 2引入了一个标准API，你可以使用它以编程方式构建查询。通过编写 <code>criteria</code>，可以为域类定义查询的 <code>where</code> 子句。
再退一步，可以将这些标准视为JPA标准API约束描述实体的谓词。</p>
</div>
<div class="paragraph">
<p>Spring Data JPA采用Eric Evans的书籍“Domain Driven Design”中的规范概念，遵循相同的语义并提供API以使用JPA条件API定义此类规范。
要支持规范，可以在存储库接口中继承 <code>JpaSpecificationExecutor</code> 接口，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">CustomerRepository</span> <span class="directive">extends</span> CrudRepository&lt;Customer, <span class="predefined-type">Long</span>&gt;, JpaSpecificationExecutor {
 <span class="error">…</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>附加接口具有允许你以各种方式执行规范的方法。例如，<code>findAll</code> 方法返回与规范匹配的所有实体，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;T&gt; findAll(Specification&lt;T&gt; spec);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 接口定义如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Specification</span>&lt;T&gt; {
  <span class="predefined-type">Predicate</span> toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以轻松地使用规范在实体之上构建可扩展的谓词集，然后可以将其与 <code>JpaRepository</code> 结合使用，
而无需为每个所需组合声明查询（方法），如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 88. 客户域的规格</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CustomerSpecs</span> {

  <span class="directive">public</span> <span class="directive">static</span> Specification&lt;Customer&gt; isLongTermCustomer() {
    <span class="keyword">return</span> <span class="keyword">new</span> Specification&lt;Customer&gt;() {
      <span class="directive">public</span> <span class="predefined-type">Predicate</span> toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder) {

         LocalDate date = <span class="keyword">new</span> LocalDate().minusYears(<span class="integer">2</span>);
         <span class="keyword">return</span> builder.lessThan(root.get(_Customer.createdAt), date);
      }
    };
  }

  <span class="directive">public</span> <span class="directive">static</span> Specification&lt;Customer&gt; hasSalesOfMoreThan(MontaryAmount value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Specification&lt;Customer&gt;() {
      <span class="directive">public</span> <span class="predefined-type">Predicate</span> toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder) {

         <span class="comment">// 在这里构建查询</span>
      }
    };
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>不可否认，样板的数量仍有改进的空间（最终可能会因Java 8闭包有所减少），但客户端变得更好，正如你将在本节后面看到的那样。
<code>_Customer</code> 类型是使用JPA Metamodel生成器生成的元模型类型（有关示例，请参阅 <a href="http://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">Hibernate实现的文档</a>）。
因此，表达式 <code>_Customer.createdAt</code> 假定 <code>Customer</code> 具有 <code>Date</code> 类型的 <code>createdAt</code> 属性。
除此之外，我们已经在业务需求抽象级别上表达了一些标准并创建了可执行 <code>Specifications</code>。所以客户端可能会像下面那样使用 <code>Specification</code>：</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. 使用简单的规范</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为什么不为这种数据访问创建查询？使用单个 <code>Specification</code> 并不比普通的查询声明有很多好处。
但当你将它们组合起来创建新的 <code>Specification</code> 对象时，规范的强大功能真的很棒。
你可以通过我们提供的规范帮助程序类来实现此目的，以构建类似于以下内容的表达式：</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. 组合规范</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">MonetaryAmount amount = <span class="keyword">new</span> MonetaryAmount(<span class="float">200.0</span>, Currencies.DOLLAR);
<span class="predefined-type">List</span>&lt;Customer&gt; customers = customerRepository.findAll(
  where(isLongTermCustomer()).or(hasSalesOfMoreThan(amount)));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 提供了一些链接和组合 <code>Specification</code> 实例的“胶水代码”方法。
这些方法允许你通过创建新的 <code>Specification</code> 实现并将它们与现有实现相结合来扩展数据访问层。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-by-example">4.6. 按示例查询</h3>
<div class="sect3">
<h4 id="query-by-example.introduction">4.6.1. 介绍</h4>
<div class="paragraph">
<p>本章介绍Query by Example并说明如何使用它。</p>
</div>
<div class="paragraph">
<p>按示例查询（QBE）是一种用户友好的查询技术，具有简单的接口。它允许动态创建查询，并且不需要你编写包含字段名称的查询。
实际上，Query by Example不要求你使用特定于存储库的查询语言来编写查询。</p>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.usage">4.6.2. 用法</h4>
<div class="paragraph">
<p>Query by Example API由三部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>探针：具有填充字段的域对象的实际示例。</p>
</li>
<li>
<p><code>ExampleMatcher</code>：<code>ExampleMatcher</code> 包含有关如何匹配特定字段的详细信息。它可以在多个示例中重用。</p>
</li>
<li>
<p><code>Example</code>：<code>Example</code> 由探针和 <code>ExampleMatcher</code> 组成。它用于创建查询。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>按示例查询非常适合几种场景：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一组静态或动态约束查询数据存储。</p>
</li>
<li>
<p>频繁重构域对象，而不必担心破坏现有查询。</p>
</li>
<li>
<p>独立于底层数据存储API工作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>按示例查询也有几个限制：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持嵌套或分组的属性约束，例如 <code>firstname = ?0 or (firstname = ?1 and lastname = ?2)</code>。</p>
</li>
<li>
<p>仅支持字符串的开始/包含/结束/正则表达式匹配以及其他属性类型的精确匹配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在开始使用Query by Example之前，你需要拥有一个域对象。首先，为存储库创建一个接口，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. Person对象样例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {

  <span class="annotation">@Id</span>
  <span class="directive">private</span> <span class="predefined-type">String</span> id;
  <span class="directive">private</span> <span class="predefined-type">String</span> firstname;
  <span class="directive">private</span> <span class="predefined-type">String</span> lastname;
  <span class="directive">private</span> Address address;

  <span class="comment">// … getters 和 setters 省略了</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例显示了一个简单的域对象。你可以使用它来创建 <code>Example</code>。默认情况下，将忽略具有 <code>null</code> 的字段，
并使用特定于存储库的默认值匹配字符串。可以使用工厂方法或使用 <a href="#query-by-example.matchers"><code>ExampleMatcher</code></a> 构建示例。
以下清单显示了一个简单的示例：</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. 简单的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Person person = <span class="keyword">new</span> Person();                     <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>);                      <i class="conum" data-value="2"></i><b>(2)</b>

Example&lt;Person&gt; example = Example.of(person);     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建域对象的新实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置要查询的属性。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建 <code>Example</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>理想情况下，使用存储库执行示例。为此，请让你的存储库接口扩展 <code>QueryByExampleExecutor&lt;T&gt;</code>。
以下清单显示了 <code>QueryByExampleExecutor</code> 接口的摘录：</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. <code>QueryByExampleExecutor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">QueryByExampleExecutor</span>&lt;T&gt; {

  &lt;S <span class="directive">extends</span> T&gt; S findOne(Example&lt;S&gt; example);

  &lt;S <span class="directive">extends</span> T&gt; <span class="predefined-type">Iterable</span>&lt;S&gt; findAll(Example&lt;S&gt; example);

  <span class="comment">// … 省略了更多功能</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.matchers">4.6.3. 示例匹配器</h4>
<div class="paragraph">
<p>示例不限于默认设置。你可以使用 <code>ExampleMatcher</code> 为字符串匹配，null值处理和属性特定设置指定自己的默认值，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. 具有自定义匹配的示例匹配器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Person person = <span class="keyword">new</span> Person();                          <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname(<span class="string"><span class="delimiter">&quot;</span><span class="content">Dave</span><span class="delimiter">&quot;</span></span>);                           <i class="conum" data-value="2"></i><b>(2)</b>

ExampleMatcher matcher = ExampleMatcher.matching()     <i class="conum" data-value="3"></i><b>(3)</b>
  .withIgnorePaths(<span class="string"><span class="delimiter">&quot;</span><span class="content">lastname</span><span class="delimiter">&quot;</span></span>)                         <i class="conum" data-value="4"></i><b>(4)</b>
  .withIncludeNullValues()                             <i class="conum" data-value="5"></i><b>(5)</b>
  .withStringMatcherEnding();                          <i class="conum" data-value="6"></i><b>(6)</b>

Example&lt;Person&gt; example = Example.of(person, matcher); <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建域对象的新实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置属性。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个 <code>ExampleMatcher</code> 以期望所有值匹配。即使没有进一步配置，在这个阶段也可直接使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径并包含null值。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径，包含null值，并执行字符串后缀匹配。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>基于域对象和配置的 <code>ExampleMatcher</code> 创建新 <code>Example</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>ExampleMatcher</code> 期望探针上设置的所有值都匹配。如果要获得与隐式定义的任何一个谓词匹配的结果，
请使用 <code>ExampleMatcher.matchingAny()</code>。</p>
</div>
<div class="paragraph">
<p>你可以为单个属性指定行为（例如“firstname”和“lastname”，或者对于嵌套属性，“address.city”）。
你可以使用匹配选项和区分大小写来调整它，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 95. 配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher(<span class="string"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span>, endsWith())
  .withMatcher(<span class="string"><span class="delimiter">&quot;</span><span class="content">lastname</span><span class="delimiter">&quot;</span></span>, startsWith().ignoreCase());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置matcher选项的另一种方法是使用lambda表达式（在Java 8中引入）。此方法创建一个回调，要求实现者修改匹配器。
你无需返回匹配器，因为配置选项保存在匹配器实例中。以下示例显示了使用lambdas的匹配器：</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. 使用lambdas配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher(<span class="string"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span>, match -&gt; match.endsWith())
  .withMatcher(<span class="string"><span class="delimiter">&quot;</span><span class="content">firstname</span><span class="delimiter">&quot;</span></span>, match -&gt; match.startsWith());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Example</code> 创建的查询使用配置的合并视图。可以在 <code>ExampleMatcher</code> 级别设置默认匹配设置，而可以将单个设置应用于特定属性路径。
除非明确定义，否则 <code>ExampleMatcher</code> 上配置的设置将由属性路径设置继承。属性路径设置优先于默认设置。
下表描述了各种 <code>ExampleMatcher</code> 设置的作用域：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. <code>ExampleMatcher</code> 设置的作用域</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">作用域</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">null值处理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExampleMatcher</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">字符串匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExampleMatcher和属性路径</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">忽略属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性路径</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">区分大小写</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExampleMatcher和属性路径</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">值转换</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性路径</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="query-by-example.execution">4.6.4. 执行示例</h4>
<div class="paragraph">
<p>在Spring Data JPA中，你可以使用存储库按示例查询，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. 使用存储库按示例查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">PersonRepository</span> <span class="directive">extends</span> JpaRepository&lt;Person, <span class="predefined-type">String</span>&gt; { <span class="error">…</span> }

<span class="directive">public</span> <span class="type">class</span> <span class="class">PersonService</span> {

  <span class="annotation">@Autowired</span> PersonRepository personRepository;

  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Person&gt; findPeople(Person probe) {
    <span class="keyword">return</span> personRepository.findAll(Example.of(probe));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
目前，只有 <code>SingularAttribute</code> 属性可用于属性匹配。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>属性说明符接受属性名称（例如 <code>firstname</code> 和 <code>lastname</code>）。你可以通过将属性与点（<code>address.city</code>）链接在一起来进行导航。
你还可以使用匹配选项和区分大小写来调整它。</p>
</div>
<div class="paragraph">
<p>下表显示了可以使用的各种 <code>StringMatcher</code> 选项以及在名为 <code>firstname</code> 的字段上使用它们的结果：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. <code>StringMatcher</code> 选项</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">逻辑结果</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (不区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code> (区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code> (不区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code> (区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code> (不区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like LOWER(?0) + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code> (区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code> (不区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code> (区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code> (不区分大小写)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0) + '%'</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="transactions">4.7. 事务</h3>
<div class="paragraph">
<p>默认情况下，存储库实例上的CRUD方法是事务性的。对于读取操作，事务配置 <code>readOnly</code> 标志设置为 <code>true</code>。
所有其他配置都使用普通的 <code>@Transactional</code>，以便应用默认事务配置。有关详细信息，请参阅
<a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/SimpleJpaRepository.html"><code>SimpleJpaRepository</code></a> 的JavaDoc。
如果需要为存储库中声明的方法之一调整事务配置，请在存储库接口中重新声明该方法，如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. CRUD的自定义事务配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> CrudRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="annotation">@Override</span>
  <span class="annotation">@Transactional</span>(timeout = <span class="integer">10</span>)
  <span class="directive">public</span> <span class="predefined-type">List</span>&lt;User&gt; findAll();

  <span class="comment">// 其它的查询方法声明</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做会导致 <code>findAll()</code> 方法以10秒的超时时间运行并且没有 <code>readOnly</code> 标志。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>更改事务行为的另一种方法是使用（通常）覆盖多个存储库的外观或服务实现。其目的是为非CRUD操作定义事务边界。
以下示例显示如何将此类Facade用于多个存储库：</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. 使用facade为多个存储库调用定义事务</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Service</span>
<span class="type">class</span> <span class="class">UserManagementImpl</span> <span class="directive">implements</span> UserManagement {

  <span class="directive">private</span> <span class="directive">final</span> UserRepository userRepository;
  <span class="directive">private</span> <span class="directive">final</span> RoleRepository roleRepository;

  <span class="annotation">@Autowired</span>
  <span class="directive">public</span> UserManagementImpl(UserRepository userRepository,
    RoleRepository roleRepository) {
    <span class="local-variable">this</span>.userRepository = userRepository;
    <span class="local-variable">this</span>.roleRepository = roleRepository;
  }

  <span class="annotation">@Transactional</span>
  <span class="directive">public</span> <span class="type">void</span> addRoleToAllUsers(<span class="predefined-type">String</span> roleName) {

    <span class="predefined-type">Role</span> role = roleRepository.findByName(roleName);

    <span class="keyword">for</span> (User user : userRepository.findAll()) {
      user.addRole(role);
      userRepository.save(user);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例导致调用 <code>addRoleToAllUsers(&#8230;&#8203;)</code> 在事务内部运行（加入现有事务或创建新事务（如果没有已运行的））。
然后忽略存储库中的事务配置，因为外部事务配置确定所使用的实际配置。请注意，你必须激活 <code>&lt;tx：annotation-driven/&gt;</code>
或显式使用 <code>@EnableTransactionManagement</code> 以使基于注解的外观配置起作用。此示例假定你已启用组件扫描。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactional-query-methods">4.7.1. 事务性查询方法</h4>
<div class="paragraph">
<p>要让你的查询方法是事务性的，请在你定义的存储库接口上使用 <code>@Transactional</code>，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. 在查询方法中使用 <code>@Transactional</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Transactional</span>(readOnly = <span class="predefined-constant">true</span>)
<span class="directive">public</span> <span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> JpaRepository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname);

  <span class="annotation">@Modifying</span>
  <span class="annotation">@Transactional</span>
  <span class="annotation">@Query</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">delete from User u where u.active = false</span><span class="delimiter">&quot;</span></span>)
  <span class="type">void</span> deleteInactiveUsers();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，你希望将 <code>readOnly</code> 标志设置为 <code>true</code>，因为大多数查询方法只读取数据。与此相反，<code>deleteInactiveUsers()</code> 使用 <code>@Modifying</code> 注解并覆盖事务配置。因此，该方法在 <code>readOnly</code> 标志设置为 <code>false</code> 的情况下运行。</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你可以将事务用于只读查询，并通过设置 <code>readOnly</code> 标志来标记它们。但是，这样做不会检查你是否触发了非查询操作（尽管某些数据库拒绝只读事务中的 <code>INSERT</code> 和 <code>UPDATE</code> 语句）。而 <code>readOnly</code> 标志则作为提示传播到底层JDBC驱动程序以进行性能优化。此外，Spring对底层JPA提供程序执行了一些优化。
例如，当与Hibernate一起使用时，当你将事务配置为 <code>readOnly</code> 时，刷新模式将设置为 <code>NEVER</code>，这会导致Hibernate跳过脏检查（对大型对象树的显著性能改进）。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking">4.8. 锁</h3>
<div class="paragraph">
<p>指定要使用锁定模式，可以在查询方法上使用 <code>@Lock</code> 注解，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. 在查询方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="comment">// 简单查询方法</span>
  <span class="annotation">@Lock</span>(LockModeType.READ)
  <span class="predefined-type">List</span>&lt;User&gt; findByLastname(<span class="predefined-type">String</span> lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法声明使触发的查询 <code>LockModeType</code> 为 <code>READ</code>。你还可以通过在存储库接口中重新声明CRUD方法并添加
<code>@Lock</code> 注解来定义CRUD方法的锁定，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. 在CRUD方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">UserRepository</span> <span class="directive">extends</span> Repository&lt;User, <span class="predefined-type">Long</span>&gt; {

  <span class="comment">// 重新声明CRUD方法</span>
  <span class="annotation">@Lock</span>(LockModeType.READ);
  <span class="predefined-type">List</span>&lt;User&gt; findAll();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="auditing">4.9. 审计</h3>
<div class="sect3">
<h4 id="auditing.basics">4.9.1. 基础</h4>
<div class="paragraph">
<p>Spring Data提供了复杂的支持，可以透明地跟踪创建或更改实体的人员以及更改发生的时间。要从该功能中受益，
你必须为你的实体类配备审计元数据，该元数据可以使用注解或通过实现接口来定义。</p>
</div>
<div class="sect4">
<h5 id="auditing.annotations">基于注解的审计元数据</h5>
<div class="paragraph">
<p>我们提供 <code>@CreatedBy</code> 和 <code>@LastModifiedBy</code> 来捕获创建或修改实体的用户以及 <code>@CreatedDate</code> 和 <code>@LastModifiedDate</code>
以捕获更改发生的时间。</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. 经审计的实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Customer</span> {

  <span class="annotation">@CreatedBy</span>
  <span class="directive">private</span> User user;

  <span class="annotation">@CreatedDate</span>
  <span class="directive">private</span> DateTime createdDate;

  <span class="comment">// … 其他属性省略</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如你所见，可以有选择地应用注解，具体取决于你要捕获的信息。进行更改时捕获的注解可用于Joda-Time，<code>DateTime</code>，
旧Java <code>Date</code> 和 <code>Calendar</code>，JDK8日期和时间类型以及 <code>long</code> 或 <code>Long</code> 类型的属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="auditing.interfaces">基于接口的审计元数据</h5>
<div class="paragraph">
<p>如果你不想使用注解来定义审核元数据，可以让你的域类实现 <code>Auditable</code> 接口，它公开了所有审计属性的 <code>setter</code> 方法。</p>
</div>
<div class="paragraph">
<p>还有一个方便的基类 <code>AbstractAuditable</code>，你可以继承它以避免需要手动实现接口方法。这样做会增加域类与Spring Data的耦合，
这可能是你想要避免的。通常，基于注解的定义审计元数据的方式是优选的，因为它具有较小的侵入性和更灵活性。</p>
</div>
<div class="sect5">
<h6 id="auditing.auditor-aware"><code>AuditorAware</code></h6>
<div class="paragraph">
<p>如果你使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code>，审计基础设施需要以某种方式了解当前主体。
为此，我们提供了一个 <code>AuditorAware&lt;T&gt;</code> SPI接口，你必须实现该接口，以告知基础设施当前与应用程序交互的用户。
泛型类型 <code>T</code> 定义了使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 注解的属性的类型。</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用Spring Security的 <code>Authentication</code> 对象的接口的实现：</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. 基于Spring Security的 <code>AuditorAware</code> 实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">SpringSecurityAuditorAware</span> <span class="directive">implements</span> AuditorAware&lt;User&gt; {

  <span class="directive">public</span> User getCurrentAuditor() {

    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

    <span class="keyword">if</span> (authentication == <span class="predefined-constant">null</span> || !authentication.isAuthenticated()) {
      <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }

    <span class="keyword">return</span> ((MyUserDetails) authentication.getPrincipal()).getUser();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该实现访问Spring Security提供的 <code>Authentication</code> 对象，并查找你在 <code>UserDetailsS​​ervice</code> 实现中创建的自定义 <code>UserDetails</code> 实例。
我们假设你通过 <code>UserDetails</code> 实现公开域用户，根据找到的身份验证获取它，你也可以从任何地方查找它。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.auditing">4.9.2. JPA审计</h4>
<div class="sect4">
<h5 id="jpa.auditing.configuration">通用审计配置</h5>
<div class="paragraph">
<p>Spring Data JPA附带了一个实体监听器，可用于触发审计信息的捕获。首先，你必须注册 <code>AuditingEntityListener</code> 以用于审计 <code>orm.xml</code>
文件中持久性上下文中的所有实体，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 105. 审计配置orm.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;persistence-unit-metadata&gt;</span>
  <span class="tag">&lt;persistence-unit-defaults&gt;</span>
    <span class="tag">&lt;entity-listeners&gt;</span>
      <span class="tag">&lt;entity-listener</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">….data.jpa.domain.support.AuditingEntityListener</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
    <span class="tag">&lt;/entity-listeners&gt;</span>
  <span class="tag">&lt;/persistence-unit-defaults&gt;</span>
<span class="tag">&lt;/persistence-unit-metadata&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你还可以将 <code>@EntityListeners</code> 注解在每个实体上以启用 <code>AuditingEntityListener</code>，如下所示：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Entity</span>
<span class="annotation">@EntityListeners</span>(AuditingEntityListener.class)
<span class="directive">public</span> <span class="type">class</span> <span class="class">MyEntity</span> {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
审计功能要求类路径上有 <code>spring-aspects.jar</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过适当修改 <code>orm.xml</code> 和类路径上持有 <code>spring-aspects.jar</code>，激活审计功能是将Spring Data JPA审计命名空间元素添加到配置中，
如下所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. 使用XML配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;jpa:auditing</span> <span class="attribute-name">auditor-aware-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">yourAuditorAwareBean</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从Spring Data JPA 1.5开始，你可以通过添加 <code>@EnableJpaAuditing</code> 注解到配置类来启用审计。
你仍然必须修改 <code>orm.xml</code> 文件并在类路径上使用 <code>spring-aspects.jar</code>。以下示例显示如何使用 <code>@EnableJpaAuditing</code> 注解：</p>
</div>
<div class="exampleblock">
<div class="title">Example 107. 使用Java配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Configuration</span>
<span class="annotation">@EnableJpaAuditing</span>
<span class="type">class</span> <span class="class">Config</span> {

  <span class="annotation">@Bean</span>
  <span class="directive">public</span> AuditorAware&lt;AuditableUser&gt; auditorProvider() {
    <span class="keyword">return</span> <span class="keyword">new</span> AuditorAwareImpl();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果将 <code>AuditorAware</code> 类型的bean暴露在 <code>ApplicationContext</code>，则审计基础设施会自动选择它并使用它来确定要在域类型上设置的当前用户。
如果在 <code>ApplicationContext</code> 中注册了多个实现，则可以通过显式设置 <code>@EnableJpaAuditing</code> 的 <code>auditorAwareRef</code> 属性来选择要使用的实现。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.misc">4.10. 其他考虑因素</h3>
<div class="sect3">
<h4 id="jpa.misc.jpa-context">4.10.1. 在自定义实现中使用 <code>JpaContext</code></h4>
<div class="paragraph">
<p>使用多个 <code>EntityManager</code> 实例和<a href="#repositories.custom-implementations">自定义存储库</a>实现时，
需要将正确的EntityManager连接到存储库实现类。你可以通过在 <code>@PersistenceContext</code> 注解中显式命名 <code>EntityManager</code> 来实现，
或者，如果 <code>EntityManager</code> 被 <code>@Autowired</code> 标注，则使用 <code>@Qualifier</code> 来区分。</p>
</div>
<div class="paragraph">
<p>从Spring Data JPA 1.9开始，Spring Data JPA包含一个名为 <code>JpaContext</code> 的类，它允许你通过托管域类获取 <code>EntityManager</code>，
假设它仅由应用程序中的一个 <code>EntityManager</code> 实例管理。以下示例显示如何在自定义存储库中使用 <code>JpaContext</code>：</p>
</div>
<div class="exampleblock">
<div class="title">Example 108. 在自定义存储库实现中使用 <code>JpaContext</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">UserRepositoryImpl</span> <span class="directive">implements</span> UserRepositoryCustom {

  <span class="directive">private</span> <span class="directive">final</span> EntityManager em;

  <span class="annotation">@Autowired</span>
  <span class="directive">public</span> UserRepositoryImpl(JpaContext context) {
    <span class="local-variable">this</span>.em = context.getEntityManagerByManagedType(User.class);
  }

  <span class="error">…</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法的优点是，如果将域类型分配给不同的持久性单元，则不必触及存储库来更改对持久性单元的引用。</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.misc.merging-persistence-units">4.10.2. 合并持久性单元</h4>
<div class="paragraph">
<p>Spring支持具有多个持久性单元。但是，有时你可能希望模块化你的应用程序，但仍然确保所有这些模块在单个持久性单元内运行。
为了实现该行为，Spring Data JPA提供了一个 <code>PersistenceUnitManager</code> 实现，该实现根据其名称自动合并持久性单元，如以下示例所示：</p>
</div>
<div class="exampleblock">
<div class="title">Example 109. 使用 <code>MergingPersistenceUnitmanager</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">….LocalContainerEntityManagerFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">persistenceUnitManager</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">….MergingPersistenceUnitManager</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
  <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jpa.misc.entity-scanning"><code>@Entity</code> 类和JPA映射文件的类路径扫描</h5>
<div class="paragraph">
<p>普通的JPA设置要求在 <code>orm.xml</code> 中列出所有注解映射的实体类。这同样适用于其它XML映射文件。Spring Data JPA
提供了一个 <code>ClasspathScanningPersistenceUnitPostProcessor</code>，它可以获取配置的基础包，并可选择采用映射文件名模式。
然后，它会扫描给定的包以获取使用 <code>@Entity</code> 或 <code>@MappedSuperclass</code> 注解的类，加载与文件名模式匹配的配置文件，并将它们交给JPA配置。
后置处理器必须配置如下：</p>
</div>
<div class="exampleblock">
<div class="title">Example 110. 使用 <code>ClasspathScanningPersistenceUnitPostProcessor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">….LocalContainerEntityManagerFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">persistenceUnitPostProcessors</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;list&gt;</span>
      <span class="tag">&lt;bean</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;constructor-arg</span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">com.acme.domain</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
        <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">mappingFileNamePattern</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">**/*Mapping.xml</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
      <span class="tag">&lt;/bean&gt;</span>
    <span class="tag">&lt;/list&gt;</span>
  <span class="tag">&lt;/property&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从Spring 3.1开始，可以直接在 <code>LocalContainerEntityManagerFactoryBean</code> 上配置要扫描的包，
以便为实体类启用类路径扫描。有关详细信息，请参阅 <a href="https://docs.spring.io/spring/docs/5.0.8.RELEASE/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String&#8230;&#8203;)">JavaDoc</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpd.misc.cdi-integration">4.10.3. CDI集成</h4>
<div class="paragraph">
<p>存储库接口的实例通常由容器创建，在使用Spring Data时，Spring是最自然的选择。Spring提供了对创建bean实例的复杂支持，
如<a href="#repositories.create-instances">创建存储库实例</a>中所述。从版本1.1.0开始，Spring Data JPA附带了一个自定义CDI扩展，
允许在CDI环境中使用存储库抽象。扩展是JAR的一部分。要激活它，请在类路径中包含Spring Data JPA JAR。</p>
</div>
<div class="paragraph">
<p>你现在可以通过为 <code>EntityManagerFactory</code> 和 <code>EntityManager</code> 实现CDI Producer来设置基础结构，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EntityManagerFactoryProducer</span> {

  <span class="annotation">@Produces</span>
  <span class="annotation">@ApplicationScoped</span>
  <span class="directive">public</span> EntityManagerFactory createEntityManagerFactory() {
    <span class="keyword">return</span> Persistence.createEntityManagerFactory(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-presistence-unit</span><span class="delimiter">&quot;</span></span>);
  }

  <span class="directive">public</span> <span class="type">void</span> close(<span class="annotation">@Disposes</span> EntityManagerFactory entityManagerFactory) {
    entityManagerFactory.close();
  }

  <span class="annotation">@Produces</span>
  <span class="annotation">@RequestScoped</span>
  <span class="directive">public</span> EntityManager createEntityManager(EntityManagerFactory entityManagerFactory) {
    <span class="keyword">return</span> entityManagerFactory.createEntityManager();
  }

  <span class="directive">public</span> <span class="type">void</span> close(<span class="annotation">@Disposes</span> EntityManager entityManager) {
    entityManager.close();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>必要的设置可能因JavaEE环境而异。你可能只需要将 <code>EntityManager</code> 重新声明为CDI bean，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">CdiConfig</span> {

  <span class="annotation">@Produces</span>
  <span class="annotation">@RequestScoped</span>
  <span class="annotation">@PersistenceContext</span>
  <span class="directive">public</span> EntityManager entityManager;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，容器必须能够自己创建JPA <code>EntityManagers</code>。所有配置都将JPA <code>EntityManager</code> 重新导出为CDI bean。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix">5. 附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="repositories.namespace-reference">5.1. 命名空间参考</h3>
<div class="sect3">
<h4 id="__code_repositories_code_元素">5.1.1. <code>&lt;repositories/&gt;</code> 元素</h4>
<div class="paragraph">
<p><code>&lt;repositories/&gt;</code> 元素触发Spring Data存储库基础结构的设置。最重要的属性是 <code>base-package</code>，
它定义了扫描Spring Data存储库接口的包。参考 <a href="#repositories.create-instances.spring">XML配置</a>。下表描述了 <code>&lt;repositories/&gt;</code> 元素的属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. 属性</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">base-package</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义要扫描的存储库接口的包，该存储库接口继承 <code>*Repository</code> （实际接口由特定的Spring Data模块确定）。
也会扫描配置包下面的所有包。允许使用通配符。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">repository-impl-postfix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义后缀以自动检测自定义存储库实现。名称以配置的后缀结尾的类被视为候选人。默认后缀为 <code>Impl</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">query-lookup-strategy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">确定用于创建查询的策略。有关详细信息，请参考 <a href="#repositories.query-methods.query-lookup-strategies">查询查找策略</a>。默认为 <code>create-if-not-found</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">named-queries-location</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义搜索的包含外部定义查询的Properties文件的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">consider-nested-repositories</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应考虑嵌套存储库接口定义。默认为 <code>false</code>。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="populator.namespace-reference">5.2. Populators命名空间参考</h3>
<div class="sect3">
<h4 id="__code_populator_code_元素">5.2.1. <code>&lt;populator/&gt;</code> 元素</h4>
<div class="paragraph">
<p><code>&lt;populator/&gt;</code> 元素允许通过Spring Data存储库基础结构填充数据存储。<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup></p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. 属性</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">locations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于填充存储库的对象的值的文件位置。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="repository-query-keywords">5.3. 存储库查询关键字</h3>
<div class="sect3">
<h4 id="_支持的查询关键字">5.3.1. 支持的查询关键字</h4>
<div class="paragraph">
<p>下表列出了Spring Data存储库查询派生机制通常支持的关键字。
但是，请参阅特定存储的文档以获取支持的关键字的确切列表，因为此处列出的某些关键字可能在特定存储中不受支持。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. 查询关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">逻辑关键字</th>
<th class="tableblock halign-left valign-top">关键字表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AFTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code>, <code>IsAfter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BEFORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code>, <code>IsBefore</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code>, <code>IsBetween</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXISTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Exists</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code>, <code>IsFalse</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code>, <code>IsGreaterThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN_EQUALS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code>, <code>IsIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code>, (or no keyword)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsEmpty</code>, <code>Empty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotEmpty</code>, <code>NotEmpty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotNull</code>, <code>IsNotNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Null</code>, <code>IsNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code>, <code>IsLessThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN_EQUAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code>, <code>IsLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Near</code>, <code>IsNear</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code>, <code>IsNot</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code>, <code>IsNotIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code>, <code>IsNotLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGEX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code>, <code>IsTrue</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WITHIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Within</code>, <code>IsWithin</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="repository-query-return-types">5.4. 存储库查询返回类型</h3>
<div class="sect3">
<h4 id="_支持的查询返回类型">5.4.1. 支持的查询返回类型</h4>
<div class="paragraph">
<p>下表列出了Spring Data存储库通常支持的返回类型。但是，请查阅特定于存储库的文档以获取支持的返回类型的确切列表，
因为特定存储库可能不支持此处列出的某些类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
地理空间类型（例如 <code>GeoResult</code>，<code>GeoResults</code> 和 <code>GeoPage</code>）仅适用于支持地理空间查询的数据存储。
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. 查询返回类型</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">void</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示没有返回值。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primitives</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java原语。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java包装器类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个特定的实体。期望查询方法最多返回一个结果。如果未找到结果，则返回 <code>null</code>。
多个结果会触发 <code>IncorrectResultSizeDataAccessException</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Iterator&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">迭代器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Collection&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">集合。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8或Guava <code>Optional</code>。期望查询方法最多返回一个结果。如果未找到结果，
则返回 <code>Optional.empty()</code> 或 <code>Optional.absent()</code>。多个结果会触发 <code>IncorrectResultSizeDataAccessException</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scala或Javaslang <code>Option</code> 类型。语义上与前面描述的Java 8的 <code>Optional</code> 相同。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stream&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8流 <code>Stream</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Future&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Future</code>。期望使用 <code>@Async</code> 注解的方法，并且需要启用Spring的异步方法执行功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CompletableFuture&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 <code>CompletableFuture</code>。期望使用 <code>@Async</code> 注解的方法，并且需要启用Spring的异步方法执行功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ListenableFuture</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.util.concurrent.ListenableFuture</code>。
期望使用 <code>@Async</code> 注解的方法，并且需要启用Spring的异步方法执行功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Slice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据块切片，指示是否有更多数据可用。需要 <code>Pageable</code> 方法参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有附加信息的切片，例如结果总数。需要 <code>Pageable</code> 方法参数。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GeoResult&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有附加信息的结果条目，例如到参考位置的距离。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GeoResults&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">带有附加信息的 <code>GeoResult&lt;T&gt;</code> 列表，例如到参考位置的平均距离。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GeoPage&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含 <code>GeoResult&lt;T&gt;</code> 的页，例如到参考位置的平均距离。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mono&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://projectreactor.io/">Project Reactor</a> <code>Mono</code> 使用响应式存储库发射零或一个元素 。期望查询方法最多返回一个结果。
如果未找到结果，则返回 <code>Mono.empty()</code>。多个结果会触发 <code>IncorrectResultSizeDataAccessException</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flux&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://projectreactor.io/">Project Reactor</a> <code>Flux</code> 使用响应式存储库发射零个，一个或多个元素。返回 <code>Flux</code> 的查询也可以发出无限数量的元素。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Single&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/ReactiveX/RxJava">RxJava</a> <code>Single</code> 使用响应式存储库发射单个元素。期望查询方法最多返回一个结果。如果未找到结果，则返回 <code>Mono.empty()</code>。
多个结果会触发 <code>IncorrectResultSizeDataAccessException</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maybe&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/ReactiveX/RxJava">RxJava</a> <code>Maybe</code> 使用响应式存储库发射零个或一个元素。期望查询方法最多返回一个结果。如果未找到结果，
则返回 <code>Mono.empty()</code>。多个结果会触发 <code>IncorrectResultSizeDataAccessException</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flowable&lt;T&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/ReactiveX/RxJava">RxJava</a> <code>Flowable</code> 使用响应式存储库发射零个，一个或多个元素。返回 <code>Flowable</code> 的查询也可以发出无限数量的元素。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="faq">5.5. FAQ</h3>
<div class="sect3">
<h4 id="_常见">5.5.1. 常见</h4>
<div class="qlist qanda">
<ol>
<li>
<p><em>我想获得更详细的日志信息，以便了解在 <code>JpaRepository</code> 中调用了哪些方法，该怎么做呢？</em></p>
<p>你可以使用Spring提供的 <code>CustomizableTraceInterceptor</code>，如以下示例所示：</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customizableTraceInterceptor</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span>
  <span class="content">org.springframework.aop.interceptor.CustomizableTraceInterceptor</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">enterMessage</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Entering $[methodName]($[arguments])</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
  <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">exitMessage</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Leaving $[methodName](): $[returnValue]</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span>

<span class="tag">&lt;aop:config&gt;</span>
  <span class="tag">&lt;aop:advisor</span> <span class="attribute-name">advice-ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">customizableTraceInterceptor</span><span class="delimiter">&quot;</span></span>
    <span class="attribute-name">pointcut</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">execution(public * org.springframework.data.jpa.repository.JpaRepository+.*(..))</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/aop:config&gt;</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_基础设施">5.5.2. 基础设施</h4>
<div class="qlist qanda">
<ol>
<li>
<p><em>目前，我已经实现了基于 <code>HibernateDaoSupport</code> 的存储库层。我使用Spring的 <code>AnnotationSessionFactoryBean</code> 创建一个 <code>SessionFactory</code>。如何在此环境中使用Spring Data存储库？</em></p>
<p>你必须使用 <code>HibernateJpaSessionFactoryBean</code> 替换 <code>AnnotationSessionFactoryBean</code>，如下所示：</p>
<div class="exampleblock">
<div class="title">Example 111. 从 <code>HibernateEntityManagerFactory</code> 查找 <code>SessionFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;bean</span> <span class="attribute-name">id</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">sessionFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.springframework.orm.jpa.vendor.HibernateJpaSessionFactoryBean</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;property</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">entityManagerFactory</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">ref</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">entityManagerFactory</span><span class="delimiter">&quot;</span></span><span class="tag">/&gt;</span>
<span class="tag">&lt;/bean&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_审计">5.5.3. 审计</h4>
<div class="qlist qanda">
<ol>
<li>
<p><em>我想使用Spring Data JPA审计功能，但我的数据库已配置为在实体上设置修改和创建日期。如何防止Spring Data以编程方式设置日期？</em></p>
<p>将 <code>auditing</code> 命名空间元素的 <code>set-dates</code> 属性设置为 <code>false</code>。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="glossary">5.6. 词汇表</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">AOP</dt>
<dd>
<p>面向切面编程</p>
</dd>
<dt class="hdlist1">Commons DBCP</dt>
<dd>
<p><a href="http://commons.apache.org/proper/commons-dbcp/index.html">Commons DataBase Connection Pools</a> - 来自Apache基础的库，提供 <code>DataSource</code> 接口的池实现</p>
</dd>
<dt class="hdlist1">CRUD</dt>
<dd>
<p>创建，读取，更新，删除 - 基本持久性操作</p>
</dd>
<dt class="hdlist1">DAO</dt>
<dd>
<p>数据访问对象 - 用于将持久化逻辑与要持久化的对象分开的模式</p>
</dd>
<dt class="hdlist1">Dependency Injection</dt>
<dd>
<p>模式将组件的依赖关系从外部传递给组件，降低组件间耦合。有关更多信息，
请参阅 <a href="http://en.wikipedia.org/wiki/Dependency_Injection" class="bare">http://en.wikipedia.org/wiki/Dependency_Injection</a></p>
</dd>
<dt class="hdlist1">EclipseLink</dt>
<dd>
<p>实现JPA的对象关系映射器 -  <a href="http://www.eclipselink.org" class="bare">http://www.eclipselink.org</a></p>
</dd>
<dt class="hdlist1">Hibernate</dt>
<dd>
<p>实现JPA的对象关系映射器 -  <a href="http://www.hibernate.org" class="bare">http://www.hibernate.org</a></p>
</dd>
<dt class="hdlist1">JPA</dt>
<dd>
<p>Java持久化API</p>
</dd>
<dt class="hdlist1">Spring</dt>
<dd>
<p>Java应用程序框架 -  <a href="http://projects.spring.io/spring-framework" class="bare">http://projects.spring.io/spring-framework</a></p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring-data/jpa/docs/2.0.9.RELEASE/reference/html">原文链接</a> &amp; <a href="https://www.oracle.com/technetwork/cn/middleware/ias/toplink-jpa-annotations-100895-zhs.html">JPA 注解参考</a>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. 请参阅 <a href="#repositories.create-instances.spring">XML配置</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-12-17 20:49:13 CST
</div>
</div>
</body>
</html>