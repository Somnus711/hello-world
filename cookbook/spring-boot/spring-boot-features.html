<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Unresolved directive in spring-boot-features.adoc - include::attributes.adoc[]">
<title>Spring Boot特性</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body id="boot-features" class="book toc2 toc-left">
<div id="header">
<h1>Spring Boot特性</h1>
<div class="details">
<span id="author" class="author">Unresolved directive in spring-boot-features.adoc - include::attributes.adoc[]</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#boot-features-spring-application">1. SpringApplication</a>
<ul class="sectlevel2">
<li><a href="#boot-features-startup-failure">1.1. 启动失败</a></li>
<li><a href="#boot-features-lazy-initialization">1.2. 延迟初始化</a></li>
<li><a href="#boot-features-banner">1.3. 自定义横幅</a></li>
<li><a href="#boot-features-customizing-spring-application">1.4. 自定义SpringApplication</a></li>
<li><a href="#boot-features-fluent-builder-api">1.5. 流式构建器API</a></li>
<li><a href="#boot-features-application-events-and-listeners">1.6. 应用程序事件和监听器</a></li>
<li><a href="#boot-features-web-environment">1.7. Web环境</a></li>
<li><a href="#boot-features-application-arguments">1.8. 访问应用程序参数</a></li>
<li><a href="#boot-features-command-line-runner">1.9. 使用ApplicationRunner或CommandLineRunner</a></li>
<li><a href="#boot-features-application-exit">1.10. 应用程序退出</a></li>
<li><a href="#boot-features-application-admin">1.11. 管理员功能</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config">2. 外部化配置</a>
<ul class="sectlevel2">
<li><a href="#boot-features-external-config-random-values">2.1. 配置随机值</a></li>
<li><a href="#boot-features-external-config-command-line-args">2.2. 访问命令行Properties</a></li>
<li><a href="#boot-features-external-config-application-property-files">2.3. 应用程序属性文件</a></li>
<li><a href="#boot-features-external-config-profile-specific-properties">2.4. 特定于Profile的Properties</a></li>
<li><a href="#boot-features-external-config-placeholders-in-properties">2.5. Properties中的占位符</a></li>
<li><a href="#boot-features-encrypting-properties">2.6. 加密Properties</a></li>
<li><a href="#boot-features-external-config-yaml">2.7. 使用YAML代替Properties</a></li>
<li><a href="#boot-features-external-config-typesafe-configuration-properties">2.8. 类型安全的配置Properties</a></li>
</ul>
</li>
<li><a href="#boot-features-profiles">3. Profiles</a>
<ul class="sectlevel2">
<li><a href="#boot-features-adding-active-profiles">3.1. 添加活动Profiles</a></li>
<li><a href="#boot-features-programmatically-setting-profiles">3.2. 以编程方式设置Profiles</a></li>
<li><a href="#boot-features-profile-specific-configuration">3.3. 特定于Profile的配置文件</a></li>
</ul>
</li>
<li><a href="#boot-features-logging">4. 日志</a>
<ul class="sectlevel2">
<li><a href="#boot-features-logging-format">4.1. 日志格式</a></li>
<li><a href="#boot-features-logging-console-output">4.2. 控制台输出</a></li>
<li><a href="#boot-features-logging-file-output">4.3. 文件输出</a></li>
<li><a href="#boot-features-custom-log-levels">4.4. 日志级别</a></li>
<li><a href="#boot-features-custom-log-groups">4.5. 日志组</a></li>
<li><a href="#boot-features-custom-log-configuration">4.6. 自定义日志配置</a></li>
<li><a href="#boot-features-logback-extensions">4.7. Logback扩展</a></li>
</ul>
</li>
<li><a href="#boot-features-internationalization">5. 国际化</a></li>
<li><a href="#boot-features-json">6. JSON</a>
<ul class="sectlevel2">
<li><a href="#boot-features-json-jackson">6.1. Jackson</a></li>
<li><a href="#boot-features-json-gson">6.2. Gson</a></li>
<li><a href="#boot-features-json-json-b">6.3. JSON-B</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-web-applications">7. 开发Web应用程序</a>
<ul class="sectlevel2">
<li><a href="#boot-features-spring-mvc">7.1. Spring Web MVC框架</a></li>
<li><a href="#boot-features-webflux">7.2. Spring WebFlux框架</a></li>
<li><a href="#boot-features-jersey">7.3. JAX-RS和Jersey</a></li>
<li><a href="#boot-features-embedded-container">7.4. 嵌入式Servlet容器支持</a></li>
<li><a href="#boot-features-reactive-server">7.5. 响应式嵌入服务器支持</a></li>
<li><a href="#boot-features-reactive-server-resources">7.6. 响应式服务器资源配置</a></li>
</ul>
</li>
<li><a href="#boot-features-rsocket">8. RSocket</a>
<ul class="sectlevel2">
<li><a href="#boot-features-rsocket-strategies-auto-configuration">8.1. RSocket策略自动配置</a></li>
<li><a href="#boot-features-rsocket-server-auto-configuration">8.2. RSocket服务器自动配置</a></li>
<li><a href="#boot-features-rsocket-messaging">8.3. Spring Messaging RSocket支持</a></li>
<li><a href="#boot-features-rsocket-requester">8.4. 使用 <code>RSocketRequester</code> 调用RSocket服务</a></li>
</ul>
</li>
<li><a href="#boot-features-security">9. 安全</a>
<ul class="sectlevel2">
<li><a href="#boot-features-security-mvc">9.1. MVC安全</a></li>
<li><a href="#boot-features-security-webflux">9.2. WebFlux安全</a></li>
<li><a href="#boot-features-security-oauth2">9.3. OAuth2</a></li>
<li><a href="#boot-features-security-saml">9.4. SAML 2.0</a></li>
<li><a href="#boot-features-security-actuator">9.5. Actuator安全</a></li>
</ul>
</li>
<li><a href="#boot-features-sql">10. 使用SQL数据库</a>
<ul class="sectlevel2">
<li><a href="#boot-features-configure-datasource">10.1. 配置DataSource</a></li>
<li><a href="#boot-features-using-jdbc-template">10.2. 使用JdbcTemplate</a></li>
<li><a href="#boot-features-jpa-and-spring-data">10.3. JPA和Spring Data JPA</a></li>
<li><a href="#boot-features-data-jdbc">10.4. Spring Data JDBC</a></li>
<li><a href="#boot-features-sql-h2-console">10.5. 使用H2的Web控制台</a></li>
<li><a href="#boot-features-jooq">10.6. 使用jOOQ</a></li>
</ul>
</li>
<li><a href="#boot-features-nosql">11. 使用NoSQL技术</a>
<ul class="sectlevel2">
<li><a href="#boot-features-redis">11.1. Redis</a></li>
<li><a href="#boot-features-mongodb">11.2. MongoDB</a></li>
<li><a href="#boot-features-neo4j">11.3. Neo4j</a></li>
<li><a href="#boot-features-solr">11.4. Solr</a></li>
<li><a href="#boot-features-elasticsearch">11.5. Elasticsearch</a></li>
<li><a href="#boot-features-cassandra">11.6. Cassandra</a></li>
<li><a href="#boot-features-couchbase">11.7. Couchbase</a></li>
<li><a href="#boot-features-ldap">11.8. LDAP</a></li>
<li><a href="#boot-features-influxdb">11.9. InfluxDB</a></li>
</ul>
</li>
<li><a href="#boot-features-caching">12. 缓存</a>
<ul class="sectlevel2">
<li><a href="#boot-features-caching-provider">12.1. 支持的缓存供应商</a></li>
</ul>
</li>
<li><a href="#boot-features-messaging">13. 消息</a>
<ul class="sectlevel2">
<li><a href="#boot-features-jms">13.1. JMS</a></li>
<li><a href="#boot-features-amqp">13.2. AMQP</a></li>
<li><a href="#boot-features-kafka">13.3. Apache Kafka支持</a></li>
</ul>
</li>
<li><a href="#boot-features-resttemplate">14. 使用 <code>RestTemplate</code> 调用REST服务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-resttemplate-customization">14.1. RestTemplate自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-webclient">15. 使用 <code>WebClient</code> 调用REST服务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-webclient-runtime">15.1. WebClient运行时</a></li>
<li><a href="#boot-features-webclient-customization">15.2. WebClient自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-validation">16. 验证</a></li>
<li><a href="#boot-features-email">17. 发送邮件</a></li>
<li><a href="#boot-features-jta">18. JTA的分布式事务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-jta-atomikos">18.1. 使用Atomikos事务管理器</a></li>
<li><a href="#boot-features-jta-bitronix">18.2. 使用Bitronix事务管理器</a></li>
<li><a href="#boot-features-jta-javaee">18.3. 使用Java EE托管事务管理器</a></li>
<li><a href="#boot-features-jta-mixed-jms">18.4. 混合XA和非XA JMS连接</a></li>
<li><a href="#boot-features-jta-supporting-alternative-embedded">18.5. 支持替代嵌入式事务管理器</a></li>
</ul>
</li>
<li><a href="#boot-features-hazelcast">19. Hazelcast</a></li>
<li><a href="#boot-features-quartz">20. Quartz调度器</a></li>
<li><a href="#boot-features-task-execution-scheduling">21. 任务执行和调度</a></li>
<li><a href="#boot-features-integration">22. Spring Integration</a></li>
<li><a href="#boot-features-session">23. Spring Session</a></li>
<li><a href="#boot-features-jmx">24. 通过JMX进行监视和管理</a></li>
<li><a href="#boot-features-testing">25. 测试</a></li>
<li><a href="#boot-features-websockets">26. WebSockets</a></li>
<li><a href="#boot-features-webservices">27. Web服务</a>
<ul class="sectlevel2">
<li><a href="#boot-features-webservices-template">27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-auto-configuration">28. 创建自己的自动配置</a>
<ul class="sectlevel2">
<li><a href="#boot-features-understanding-auto-configured-beans">28.1. 了解自动配置的Bean</a></li>
<li><a href="#boot-features-locating-auto-configuration-candidates">28.2. 查找自动配置候选人</a></li>
<li><a href="#boot-features-condition-annotations">28.3. 条件注解</a></li>
<li><a href="#boot-features-test-autoconfig">28.4. 测试你的自动配置</a></li>
<li><a href="#boot-features-custom-starter">28.5. 创建自己的Starter</a></li>
</ul>
</li>
<li><a href="#boot-features-whats-next">29. 接下来要读什么</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本节将深入介绍Spring Boot。在这里，你可以了解可能要使用和自定义的关键功能。开始之前，建议你先阅读<a href="spring-boot.html#using-boot">[spring-boot#using-boot]</a>部分，
以便你有足够的基础知识。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-spring-application">1. SpringApplication</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>SpringApplication</code> 类提供了一种便捷的方式来引导从 <code>main()</code> 方法启动的Spring应用程序。在大多数情况下，
你可以委托给静态 <code>SpringApplication.run</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication.run(MySpringConfiguration.class, args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你的应用程序启动时，你应该看到类似于以下输出的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v{spring-boot-version}

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，显示 <code>INFO</code> 日志消息，包括一些相关的启动详细信息，例如：启动应用程序的用户。如果你需要除 <code>INFO</code> 级别以外的其他日志，
则可以按照<a href="#boot-features-custom-log-levels">日志级别</a>中的说明进行设置。使用主应用程序类包中的实现版本来确定应用程序版本。
可以通过将 <code>spring.main.log-startup-info</code> 设置为 <code>false</code> 来关闭启动信息记录。这还将关闭对应用程序激活的环境配置文件的日志记录。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在启动期间添加其他日志记录，可以在 <code>SpringApplication</code> 的子类中重写 <code>logStartupInfo(boolean)</code>。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-startup-failure">1.1. 启动失败</h3>
<div class="paragraph">
<p>如果你的应用程序无法启动，则已注册的 <code>FailureAnalyzers</code> 将有机会提供专门的错误消息和解决该问题的具体措施。
例如：如果你在端口8080上启动Web应用程序并且该端口已在使用中，则应该看到类似于以下消息的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>***************************
APPLICATION FAILED TO START
***************************

Description:

Embedded servlet container failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot提供了大量的 <code>FailureAnalyzer</code> 实现，你可以添加<a href="howto.html#howto-failure-analyzer">自己的实现</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果没有故障分析器能够处理该异常，你仍然可以显示完整条件报告以更好地了解出了什么问题。
为此，你需要为 <code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code>
<a href="#boot-features-external-config">启用 <code>debug</code> 属性</a>或
<a href="#boot-features-custom-log-levels">启用 <code>DEBUG</code> 日志记录</a>。</p>
</div>
<div class="paragraph">
<p>例如，如果使用 <code>java -jar</code> 运行应用程序，则可以按以下方式启用 <code>debug</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-lazy-initialization">1.2. 延迟初始化</h3>
<div class="paragraph">
<p><code>SpringApplication</code> 允许延迟初始化应用程序。启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。
因此，启用延迟初始化可以减少应用程序启动所需的时间。在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。</p>
</div>
<div class="paragraph">
<p>延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。如果错误配置的Bean被延迟初始化，则启动期间将不再发生故障，
并且只有在初始化Bean时问题才会发现。还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，
而不仅仅是启动期间初始化的bean。由于这些原因，默认情况下不会启用延迟初始化，
因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>SpringApplicationBuilder</code> 上的 <code>lazyInitialization</code> 方法或 <code>SpringApplication</code> 上的
<code>setLazyInitialization</code> 方法以编程方式启用延迟初始化。另外，可以使用 <code>spring.main.lazy-initialization</code>
属性启用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.main.lazy-initialization=true</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 <code>@Lazy(false)</code>
注解将它们的延迟属性显式设置为 <code>false</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-banner">1.3. 自定义横幅</h3>
<div class="paragraph">
<p>可以通过将 <code>banner.txt</code> 文件添加到类路径或将 <code>spring.banner.location</code> 属性设置为此类文件的位置来更改启动时打印的横幅。
如果文件的编码不是UTF-8，则可以设置 <code>spring.banner.charset</code>。除了文本文件之外，你还可以将
<code>banner.gif</code>，<code>banner.jpg</code> 或 <code>banner.png</code> 图像文件添加到类路径中，或设置 <code>spring.banner.image.location</code> 属性。
图像将转换为ASCII艺术品并打印在任何文字横幅上方。</p>
</div>
<div class="paragraph">
<p>在 <code>banner.txt</code> 文件中，你可以使用以下任意占位符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. 横幅变量</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Variable</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你的应用程序的版本号，在 <code>MANIFEST.MF</code> 中声明。例如：<code>Implementation-Version: 1.0</code> 被打印为 <code>1.0</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序版本号的格式化显示（用小括号括起来并以v开头）。例如：<code>(v1.0)</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本。例如 <code>{spring-boot-version}</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本的格式化显示（用小括号括起来并以v开头）。例如：<code>(v{spring-boot-version})</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${Ansi.NAME}</code> (or <code>${AnsiColor.NAME}</code>, <code>${AnsiBackground.NAME}</code>, <code>${AnsiStyle.NAME}</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其中 <code>NAME</code> 是ANSI转义代码的名称。有关详细信息，请参见
  {spring-boot-module-code}/ansi/AnsiPropertySource.java[<code>AnsiPropertySource</code>]。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.title}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序标题。例如：<code>Implementation-Title: MyApp</code> 被打印为 <code>MyApp</code>。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要以编程方式生成横幅，则可以使用 <code>SpringApplication.setBanner(&#8230;&#8203;)</code> 方法。
使用 <code>org.springframework.boot.Banner</code> 接口并实现自己的 <code>printBanner()</code> 方法。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.main.banner-mode</code> 属性来确定横幅是否必须在 <code>System.out</code>（<code>控制台</code>）上打印，
是否必须发送到配置的日志记录器（<code>log</code>）或根本不打印（<code>关闭</code>）。</p>
</div>
<div class="paragraph">
<p>打印的横幅用 <code>springBootBanner</code> 名称注册为单例bean。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-customizing-spring-application">1.4. 自定义SpringApplication</h3>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 的默认设置不符合你的喜好，你可以创建一个本地实例并对其进行自定义。例如：要关闭横幅，你可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
传递给 <code>SpringApplication</code> 的构造函数参数是Spring bean的配置源。在大多数情况下，
它们是对 <code>@Configuration</code> 类的引用，但也可以是对XML配置或应扫描的程序包的引用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也可以通过使用 <code>application.properties</code> 文件配置 <code>SpringApplication</code>。有关详细信息，请参见 <em><a href="#boot-features-external-config">外部化配置</a></em>。</p>
</div>
<div class="paragraph">
<p>有关配置选项的完整列表，请参见 {spring-boot-module-api}/SpringApplication.html[<code>SpringApplication</code> Javadoc]。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-fluent-builder-api">1.5. 流式构建器API</h3>
<div class="paragraph">
<p>如果你需要构建 <code>ApplicationContext</code> 层次结构（具有父/子关系的多个上下文），或者如果你更喜欢使用“流式”构建器API，
则可以使用 <code>SpringApplicationBuilder</code>。</p>
</div>
<div class="paragraph">
<p><code>SpringApplicationBuilder</code> 使你可以将多个方法调用链接在一起，并包括允许你创建层次结构的 <code>parent</code> 和 <code>child</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
创建 <code>ApplicationContext</code> 层次结构时有一些限制。例如，Web组件必须包含在子上下文中，
并且父上下文和子上下文都使用相同的 <code>Environment</code>。有关完整的详细信息，请参见
{spring-boot-module-api}/builder/SpringApplicationBuilder.html[<code>SpringApplicationBuilder</code> Javadoc] 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-events-and-listeners">1.6. 应用程序事件和监听器</h3>
<div class="paragraph">
<p>除了通常的Spring Framework事件（例如：
{spring-framework-api}/context/event/ContextRefreshedEvent.html[<code>ContextRefreshedEvent</code>]）之外，
<code>SpringApplication</code> 还发送一些其他应用程序事件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实际上在创建 <code>ApplicationContext</code> 之前会触发一些事件，因此你不能将监听器注册为 <code>@Bean</code>。
你可以使用 <code>SpringApplication.addListeners(&#8230;&#8203;)</code> 方法或 <code>SpringApplicationBuilder.listeners(&#8230;&#8203;)</code> 方法注册它们。</p>
</div>
<div class="paragraph">
<p>如果希望这些侦听器自动注册，而不管以何种方式创建应用程序，都可以将
<code>META-INF/spring.factories</code> 文件添加到你的项目中，并使用 <code>org.springframework.context.ApplicationListener</code>
键引用你的侦听器。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.context.ApplicationListener=com.example.project.MyListener</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件在你的应用程序运行时按以下顺序发送：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在运行开始时但在任何处理之前（侦听器和初始化器的注册除外）发送 <code>ApplicationStartingEvent</code>。</p>
</li>
<li>
<p>已知晓要在上下文中使用的环境但在创建上下文之前，将发送 <code>ApplicationEnvironmentPreparedEvent</code>。</p>
</li>
<li>
<p>准备 <code>ApplicationContext</code> 并调用ApplicationContextInitializers之后但在加载任何bean
定义之前发送 <code>ApplicationContextInitializedEvent</code>。</p>
</li>
<li>
<p>在刷新开始之前但在加载bean定义之后发送 <code>ApplicationPreparedEvent</code>。</p>
</li>
<li>
<p>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前，将发送 <code>ApplicationStartedEvent</code>。</p>
</li>
<li>
<p>在调用任何应用程序和命令行运行程序之后，将发送 <code>ApplicationReadyEvent</code>。它指示该应用程序已准备就绪，可以处理请求。</p>
</li>
<li>
<p>如果启动时发生异常，则发送 <code>ApplicationFailedEvent</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面的列表仅包含绑定到 <code>SpringApplication</code> 的 <code>SpringApplicationEvents</code>。除这些以外，以下事件也在
<code>ApplicationPreparedEvent</code> 之后和 <code>ApplicationStartedEvent</code> 之前发布：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>刷新 <code>ApplicationContext</code> 后发送 <code>ContextRefreshedEvent</code>。</p>
</li>
<li>
<p>WebServer准备就绪后，将发送 <code>WebServerInitializedEvent</code>。<code>ServletWebServerInitializedEvent</code>
和 <code>ReactiveWebServerInitializedEvent</code> 分别是servlet和reactive的变体。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你通常不需要使用应用程序事件，但是知道它们的存在可能很方便。在Spring Boot内部使用事件来处理各种任务。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件是通过使用Spring Framework的事件发布机制发送的。
此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。
结果，如果你的应用程序使用 <code>SpringApplication</code> 实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。</p>
</div>
<div class="paragraph">
<p>为了使你的侦听器能够区分其上下文的事件和后代上下文的事件，则应请求注入其应用程序上下文，
然后将注入的上下文与事件的上下文进行比较。可以通过实现 <code>ApplicationContextAware</code> 来注入上下文，
或者如果侦听器是bean，则可以使用 <code>@Autowired</code> 注入上下文。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-web-environment">1.7. Web环境</h3>
<div class="paragraph">
<p><code>SpringApplication</code> 尝试代表你创建正确的 <code>ApplicationContext</code> 类型。用于确定是 <code>WebApplicationType</code> 的算法非常简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果存在Spring MVC，则使用 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
</li>
<li>
<p>如果不存在Spring MVC但存在Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></p>
</li>
<li>
<p>否则，将使用 <code>AnnotationConfigApplicationContext</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着，如果你在同一应用程序中使用Spring MVC和Spring WebFlux中的新 <code>WebClient</code>，则默认情况下将使用Spring
MVC。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻松覆盖它。</p>
</div>
<div class="paragraph">
<p>也可以通过调用 <code>setApplicationContextClass(&#8230;&#8203;)</code> 完全控制要使用的 <code>ApplicationContext</code> 类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在JUnit测试中使用 <code>SpringApplication</code> 时，通常希望调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-arguments">1.8. 访问应用程序参数</h3>
<div class="paragraph">
<p>如果你需要访问传递给 <code>SpringApplication.run(&#8230;&#8203;)</code> 的应用程序参数，
则可以注入 <code>org.springframework.boot.ApplicationArguments</code> bean。<code>ApplicationArguments</code> 接口提供对原始
<code>String[]</code> 参数以及已解析的 <code>option</code> 和 <code>non-option</code> 参数的访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;

@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List&lt;String&gt; files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot还向Spring <code>Environment</code> 注册了 <code>CommandLinePropertySource</code>。
这样，你还可以使用 <code>@Value</code> 注解注入单个应用程序参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-command-line-runner">1.9. 使用ApplicationRunner或CommandLineRunner</h3>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 启动后需要运行一些特定的代码，则可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口。
这两个接口以相同的方式工作并提供一个 <code>run</code> 方法，该方法在 <code>SpringApplication.run(&#8230;&#8203;)</code> 完成之前被调用。</p>
</div>
<div class="paragraph">
<p><code>CommandLineRunner</code> 接口以简单的字符串数组提供对应用程序参数的访问，而 <code>ApplicationRunner</code> 使用前面讨论的
<code>ApplicationArguments</code> 接口。以下示例显示了带有 <code>run</code> 方法的 <code>CommandLineRunner</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了必须按特定顺序调用的几个 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> Beans，则可以另外实现
<code>org.springframework.core.Ordered</code> 接口或使用 <code>org.springframework.core.annotation.Order</code> 注解。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-exit">1.10. 应用程序退出</h3>
<div class="paragraph">
<p>每个 <code>SpringApplication</code> 向JVM注册一个关闭钩子，以确保 <code>ApplicationContext</code> 在退出时正常关闭。
可以使用所有标准的Spring生命周期回调（例如：<code>DisposableBean</code> 接口或 <code>@PreDestroy</code> 注解）。</p>
</div>
<div class="paragraph">
<p>另外，如果bean希望在调用 <code>SpringApplication.exit()</code> 时返回特定的退出码，
则可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口。然后可以将此退出码传递给 <code>System.exit()</code>，
以将其作为状态码返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ExitCodeApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -&gt; 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，<code>ExitCodeGenerator</code> 接口可以通过异常实现。遇到此类异常时，Spring Boot返回实现的 <code>getExitCode()</code> 方法提供的退出码。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-application-admin">1.11. 管理员功能</h3>
<div class="paragraph">
<p>通过指定 <code>spring.application.admin.enabled</code> 属性，可以为应用程序启用与管理员相关的功能。
这将在平台MBeanServer上公开 {spring-boot-module-code}/admin/SpringApplicationAdminMXBean.java[<code>SpringApplicationAdminMXBean</code>]。
你可以使用此功能来远程管理Spring Boot应用程序。此功能对于任何服务包装器实现也可能很有用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你想知道应用程序在哪个HTTP端口上运行，请使用 <code>local.server.port</code> 键获取属性。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-external-config">2. 外部化配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot使你可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。你可以使用properties文件，YAML文件，
环境变量和命令行参数来外部化配置。可以使用 <code>@Value</code> 注解将属性值直接注入到你的bean中，
可以通过Spring的 <code>Environment</code> 抽象访问，也可以通过 <code>@ConfigurationProperties</code>
<a href="#boot-features-external-config-typesafe-configuration-properties">绑定到结构化对象</a>。</p>
</div>
<div class="paragraph">
<p>Spring Boot使用一个非常特殊的 <code>PropertySource</code> 顺序，该顺序旨在允许合理地覆盖值。按以下顺序考虑属性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当devtools处于活动状态时，<code>$HOME/.config/spring-boot</code> 文件夹中的
<a href="using-spring-boot.html#using-boot-devtools-globalsettings">Devtools全局设置属性</a>。</p>
</li>
<li>
<p>测试上的 {spring-framework-api}/test/context/TestPropertySource.html[<code>@TestPropertySource</code>]注解。</p>
</li>
<li>
<p>测试中的properties属性。在 <code>@SpringBootTest</code> 和测试注解上可用，
用于<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试应用程序的特定部分</a>。</p>
</li>
<li>
<p>命令行参数。</p>
</li>
<li>
<p>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入在环境变量或系统属性中的嵌入式JSON）。</p>
</li>
<li>
<p><code>ServletConfig</code> 的初始化参数。</p>
</li>
<li>
<p><code>ServletContext</code> 的初始化参数。</p>
</li>
<li>
<p>来自 <code>java:comp/env</code> 的JNDI属性。</p>
</li>
<li>
<p>Java系统属性（<code>System.getProperties()</code>）。</p>
</li>
<li>
<p>操作系统环境变量。</p>
</li>
<li>
<p>一个 <code>RandomValuePropertySource</code> 仅具有 <code>random.*</code> 属性。</p>
</li>
<li>
<p>打包jar之外的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar之外的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p><code>@Configuration</code> 类上的 {spring-framework-api}/context/annotation/PropertySource.html[<code>@PropertySource</code>]注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到 <code>Environment</code> 中。现在配置某些属性
（如 <code>logging.*</code> 和 <code>spring.main.*</code>）为时已晚，这些属性在刷新开始之前就已读取。</p>
</li>
<li>
<p>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了提供一个具体的示例，假设你开发了一个使用 <code>name</code> 属性的 <code>@Component</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在你的应用程序类路径上（例如：在jar中），你可以拥有一个 <code>application.properties</code> 文件，该文件为 <code>name</code>
提供合理的默认属性值。在新环境中运行时，可以在jar外部提供一个覆盖 <code>name</code> 的 <code>application.properties</code> 文件。
对于一次性测试，可以使用特定的命令行开关启动（例如：<code>java -jar app.jar --name="Spring"</code>）。</p>
</div>
<div id="boot-features-external-config-application-json" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以在命令行中使用环境变量来提供 <code>SPRING_APPLICATION_JSON</code> 属性。例如，你可以在UN*X shell中使用以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，你最终在Spring <code>Environment</code> 中获得了 <code>acme.name=test</code>。你还可以在System属性中将JSON作为
<code>spring.application.json</code> 提供，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用命令行参数来提供JSON，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --spring.application.json='{"name":"test"}'</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以将JSON作为JNDI变量提供，如下所示： <code>java:comp/env/spring.application.json</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-random-values">2.1. 配置随机值</h3>
<div class="paragraph">
<p><code>RandomValuePropertySource</code> 可用于注入随机值（例如：注入密钥或测试用例）。它可以产生整数，longs，uuid或字符串，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>random.int*</code> 语法是 <code>OPEN value (,max) CLOSE</code>，其中 <code>OPEN,CLOSE</code> 是任何字符，
而 <code>value,max</code> 是整数。如果提供了 <code>max</code>，则 <code>value</code> 是最小值，而 <code>max</code> 是最大值（不包括它）。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-command-line-args">2.2. 访问命令行Properties</h3>
<div class="paragraph">
<p>默认情况下，<code>SpringApplication</code> 将所有命令行选项参数（即以 <code>--</code> 开头的参数，例如 <code>--server.port=9000</code>）转换为属性，
并将其添加到Spring <code>Environment</code> 中。如前所述，命令行属性始终优先于其他属性源。</p>
</div>
<div class="paragraph">
<p>如果你不希望将命令行属性添加到环境中，可以使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 禁用它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-application-property-files">2.3. 应用程序属性文件</h3>
<div class="paragraph">
<p><code>SpringApplication</code> 在以下位置从 <code>application.properties</code> 文件加载属性，并将它们添加到Spring <code>Environment</code>：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当前目录的 <code>/config</code> 子目录</p>
</li>
<li>
<p>当前目录</p>
</li>
<li>
<p>类路径下的 <code>/config</code> 目录</p>
</li>
<li>
<p>类路径根目录</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该列表按优先级排序（列表前面定义的属性会覆盖后面的）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以<a href="#boot-features-external-config-yaml">使用YAML ('.yml')文件</a>来替代 '.properties'。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不喜欢 <code>application.properties</code> 作为配置文件名，则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名。
你还可以通过使用 <code>spring.config.location</code> 环境属性（这是目录位置或以逗号分隔的文件路径列表）来显式引用位置。
下面的示例演示如何指定其他文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.name=myproject</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to specify two locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>spring.config.name</code> 和 <code>spring.config.location</code> 很早就被用于确定必须加载的文件。
必须将它们定义为环境属性（通常是操作系统环境变量，系统属性或命令行参数）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>配置位置以相反的顺序搜索。默认情况下，配置的位置是 <code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>spring.config.location</code> 配置自定义配置位置后，它们将替换默认位置。例如：如果 <code>spring.config.location</code> 配置为值
<code>classpath:custom-config/,file:./custom-config/</code>，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>另外，当使用 <code>spring.config.additional-location</code> 配置自定义配置位置时，除默认位置外，还会考虑使用它们。
在默认位置之前搜索其他附加位置。例如：如果配置了 <code>classpath:/custom-config/,file:./custom-config/</code> 的附加位置，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过此搜索顺序，你可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。
你可以在默认位置之一的 <code>application.properties</code>（或使用 <code>spring.config.name</code> 选择的其他任何基本名称）中为应用程序提供默认值。
然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用环境变量而不是系统属性，则大多数操作系统都不允许使用句点分隔的键名，但是可以使用下划线
（例如：使用 <code>SPRING_CONFIG_NAME</code> 代替 <code>spring.config.name</code>）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你的应用程序在容器中运行，则可以使用JNDI属性（在 <code>java:comp/env</code> 中）或servlet上下文初始化参数代替环境变量或系统属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-profile-specific-properties">2.4. 特定于Profile的Properties</h3>
<div class="paragraph">
<p>除了 <code>application.properties</code> 文件之外，还可以使用以下命名约定来定义特定于profile的属性：
<code>application-{profile}.properties</code>。如果没有设置激活的profile，则 <code>Environment</code> 具有一组默认的profiles（默认为
<code>[default]</code>）。换句话说，如果未显式激活任何profiles，那么将从 <code>application-default.properties</code> 中加载属性。</p>
</div>
<div class="paragraph">
<p>特定于profile的属性是从与标准 <code>application.properties</code> 相同的位置加载的，特定于profile的文件始终会覆盖非特定文件，
而无论特定于profile的文件是位于打包jar的内部还是外部。</p>
</div>
<div class="paragraph">
<p>如果指定了多个profiles，则采用最后一个获胜策略。例如：将 <code>spring.profiles.active</code>
属性指定的profiles添加到通过SpringApplication API配置的profiles之后，因此具有优先权。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>spring.config.location</code> 中指定了任何文件，则不会考虑这些文件特定于profile的变体。
如果你还想使用特定于profile的属性，请使用 <code>spring.config.location</code> 中的目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-placeholders-in-properties">2.5. Properties中的占位符</h3>
<div class="paragraph">
<p><code>application.properties</code> 中的值在使用时会通过现有的 <code>Environment</code> 进行过滤，因此你可以参考在它之前定义的值（例如：从System属性中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">app.name=MyApp
app.description=${app.name} is a Spring Boot application</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以使用这种技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见
{spring-boot-docs}/htmlsingle/#howto-use-short-command-line-arguments[使用“简短”命令行参数方法]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-encrypting-properties">2.6. 加密Properties</h3>
<div class="paragraph">
<p>Spring Boot不提供对加密属性值的任何内置支持，但是，它确实提供了修改Spring <code>Environment</code> 中包含的值所必需的钩子。
<code>EnvironmentPostProcessor</code> 界面允许你在应用程序启动之前操纵 <code>Environment</code>。
有关详细信息，请参见 {spring-boot-docs}/htmlsingle/#howto-customize-the-environment-or-application-context[在启动前自定义环境或ApplicationContext]。</p>
</div>
<div class="paragraph">
<p>如果你正在寻找一种安全的方式来存储凭据和密码， <a href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a>
项目提供了对在 <a href="https://www.vaultproject.io/">HashiCorp Vault</a>中存储外部配置的支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-yaml">2.7. 使用YAML代替Properties</h3>
<div class="paragraph">
<p><a href="https://yaml.org">YAML</a>是一个JSON超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在类路径上具有
<a href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库，
<code>SpringApplication</code> 类就会自动支持YAML作为Properties的替代方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用“启动器”，则 <code>spring-boot-starter</code> 会自动提供SnakeYAML。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-loading-yaml">2.7.1. 加载YAML</h4>
<div class="paragraph">
<p>Spring Framework提供了两个方便的类，可用于加载YAML文档。<code>YamlPropertiesFactoryBean</code> 将YAML作为 <code>Properties</code> 加载，
而 <code>YamlMapFactoryBean</code> 将YAML作为 <code>Map</code> 加载。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下YAML文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">environments:
    dev:
        url: https://dev.example.com
        name: Developer Setup
    prod:
        url: https://another.example.com
        name: My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>YAML列表用 <code>[index]</code> 解引用器表示为属性键。例如：考虑以下YAML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">my:
   servers:
       - dev.example.com
       - another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.servers[0]=dev.example.com
my.servers[1]=another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过使用Spring Boot的 <code>Binder</code> 实用程序（<code>@ConfigurationProperties</code> 所做的）绑定到类似的属性，
你需要在目标bean中拥有一个类型为 <code>java.util.List</code>（或 <code>Set</code>）属性，或者你需要提供一个setter或使用可变值对其进行初始化。
例如，以下示例绑定到前面显示的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="my")
public class Config {

    private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();

    public List&lt;String&gt; getServers() {
        return this.servers;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-exposing-yaml-to-spring">2.7.2. 在Spring环境中将YAML公开为Properties</h4>
<div class="paragraph">
<p><code>YamlPropertySourceLoader</code> 类可用于在Spring <code>Environment</code> 中将YAML公开为 <code>PropertySource</code>。
这样做可以让你使用 <code>@Value</code> 注解和占位符语法来访问YAML属性。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-multi-profile-yaml">2.7.3. Multi-profile的YAML文档</h4>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles</code> 键在一个文件中指定多个特定于profile的YAML文档，以指示何时应用该文档，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production &amp; eu-central
server:
    address: 192.168.1.120</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>development</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>127.0.0.1</code>。
同样，如果 <code>production</code> <strong>和</strong> <code>eu-central</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>192.168.1.120</code>。
如果 <strong>未</strong> 启用 <code>development</code>, <code>production</code> 和 <code>eu-central</code> profiles，则该属性的值为 <code>192.168.1.100</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因此 <code>spring.profiles</code> 可以包含一个简单的profile名称（例如：<code>production</code>）或profile表达式。
profile表达式允许表达更复杂的profile逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。有关更多详细信息，请参阅
{spring-framework-docs}core.html#beans-definition-profiles-java[参考指南]。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果在启动应用程序上下文时未明确激活任何profiles，则会激活默认的profiles。因此，在以下YAML中，我们为
<code>spring.security.user.password</code> 设置了一个值，该值 <strong>仅</strong> 在 "default" profile中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>而在以下示例中，则会始终设置密码是因为该密码未附加到任何profile，并且必须根据需要在所有其他profiles中将其显式重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
spring:
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>spring.profiles</code> 元素指定的Spring profiles可以选择使用 <code>!</code> 字符来否定。如果为单个文档指定了否定的和非否定的profiles，
则至少一个非否定的profile必须匹配，并且否定的profiles不能匹配。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-yaml-shortcomings">2.7.4. YAML的缺点</h4>
<div class="paragraph">
<p>无法使用 <code>@PropertySource</code> 注解加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用properties文件。</p>
</div>
<div class="paragraph">
<p>在特定于profile的YAML文件中使用多YAML文档语法可能会导致意外行为。例如：考虑文件中的以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: "!test"
  security:
    user:
      password: "secret"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用参数 <code>--spring.profiles.active=dev</code> 运行该应用程序，则可能希望将 <code>security.user.password</code> 设置为“<code>secret</code>”，但事实并非如此。</p>
</div>
<div class="paragraph">
<p>嵌套文档将被过滤，因为主文件名为 <code>application-dev.yml</code>。它已经被认为是特定于profile的，并且嵌套文档将被忽略。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议你不要混用特定于profile的YAML文件和多个YAML文档。坚持只使用其中之一。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config-typesafe-configuration-properties">2.8. 类型安全的配置Properties</h3>
<div class="paragraph">
<p>使用 <code>@Value("${property}")</code> 注解来注入配置属性有时会很麻烦，尤其是当你使用多个properties或数据本质上是分层的时。
Spring Boot提供了一种使用属性的替代方法，使用强类型的properties bean来管理和验证应用程序的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
另请参见<a href="#boot-features-external-config-vs-value"><code>@Value</code> 和类型安全的配置properties之间的区别</a>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-java-bean-binding">2.8.1. JavaBean properties绑定</h4>
<div class="paragraph">
<p>可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("acme")
public class AcmeProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    public boolean isEnabled() { ... }

    public void setEnabled(boolean enabled) { ... }

    public InetAddress getRemoteAddress() { ... }

    public void setRemoteAddress(InetAddress remoteAddress) { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private String username;

        private String password;

        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton("USER"));

        public String getUsername() { ... }

        public void setUsername(String username) { ... }

        public String getPassword() { ... }

        public void setPassword(String password) { ... }

        public List&lt;String&gt; getRoles() { ... }

        public void setRoles(List&lt;String&gt; roles) { ... }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的POJO定义了以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acme.enabled</code>，默认值为 <code>false</code>。</p>
</li>
<li>
<p><code>acme.remote-address</code>，其类型可以从 <code>String</code> 强制转换。</p>
</li>
<li>
<p><code>acme.security.username</code>，带有嵌套的“security”对象，其名称由属性名称确定。
特别是，返回类型根本没有使用，也可能是 <code>SecurityProperties</code>。</p>
</li>
<li>
<p><code>acme.security.password</code>。</p>
</li>
<li>
<p><code>acme.security.roles</code>，带有默认拥有单个 <code>USER</code> 的 <code>String</code> 集合。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot自动配置大量使用 <code>@ConfigurationProperties</code> 来轻松配置自动配置的bean。
与自动配置类相似，Spring Boot中可用的 <code>@ConfigurationProperties</code> 类仅供内部使用。
通过Properties文件、YAML文件、环境变量等配置映射到的类属性是公共API，但是该类本身的内容并不意味着可以直接使用。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种自动配置依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，
就像在Spring MVC中一样。在以下情况下，可以忽略setter：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maps，只要它们被初始化，需要一个getter但不一定是setter，因为绑定器可以对它们进行修改。</p>
</li>
<li>
<p>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（properties）来访问集合和数组。
在后一种情况下，必须使用setter。我们建议始终为此类类型添加setter。如果初始化集合，请确保它不是不可变的（如上例所示）。</p>
</li>
<li>
<p>如果初始化了嵌套的POJO属性（如前面示例中的 <code>Security</code> 字段），则不需要setter。
如果希望绑定器通过使用其默认构造函数动态创建实例，则需要一个setter。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有些人使用Lombok项目自动添加getters和setters。确保Lombok不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。</p>
</div>
<div class="paragraph">
<p>最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-constructor-binding">2.8.2. 构造函数绑定</h4>
<div class="paragraph">
<p>上一节中的示例可以用不可变的方式重写，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.ConstructorBinding;
import org.springframework.boot.context.properties.DefaultValue;

@ConstructorBinding
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final boolean enabled;

    private final InetAddress remoteAddress;

    private final Security security;

    public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    public boolean isEnabled() { ... }

    public InetAddress getRemoteAddress() { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private final String username;

        private final String password;

        private final List&lt;String&gt; roles;

        public Security(String username, String password,
                @DefaultValue("USER") List&lt;String&gt; roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        public String getUsername() { ... }

        public String getPassword() { ... }

        public List&lt;String&gt; getRoles() { ... }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此设置中，<code>@ConstructorBinding</code> 注解用于指示应使用构造函数绑定。这意味着绑定器将期望找到带有你希望绑定的参数的构造函数。</p>
</div>
<div class="paragraph">
<p><code>@ConstructorBinding</code> 类的嵌套成员（例如上例中的 <code>Security</code>）也将通过其构造函数进行绑定。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>@DefaultValue</code> 指定默认值，并且将应用相应的转换服务将 <code>String</code> 值强制转换为缺失属性的目标类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用构造函数绑定，必须使用 <code>@EnableConfigurationProperties</code> 或配置属性扫描来启用该类。你不能对通过常规Spring机制创建的bean
使用构造函数绑定（例如：<code>@Component</code> bean，通过 <code>@Bean</code> 方法创建的bean或使用 <code>@Import</code> 加载的bean）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 <code>@ConstructorBinding</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-enabling">2.8.3. 启用被 <code>@ConfigurationProperties</code> 注解的类型</h4>
<div class="paragraph">
<p>Spring Boot提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为Bean的基础设施。
你可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。</p>
</div>
<div class="paragraph">
<p>有时，用 <code>@ConfigurationProperties</code> 注解的类可能不适用于扫描，例如：如果你正在开发自己的自动配置，
或者想要有条件地启用它们。在这些情况下，请使用 <code>@EnableConfigurationProperties</code> 注解指定要处理的类型列表。
可以在任何 <code>@Configuration</code> 类上完成此操作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用配置属性扫描，请将 <code>@ConfigurationPropertiesScan</code> 注解添加到你的应用程序。
通常，它被添加到使用 <code>@SpringBootApplication</code> 注解的主应用程序类中，但可以将其添加到任何 <code>@Configuration</code> 类中。
默认情况下，将从声明注解的类的包中进行扫描。如果要定义待扫描的特定程序包，可以按照以下示例所示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
public class MyApplication {
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>@ConfigurationProperties</code> bean is registered using configuration property scanning or via <code>@EnableConfigurationProperties</code>, the bean has a conventional name: <code>&lt;prefix&gt;-&lt;fqn&gt;</code>, where <code>&lt;prefix&gt;</code> is the environment key prefix specified in the <code>@ConfigurationProperties</code> annotation and <code>&lt;fqn&gt;</code> is the fully qualified name of the bean.
If the annotation does not provide any prefix, only the fully qualified name of the bean is used.</p>
</div>
<div class="paragraph">
<p>使用配置属性扫描或通过 <code>@EnableConfigurationProperties</code> 注册 <code>@ConfigurationProperties</code> Bean时，
该Bean具有常规名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，其中 <code>&lt;prefix&gt;</code> 是 <code>@ConfigurationProperties</code> 注解中指定的环境键前缀。
<code>&lt;fqn&gt;</code> 是Bean的完全限定名称。如果注解不提供任何前缀，则仅使用Bean的完全限定名称。</p>
</div>
<div class="paragraph">
<p>上例中的bean名称是 <code>acme-com.example.AcmeProperties</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们建议 <code>@ConfigurationProperties</code> 仅处理环境，尤其不要从上下文中注入其他bean。
对于极端情况，可以使用setter注入或框架提供的任何 <code>*Aware</code> 接口（例如：需要访问 <code>Environment</code> 的 <code>EnvironmentAware</code>）。
如果仍然想使用构造函数注入其他bean，则必须使用 <code>@Component</code> 注解配置properties bean，并使用基于JavaBean的属性绑定。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-using">2.8.4. 使用被 <code>@ConfigurationProperties</code> 注解的类型</h4>
<div class="paragraph">
<p>这种配置方式在 <code>SpringApplication</code> 外部的YAML配置中特别好用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml"># application.yml

acme:
    remote-address: 192.168.1.1
    security:
        username: admin
        roles:
          - USER
          - ADMIN

# additional configuration as required</code></pre>
</div>
</div>
<div class="paragraph">
<p>要与 <code>@ConfigurationProperties</code> Bean一起使用，可以像其他任何Bean一样注入它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final AcmeProperties properties;

    @Autowired
    public MyService(AcmeProperties properties) {
        this.properties = properties;
    }

     //...

    @PostConstruct
    public void openConnection() {
        Server server = new Server(this.properties.getRemoteAddress());
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>@ConfigurationProperties</code> 还可让你生成元数据文件，IDE可以使用这些元数据文件为你自己的键提供自动完成功能。
有关详细信息，请参见 {spring-boot-docs}/htmlsingle/#configuration-metadata[附录]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-3rd-party-configuration">2.8.5. 第三方配置</h4>
<div class="paragraph">
<p>除了使用 <code>@ConfigurationProperties</code> 注解类外，还可以在public <code>@Bean</code> 方法上使用它。当你要将属性绑定到控件之外的第三方组件时，这样做特别有用。</p>
</div>
<div class="paragraph">
<p>要从 <code>Environment</code> 属性配置Bean，请将 <code>@ConfigurationProperties</code> 添加到其Bean注册中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix = "another")
@Bean
public AnotherComponent anotherComponent() {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code>another</code> 前缀定义的任何JavaBean属性都以类似于前面的 <code>AcmeProperties</code> 示例的方式映射到该 <code>AnotherComponent</code> bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-relaxed-binding">2.8.6. 宽松绑定</h4>
<div class="paragraph">
<p>Spring Boot使用一些宽松的规则将 <code>Environment</code> 属性绑定到 <code>@ConfigurationProperties</code> bean，
因此 <code>Environment</code> 属性名称和bean属性名称之间不需要完全匹配。有用的常见示例包括：以破折号分隔的环境属性
（例如：<code>context-path</code> 绑定到 <code>contextPath</code>）和大写的环境属性（例如：<code>PORT</code> 绑定到 <code>port</code>）。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下 <code>@ConfigurationProperties</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme.my-project.person")
public class OwnerProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用前面的代码，以下属性名称均可以使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. 宽松绑定</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my-project.person.first-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kebab格式，建议在 <code>.properties</code> 和 <code>.yml</code> 文件中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.myProject.person.firstName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准小驼峰式语法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my_project.person.first_name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线表示法，是 <code>.properties</code> 和 <code>.yml</code> 文件中使用的另一种格式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写格式，使用系统环境变量时建议使用。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
注解的前缀值 <em>必须</em> 为kebab格式（小写，并用 <code>-</code> 分隔，例如：<code>acme.my-project.person</code>）。
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. 每个属性源的宽松绑定规则</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性源</th>
<th class="tableblock halign-left valign-top">支持</th>
<th class="tableblock halign-left valign-top">列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Properties文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YAML文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard YAML list syntax or comma-separated values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以下划线作为定界符的大写格式。<code>_</code> 不应在属性名称中使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线包围的数值，例如：<code>MY_ACME_1_OTHER = my.acme[1].other</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议，如果可能，属性以小写kebab格式存储，例如：<code>my.property-name=acme</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>绑定到 <code>Map</code> 属性时，如果 <code>key</code> 包含小写字母数字字符或 <code>-</code> 以外的任何其他字符，则需要使用方括号表示法，以便保留原始值。
如果键没有被 <code>[]</code> 包围，则所有非字母数字或 <code>-</code> 字符都将被删除。例如，考虑将以下属性绑定到 <code>Map</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    "[/key1]": value1
    "[/key2]": value2
    /key3: value3</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的属性将以 <code>/key1</code>，<code>/key2</code> 和 <code>key3</code> 作为映射中的键被绑定到 <code>Map</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于YAML文件，方括号需要用引号引起来，以便正确解析。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-complex-type-merge">2.8.7. 合并复杂类型</h4>
<div class="paragraph">
<p>如果在多个地方配置了列表，则通过替换整个列表来进行覆盖。</p>
</div>
<div class="paragraph">
<p>例如：假设 <code>MyPojo</code> 对象的 <code>name</code> 和 <code>description</code> 属性默认为 <code>null</code>。
下面的示例从 <code>AcmeProperties</code> 公开 <code>MyPojo</code> 对象的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;();

    public List&lt;MyPojo&gt; getList() {
        return this.list;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目，如先前所定义。
但是，如果启用了 <code>dev</code> profile，则该列表仍然仅包含一个条目（名称为 <code>my another name</code>，并且描述为 <code>null</code>）。
此配置 <em>不会</em> 将第二个 <code>MyPojo</code> 实例添加到列表中，并且不会合并条目。</p>
</div>
<div class="paragraph">
<p>在多个profiles中指定 <code>List</code> 时，将使用优先级最高的列表（并且仅使用那个列表）。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
    - name: another name
      description: another description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>dev</code> profile处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目
（其名称为 <code>my another name</code>，并且描述为 <code>null</code>）。对于YAML，可以使用逗号分隔的列表和YAML列表来完全覆盖列表的内容。</p>
</div>
<div class="paragraph">
<p>对于 <code>Map</code> 属性，可以绑定从多个来源绘制的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。
下面的示例从 <code>AcmeProperties</code> 公开 <code>Map&lt;String, MyPojo&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final Map&lt;String, MyPojo&gt; map = new HashMap&lt;&gt;();

    public Map&lt;String, MyPojo&gt; getMap() {
        return this.map;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.map</code> 包含一个键为key1的条目（名称为 <code>my name 1</code>，描述为 <code>my description 1</code>）。
但是，如果启用了 <code>dev</code> profile，则map包含两个条目，其中键为key1的条目（名称为 <code>dev name 1</code>，描述为 <code>my description 1</code>）
和key2（名称为 <code>dev name 2</code>，描述为 <code>dev description 2</code>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前述合并规则不仅适用于YAML文件，而且适用于所有属性源中的属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-conversion">2.8.8. 属性转换</h4>
<div class="paragraph">
<p>当Spring Boot绑定到 <code>@ConfigurationProperties</code> bean时，它尝试将外部应用程序属性强制为正确的类型。
如果需要自定义类型转换，则可以提供一个 <code>ConversionService</code> bean（具有一个名为 <code>conversionService</code> 的bean）
或自定义属性编辑器（通过 <code>CustomEditorConfigurer</code> bean）或自定义 <code>Converters</code>（具有定义为 <code>@ConfigurationPropertiesBinding</code> 的bean定义）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于在应用程序生命周期中非常早就请求了此bean，因此请确保限制你的 <code>ConversionService</code> 使用的依赖项。
通常，你需要的任何依赖项可能在创建时未完全初始化。如果配置键强制转换不需要自定义的转换服务，则可能要重命名自定义的
<code>ConversionService</code> 且它仅依赖于具有 <code>@ConfigurationPropertiesBinding</code> 限定的自定义转换器。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion-duration">转换持续时间</h5>
<div class="paragraph">
<p>Spring Boot为表达持续时间提供了专门的支持。如果公开 <code>java.time.Duration</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（使用毫秒作为默认单位，除非已指定 <code>@DurationUnit</code>）</p>
</li>
<li>
<p>{java-api}/java/time/Duration.html#parse-java.lang.CharSequence-[<code>java.time.Duration</code> 使用的]标准ISO-8601格式</p>
</li>
<li>
<p>值和单位相结合的更易读的格式（例如：10s表示10秒）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.system")
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定30秒的会话超时，则 <code>30</code>，<code>PT30S</code> 和 <code>30s</code> 都是等效的。可以使用以下任意形式指定500ms的读取超时：
<code>500</code>，<code>PT0.5S</code> 和 <code>500ms</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns</code> 纳秒</p>
</li>
<li>
<p><code>us</code> 微秒</p>
</li>
<li>
<p><code>ms</code> 毫秒</p>
</li>
<li>
<p><code>s</code> 秒</p>
</li>
<li>
<p><code>m</code> 分钟</p>
</li>
<li>
<p><code>h</code> 小时</p>
</li>
<li>
<p><code>d</code> 天</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是毫秒，可以使用 <code>@DurationUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要从仅使用 <code>Long</code> 表示持续时间的先前版本进行升级，原单位若不是毫秒那么请确保在切换到 <code>Duration</code>
时指定单位（使用 <code>@DurationUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion-datasize">转换数据大小</h5>
<div class="paragraph">
<p>Spring Framework具有 <code>DataSize</code> 值类型，以字节为单位表示大小。如果公开 <code>DataSize</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（除非已指定 <code>@DataSizeUnit</code>，否则使用字节作为默认单位）</p>
</li>
<li>
<p>值和单位耦合在一起的更易读的格式（例如：10MB表示10兆字节）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.io")
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>若要指定10 MB的缓冲区大小，则 <code>10</code> 和 <code>10MB</code> 是等效的。256个字节大小的阈值可以指定为 <code>256</code> 或 <code>256B</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>B</code> 字节</p>
</li>
<li>
<p><code>KB</code> 千字节</p>
</li>
<li>
<p><code>MB</code> 兆字节</p>
</li>
<li>
<p><code>GB</code> 千兆字节</p>
</li>
<li>
<p><code>TB</code> 兆兆字节</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是字节，可以使用 <code>@DataSizeUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要从仅使用 <code>Long</code> 表示大小的先前版本进行升级，原单位若不是字节那么请确保在切换到 <code>DataSize</code>
时指定单位（使用 <code>@DataSizeUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-validation">2.8.9. @ConfigurationProperties验证</h4>
<div class="paragraph">
<p>每当使用Spring的 <code>@Validated</code> 注解对 <code>@ConfigurationProperties</code> 类进行批注时，
Spring Boot就会尝试对其进行验证。你可以在配置类上直接使用JSR-303 <code>javax.validation</code> 约束注解。
为此，请确保在类路径上有兼容的JSR-303实现，然后将约束注解添加到字段中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    // ... getters and setters

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以通过使用 <code>@Validated</code> 注解创建配置属性的 <code>@Bean</code> 方法来触发验证。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了确保始终为嵌套属性触发验证，即使未找到任何属性，也必须使用 <code>@Valid</code> 注解关联的字段。下面的示例基于前面的 <code>AcmeProperties</code> 示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以通过创建一个名为 <code>configurationPropertiesValidator</code> 的bean定义来添加自定义Spring <code>Validator</code>。
<code>@Bean</code> 方法应声明为 <code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，
并且将 <code>@Bean</code> 方法声明为 <code>static</code> 可以使创建该bean而不必实例化 <code>@Configuration</code> 类。这样做避免了由早期实例化引起的任何问题。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring-boot-actuator</code> 模块包括一个公开所有 <code>@ConfigurationProperties</code> beans的端点。
将你的Web浏览器指向 <code>/actuator/configprops</code> 或使用等效的JMX端点访问。有关详细信息，请参见“
{spring-boot-docs}/htmlsingle/#production-ready-endpoints[生产就绪功能]”部分。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-vs-value">2.8.10. @ConfigurationProperties vs @Value</h4>
<div class="paragraph">
<p><code>@Value</code> 注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。
下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 支持的功能：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">功能</th>
<th class="tableblock halign-left valign-top"><code>@ConfigurationProperties</code></th>
<th class="tableblock halign-left valign-top"><code>@Value</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#boot-features-external-config-relaxed-binding">宽松绑定</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{spring-boot-docs}/htmlsingle/#configuration-metadata[元数据支持]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SpEL</code> 评估</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果你为自己的组件定义了一组配置键，我们建议你将它们组合在以 <code>@ConfigurationProperties</code> 注解的POJO中。
你还应该意识到，由于 <code>@Value</code> 不支持宽松的绑定，因此如果你需要使用环境变量来提供值，则它不是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>最后，尽管你可以在 <code>@Value</code> 中编写SpEL表达式，但不会从<a href="#boot-features-external-config-application-property-files">应用程序属性文件</a>中处理此类表达式。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-profiles">3. Profiles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Profiles提供了一种隔离应用程序配置部分并使之仅在某些环境中可用的方法。
任何 <code>@Component</code>，<code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 标记以限制其加载时间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果 <code>@ConfigurationProperties</code> Bean是通过 <code>@EnableConfigurationProperties</code> 而非自动扫描注册的，
则需要在具有 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解。
在自动扫描 <code>@ConfigurationProperties</code> 的情况下，可以在 <code>@ConfigurationProperties</code> 类本身上指定 <code>@Profile</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles.active</code> 环境属性来指定哪些配置文件处于激活状态。你可以通过本章前面介绍的任何方式指定属性。
例如，你可以将其包含在 <code>application.properties</code> 中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.profiles.active=dev,hsqldb</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。</p>
</div>
<div class="sect2">
<h3 id="boot-features-adding-active-profiles">3.1. 添加活动Profiles</h3>
<div class="paragraph">
<p><code>spring.profiles.active</code> 属性遵循与其他属性相同的排序规则：最高的 <code>PropertySource</code> 获胜。这意味着你可以在
<code>application.properties</code> 中指定要激活配置文件，然后使用命令行开关 <strong>替换</strong> 它们。</p>
</div>
<div class="paragraph">
<p>有时，将特定于profile的属性 <strong>添加</strong> 到活动profiles而不是替换它们很有用。
<code>spring.profiles.include</code> 属性可用于无条件添加活动Profiles。<code>SpringApplication</code> 入口点还具有Java API，
用于设置其他附加的profiles（即在由 <code>spring.profiles.active</code> 属性激活的profiles之上）。
参见 {spring-boot-module-api}/SpringApplication.html[SpringApplication]中的 <code>setAdditionalProfiles()</code> 方法。</p>
</div>
<div class="paragraph">
<p>例如，当使用开关 <code>--spring.profiles.active=prod</code> 运行具有以下属性的应用程序时，<code>proddb</code> 和 <code>prodmq</code> 配置文件也会被激活：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.include:
  - proddb
  - prodmq</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请记住，可以在YAML文档中定义 <code>spring.profiles</code> 属性，以确定该特定文档何时包含在配置中。有关更多详细信息，请参见
{spring-boot-docs}/htmlsingle/#howto-change-configuration-depending-on-the-environment[根据环境更改配置]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-programmatically-setting-profiles">3.2. 以编程方式设置Profiles</h3>
<div class="paragraph">
<p>你可以在应用程序运行之前通过调用 <code>SpringApplication.setAdditionalProfiles(&#8230;&#8203;)</code> 以编程方式设置活动配置文件。
也可以使用Spring的 <code>ConfigurableEnvironment</code> 接口来激活profiles。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-profile-specific-configuration">3.3. 特定于Profile的配置文件</h3>
<div class="paragraph">
<p><code>application.properties</code>（或 <code>application.yml</code>）和通过
<code>@ConfigurationProperties</code> 所引用文件的特定于profile的变体都会被视为配置文件并加载。
有关详细信息，请参见“<a href="#boot-features-external-config-profile-specific-properties">特定于Profile的Properties</a>”。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-logging">4. 日志</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot使用 <a href="https://commons.apache.org/logging">Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。
提供了 {java-api}/java/util/logging/package-summary.html[Java Util Logging]，
<a href="https://logging.apache.org/log4j/2.x/">Log4J2</a>和 <a href="https://logback.qos.ch/">Logback</a>的默认配置。
在每种情况下，日志记录器都已预先配置为使用控制台输出，同时还提供可选的文件输出。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果使用“<code>Starters</code>”，则使用Logback进行日志记录。还包括适当的Logback路由，以确保使用
Java Util Logging，Commons Logging，Log4J或SLF4J的从属库都可以正常工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Java有许多可用的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。
通常，你不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。
这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-logging-format">4.1. 日志格式</h3>
<div class="paragraph">
<p>Spring Boot的默认日志输出类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</pre>
</div>
</div>
<div class="paragraph">
<p>默认输出以下条目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日期和时间：毫秒精度，易于分类。</p>
</li>
<li>
<p>日志级别：<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code> 和 <code>TRACE</code>。</p>
</li>
<li>
<p>进程ID。</p>
</li>
<li>
<p><code>---</code> 分隔符用于区分实际日志消息的开始。</p>
</li>
<li>
<p>线程名：用方括号括起来（对于控制台输出，可能会被截断）。</p>
</li>
<li>
<p>记录器名称：这通常是源类名称（通常是缩写格式）。</p>
</li>
<li>
<p>日志消息。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Logback没有 <code>FATAL</code> 日志级别。它被映射到 <code>ERROR</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging-console-output">4.2. 控制台输出</h3>
<div class="paragraph">
<p>默认日志配置在消息写入时将消息回显到控制台。默认情况下，将记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
你还可以通过使用 <code>--debug</code> 标志启动应用程序来启用“<code>debug</code>”模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --debug</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以在 <code>application.properties</code> 中指定 <code>debug=true</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启用调试模式后，将配置一些核心日志记录器（嵌入式容器，Hibernate和Spring Boot）以输出更多信息。
启用调试模式 <em>不会</em> 将你的应用程序配置为记录所有具有 <code>DEBUG</code> 级别的消息。</p>
</div>
<div class="paragraph">
<p>或者，你可以通过使用 <code>--trace</code> 标志（或 <code>application.properties</code> 中的 <code>trace=true</code>）启动应用程序来启用“<code>trace</code>”模式。
这样做可以为某些核心记录器（嵌入式容器，Hibernate schema生成以及整个Spring产品组合）启用跟踪记录。</p>
</div>
<div class="sect3">
<h4 id="boot-features-logging-color-coded-output">4.2.1. 颜色编码输出</h4>
<div class="paragraph">
<p>如果你的终端支持ANSI，则使用彩色输出来提高可读性。你可以将 <code>spring.output.ansi.enabled</code> 设置为
{spring-boot-module-api}/ansi/AnsiOutput.Enabled.html[支持的值]，以覆盖自动检测。</p>
</div>
<div class="paragraph">
<p>使用 <code>%clr</code> 转换字配置颜色编码。转换器以最简单的形式根据日志级别为输出着色，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%5p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了日志级别到颜色的映射：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Level</th>
<th class="tableblock halign-left valign-top">Color</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FATAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ERROR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WARN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">黄色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INFO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEBUG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另外，你可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如：要使文本变黄，请使用以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持以下颜色和样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>blue</code></p>
</li>
<li>
<p><code>cyan</code></p>
</li>
<li>
<p><code>faint</code></p>
</li>
<li>
<p><code>green</code></p>
</li>
<li>
<p><code>magenta</code></p>
</li>
<li>
<p><code>red</code></p>
</li>
<li>
<p><code>yellow</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging-file-output">4.3. 文件输出</h3>
<div class="paragraph">
<p>默认情况下，Spring Boot仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，
则需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性（例如：在 <code>application.properties</code> 中）。</p>
</div>
<div class="paragraph">
<p>下表显示了如何结合使用 <code>logging.*</code> 属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. 日志属性</caption>
<colgroup>
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 57%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>logging.file.name</code></th>
<th class="tableblock halign-left valign-top"><code>logging.file.path</code></th>
<th class="tableblock halign-left valign-top">示例</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅控制台记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>my.log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写入指定的日志文件。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定目录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将 <code>spring.log</code> 写入指定目录。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>日志文件达到10 MB时会旋转，并且与控制台输出一样，默认情况下会记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
可以使用 <code>logging.file.max-size</code> 属性更改大小限制。除非已设置 <code>logging.file.max-history</code> 属性，
否则以前旋转的文件将无限期存档。可以使用 <code>logging.file.total-size-cap</code> 限制日志归档文件的总大小。
当日志归档的总大小超过该阈值时，将删除备份。要在应用程序启动时强制清除日志归档文件，
请使用 <code>logging.file.clean-history-on-start</code> 属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
日志记录属性独立于实际的日志记录基础设施。因此，特定的配置键（例如：Logback的 <code>logback.configurationFile</code>）不是由Spring Boot管理的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-levels">4.4. 日志级别</h3>
<div class="paragraph">
<p>通过使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 可以在Spring <code>Environment</code> 中（例如：在 <code>application.properties</code> 中）
设置所有受支持的日志记录器级别。其中 <code>level</code> 是TRACE, DEBUG, INFO, WARN, ERROR, FATAL 或 OFF。
可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器。</p>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>application.properties</code> 中的潜在日志记录设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.root=warn
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用环境变量设置日志记录级别。例如：<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 会将
<code>org.springframework.web</code> 设置为 <code>DEBUG</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
以上方法仅适用于程序包级别的日志记录。由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。
如果需要为类配置日志记录，则可以使用<a href="#boot-features-external-config-application-json"><code>SPRING_APPLICATION_JSON</code></a>变量。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-groups">4.5. 日志组</h3>
<div class="paragraph">
<p>能够将相关记录器分组在一起通常是很有用的，以便可以同时配置它们。例如：你可能通常会更改 <em>所有</em> 与Tomcat相关的记录器的日志级别，但是你不容易记住顶层软件包。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，Spring Boot允许你在Spring <code>Environment</code> 中定义日志记录组。例如：以下是通过将“<code>tomcat</code>”组添加到
<code>application.properties</code> 来定义它的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义后，你可以仅使用一行就更改该组中所有记录器的日志级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.tomcat=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot包含以下预定义的日志记录组，它们可以直接使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">记录器</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">web</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.codec</code>, <code>org.springframework.http</code>, <code>org.springframework.web</code>, <code>org.springframework.boot.actuate.endpoint.web</code>, <code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sql</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.jdbc.core</code>, <code>org.hibernate.SQL</code>, <code>org.jooq.tools.LoggerListener</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-custom-log-configuration">4.6. 自定义日志配置</h3>
<div class="paragraph">
<p>可以通过在类路径中包括适当的库来激活各种日志记录系统，并可以通过在类路径的根目录中或在以下Spring
<code>Environment</code> 属性指定的位置中提供适当的配置文件来进一步自定义日志文件：<code>logging.config</code>。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性来强制Spring Boot使用特定的日志记录系统。
该值应该是 <code>LoggingSystem</code> 实现的完全限定类名。你也可以使用 <code>none</code> 值完全禁用Spring Boot的日志记录配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于日志记录是在创建 <code>ApplicationContext</code> <strong>之前</strong> 初始化的，因此无法从Spring
<code>@Configuration</code> 文件中的 <code>@PropertySources</code> 控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>根据你的日志记录系统，将加载以下文件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">志记录系统</th>
<th class="tableblock halign-left valign-top">自定义配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> 或 <code>logback.groovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Log4j2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log4j2-spring.xml</code> 或 <code>log4j2.xml</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDK (Java Util Logging)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.properties</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果可能，我们建议你在日志配置中使用 <code>-spring</code> 变体（例如：使用 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>）。
如果使用标准配置位置，Spring将无法完全控制日志初始化。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这会引起问题。我们建议你尽可能在“可执行jar”运行时避免使用它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了帮助定制，将一些其他属性从Spring <code>Environment</code> 转移到系统属性，如下表所述：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Environment</th>
<th class="tableblock halign-left valign-top">System Property</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.exception-conversion-word</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_EXCEPTION_CONVERSION_WORD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录异常时使用的转换字。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.clean-history-on-start</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_CLEAN_HISTORY_ON_START</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在启动时清除存档日志文件（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_SIZE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大日志文件大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-history</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_HISTORY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的最大归档日志文件数（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_PATH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.total-size-cap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_TOTAL_SIZE_CAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的备份日志的总大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.console</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONSOLE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制台上使用的日志模式（stdout）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.dateformat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_DATEFORMAT_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录日期格式的附加模式。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FILE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件中使用的日志模式（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_LEVEL_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现日志级别时使用的格式（默认为 <code>%5p</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.rolling-file-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROLLING_FILE_NAME_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过渡日志文件名的模式（默认为 <code>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前进程ID（如果可能，并且尚未将其定义为操作系统环境变量时将被发现）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见 <code>spring-boot.jar</code> 中的默认配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml[Logback]</p>
</li>
<li>
<p>{spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml[Log4j 2]</p>
</li>
<li>
<p>{spring-boot-code}/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties[Java Util logging]</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要在日志记录属性中使用占位符，则应使用<a href="#boot-features-external-config-placeholders-in-properties">Spring Boot的语法</a>而不是基础框架的语法。
值得注意的是，如果使用Logback，则应使用 <code>:</code> 作为属性名称与其默认值之间的分隔符，而不应使用 <code>:-</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以通过仅覆盖 <code>LOG_LEVEL_PATTERN</code>（或Logback的 <code>logging.pattern.level</code>）来将MDC和其他临时内容添加到日志行。
例如，如果你使用 <code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含一个名为“user”的MDC条目（如果存在），如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
Handling authenticated request</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logback-extensions">4.7. Logback扩展</h3>
<div class="paragraph">
<p>Spring Boot包含许多Logback扩展，可以帮助进行高级配置。你可以在 <code>logback-spring.xml</code> 配置文件中使用这些扩展名。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于标准 <code>logback.xml</code> 配置文件加载得太早，因此无法在其中使用扩展名。你需要使用 <code>logback-spring.xml</code> 或定义 <code>logging.config</code> 属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
这些扩展不能与Logback的 <a href="https://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a>一起使用。
如果尝试这样做，则对配置文件进行更改将导致类似于以下日志之一的错误：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</pre>
</div>
</div>
<div class="sect3">
<h4 id="_特定于profile的配置">4.7.1. 特定于Profile的配置</h4>
<div class="paragraph">
<p>通过 <code>&lt;springProfile&gt;</code> 标记，你可以根据活动的Spring profiles有选择地包括或排除配置部分。
在 <code>&lt;configuration&gt;</code> 元素内的任何位置都支持profile部分。使用 <code>name</code> 属性指定哪个profile接受配置。
<code>&lt;springProfile&gt;</code> 标记可以包含简单的profile名称（例如：<code>staging</code>）或profile表达式。
profile表达式允许表达更复杂的配置文件逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。
有关更多详细信息，请参阅 {spring-framework-docs}core.html#beans-definition-profiles-java[参考指南]。
以下清单显示了三个样本profiles：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProfile name="staging"&gt;
    &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="dev | staging"&gt;
    &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="!production"&gt;
    &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;
&lt;/springProfile&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_环境属性">4.7.2. 环境属性</h4>
<div class="paragraph">
<p><code>&lt;springProperty&gt;</code> 标签使你可以从Spring <code>Environment</code> 中公开属性，以在Logback中使用。
如果要在Logback配置中访问 <code>application.properties</code> 文件中的值，则这样做很有用。
该标签的工作方式类似于Logback的标准 <code>&lt;property&gt;</code> 标签。但是，不是指定直接 <code>value</code>，而是指定属性的 <code>source</code>（来自 <code>Environment</code>）。
如果需要将属性存储在 <code>local</code> 作用域以外的其他位置，则可以使用 <code>scope</code> 属性。如果需要后备值（如果未在环境中设置该属性），
则可以使用 <code>defaultValue</code> 属性。以下示例显示如何公开在Logback中使用的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
        defaultValue="localhost"/&gt;
&lt;appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"&gt;
    &lt;remoteHost&gt;${fluentHost}&lt;/remoteHost&gt;
    ...
&lt;/appender&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>source</code> 必须以kebab格式指定（例如：<code>my.property-name</code>）。但是，可以使用宽松的规则将属性添加到 <code>Environment</code> 中。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-internationalization">5. 国际化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot支持本地化消息，因此你的应用程序可以迎合不同语言首选项的用户。
默认情况下，Spring Boot在类路径的根目录下查找存在的 <code>messages</code> 资源包。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当已配置资源束的默认属性文件可用时（即默认情况下为 <code>messages.properties</code>），将应用自动配置。
如果你的资源包仅包含特定于语言的属性文件，则需要添加默认文件。如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 <code>MessageSource</code> 可用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.messages</code> 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring.messages.basename</code> 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/context/MessageSourceProperties.java[<code>MessageSourceProperties</code>]。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-json">6. JSON</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了与三个JSON映射库的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gson</p>
</li>
<li>
<p>Jackson</p>
</li>
<li>
<p>JSON-B</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jackson是首选的默认库。</p>
</div>
<div class="sect2">
<h3 id="boot-features-json-jackson">6.1. Jackson</h3>
<div class="paragraph">
<p>提供了Jackson的自动配置，并且Jackson是 <code>spring-boot-starter-json</code> 的一部分。当Jackson放在类路径上时，
将自动配置 <code>ObjectMapper</code> Bean。提供了几个配置属性，用于
{spring-boot-docs}/htmlsingle/#howto-customize-the-jackson-objectmapper[自定义 <code>ObjectMapper</code> 的配置]。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json-gson">6.2. Gson</h3>
<div class="paragraph">
<p>提供了Gson的自动配置。当Gson在类路径上时，将自动配置 <code>Gson</code> bean。提供了几个 <code>spring.gson.*</code>
配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个 <code>GsonBuilderCustomizer</code> bean。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json-json-b">6.3. JSON-B</h3>
<div class="paragraph">
<p>提供了JSON-B的自动配置。当JSON-B API和实现位于类路径上时，将自动配置 <code>Jsonb</code> bean。首选的JSON-B实现是提供了依赖管理的
<a href="http://johnzon.apache.org/">Apache Johnzon</a>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-developing-web-applications">7. 开发Web应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot非常适合于Web应用程序开发。你可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建独立的HTTP服务器。
大多数Web应用程序都使用 <code>spring-boot-starter-web</code> 模块来快速启动和运行。
你还可以选择使用 <code>spring-boot-starter-webflux</code> 模块构建响应式Web应用程序。</p>
</div>
<div class="sect2">
<h3 id="boot-features-spring-mvc">7.1. Spring Web MVC框架</h3>
<div class="paragraph">
<p>{spring-framework-docs}#mvc[Spring Web MVC框架]
（通常简称为“Spring MVC”）是一个丰富的“<code>model view controller</code>”Web框架。
Spring MVC使你可以创建特殊的 <code>@Controller</code> 或 <code>@RestController</code> Bean来处理传入的HTTP请求。
使用 <code>@RequestMapping</code> 注解将控制器中的方法映射到HTTP。</p>
</div>
<div class="paragraph">
<p>以下代码显示了提供JSON数据返回的典型 <code>@RestController</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping(value="/users")
public class MyRestController {

    @RequestMapping(value="/{user}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
    List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
    public User deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC是核心Spring Framework的一部分，有关详细信息，请参阅 {spring-framework-docs}#mvc[参考文档]。
在 spring.io/guides 上还有一些涵盖Spring MVC的指南。</p>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-auto-configuration">7.1.1. Spring MVC自动配置</h4>
<div class="paragraph">
<p>Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含 <code>ContentNegotiatingViewResolver</code> 和 <code>BeanNameViewResolver</code> Bean。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>Converter</code>，<code>GenericConverter</code> 和 <code>Formatter</code> Bean。</p>
</li>
<li>
<p>对 <code>HttpMessageConverters</code> 的支持（<a href="#boot-features-spring-mvc-message-converters">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>MessageCodesResolver</code>（<a href="#boot-features-spring-message-codes">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>静态 <code>index.html</code> 支持。</p>
</li>
<li>
<p>自定义 <code>Favicon</code> 支持（<a href="#boot-features-spring-mvc-favicon">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动使用 <code>ConfigurableWebBindingInitializer</code> Bean（<a href="#boot-features-spring-mvc-web-binding-initializer">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot MVC功能并想要添加其他 {spring-framework-docs}#mvc[MVC配置]（拦截器，格式化程序，视图控制器和其他功能），
则可以添加自己的类型为 <code>WebMvcConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不添加</strong> <code>@EnableWebMvc</code>。
如果希望提供 <code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code> 或
<code>ExceptionHandlerExceptionResolver</code> 的自定义实例，则可以声明一个 <code>WebMvcRegistrationsAdapter</code> 实例以提供此类组件。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring MVC，则可以添加自己的带有 <code>@EnableWebMvc</code> 注解的 <code>@Configuration</code> 类。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-message-converters">7.1.2. HttpMessageConverters</h4>
<div class="paragraph">
<p>Spring MVC使用 <code>HttpMessageConverter</code> 接口转换HTTP请求和响应。开箱即用中包含明智的默认设置。
例如：可以将对象自动转换为JSON（通过使用Jackson库）或XML（如果可用通过使用Jackson XML扩展或如果Jackson
XML扩展不可用通过使用JAXB）。默认情况下，字符串以 <code>UTF-8</code> 编码。</p>
</div>
<div class="paragraph">
<p>如果你需要添加或自定义转换器，则可以使用Spring Boot的 <code>HttpMessageConverters</code> 类，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上下文中存在的所有 <code>HttpMessageConverter</code> bean都将添加到转换器列表中。你也可以用相同的方法覆盖默认转换器。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-components">7.1.3. 自定义JSON序列化器和反序列化器</h4>
<div class="paragraph">
<p>如果使用Jackson序列化和反序列化JSON数据，则可能要编写自己的 <code>JsonSerializer</code> 和 <code>JsonDeserializer</code> 类。
自定义序列化程序通常是 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块向Jackson进行注册的</a>，
但是Spring Boot提供了替代的 <code>@JsonComponent</code> 注解，这使得直接注册Spring Bean更加容易。</p>
</div>
<div class="paragraph">
<p>你可以直接在 <code>JsonSerializer</code>，<code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。
你还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

    public static class Serializer extends JsonSerializer&lt;SomeObject&gt; {
        // ...
    }

    public static class Deserializer extends JsonDeserializer&lt;SomeObject&gt; {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> bean都会自动向Jackson注册。
因为 <code>@JsonComponent</code> 用 <code>@Component</code> 进行元注解，所以适用常规的组件扫描规则。</p>
</div>
<div class="paragraph">
<p>Spring Boot还提供了 {spring-boot-module-code}/jackson/JsonObjectSerializer.java[<code>JsonObjectSerializer</code>]
和 {spring-boot-module-code}/jackson/JsonObjectDeserializer.java[<code>JsonObjectDeserializer</code>]基类，
这些基类在序列化对象时为标准Jackson版本提供了有用的替代方法。有关详细信息，请参见Javadoc中的
{spring-boot-module-api}/jackson/JsonObjectSerializer.html[<code>JsonObjectSerializer</code>]和
{spring-boot-module-api}/jackson/JsonObjectDeserializer.html[<code>JsonObjectDeserializer</code>]。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-message-codes">7.1.4. MessageCodesResolver</h4>
<div class="paragraph">
<p>Spring MVC有一种生成错误码以从绑定错误中呈现错误消息的策略：<code>MessageCodesResolver</code>。
如果你设置 <code>spring.mvc.message-codes-resolver-format</code> 属性为 <code>PREFIX_ERROR_CODE</code> 或 <code>POSTFIX_ERROR_CODE</code>，
Spring Boot会为你创建一个（请参见 {spring-framework-api}/validation/DefaultMessageCodesResolver.Format.html[<code>DefaultMessageCodesResolver.Format</code>]中的枚举）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-static-content">7.1.5. 静态内容</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中的 <code>/static</code> 目录（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/ resources</code>）
或ServletContext的根目录中提供静态内容。它使用Spring MVC中的 <code>ResourceHttpRequestHandler</code>，
以便你可以通过添加自己的 <code>WebMvcConfigurer</code> 并重写 <code>addResourceHandlers</code> 方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>在独立的Web应用程序中，还启用了容器中的默认Servlet，并将其用作降级方案，如果Spring决定不处理，
则从 <code>ServletContext</code> 的根目录提供内容。在大多数情况下，这不会发生（除非你修改默认的MVC配置），
因为Spring始终可以通过 <code>DispatcherServlet</code> 处理请求。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以使用 <code>spring.mvc.static-path-pattern</code> 属性进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以按如下方式实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 属性来自定义静态资源位置（用目录位置列表替换默认值）。
根Servlet上下文路径 <code>"/"</code> 也会作为位置自动添加。</p>
</div>
<div class="paragraph">
<p>除了前面提到的“标准”静态资源位置， <a href="https://www.webjars.org/">Webjars 内容</a>还有一个特殊情况。
如果jar文件以Webjars格式打包，则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的应用程序打包为jar，则不要使用 <code>src/main/webapp</code> 目录。尽管此目录是一个通用标准，
但它仅与war打包一起使用，并且如果生成jar，大多数构建工具都将其忽略。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用案例如：缓存清除静态资源或对Webjars使用版本无关的URL。</p>
</div>
<div class="paragraph">
<p>要对Webjars使用版本无关的URL，请添加 <code>webjars-locator-core</code> 依赖项，然后声明你的Webjar。
以jQuery为例，添加 <code>"/webjars/jquery/jquery.min.js"</code> 将得到 <code>"/webjars/jquery/x.y.z/jquery.min.js"</code>，
其中 <code>x.y.z</code> 是Webjar版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用JBoss，则需要声明 <code>webjars-locator-jboss-vfs</code> 依赖项，而不是 <code>webjars-locator-core</code>。
否则，所有Webjar都解析为 <code>404</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，并在URL中有效地添加了内容哈希，例如：
<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过为Thymeleaf和FreeMarker自动配置 <code>ResourceUrlEncodingFilter</code>，可以在运行时在模板中重写到资源的链接。
使用JSP时，你应该手动声明此过滤器。当前尚不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，以及使用
{spring-framework-api}/web/servlet/resource/ResourceUrlProvider.html[<code>ResourceUrlProvider</code>]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如：当使用JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以相互组合的原因。
“固定”策略在URL中添加静态版本字符串，而不更改文件名，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这种配置，位于 <code>"/js/lib/"</code> 下的JavaScript模块使用固定的版本控制策略（<code>"/v12/js/lib/mymodule.js"</code>），
而其他资源仍使用内容版本（<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code>）。</p>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/web/ResourceProperties.java[<code>ResourceProperties</code>]。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该功能已在专门的 <a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客文章</a>
和Spring Framework的 {spring-framework-docs}#mvc-config-static-resources[参考文档]中进行了详细说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-welcome-page">7.1.6. 欢迎页面</h4>
<div class="paragraph">
<p>Spring Boot支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找 <code>index.html</code> 文件。如果未找到，则寻找 <code>index</code>
模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-favicon">7.1.7. 自定义图标</h4>
<div class="paragraph">
<p>与其他静态资源一样，Spring Boot在已配置的静态内容位置中查找 <code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-pathmatch">7.1.8. 路径匹配和内容协商</h4>
<div class="paragraph">
<p>Spring MVC可以通过查看请求路径并将其匹配到应用程序中定义的映射（例如：Controller方法上的 <code>@GetMapping</code> 注解）来将传入的HTTP请求映射到处理程序。</p>
</div>
<div class="paragraph">
<p>Spring Boot选择默认情况下禁用后缀模式匹配，这意味着 <code>"GET /projects/spring-boot.json"</code> 之类的请求将不会与
<code>@GetMapping("/projects/spring-boot")</code> 映射进行匹配。这被认为是
{spring-framework-docs}#mvc-ann-requestmapping-suffix-pattern-match[Spring MVC应用程序的最佳实践]。
过去，此功能主要用于未发送正确的“Accept”请求头的HTTP客户端，我们需要确保将正确的内容类型发送给客户端。
如今，内容协商已变得更加可靠。</p>
</div>
<div class="paragraph">
<p>还有其他处理HTTP客户端的方法，这些客户端不能始终发送正确的“Accept”请求头。
除了使用后缀匹配，我们还可以使用查询参数来确保将诸如 <code>"GET /projects/spring-boot?format=json"</code> 之类的请求映射到
<code>@GetMapping("/projects/spring-boot")</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你了解了注意事项，但仍希望你的应用程序使用后缀模式匹配，则需要以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-suffix-pattern=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，与其打开所有后缀模式，不如只支持已注册的后缀模式，这更安全：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-web-binding-initializer">7.1.9. ConfigurableWebBindingInitializer</h4>
<div class="paragraph">
<p>Spring MVC使用 <code>WebBindingInitializer</code> 来为特定请求初始化 <code>WebDataBinder</code>。
如果创建自己的 <code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC以使用它。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc-template-engines">7.1.10. 模板引擎</h4>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，
包括Thymeleaf，FreeMarker和JSP。同样，许多其他模板引擎也提供包括他们自己的Spring MVC集成。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果可能，应避免使用JSP。将它们与嵌入式servlet容器一起使用时，存在几个<a href="#boot-features-jsp-limitations">已知的限制</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
根据你运行应用程序的方式，IntelliJ IDEA对类路径的排序不同。与使用Maven或Gradle或从其打包的jar运行应用程序时相比，
从IDE的main方法运行应用程序的顺序会有所不同。这可能导致Spring Boot无法在类路径上找到模板。
如果遇到此问题，可以在IDE中重新排序类路径，以首先放置模块的类和资源。
或者，你可以配置模板前缀以搜索类路径上的每个 <code>templates</code> 目录，例如：<code>classpath*:/templates/</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-error-handling">7.1.11. 错误处理</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot提供一个 <code>/error</code> 映射，以一种明智的方式处理所有错误，并且在servlet容器中注册为“<code>global</code>”错误页面。
对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“<code>whitelabel</code>”错误视图以HTML格式呈现相同的数据（要对其进行自定义，请添加一个可解决 <code>error</code> 的 <code>View</code>）。
要完全替换默认行为，可以实现 <code>ErrorController</code> 并注册该类型的bean定义，或者添加类型为 <code>ErrorAttributes</code> 的bean以使用现有机制，但替换其内容。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>BasicErrorController</code> 可用作自定义 <code>ErrorController</code> 的基类。如果要为新的内容类型添加处理程序（默认是专门处理
<code>text/html</code> 并为其他所有内容提供降级功能），则此功能特别有用。为此，请继承 <code>BasicErrorController</code>，添加具有 <code>@RequestMapping</code>
的公共方法，该方法具有 <code>produces</code> 属性，并创建新类型的Bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以定义一个用 <code>@ControllerAdvice</code> 注解的类，以自定义JSON文档以针对特定的控制器和/或异常类型返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(YourException.class)
    @ResponseBody
    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new CustomErrorType(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果与 <code>AcmeController</code> 在同一包中定义的控制器抛出 <code>YourException</code>，则使用 <code>CustomErrorType</code>
POJO的JSON表示形式而不是 <code>ErrorAttributes</code> 表示形式。</p>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling-custom-error-pages">自定义错误页面</h5>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板来构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用FreeMarker模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的映射，还可以添加实现 <code>ErrorViewResolver</code> 接口的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request,
            HttpStatus status, Map&lt;String, Object&gt; model) {
        // Use the request or status to optionally return a ModelAndView
        return ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用常规的Spring MVC功能，例如： {spring-framework-docs}#mvc-exceptionhandlers[<code>@ExceptionHandler</code> 方法]和
{spring-framework-docs}#mvc-ann-controller-advice[<code>@ControllerAdvice</code>]。然后，<code>ErrorController</code> 拾取所有未处理的异常。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling-mapping-error-pages-without-mvc">在Spring MVC之外映射错误页面</h5>
<div class="paragraph">
<p>对于不使用Spring MVC的应用程序，可以使用 <code>ErrorPageRegistrar</code> 接口直接注册 <code>ErrorPages</code>。
此抽象直接与基础嵌入式servlet容器一起使用，即使你没有Spring MVC <code>DispatcherServlet</code> 它也可以使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ErrorPageRegistrar errorPageRegistrar(){
    return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>ErrorPage</code> 上注册了一个最终由 <code>Filter</code> 处理的路径（这在某些非Spring Web框架中很常见，如Jersey和Wicket），
则必须将 <code>Filter</code> 显式注册为 <code>ERROR</code> 调度程序，如下面的例子所示：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new MyFilter());
    ...
    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
    return registration;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，默认的 <code>FilterRegistrationBean</code> 不包含 <code>ERROR</code> 调度程序类型。</p>
</div>
<div id="boot-features-error-handling-websphere" class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
当部署到Servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到适当的错误页面。
如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0
及更高版本在成功完成servlet的服务方法后提交响应。
你应该通过将 <code>com.ibm.ws.webcontainer.invokeFlushAfterService</code> 设置为 <code>false</code> 来禁用此行为。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-hateoas">7.1.12. Spring HATEOAS</h4>
<div class="paragraph">
<p>如果你开发使用超媒体的RESTful API，Spring Boot将为Spring HATEOAS提供自动配置，
该配置可与大多数应用程序很好地兼容。自动配置取代了手动使用 <code>@EnableHypermediaSupport</code> 的需要，
并注册了许多bean来简化基于超媒体的应用程序的构建，其中包括 <code>LinkDiscoverers</code>（用于客户端支持）和 <code>ObjectMapper</code>
其配置为将响应正确地组装为所需的表示形式。通过设置各种 <code>spring.jackson.*</code> 属性，
或通过 <code>Jackson2ObjectMapperBuilder</code> bean（如果存在）来定制 <code>ObjectMapper</code>。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@EnableHypermediaSupport</code> 来控制Spring HATEOAS的配置。请注意，这样做会禁用前面所述的 <code>ObjectMapper</code> 定制。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-cors">7.1.13. CORS支持</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>（CORS）是由 <a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实施的
<a href="https://www.w3.org/TR/cors/">W3C 规范</a>，可让你灵活地指定授权哪种类型的跨域请求，而不是使用诸如IFRAME或JSONP之类的安全性较低，功能较弱的方法。</p>
</div>
<div class="paragraph">
<p>从4.2版本开始，Spring MVC {spring-framework-docs}#mvc-cors[支持CORS]。在Spring Boot应用程序中使用带有
{spring-framework-api}/web/bind/annotation/CrossOrigin.html[<code>@CrossOrigin</code>]
注解的 {spring-framework-docs}#mvc-cors-controller[控制器方法CORS配置]不需要任何特定的配置。
可以通过使用自定义的 <code>addCorsMappings(CorsRegistry)</code> 方法注册 <code>WebMvcConfigurer</code> Bean来定义
{spring-framework-docs}#mvc-cors-global[全局CORS配置]，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webflux">7.2. Spring WebFlux框架</h3>
<div class="paragraph">
<p>Spring WebFlux是Spring Framework 5.0中引入的新响应式Web框架。
与Spring MVC不同，它不需要Servlet API，是完全异步和非阻塞的，并且通过 <a href="https://projectreactor.io/">Reactor项目</a>
实现 <a href="https://www.reactive-streams.org/">Reactive Streams</a>规范。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux有两种形式：函数式的和基于注解的。基于注解的模型非常类似于Spring MVC模型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/users")
public class MyRestController {

    @GetMapping("/{user}")
    public Mono&lt;User&gt; getUser(@PathVariable Long user) {
        // ...
    }

    @GetMapping("/{user}/customers")
    public Flux&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @DeleteMapping("/{user}")
    public Mono&lt;User&gt; deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数式变体“<code>WebFlux.fn</code>”将路由配置与请求的实际处理分开，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class RoutingConfiguration {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler) {
        return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
                .andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
                .andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
    }

}

@Component
public class UserHandler {

    public Mono&lt;ServerResponse&gt; getUser(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; deleteUser(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux是Spring Framework的一部分，其 {spring-framework-docs}web-reactive.html#webflux-fn[参考文档]中提供了详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以根据需要定义任意数量的 <code>RouterFunction</code> beans，以对路由器的定义进行模块化。如果需要应用优先级，可以排序Beans。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先将 <code>spring-boot-starter-webflux</code> 模块添加到你的应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在应用程序中同时添加 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-webflux</code> 模块会导致Spring
Boot自动配置Spring MVC，而不是WebFlux。之所以选择这种行为，是因为许多Spring开发人员将 <code>spring-boot-starter-webflux</code>
添加到其Spring MVC应用程序中以使用响应式 <code>WebClient</code>。你仍然可以通过将选定的应用程序类型设置为
<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code> 来强制执行选择。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-auto-configuration">7.2.1. Spring WebFlux自动配置</h4>
<div class="paragraph">
<p>Spring Boot为Spring WebFlux提供了自动配置，可与大多数应用程序很好地配合使用。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 实例配置编解码器（<a href="#boot-features-webflux-httpcodecs">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot WebFlux功能并想要添加其他WebFlux配置，则可以添加自己的类型为
<code>WebFluxConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不</strong> 添加 <code>@EnableWebFlux</code>。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring WebFlux，则可以添加带有 <code>@EnableWebFlux</code> 注解的自己的 <code>@Configuration</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-httpcodecs">7.2.2. 带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h4>
<div class="paragraph">
<p>Spring WebFlux使用 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 接口转换HTTP请求和响应。
通过查看类路径中可用的库，使用 <code>CodecConfigurer</code> 将它们配置为具有合理的默认值。</p>
</div>
<div class="paragraph">
<p>Spring Boot为编解码器 <code>spring.codec.*</code> 提供了专用的配置属性。它还通过使用 <code>CodecCustomizer</code> 实例应用进一步的自定义。
例如，将 <code>spring.jackson.*</code> 配置keys应用于Jackson编解码器。</p>
</div>
<div class="paragraph">
<p>如果需要添加或自定义编解码器，则可以创建一个自定义 <code>CodecCustomizer</code> 组件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.codec.CodecCustomizer;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return codecConfigurer -&gt; {
            // ...
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以利用<a href="#boot-features-json-components">Boot&#8217;s自定义JSON序列化器和反序列化器</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-static-content">7.2.3. 静态内容</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中名为 <code>/static</code>（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code>）的目录中提供静态内容。
它使用Spring WebFlux中的 <code>ResourceWebHandler</code>，以便你可以通过添加自己的 <code>WebFluxConfigurer</code> 并覆盖 <code>addResourceHandlers</code>
方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以通过设置 <code>spring.webflux.static-path-pattern</code> 属性来对其进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以实现如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webflux.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 自定义静态资源位置。这样做会将默认值替换为目录位置列表。
如果这样做，默认的欢迎页面检测将切换到你的自定义位置。因此，如果启动时你指定的任何位置有 <code>index.html</code>，则它是应用程序的主页。</p>
</div>
<div class="paragraph">
<p>除了前面列出的“标准”静态资源位置外，https://www.webjars.org/[Webjar内容]有个特殊情况。如果jar文件以Webjars格式打包，
则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring WebFlux应用程序不严格依赖Servlet API，因此不能将它们部署为war文件，也不使用 <code>src/main/webapp</code> 目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-template-engines">7.2.4. 模板引擎</h4>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring WebFlux来提供动态HTML内容。
Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-error-handling">7.2.5. 错误处理</h4>
<div class="paragraph">
<p>Spring Boot提供了一个 <code>WebExceptionHandler</code>，以一种明智的方式处理所有错误。它在处理顺序中的位置紧靠WebFlux提供的处理程序之前，
后者被认为是最后一个处理程序。对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“whitelabel”错误处理程序，以HTML格式呈现相同的数据。你还可以提供自己的HTML模板来显示错误（请参阅
<a href="#boot-features-webflux-error-handling-custom-error-pages">下一节</a>）。</p>
</div>
<div class="paragraph">
<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，你可以添加类型为 <code>ErrorAttributes</code> 的bean。</p>
</div>
<div class="paragraph">
<p>要更改错误处理行为，可以实现 <code>ErrorWebExceptionHandler</code> 并注册该类型的bean定义。由于 <code>WebExceptionHandler</code> 的级别很低，
因此Spring Boot还提供了一个方便的 <code>AbstractErrorWebExceptionHandler</code>，可让你以WebFlux函数式方式处理错误，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    // Define constructor here

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) {

        return RouterFunctions
                .route(aPredicate, aHandler)
                .andRoute(anotherPredicate, anotherHandler);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了获得更完整的图像，你还可以直接将 <code>DefaultErrorWebExceptionHandler</code> 子类化并重写特定方法。</p>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-error-handling-custom-error-pages">自定义错误页面</h5>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用Mustache模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux-web-filters">7.2.6. Web过滤器</h4>
<div class="paragraph">
<p>Spring WebFlux提供了一个 <code>WebFilter</code> 接口，可以实现该接口来过滤HTTP请求-响应交换。
在应用程序上下文中找到的 <code>WebFilter</code> bean将自动用于过滤每个交换。</p>
</div>
<div class="paragraph">
<p>如果过滤器的顺序很重要，则可以实现 <code>Ordered</code> 或使用 <code>@Order</code> 进行注解。
Spring Boot自动配置会为你配置Web过滤器。这样做时，将使用下表中显示的顺序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Web过滤器</th>
<th class="tableblock halign-left valign-top">顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MetricsWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilterChainProxy</code> (Spring Security)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-100</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpTraceWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE - 10</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jersey">7.3. JAX-RS和Jersey</h3>
<div class="paragraph">
<p>如果你更喜欢REST端点的JAX-RS编程模型，则可以使用可用的实现之一来代替Spring MVC。
<a href="https://jersey.github.io/">Jersey</a> 和 <a href="https://cxf.apache.org/">Apache CXF</a>开箱即用。
CXF要求你在应用程序上下文中将其 <code>Servlet</code> 或 <code>Filter</code> 注册为 <code>@Bean</code>。
Jersey提供了一些native Spring支持，因此我们还在Spring Boot中提供了对它的自动配置支持，以及一个启动器。</p>
</div>
<div class="paragraph">
<p>要开始使用Jersey，请将 <code>spring-boot-starter-jersey</code> 作为依赖项包括在内，然后需要一个
<code>ResourceConfig</code> 类型的 <code>@Bean</code>，在其中注册所有端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Jersey&#8217;s对扫描可执行档案的支持非常有限。例如：在运行可执行的war文件时，
它无法扫描在<a href="deployment.html#deployment-install">完全可执行的jar文件</a>或
<code>WEB-INF/classes</code> 中找到的包中的端点。为了避免这种限制，不应该使用 <code>packages</code> 方法，
而应该使用 <code>register</code> 方法分别注册端点，如前面的示例所示。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于更高级的定制，你还可以注册任意数量的 <code>ResourceConfigCustomizer</code> 实现beans。</p>
</div>
<div class="paragraph">
<p>所有注册的端点应为具有HTTP资源注解的 <code>@Components</code>（<code>@GET</code> 和其他注解），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Path("/hello")
public class Endpoint {

    @GET
    public String message() {
        return "Hello";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于端点是Spring <code>@Component</code>，因此其生命周期由Spring管理，你可以使用 <code>@Autowired</code> 注解注入依赖项，
并使用 <code>@Value</code> 注解注入外部配置。默认情况下，Jersey servlet被注册并映射到 <code>/*</code>。
你可以通过将 <code>@ApplicationPath</code> 添加到 <code>ResourceConfig</code> 来更改映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jersey在名为 <code>jerseyServletRegistration</code> 的 <code>ServletRegistrationBean</code> 类型的 <code>@Bean</code> 中设置为Servlet。
默认情况下，该Servlet延迟初始化，但是你可以通过设置 <code>spring.jersey.servlet.load-on-startup</code> 来自定义该行为。
你可以通过创建自己的同名bean之一来禁用或覆盖该bean。你还可以通过设置 <code>spring.jersey.type=filter</code>
（在这种情况下，要替换或覆盖的 <code>@Bean</code> 是 <code>jerseyFilterRegistration</code>）来使用过滤器而不是servlet。
过滤器具有 <code>@Order</code>，你可以使用 <code>spring.jersey.filter.order</code> 进行设置。可以通过使用 <code>spring.jersey.init.*</code> 来指定属性映射，
从而为servlet和过滤器注册都赋予init参数。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-embedded-container">7.4. 嵌入式Servlet容器支持</h3>
<div class="paragraph">
<p>Spring Boot包括对嵌入式 <a href="https://tomcat.apache.org/">Tomcat</a>， <a href="https://www.eclipse.org/jetty/">Jetty</a>和
默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-servlets-filters-listeners">7.4.1. Servlets, Filters和listeners</h4>
<div class="paragraph">
<p>使用嵌入式Servlet容器时，可以通过使用Spring beans或扫描Servlet组件来注册Servlet规范中的servlets，过滤器和所有监听器（例如：<code>HttpSessionListener</code>）。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners-beans">将Servlets, Filters和Listeners注册为Spring Beans</h5>
<div class="paragraph">
<p>任何作为Spring Bean的 <code>Servlet</code>，<code>Filter</code> 或 <code>*Listener</code> 实例都向嵌入式容器注册。如果要在配置过程中引用
<code>application.properties</code> 中的值，这可能特别方便。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果上下文仅包含单个Servlet，则将其映射到 <code>/</code>。对于多个servlet bean，bean名称被用作路径前缀。
过滤器映射到 <code>/*</code>。</p>
</div>
<div class="paragraph">
<p>如果基于约定的映射不够灵活，则可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>
和 <code>ServletListenerRegistrationBean</code> 类进行完全控制。</p>
</div>
<div class="paragraph">
<p>通常可以使无序的过滤器beans处于安全状态。如果需要特定的顺序，则应使用 <code>@Order</code> 注解 <code>Filter</code> 或使其实现 <code>Ordered</code>。
你不能通过使用 <code>@Order</code> 注解 <code>Filter</code> 的bean方法来配置 <code>Filter</code> 的顺序。如果你不能更改 <code>Filter</code> 类以添加 <code>@Order</code> 或实现 <code>Ordered</code>，
则必须为 <code>Filter</code> 定义一个 <code>FilterRegistrationBean</code> 并使用 <code>setOrder(int)</code> 方法设置注册bean的顺序。
避免配置一个在 <code>Ordered.HIGHEST_PRECEDENCE</code> 上读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。
如果Servlet过滤器包装了请求，则应使用小于或等于 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 的顺序来配置它。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要查看应用程序中每个 <code>Filter</code> 的顺序，请为 <code>web</code> <a href="#boot-features-custom-log-groups">日志记录组</a>
（<code>logging.level.web=debug</code>）启用调试级别的日志记录。然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
注册 <code>Filter</code> beans时要小心，因为它们是在应用程序生命周期中很早就初始化的。如果需要注册与其他bean交互的 <code>Filter</code>
，请考虑改用 {spring-boot-module-api}/web/servlet/DelegatingFilterProxyRegistrationBean.html[<code>DelegatingFilterProxyRegistrationBean</code>]。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-context-initializer">7.4.2. Servlet上下文初始化</h4>
<div class="paragraph">
<p>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code> 接口或Spring的
<code>org.springframework.web.WebApplicationInitializer</code> 接口。这是一个有意的设计决定，
旨在降低在war中运行的第三方库可能破坏Spring Boot应用程序的风险。</p>
</div>
<div class="paragraph">
<p>如果你需要在Spring Boot应用程序中执行Servlet上下文初始化，则应该注册一个实现
<code>org.springframework.boot.web.servlet.ServletContextInitializer</code> 接口的bean。
单个 <code>onStartup</code> 方法提供对 <code>ServletContext</code> 的访问，并且在必要时可以轻松地用作现有 <code>WebApplicationInitializer</code> 的适配器。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners-scanning">扫描Servlets, Filters和Listeners</h5>
<div class="paragraph">
<p>使用嵌入式容器时，可以使用 <code>@ServletComponentScan</code> 启用自动注册带有 <code>@WebServlet</code>，<code>@WebFilter</code> 和 <code>@WebListener</code> 的类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@ServletComponentScan</code> 在独立容器中无效，而是使用容器的内置发现机制。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container-application-context">7.4.3. ServletWebServerApplicationContext</h4>
<div class="paragraph">
<p>在后台，Spring Boot使用另一种类型的 <code>ApplicationContext</code> 来支持嵌入式Servlet容器。
<code>ServletWebServerApplicationContext</code> 是 <code>WebApplicationContext</code> 的一种特殊类型，
它通过搜索单个 <code>ServletWebServerFactory</code> bean来自我引导。通常，已经自动配置了
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 或 <code>UndertowServletWebServerFactory</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通常，你不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表你创建了相应的 <code>ApplicationContext</code>
和 <code>ServletWebServerFactory</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-customizing-embedded-containers">7.4.4. 自定义嵌入式Servlet容器</h4>
<div class="paragraph">
<p>可以使用Spring <code>Environment</code> 属性来配置常见的servlet容器设置。通常，你将在 <code>application.properties</code>
文件中定义属性。</p>
</div>
<div class="paragraph">
<p>常用服务器设置包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络设置：监听传入HTTP请求的端口（<code>server.port</code>），绑定到 <code>server.address</code> 的接口地址，等等。</p>
</li>
<li>
<p>会话设置：会话是否持久（<code>server.servlet.session.persistent</code>），会话超时（<code>server.servlet.session.timeout</code>），
会话数据的位置（<code>server.servlet.session.store-dir</code>）和会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</p>
</li>
<li>
<p>错误管理：错误页面的位置（<code>server.error.path</code>）等。</p>
</li>
<li>
<p>{spring-boot-docs}/htmlsingle/#howto-configure-ssl[SSL]</p>
</li>
<li>
<p>{spring-boot-docs}/htmlsingle/#how-to-enable-http-response-compression[HTTP压缩]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot尝试尽可能多地公开通用设置，但这并不总是可能的。对于这些情况，
专用名称空间提供特定服务器的自定义项（请参阅 <code>server.tomcat</code> 和 <code>server.undertow</code>）。
例如：可以使用嵌入式servlet容器的特定功能配置 {spring-boot-docs}/htmlsingle/#howto-configure-accesslogs[访问日志]。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关完整列表，请参见 {spring-boot-autoconfigure-module-code}/web/ServerProperties.java[<code>ServerProperties</code>]类。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-programmatic-embedded-container-customization">编程定制</h5>
<div class="paragraph">
<p>如果需要以编程方式配置嵌入式Servlet容器，则可以注册一个实现 <code>WebServerFactoryCustomizer</code> 接口的Spring
Bean。<code>WebServerFactoryCustomizer</code> 提供对 <code>ConfigurableServletWebServerFactory</code>
的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 和 <code>UndertowServletWebServerFactory</code> 是
<code>ConfigurableServletWebServerFactory</code> 的专用变体，分别具有针对Tomcat，Jetty和Undertow的其他自定义设置方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-customizing-configurableservletwebserverfactory-directly">直接自定义ConfigurableServletWebServerFactory</h5>
<div class="paragraph">
<p>如果上述定制技术太有限，则可以自己注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>
或 <code>UndertowServletWebServerFactory</code> bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
    return factory;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供了许多配置选项的设置器。如果你需要做一些更奇特的操作，还提供了几种受保护的方法“<code>hooks</code>”。有关详细信息，请参见
{spring-boot-module-api}/web/servlet/server/ConfigurableServletWebServerFactory.html[源代码文档]。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jsp-limitations">7.4.5. JSP局限性</h4>
<div class="paragraph">
<p>运行使用嵌入式servlet容器（并打包为可执行档案）的Spring Boot应用程序时，JSP支持存在一些限制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Jetty和Tomcat，如果使用war包装，它应该可以工作。
一个可执行的war在使用 <code>java -jar</code> 启动时可以工作，并且可以部署到任何标准容器中。使用可执行jar时不支持JSPs。</p>
</li>
<li>
<p>Undertow不支持JSPs。</p>
</li>
<li>
<p>创建定制的 <code>error.jsp</code> 页面不会覆盖默认视图以进行<a href="#boot-features-error-handling">错误处理</a>。应改用
<a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a>。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-reactive-server">7.5. 响应式嵌入服务器支持</h3>
<div class="paragraph">
<p>Spring Boot包含对以下响应式Web嵌入服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。
大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-reactive-server-resources">7.6. 响应式服务器资源配置</h3>
<div class="paragraph">
<p>当自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，这些bean将向服务器实例提供HTTP资源：
<code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，这些资源还将与Reactor Netty和Jetty客户端共享，以实现最佳性能，前提是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器和客户端使用相同的技术</p>
</li>
<li>
<p>客户端实例是使用Spring Boot自动配置的 <code>WebClient.Builder</code> bean构建的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="#boot-features-webclient-runtime">WebClient Runtime部分</a>中了解有关客户端资源配置的更多信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-rsocket">8. RSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rsocket.io">RSocket</a>是用于字节流传输的二进制协议。它通过在单个连接上传递异步消息来支持对称交互模型。</p>
</div>
<div class="paragraph">
<p>Spring框架的 <code>spring-messaging</code> 模块在客户端和服务器端都支持RSocket请求者和响应者。有关更多详细信息，请参见Spring
Framework参考中的 {spring-framework-docs}web-reactive.html#rsocket-spring[RSocket部分]，其中包括RSocket协议的概述。</p>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-strategies-auto-configuration">8.1. RSocket策略自动配置</h3>
<div class="paragraph">
<p>Spring Boot自动配置一个 <code>RSocketStrategies</code> bean，该bean提供了编码和解码RSocket有效载荷所需的所有基础设施。
默认情况下，自动配置将尝试（按顺序）配置以下内容：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Jackson的 <a href="https://cbor.io/">CBOR</a>编解码器</p>
</li>
<li>
<p>Jackson的JSON编解码器</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-socket</code> 启动器提供了两个依赖项。查阅<a href="#boot-features-json-jackson">Jackson支持部分</a>，
了解更多定制的可能性。</p>
</div>
<div class="paragraph">
<p>开发人员可以通过创建实现 <code>RSocketStrategiesCustomizer</code> 接口的bean来自定义 <code>RSocketStrategies</code> 组件。
请注意，它们的 <code>@Order</code> 很重要，因为它确定编解码器的顺序。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-server-auto-configuration">8.2. RSocket服务器自动配置</h3>
<div class="paragraph">
<p>Spring Boot提供了RSocket服务器自动配置。所需的依赖关系由 <code>spring-boot-starter-rsocket</code> 提供。</p>
</div>
<div class="paragraph">
<p>Spring Boot允许从WebFlux服务器通过WebSocket公开RSocket，或支持独立的RSocket服务器。这取决于应用程序的类型及其配置。</p>
</div>
<div class="paragraph">
<p>对于WebFlux应用程序（即 <code>WebApplicationType.REACTIVE</code> 类型），RSocket服务器只有在下列属性匹配时才会被插入到Web服务器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
spring.rsocket.server.transport=websocket # websocket is chosen as a transport
#spring.rsocket.server.port= # no port is defined</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
只有Reactor Netty才支持将RSocket插入web服务器，因为RSocket本身就是用这个库构建的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外，RSocket TCP或Websocket服务器也可以作为独立的嵌入式服务器启动。除了依赖性要求之外，唯一需要的配置是为该服务器定义端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.port=9898 # the only required configuration
spring.rsocket.server.transport=tcp # you're free to configure other properties</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-messaging">8.3. Spring Messaging RSocket支持</h3>
<div class="paragraph">
<p>Spring Boot将为RSocket自动配置Spring Messaging基础设施。</p>
</div>
<div class="paragraph">
<p>这意味着Spring Boot将创建一个 <code>RSocketMessageHandler</code> bean，该bean将处理对你的应用程序的RSocket请求。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket-requester">8.4. 使用 <code>RSocketRequester</code> 调用RSocket服务</h3>
<div class="paragraph">
<p>在服务器和客户端之间建立RSocket通道后，任何一方都可以向另一方发送或接收请求。</p>
</div>
<div class="paragraph">
<p>作为服务器，你可以在RSocket <code>@Controller</code> 的任何处理程序方法上注入 <code>RSocketRequester</code> 实例。
作为客户端，你需要首先配置和建立RSocket连接。在这种情况下，Spring Boot会使用预期的编解码器自动配置 <code>RSocketRequester.Builder</code>。</p>
</div>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code> 实例是一个原型bean，这意味着每个注入点将为你提供一个新实例。
这样做是有目的的，因为此构建器是有状态的，因此你不应使用同一实例创建具有不同设置的请求者。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RSocketRequester rsocketRequester;

    public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
        this.rsocketRequester = rsocketRequesterBuilder
                .connectTcp("example.org", 9898).block();
    }

    public Mono&lt;User&gt; someRSocketCall(String name) {
        return this.requester.route("user").data(name)
                .retrieveMono(User.class);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-security">9. 安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果 {spring-security}[Spring Security]在类路径上，则默认情况下Web应用程序是安全的。
Spring Boot依靠Spring Security的内容协商策略来确定是使用 <code>httpBasic</code> 还是 <code>formLogin</code>。
要将方法级安全性添加到Web应用程序，还可以使用所需的设置添加 <code>@EnableGlobalMethodSecurity</code>。
可以在 {spring-security-docs}#jc-method[Spring Security参考指南]中找到更多信息。</p>
</div>
<div class="paragraph">
<p>默认的 <code>UserDetailsService</code> 具有单个用户。用户名是 <code>user</code>，密码是随机的，并在应用程序启动时以INFO级别显示，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你微调日志记录配置，请确保将 <code>org.springframework.boot.autoconfigure.security</code> 类别设置为记录 <code>INFO</code>
级别的消息。否则，不会打印默认密码。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以通过提供 <code>spring.security.user.name</code> 和 <code>spring.security.user.password</code> 来更改用户名和密码。</p>
</div>
<div class="paragraph">
<p>默认情况下，你在Web应用程序中获得的基本功能是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个具有内存存储的 <code>UserDetailsService</code>（如果是WebFlux应用程序，则为 <code>ReactiveUserDetailsService</code>）Bean，
一个具有已生成密码的用户（请参阅 {spring-boot-module-api}/autoconfigure/security/SecurityProperties.User.html[<code>SecurityProperties.User</code>]以获取用户属性）。</p>
</li>
<li>
<p>整个应用程序的基于表单的登录或HTTP基本安全性（取决于请求中的 <code>Accept</code> 头部）（包括执行器端点，如果执行器位于类路径上）。</p>
</li>
<li>
<p>用于发布身份验证事件的 <code>DefaultAuthenticationEventPublisher</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以通过为它添加一个bean来提供一个不同的 <code>AuthenticationEventPublisher</code>。</p>
</div>
<div class="sect2">
<h3 id="boot-features-security-mvc">9.1. MVC安全</h3>
<div class="paragraph">
<p>默认的安全配置在 <code>SecurityAutoConfiguration</code> 和 <code>UserDetailsServiceAutoConfiguration</code> 中实现。
<code>SecurityAutoConfiguration</code> 导入用于Web安全的 <code>SpringBootWebSecurityConfiguration</code>，
而 <code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。
要完全关闭默认的Web应用程序安全性配置或合并多个Spring Security组件（例如：OAuth 2客户端和资源服务器），
请添加类型为 <code>WebSecurityConfigurerAdapter</code> 的bean（这样做不会禁用 <code>UserDetailsService</code> 配置或Actuator的安全性）。</p>
</div>
<div class="paragraph">
<p>要关闭 <code>UserDetailsService</code> 配置，你可以添加
<code>UserDetailsService</code>、<code>AuthenticationProvider</code> 或 <code>AuthenticationManager</code> 类型的bean。</p>
</div>
<div class="paragraph">
<p>通过添加自定义 <code>WebSecurityConfigurerAdapter</code> 可以覆盖访问规则。
Spring Boot提供了便捷的方法，可用于覆盖actuator端点和静态资源的访问规则。
<code>EndpointRequest</code> 可用于创建基于 <code>management.endpoints.web.base-path</code> 属性的 <code>RequestMatcher</code>。
可以使用 <code>PathRequest</code> 为常用位置的资源创建一个 <code>RequestMatcher</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-webflux">9.2. WebFlux安全</h3>
<div class="paragraph">
<p>与Spring MVC应用程序类似，你可以通过添加 <code>spring-boot-starter-security</code> 依赖项来保护WebFlux应用程序。
默认的安全配置在 <code>ReactiveSecurityAutoConfiguration</code> 和 <code>UserDetailsServiceAutoConfiguration</code> 中实现。
<code>ReactiveSecurityAutoConfiguration</code> 导入 <code>WebFluxSecurityConfiguration</code> 以获得Web安全，
而 <code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。
要完全关闭默认的Web应用程序安全配置，你可以添加 <code>WebFilterChainProxy</code> 类型的Bean
（这样做不会禁用 <code>UserDetailsService</code> 配置或Actuator的安全性）。</p>
</div>
<div class="paragraph">
<p>要关闭 <code>UserDetailsService</code> 配置，你可以添加类型为 <code>ReactiveUserDetailsService</code> 或 <code>ReactiveAuthenticationManager</code>
的bean。</p>
</div>
<div class="paragraph">
<p>可以通过添加自定义 <code>SecurityWebFilterChain</code> bean来配置访问规则以及使用多个Spring Security组件
（例如：OAuth 2 Client和Resource Server）。Spring Boot提供了便捷的方法，可用于覆盖actuator端点和静态资源的访问规则。
<code>EndpointRequest</code> 可用于创建基于 <code>management.endpoints.web.base-path</code> 属性的 <code>ServerWebExchangeMatcher</code>。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>PathRequest</code> 为常用位置的资源创建 <code>ServerWebExchangeMatcher</code>。</p>
</div>
<div class="paragraph">
<p>例如，你可以通过添加以下内容来自定义安全配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange()
            .matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
            .pathMatchers("/foo", "/bar")
                .authenticated().and()
            .formLogin().and()
        .build();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-oauth2">9.3. OAuth2</h3>
<div class="paragraph">
<p><a href="https://oauth.net/2/">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2-client">9.3.1. 客户端</h4>
<div class="paragraph">
<p>如果你在类路径中具有 <code>spring-security-oauth2-client</code>，则可以利用一些自动配置功能来轻松设置OAuth2/OpenID Connect客户端。
此配置使用 <code>OAuth2ClientProperties</code> 下的属性。相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>你可以在 <code>spring.security.oauth2.client</code> 前缀下注册多个OAuth2客户端和Provider，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client-1.client-id=abcd
spring.security.oauth2.client.registration.my-client-1.client-secret=password
spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-1.scope=user
spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-2.client-id=abcd
spring.security.oauth2.client.registration.my-client-2.client-secret=password
spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-2.scope=email
spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect发现</a>的OpenID
Connect Providers，可以进一步简化配置。
供应商需要配置一个 <code>issuer-uri</code>，该URI是其声明的Issuer标识符。
例如，如果提供的 <code>issuer-uri</code> 是“https://example.com”，则将向“https://example.com/.well-known/openid-configuration”
发出 <code>OpenID Provider Configuration Request</code>。结果应为 <code>OpenID Provider Configuration Response</code>。
以下示例显示了如何使用 <code>issuer-uri</code> 配置OpenID Connect Provider：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Spring Security的 <code>OAuth2LoginAuthenticationFilter</code> 仅处理与 <code>/login/oauth2/code/*</code> 匹配的URL。
如果要自定义 <code>redirect-uri</code> 以使用其他模式，则需要提供配置以处理该自定义模式。
例如，对于servlet应用程序，你可以添加自己的类似于以下内容的 <code>WebSecurityConfigurerAdapter</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .redirectionEndpoint()
                    .baseUri("/custom-callback");
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-common-providers">常见供应商的OAuth2客户端注册</h5>
<div class="paragraph">
<p>对于常见的OAuth2和OpenID供应商，包括Google，Github，Facebook和Okta，我们提供了一组供应商默认值（分别为
<code>google</code>，<code>github</code>，<code>facebook</code> 和 <code>okta</code>）。</p>
</div>
<div class="paragraph">
<p>如果不需要自定义这些供应商，则可以将 <code>provider</code> 属性设置为需要为其推断默认值的属性。
另外，如果用于客户端注册的key与默认支持的供应商匹配，则Spring Boot也会进行推断。</p>
</div>
<div class="paragraph">
<p>换句话说，以下示例中的两个配置都使用Google供应商：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client.client-id=abcd
spring.security.oauth2.client.registration.my-client.client-secret=password
spring.security.oauth2.client.registration.my-client.provider=google

spring.security.oauth2.client.registration.google.client-id=abcd
spring.security.oauth2.client.registration.google.client-secret=password</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2-server">9.3.2. 资源服务器</h4>
<div class="paragraph">
<p>如果你的类路径上有 <code>spring-security-oauth2-resource-server</code>，则Spring Boot可以设置OAuth2资源服务器。
对于JWT配置，需要指定JWK Set URI或OIDC Issuer URI，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果授权服务器不支持JWK Set URI，则可以使用用于验证JWT签名的公钥来配置资源服务器。
可以使用 <code>spring.security.oauth2.resourceserver.jwt.public-key-location</code> 属性来完成此操作，
该属性值需要指向包含PEM-encoded x509格式的公钥的文件。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>另外，你可以为Servlet应用程序定义自己的 <code>JwtDecoder</code> Bean，或者为响应式应用程序定义 <code>ReactiveJwtDecoder</code>。</p>
</div>
<div class="paragraph">
<p>如果使用opaque tokens而不是JWT，则可以配置以下属性以通过自省来验证tokens：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>另外，你可以为Servlet应用程序定义自己的 <code>OpaqueTokenIntrospector</code> Bean，或者为响应式应用程序定义
<code>ReactiveOpaqueTokenIntrospector</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_授权服务器">9.3.3. 授权服务器</h4>
<div class="paragraph">
<p>当前，Spring Security不提供对实现OAuth 2.0授权服务器的支持。但是， {spring-security-oauth2}[Spring Security OAuth]项目提供了此功能，
最终将被Spring Security完全取代。在此之前，你可以使用 <code>spring-security-oauth2-autoconfigure</code>
模块轻松设置OAuth 2.0授权服务器；有关说明，请参见其 <a href="https://docs.spring.io/spring-security-oauth2-boot">文档</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-saml">9.4. SAML 2.0</h3>
<div class="sect3">
<h4 id="boot-features-security-saml2-relying-party">9.4.1. 依赖方</h4>
<div class="paragraph">
<p>如果你在类路径中具有 <code>spring-security-saml2-service-provider</code>，则可以利用一些自动配置功能来轻松设置
SAML 2.0依赖方。此配置使用 <code>Saml2RelyingPartyProperties</code> 下的属性。</p>
</div>
<div class="paragraph">
<p>依赖方注册代表身份供应商IDP和服务供应商SP之间的配对配置。你可以在 <code>spring.security.saml2.relyingparty</code> 前缀下注册多个依赖方，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security-actuator">9.5. Actuator安全</h3>
<div class="paragraph">
<p>为了安全起见，默认情况下禁用 <code>/health</code> 和 <code>/info</code> 以外的所有actuators。
<code>management.endpoints.web.exposure.include</code> 属性可用于启用actuators。</p>
</div>
<div class="paragraph">
<p>如果Spring Security位于类路径上，并且不存在其他 <code>WebSecurityConfigurerAdapter</code>，
则除 <code>/health</code> 和 <code>/info</code> 以外的所有actuators均由Spring Boot自动配置保护。
如果定义自定义 <code>WebSecurityConfigurerAdapter</code>，则Spring Boot自动配置将退出，你将完全控制actuator访问规则。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在设置 <code>management.endpoints.web.exposure.include</code> 之前，请确保暴露的actuators不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如
Spring Security之类的方法进行保护。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-security-csrf">9.5.1. 跨站请求伪造保护</h4>
<div class="paragraph">
<p>由于Spring Boot依赖于Spring Security的默认设置，因此CSRF保护默认情况下处于启用状态。
这意味着在使用默认安全配置时，需要POST（shutdown和loggers端点），PUT或DELETE的actuator端点将收到403 forbidden错误。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们建议仅在创建非浏览器客户端使用的服务时完全禁用CSRF保护。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>关于CSRF保护的其他信息可以在 {spring-security-docs}#csrf[Spring Security参考指南]中找到。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-sql">10. 使用SQL数据库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{spring-framework}[Spring Framework]为使用SQL数据库提供了广泛的支持，从使用 <code>JdbcTemplate</code> 的直接JDBC
访问到完整的“<code>对象关系映射</code>”技术（例如：Hibernate）。
{spring-data}[Spring Data]提供了更高级别的功能：直接从接口创建 <code>Repository</code> 实现，并使用约定从你的方法名称生成查询。</p>
</div>
<div class="sect2">
<h3 id="boot-features-configure-datasource">10.1. 配置DataSource</h3>
<div class="paragraph">
<p>Java的 <code>javax.sql.DataSource</code> 接口提供了使用数据库连接的标准方法。传统上，“DataSource”使用 <code>URL</code> 和一些凭据来建立数据库连接。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多高级示例，请参见 {spring-boot-docs}/htmlsingle/#howto-configure-a-datasource["How-to"部分]，通常可以完全控制DataSource的配置。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-database-support">10.1.1. 嵌入式数据库支持</h4>
<div class="paragraph">
<p>使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。你需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
"How-to"部分包括有关 {spring-boot-docs}/htmlsingle/#howto-database-initialization[如何初始化数据库的部分]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot可以自动配置嵌入式 <a href="https://www.h2database.com">H2</a>， <a href="http://hsqldb.org/">HSQL</a>和
<a href="https://db.apache.org/derby/">Derby</a>数据库。你无需提供任何连接URL。你只需要包含要使用的嵌入式数据库的构建依赖项即可。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你在测试中使用此功能，则可能会注意到，整个测试套件将重复使用同一数据库，而不管你使用的应用程序上下文有多少。
如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 <code>spring.datasource.generate-unique-name</code> 设置为true。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，典型的POM依赖关系如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你需要依赖 <code>spring-jdbc</code> 来自动配置嵌入式数据库。在此示例中，它通过 <code>spring-boot-starter-data-jpa</code> 传递性地传入。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果出于某种原因确实为嵌入式数据库配置了连接URL，请务必确保禁用了数据库的自动关闭功能。
如果使用H2，则应使用 <code>DB_CLOSE_ON_EXIT=FALSE</code> 进行操作。如果使用HSQLDB，则应确保未使用 <code>shutdown=true</code>。
通过禁用数据库的自动关闭功能，Spring Boot可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以进行自动关闭。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connect-to-production-database">10.1.2. 连接到生产数据库</h4>
<div class="paragraph">
<p>生产数据库连接也可以通过使用池化 <code>DataSource</code> 来自动配置。Spring Boot使用以下算法来选择特定的实现：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>我们更喜欢 <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>的性能和并发性。如果有HikariCP，我们总是选择它。</p>
</li>
<li>
<p>反之，如果Tomcat池化 <code>DataSource</code> 可用，我们将使用它。</p>
</li>
<li>
<p>HikariCP和Tomcat池数据源均不可用，如果 <a href="https://commons.apache.org/proper/commons-dbcp/">Commons DBCP2</a>可用，我们将使用它。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果你使用 <code>spring-boot-starter-jdbc</code> 或 <code>spring-boot-starter-data-jpa</code> “<code>starters</code>”，则会自动获得对
<code>HikariCP</code> 的依赖。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你可以通过设置 <code>spring.datasource.type</code> 属性来完全绕过该算法，并指定要使用的连接池。
如果你在Tomcat容器中运行应用程序，这一点尤其重要，因为默认情况下提供了 <code>tomcat-jdbc</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
其他连接池始终可以手动配置。如果定义自己的 <code>DataSource</code> bean，则不会进行自动配置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>DataSource配置由 <code>spring.datasource.*</code> 中的外部配置属性控制。例如：你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你至少应通过设置 <code>spring.datasource.url</code> 属性来指定URL。否则，Spring Boot会尝试自动配置嵌入式数据库。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你通常不需要指定 <code>driver-class-name</code> 名称，因为Spring Boot可以根据 <code>url</code> 从大多数数据库推断出它。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于要创建池化 <code>DataSource</code>，我们需要能够验证有效的 <code>Driver</code> 类是否可用，因此我们在进行任何操作之前都要进行检查。
换句话说，如果设置 <code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，则该类必须是可加载的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/jdbc/DataSourceProperties.java[<code>DataSourceProperties</code>]。
这些是不管实际实现如何都会起作用的标准选项。也可以使用它们各自的前缀（
<code>spring.datasource.hikari.*</code>, <code>spring.datasource.tomcat.*</code> 和 <code>spring.datasource.dbcp2.*</code>）
微调实现特定的设置。有关更多详细信息，请参阅所用连接池实现的文档。</p>
</div>
<div class="paragraph">
<p>例如，如果使用 {tomcat-docs}/jdbc-pool.html#Common_Attributes[Tomcat连接池]，则可以自定义许多其他设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-a-jndi-datasource">10.1.3. 连接到JNDI数据源</h4>
<div class="paragraph">
<p>如果你将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能来配置和管理DataSource，并使用JNDI对其进行访问。</p>
</div>
<div class="paragraph">
<p><code>spring.datasource.jndi-name</code> 属性可以用作 <code>spring.datasource.url</code>，<code>spring.datasource.username</code> 和
<code>spring.datasource.password</code> 属性的替代方案，以从特定的JNDI位置访问 <code>DataSource</code>。
例如：<code>application.properties</code> 中的以下部分显示了如何访问JBoss AS定义的 <code>DataSource</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.jndi-name=java:jboss/datasources/customers</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-using-jdbc-template">10.2. 使用JdbcTemplate</h3>
<div class="paragraph">
<p>Spring的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的，你可以将它们直接 <code>@Autowire</code>
到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public MyBean(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>spring.jdbc.template.*</code> 属性来自定义模板的某些属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jdbc.template.max-rows=500</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NamedParameterJdbcTemplate</code> 在幕后重用相同的 <code>JdbcTemplate</code> 实例。如果定义了多个 <code>JdbcTemplate</code>
并且不存在主要候选对象，则不会自动配置 <code>NamedParameterJdbcTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jpa-and-spring-data">10.3. JPA和Spring Data JPA</h3>
<div class="paragraph">
<p>Java Persistence API是一种标准技术，可让你将对象“映射”到关系数据库。
<code>spring-boot-starter-data-jpa</code> POM提供了一种快速入门的方法。它提供以下关键依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hibernate: 最受欢迎的JPA实现之一。</p>
</li>
<li>
<p>Spring Data JPA: 使基于JPA的存储库的实现变得容易。</p>
</li>
<li>
<p>Spring ORMs: Spring框架对ORM的核心支持。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在这里，我们不会过多讨论JPA或 {spring-data}[Spring Data]。
你可以按照 <a href="https://spring.io" class="bare">https://spring.io</a> 的 <a href="https://spring.io/guides/gs/accessing-data-jpa/">“使用JPA访问数据”</a>指南进行操作，
并阅读 {spring-data-jpa}[Spring Data JPA]和 <a href="https://hibernate.org/orm/documentation/">Hibernate</a>参考文档。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-entity-classes">10.3.1. 实体类</h4>
<div class="paragraph">
<p>传统上，JPA“<code>Entity</code>”类在 <code>persistence.xml</code> 文件中指定。在Spring Boot中，此文件不是必需的，而是使用“实体扫描”。
默认情况下，将搜索主配置类（用 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的一个）下的所有软件包。</p>
</div>
<div class="paragraph">
<p>考虑任何带有 <code>@Entity</code>，<code>@Embeddable</code> 或 <code>@MappedSuperclass</code> 注解的类。典型的实体类类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.io.Serializable;
import javax.persistence.*;

@Entity
public class City implements Serializable {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String state;

    // ... additional members, often include @OneToMany mappings

    protected City() {
        // no-args constructor required by JPA spec
        // this one is protected since it shouldn't be used directly
    }

    public City(String name, String state) {
        this.name = name;
        this.state = state;
    }

    public String getName() {
        return this.name;
    }

    public String getState() {
        return this.state;
    }

    // ... etc

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以使用 <code>@EntityScan</code> 注解来自定义实体扫描位置。请参见
{spring-boot-docs}/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration[“从Spring配置中分离@Entity定义”]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-jpa-repositories">10.3.2. Spring Data JPA存储库</h4>
<div class="paragraph">
<p>{spring-data-jpa}[Spring Data JPA]存储库是可以定义以访问数据的接口。JPA查询是根据你的方法名称自动创建的。
例如：<code>CityRepository</code> 接口可能声明了 <code>findAllByState(String state)</code> 方法来查找给定状态下的所有城市。</p>
</div>
<div class="paragraph">
<p>对于更复杂的查询，你可以使用Spring Data的 {spring-data-jpa-api}/repository/Query.html[<code>Query</code>]注解对方法进行注释。</p>
</div>
<div class="paragraph">
<p>Spring Data存储库通常从 {spring-data-commons-api}/repository/Repository.html[<code>Repository</code>]或
{spring-data-commons-api}/repository/CrudRepository.html[<code>CrudRepository</code>]接口继承。
如果使用自动配置，则会从包含主配置类（以 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的主配置类）的包中搜索存储库。</p>
</div>
<div class="paragraph">
<p>以下示例显示了典型的Spring Data存储库接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Data JPA存储库支持三种不同的引导模式：default, deferred 和 lazy。
要启用deferred引导或lazy引导，请将 <code>spring.data.jpa.repositories.bootstrap-mode</code> 属性分别设置为 <code>deferred</code> 或 <code>lazy</code>。
使用deferred或lazy启动时，自动配置的 <code>EntityManagerFactoryBuilder</code> 将使用上下文的 <code>AsyncTaskExecutor</code>（如果有）作为引导执行器。
如果存在多个，则将使用一个名为 <code>applicationTaskExecutor</code> 的执行器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们仅仅触及了Spring Data JPA的皮毛。有关完整的详细信息，请参阅 {spring-data-jdbc-docs}[Spring Data JPA参考文档]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-creating-and-dropping-jpa-databases">10.3.3. 创建和删除JPA数据库</h4>
<div class="paragraph">
<p>默认情况下，<strong>仅</strong> 当你使用嵌入式数据库（H2，HSQL或Derby）时，才会自动创建JPA数据库。
你可以使用 <code>spring.jpa.*</code> 属性显式配置JPA设置。
例如：要创建和删除表，可以将以下行添加到 <code>application.properties</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.ddl-auto=create-drop</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为此，Hibernate自己的内部属性名称是 <code>hibernate.hbm2ddl.auto</code>。
你可以使用 <code>spring.jpa.properties.*</code>（将它们添加到实体管理器时，会先剔除前缀）来设置它以及其他Hibernate本地属性。
下面的行显示了为Hibernate设置JPA属性的示例：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.properties.hibernate.globally_quoted_identifiers=true</pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的行将 <code>hibernate.globally_quoted_identifiers</code> 属性值设置为 <code>true</code> 传递给Hibernate实体管理器。</p>
</div>
<div class="paragraph">
<p>默认情况下，DDL执行（或验证）推迟到 <code>ApplicationContext</code> 启动之后。还有一个 <code>spring.jpa.generate-ddl</code> 标志，
但是如果Hibernate自动配置处于活动状态，则不会使用它，因为 <code>ddl-auto</code> 设置粒度更细。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jpa-in-web-environment">10.3.4. 在视图中打开EntityManager</h4>
<div class="paragraph">
<p>如果你正在运行Web应用程序，则Spring Boot默认情况下会注册
{spring-framework-api}/orm/jpa/support/OpenEntityManagerInViewInterceptor.html[<code>OpenEntityManagerInViewInterceptor</code>]
以应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。
如果你不希望出现这种情况，则应在 <code>application.properties</code> 中将 <code>spring.jpa.open-in-view</code> 设置为 <code>false</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-data-jdbc">10.4. Spring Data JDBC</h3>
<div class="paragraph">
<p>Spring Data包括对JDBC的存储库支持，并将为 <code>CrudRepository</code> 上的方法自动生成SQL。对于更高级的查询，提供了 <code>@Query</code> 注解。</p>
</div>
<div class="paragraph">
<p>当必要的依赖项位于类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。
可以将它们添加到你的项目中，而只需依赖 <code>spring-boot-starter-data-jdbc</code>。
如有必要，你可以通过在应用程序中添加 <code>@EnableJdbcRepositories</code> 注解或
<code>JdbcConfiguration</code> 子类来控制Spring Data JDBC的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data JDBC的完整详细信息，请参考 {spring-data-jdbc-docs}[参考文档]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-sql-h2-console">10.5. 使用H2的Web控制台</h3>
<div class="paragraph">
<p><a href="https://www.h2database.com">H2数据库</a>提供了一个 <a href="https://www.h2database.com/html/quickstart.html#h2_console">基于浏览器</a>的控制台，
Spring Boot可以为你自动配置该控制台。满足以下条件时，将自动配置控制台：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你正在开发基于servlet的Web应用程序。</p>
</li>
<li>
<p><code>com.h2database:h2</code> 在类路径上。</p>
</li>
<li>
<p>你正在使用 <a href="using-spring-boot.html#using-boot-devtools">Spring Boot的开发者工具</a>。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你未使用Spring Boot的开发者工具，但仍想使用H2的控制台，则可以将 <code>spring.h2.console.enabled</code> 属性配置为 <code>true</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
H2控制台仅在开发期间使用，因此应注意确保在生产中未将 <code>spring.h2.console.enabled</code> 设置为 <code>true</code>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-sql-h2-console-custom-path">10.5.1. 更改H2控制台的路径</h4>
<div class="paragraph">
<p>默认情况下，该控制台在 <code>/h2-console</code> 端点可用。你可以使用 <code>spring.h2.console.path</code> 属性来自定义控制台的路径。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jooq">10.6. 使用jOOQ</h3>
<div class="paragraph">
<p>jOOQ Object Oriented Querying (<a href="https://www.jooq.org/">jOOQ</a>)是 <a href="https://www.datageekery.com/">Data Geekery</a>
的一种流行产品，它可以从数据库中生成Java代码，并允许你通过其流式API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p>
</div>
<div class="sect3">
<h4 id="_代码生成">10.6.1. 代码生成</h4>
<div class="paragraph">
<p>为了使用jOOQ类型安全查询，你需要从数据库schema中生成Java类。你可以按照 {jooq-docs}/#jooq-in-7-steps-step3[jOOQ用户手册]中的说明进行操作。
如果你使用 <code>jooq-codegen-maven</code> 插件，并且还使用 <code>spring-boot-starter-parent</code> “父POM”，
则可以安全地忽略该插件的 <code>&lt;version&gt;</code> 标签。你还可以使用Spring Boot定义的版本变量（例如：<code>h2.version</code>）
来声明插件的数据库依赖关系。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.jooq&lt;/groupId&gt;
    &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;
    &lt;executions&gt;
        ...
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;${h2.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;configuration&gt;
        &lt;jdbc&gt;
            &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
            &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;
        &lt;/jdbc&gt;
        &lt;generator&gt;
            ...
        &lt;/generator&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用dslcontext">10.6.2. 使用DSLContext</h4>
<div class="paragraph">
<p>jOOQ提供的流式API是通过 <code>org.jooq.DSLContext</code> 接口启动的。
Spring Boot将 <code>DSLContext</code> 自动配置为Spring Bean，并将其连接到你的应用程序 <code>DataSource</code>。
要使用 <code>DSLContext</code>，可以使用 <code>@Autowire</code>，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JooqExample implements CommandLineRunner {

    private final DSLContext create;

    @Autowired
    public JooqExample(DSLContext dslContext) {
        this.create = dslContext;
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
jOOQ手册倾向于使用名为 <code>create</code> 的变量来保存 <code>DSLContext</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，可以使用 <code>DSLContext</code> 构造查询，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public List&lt;GregorianCalendar&gt; authorsBornAfter1980() {
    return this.create.selectFrom(AUTHOR)
        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
        .fetch(AUTHOR.DATE_OF_BIRTH);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jooq_sql方言">10.6.3. jOOQ SQL方言</h4>
<div class="paragraph">
<p>除非已配置 <code>spring.jooq.sql-dialect</code> 属性，否则Spring Boot会确定要用于数据源的SQL方言。如果Spring Boot无法检测到方言，则使用 <code>DEFAULT</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot只能自动配置开源版本的jOOQ支持的方言。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_自定义jooq">10.6.4. 自定义jOOQ</h4>
<div class="paragraph">
<p>可以通过定义自己的 <code>@Bean</code> 定义来实现更高级的自定义，这在创建jOOQ <code>Configuration</code> 时将使用。你可以为以下jOOQ类型定义bean：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConnectionProvider</code></p>
</li>
<li>
<p><code>ExecutorProvider</code></p>
</li>
<li>
<p><code>TransactionProvider</code></p>
</li>
<li>
<p><code>RecordMapperProvider</code></p>
</li>
<li>
<p><code>RecordUnmapperProvider</code></p>
</li>
<li>
<p><code>Settings</code></p>
</li>
<li>
<p><code>RecordListenerProvider</code></p>
</li>
<li>
<p><code>ExecuteListenerProvider</code></p>
</li>
<li>
<p><code>VisitListenerProvider</code></p>
</li>
<li>
<p><code>TransactionListenerProvider</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果要完全控制jOOQ配置，也可以创建自己的 <code>org.jooq.Configuration</code> <code>@Bean</code>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-nosql">11. 使用NoSQL技术</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data提供了其他项目来帮助你访问各种NoSQL技术，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{spring-data-mongodb}[MongoDB]</p>
</li>
<li>
<p>{spring-data-neo4j}[Neo4J]</p>
</li>
<li>
<p>{spring-data-elasticsearch}[Elasticsearch]</p>
</li>
<li>
<p>{spring-data-solr}[Solr]</p>
</li>
<li>
<p>{spring-data-redis}[Redis]</p>
</li>
<li>
<p>{spring-data-gemfire}[GemFire] or {spring-data-geode}[Geode]</p>
</li>
<li>
<p>{spring-data-cassandra}[Cassandra]</p>
</li>
<li>
<p>{spring-data-couchbase}[Couchbase]</p>
</li>
<li>
<p>{spring-data-ldap}[LDAP]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。
你可以使用其他项目，但必须自己进行配置。请参阅 {spring-data} 中的相应参考文档。</p>
</div>
<div class="sect2">
<h3 id="boot-features-redis">11.1. Redis</h3>
<div class="paragraph">
<p><a href="https://redis.io/">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。
Spring Boot为 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>和 <a href="https://github.com/xetorthio/jedis/">Jedis</a>
客户端库以及Spring Data Redis提供的基于它们的抽象提供了基本的自动配置。</p>
</div>
<div class="paragraph">
<p>有一个 <code>spring-boot-starter-data-redis</code> “<code>Starter</code>”便于收集依赖项。默认情况下，它使用 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。
该启动器可以处理传统应用程序和响应式应用程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们还提供了一个 <code>spring-boot-starter-data-redis-reactive</code> “<code>Starter</code>”，以与具有响应式支持的其他存储保持一致。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-redis">11.1.1. 连接到Redis</h4>
<div class="paragraph">
<p>你可以像注入其他任何Spring Bean一样注入自动配置的 <code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code> 或vanilla
<code>RedisTemplate</code> 实例。默认情况下，该实例尝试连接到位于 <code>localhost:6379</code> 的Redis服务器。
下面的清单显示了这种Bean的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private StringRedisTemplate template;

    @Autowired
    public MyBean(StringRedisTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以注册任意数量的Bean，这些Bean实现 <code>LettuceClientConfigurationBuilderCustomizer</code> 以获得更高级的自定义。
如果使用Jedis，则可以使用 <code>JedisClientConfigurationBuilderCustomizer</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果添加自己的任何自动配置类型的 <code>@Bean</code>，它将替换默认值
（<code>RedisTemplate</code> 除外，除非排除是基于bean名称 <code>redisTemplate</code> 而不是其类型时）。
默认情况下，如果 <code>commons-pool2</code> 在类路径上，则会得到一个池化的连接工厂。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-mongodb">11.2. MongoDB</h3>
<div class="paragraph">
<p><a href="https://www.mongodb.com/">MongoDB</a>是一个开源NoSQL文档数据库，它使用类似JSON的结构而不是传统的基于表的关系数据。
Spring Boot为MongoDB的使用提供了许多便利，包括 <code>spring-boot-starter-data-mongodb</code> 和
<code>spring-boot-starter-data-mongodb-reactive</code> “<code>Starters</code>”。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-mongodb">11.2.1. 连接到MongoDB数据库</h4>
<div class="paragraph">
<p>要访问Mongo数据库，可以注入自动配置的 <code>org.springframework.data.mongodb.MongoDbFactory</code>。
默认情况下，该实例尝试通过 <code>mongodb://localhost/test</code> 连接到MongoDB服务器。
以下示例显示了如何连接到MongoDB数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.data.mongodb.MongoDbFactory;
import com.mongodb.DB;

@Component
public class MyBean {

    private final MongoDbFactory mongo;

    @Autowired
    public MyBean(MongoDbFactory mongo) {
        this.mongo = mongo;
    }

    // ...

    public void example() {
        DB db = mongo.getDb();
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以设置 <code>spring.data.mongodb.uri</code> 属性来更改URL并配置其他设置，例如 <em>副本集</em>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，只要你使用Mongo 2.x，就可以指定 <code>host</code>/<code>port</code>。例如：你可以在 <code>application.properties</code> 中声明以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你定义了自己的 <code>MongoClient</code>，它将用于自动配置合适的 <code>MongoDbFactory</code>。<code>com.mongodb.MongoClient</code> 和
<code>com.mongodb.client.MongoClient</code> 均受支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用Mongo 3.0 Java驱动程序，则不支持 <code>spring.data.mongodb.host</code> 和 <code>spring.data.mongodb.port</code>。
在这种情况下，应使用 <code>spring.data.mongodb.uri</code> 提供所有配置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果未指定 <code>spring.data.mongodb.port</code>，则使用默认值 <code>27017</code>。你可以从前面显示的示例中删除此行。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不使用Spring Data Mongo，则可以注入 <code>com.mongodb.MongoClient</code> bean，而不是使用 <code>MongoDbFactory</code>。
如果你想完全控制建立MongoDB连接的方式，还可以声明自己的 <code>MongoDbFactory</code> 或 <code>MongoClient</code> bean。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用响应式驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置会自动配置该工厂。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongo-template">11.2.2. MongoTemplate</h4>
<div class="paragraph">
<p>{spring-data-mongodb}[Spring Data MongoDB]提供了一个 {spring-data-mongodb-api}/core/MongoTemplate.html[<code>MongoTemplate</code>]类，
该类的设计与Spring的 <code>JdbcTemplate</code> 非常相似。与 <code>JdbcTemplate</code> 一样，Spring Boot为你自动配置一个Bean来注入模板，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final MongoTemplate mongoTemplate;

    @Autowired
    public MyBean(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参见 {spring-data-mongodb-api}/core/MongoOperations.html[<code>MongoOperations</code> Javadoc]。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-mongodb-repositories">11.2.3. Spring Data MongoDB存储库</h4>
<div class="paragraph">
<p>Spring Data包括对MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动构造查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础设施。你可以从以前的JPA示例开始，并假设 <code>City</code> 现在是Mongo数据类，而不是JPA
<code>@Entity</code>，它的工作方式相同，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以使用 <code>@EntityScan</code> 注解来自定义文档扫描位置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其 {spring-data-mongodb}[参考文档]。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongo-embedded">11.2.4. 嵌入式Mongo</h4>
<div class="paragraph">
<p>Spring Boot为 <a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo">Embedded Mongo</a>提供自动配置。
要在Spring Boot应用程序中使用它，请添加对 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code> 的依赖。</p>
</div>
<div class="paragraph">
<p>可以通过设置 <code>spring.data.mongodb.port</code> 属性来配置Mongo监听的端口。要使用随机分配的空闲端口，请使用0值。
<code>MongoAutoConfiguration</code> 创建的 <code>MongoClient</code> 将自动配置为使用随机分配的端口。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果未配置自定义端口，则默认情况下，嵌入式支持会使用随机端口（而不是27017）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果类路径上有SLF4J，则Mongo产生的输出将自动路由到名为 <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code> 的记录器。</p>
</div>
<div class="paragraph">
<p>你可以声明自己的 <code>IMongodConfig</code> 和 <code>IRuntimeConfig</code> bean，以控制Mongo实例的配置和日志记录路由。
可以通过声明 <code>DownloadConfigBuilderCustomizer</code> bean来定制下载配置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-neo4j">11.3. Neo4j</h3>
<div class="paragraph">
<p><a href="https://neo4j.com/">Neo4j</a> is an open-source NoSQL graph database that uses a rich data model of nodes connected by first class relationships, which is better suited for connected big data than traditional RDBMS approaches.
Spring Boot offers several conveniences for working with Neo4j, including the <code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221;.</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-neo4j">11.3.1. Connecting to a Neo4j Database</h4>
<div class="paragraph">
<p>To access a Neo4j server, you can inject an auto-configured <code>org.neo4j.ogm.session.Session</code>.
By default, the instance tries to connect to a Neo4j server at <code>localhost:7687</code> using the Bolt protocol.
The following example shows how to inject a Neo4j <code>Session</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final Session session;

    @Autowired
    public MyBean(Session session) {
        this.session = session;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can configure the uri and credentials to use by setting the <code>spring.data.neo4j.*</code> properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.uri=bolt://my-server:7687
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can take full control over the session creation by adding either an <code>org.neo4j.ogm.config.Configuration</code> bean or an <code>org.neo4j.ogm.session.SessionFactory</code> bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-neo4j-embedded">11.3.2. Using the Embedded Mode</h4>
<div class="paragraph">
<p>If you add <code>org.neo4j:neo4j-ogm-embedded-driver</code> to the dependencies of your application, Spring Boot automatically configures an in-process embedded instance of Neo4j that does not persist any data when your application shuts down.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the embedded Neo4j OGM  driver  does not provide the Neo4j kernel itself, you have to declare <code>org.neo4j:neo4j</code> as dependency yourself.
Refer to <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started">the Neo4j OGM documentation</a> for a list of compatible versions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The embedded driver takes precedence over the other drivers when there are multiple drivers on the classpath.
You can explicitly disable the embedded mode by setting <code>spring.data.neo4j.embedded.enabled=false</code>.</p>
</div>
<div class="paragraph">
<p><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test">Data Neo4j Tests</a> automatically make use of an embedded Neo4j instance if the embedded driver and Neo4j kernel are on the classpath as described above.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can enable persistence for the embedded mode by providing a path to a database file in your configuration, e.g. <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j-ogm-native-types">11.3.3. Using Native Types</h4>
<div class="paragraph">
<p>Neo4j-OGM can map some types, like those in <code>java.time.*</code>, to <code>String</code>-based properties or to one of the native types that Neo4j provides.
For backwards compatibility reasons the default for Neo4j-OGM is to use a <code>String</code>-based representation.
To use native types, add a dependency on either <code>org.neo4j:neo4j-ogm-bolt-native-types</code> or <code>org
.neo4j:neo4j-ogm-embedded-native-types</code>, and configure the <code>spring.data.neo4j.use-native-types</code>
property as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.use-native-types=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j-ogm-session">11.3.4. Neo4jSession</h4>
<div class="paragraph">
<p>By default, if you are running a web application, the session is bound to the thread for the entire processing of the request (that is, it uses the "Open Session in View" pattern).
If you do not want this behavior, add the following line to your <code>application.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.open-in-view=false</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-neo4j-repositories">11.3.5. Spring Data Neo4j Repositories</h4>
<div class="paragraph">
<p>Spring Data includes repository support for Neo4j.</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j shares the common infrastructure with Spring Data JPA as many other Spring Data modules do.
You could take the JPA example from earlier and define <code>City</code> as Neo4j OGM <code>@NodeEntity</code> rather than JPA <code>@Entity</code> and the repository abstraction works in the same way, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.util.Optional;

import org.springframework.data.neo4j.repository.*;

public interface CityRepository extends Neo4jRepository&lt;City, Long&gt; {

    Optional&lt;City&gt; findOneByNameAndState(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221; enables the repository support as well as transaction management.
You can customize the locations to look for repositories and entities by using <code>@EnableNeo4jRepositories</code> and <code>@EntityScan</code> respectively on a <code>@Configuration</code>-bean.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Neo4j, including its object mapping technologies, refer to the {spring-data-neo4j-docs}[reference documentation].
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-solr">11.4. Solr</h3>
<div class="paragraph">
<p><a href="https://lucene.apache.org/solr/">Apache Solr</a> is a search engine.
Spring Boot offers basic auto-configuration for the Solr 5 client library and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-solr">Spring Data Solr</a>.
There is a <code>spring-boot-starter-data-solr</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-solr">11.4.1. Connecting to Solr</h4>
<div class="paragraph">
<p>You can inject an auto-configured <code>SolrClient</code> instance as you would any other Spring bean.
By default, the instance tries to connect to a server at <code><a href="http://localhost:8983/solr" class="bare">http://localhost:8983/solr</a></code>.
The following example shows how to inject a Solr bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private SolrClient solr;

    @Autowired
    public MyBean(SolrClient solr) {
        this.solr = solr;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you add your own <code>@Bean</code> of type <code>SolrClient</code>, it replaces the default.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-solr-repositories">11.4.2. Spring Data Solr Repositories</h4>
<div class="paragraph">
<p>Spring Data includes repository support for Apache Solr.
As with the JPA repositories discussed earlier, the basic principle is that queries are automatically constructed for you based on method names.</p>
</div>
<div class="paragraph">
<p>In fact, both Spring Data JPA and Spring Data Solr share the same common infrastructure.
You could take the JPA example from earlier and, assuming that <code>City</code> is now a <code>@SolrDocument</code> class rather than a JPA <code>@Entity</code>, it works in the same way.</p>
</div>
<div class="paragraph">
<p>IP: For complete details of Spring Data Solr, refer to the {spring-data-solr-docs}[reference documentation].</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-elasticsearch">11.5. Elasticsearch</h3>
<div class="paragraph">
<p><a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> is an open source, distributed, RESTful search and analytics engine.
Spring Boot offers basic auto-configuration for Elasticsearch.</p>
</div>
<div class="paragraph">
<p>Spring Boot supports several clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The official Java "Low Level" and "High Level" REST clients</p>
</li>
<li>
<p>The <code>ReactiveElasticsearchClient</code> provided by Spring Data Elasticsearch</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The transport client is still available but its support has been deprecated in <a href="https://github.com/spring-projects/spring-data-elasticsearch">Spring Data Elasticsearch</a> and Elasticsearch itself.
It will be removed in a future release.
Spring Boot provides a dedicated &#8220;Starter&#8221;, <code>spring-boot-starter-data-elasticsearch</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/searchbox-io/Jest">Jest</a> client has been deprecated as well, since both Elasticsearch and Spring Data Elasticsearch provide official support for REST clients.</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-rest">11.5.1. Connecting to Elasticsearch using REST clients</h4>
<div class="paragraph">
<p>Elasticsearch ships <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">two different REST clients</a> that you can use to query a cluster: the "Low Level" client and the "High Level" client.</p>
</div>
<div class="paragraph">
<p>If you have the <code>org.elasticsearch.client:elasticsearch-rest-client</code> dependency on the classpath, Spring Boot will auto-configure and register a <code>RestClient</code> bean that by default targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how <code>RestClient</code> is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.rest.uris=https://search.example.com:9200
spring.elasticsearch.rest.read-timeout=10s
spring.elasticsearch.rest.username=user
spring.elasticsearch.rest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>RestClientBuilderCustomizer</code> for more advanced customizations.
To take full control over the registration, define a <code>RestClient</code> bean.</p>
</div>
<div class="paragraph">
<p>If you have the <code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code> dependency on the classpath, Spring Boot will auto-configure a <code>RestHighLevelClient</code>, which wraps any existing <code>RestClient</code> bean, reusing its HTTP configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-reactive-rest">11.5.2. Connecting to Elasticsearch using Reactive REST clients</h4>
<div class="paragraph">
<p>{spring-data-elasticsearch}[Spring Data Elasticsearch] ships <code>ReactiveElasticsearchClient</code> for querying Elasticsearch instances in a reactive fashion.
It is built on top of WebFlux&#8217;s <code>WebClient</code>, so both <code>spring-boot-starter-elasticsearch</code> and <code>spring-boot-starter-webflux</code> dependencies are useful to enable this support.</p>
</div>
<div class="paragraph">
<p>By default, Spring Boot will auto-configure and register a <code>ReactiveElasticsearchClient</code>
bean that targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how it is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
spring.data.elasticsearch.client.reactive.use-ssl=true
spring.data.elasticsearch.client.reactive.socket-timeout=10s
spring.data.elasticsearch.client.reactive.username=user
spring.data.elasticsearch.client.reactive.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the configuration properties are not enough and you&#8217;d like to fully control the client
configuration, you can register a custom <code>ClientConfiguration</code> bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-jest">11.5.3. Connecting to Elasticsearch using Jest</h4>
<div class="paragraph">
<p>Now that Spring Boot supports the official <code>RestHighLevelClient</code>, Jest support is deprecated.</p>
</div>
<div class="paragraph">
<p>If you have <code>Jest</code> on the classpath, you can inject an auto-configured <code>JestClient</code> that by default targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how the client is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.jest.uris=https://search.example.com:9200
spring.elasticsearch.jest.read-timeout=10000
spring.elasticsearch.jest.username=user
spring.elasticsearch.jest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>HttpClientConfigBuilderCustomizer</code> for more advanced customizations.
The following example tunes additional HTTP settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {

    @Override
    public void customize(HttpClientConfig.Builder builder) {
        builder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To take full control over the registration, define a <code>JestClient</code> bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-elasticsearch-spring-data">11.5.4. Connecting to Elasticsearch by Using Spring Data</h4>
<div class="paragraph">
<p>To connect to Elasticsearch, a <code>RestHighLevelClient</code> bean must be defined,
auto-configured by Spring Boot or manually provided by the application (see previous sections).
With this configuration in place, an
<code>ElasticsearchRestTemplate</code> can be injected like any other Spring bean,
as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final ElasticsearchRestTemplate template;

    public MyBean(ElasticsearchRestTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the presence of <code>spring-data-elasticsearch</code> and the required dependencies for using a <code>WebClient</code> (typically <code>spring-boot-starter-webflux</code>), Spring Boot can also auto-configure a <a href="#boot-features-connecting-to-elasticsearch-reactive-rest">ReactiveElasticsearchClient</a> and a <code>ReactiveElasticsearchTemplate</code> as beans.
They are the reactive equivalent of the other REST clients.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-elasticsearch-repositories">11.5.5. Spring Data Elasticsearch Repositories</h4>
<div class="paragraph">
<p>Spring Data includes repository support for Elasticsearch.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed for you automatically based on method names.</p>
</div>
<div class="paragraph">
<p>In fact, both Spring Data JPA and Spring Data Elasticsearch share the same common infrastructure.
You could take the JPA example from earlier and, assuming that <code>City</code> is now an Elasticsearch <code>@Document</code> class rather than a JPA <code>@Entity</code>, it works in the same way.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Elasticsearch, refer to the {spring-data-elasticsearch-docs}[reference documentation].
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot supports both classic and reactive Elasticsearch repositories, using the <code>ElasticsearchRestTemplate</code> or <code>ReactiveElasticsearchTemplate</code> beans.
Most likely those beans are auto-configured by Spring Boot given the required dependencies are present.</p>
</div>
<div class="paragraph">
<p>If you wish to use your own template for backing the Elasticsearch repositories, you can add your own <code>ElasticsearchRestTemplate</code> or <code>ElasticsearchOperations</code> <code>@Bean</code>, as long as it is named <code>"elasticsearchTemplate"</code>.
Same applies to <code>ReactiveElasticsearchTemplate</code> and <code>ReactiveElasticsearchOperations</code>, with the bean name <code>"reactiveElasticsearchTemplate"</code>.</p>
</div>
<div class="paragraph">
<p>You can choose to disable the repositories support with the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.repositories.enabled=false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-cassandra">11.6. Cassandra</h3>
<div class="paragraph">
<p><a href="https://cassandra.apache.org/">Cassandra</a> is an open source, distributed database management system designed to handle large amounts of data across many commodity servers.
Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-cassandra">Spring Data Cassandra</a>.
There is a <code>spring-boot-starter-data-cassandra</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-cassandra">11.6.1. Connecting to Cassandra</h4>
<div class="paragraph">
<p>You can inject an auto-configured <code>CassandraTemplate</code> or a Cassandra <code>Session</code> instance as you would with any other Spring Bean.
The <code>spring.data.cassandra.*</code> properties can be used to customize the connection.
Generally, you provide <code>keyspace-name</code> and <code>contact-points</code> properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.cassandra.keyspace-name=mykeyspace
spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>ClusterBuilderCustomizer</code> for more advanced customizations.</p>
</div>
<div class="paragraph">
<p>The following code listing shows how to inject a Cassandra bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private CassandraTemplate template;

    @Autowired
    public MyBean(CassandraTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you add your own <code>@Bean</code> of type <code>CassandraTemplate</code>, it replaces the default.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-cassandra-repositories">11.6.2. Spring Data Cassandra Repositories</h4>
<div class="paragraph">
<p>Spring Data includes basic repository support for Cassandra.
Currently, this is more limited than the JPA repositories discussed earlier and needs to annotate finder methods with <code>@Query</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Cassandra, refer to the <a href="https://docs.spring.io/spring-data/cassandra/docs/">reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-couchbase">11.7. Couchbase</h3>
<div class="paragraph">
<p><a href="https://www.couchbase.com/">Couchbase</a> is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications.
Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-couchbase">Spring Data Couchbase</a>.
There are <code>spring-boot-starter-data-couchbase</code> and <code>spring-boot-starter-data-couchbase-reactive</code> &#8220;Starters&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-couchbase">11.7.1. Connecting to Couchbase</h4>
<div class="paragraph">
<p>You can get a <code>Bucket</code> and <code>Cluster</code> by adding the Couchbase SDK and some configuration.
The <code>spring.couchbase.*</code> properties can be used to customize the connection.
Generally, you provide the bootstrap hosts, bucket name, and password, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
spring.couchbase.bucket.name=my-bucket
spring.couchbase.bucket.password=secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You need to provide <em>at least</em> the bootstrap host(s), in which case the bucket name is <code>default</code> and the password is an empty String.
Alternatively, you can define your own <code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code> to take control over the whole configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is also possible to customize some of the <code>CouchbaseEnvironment</code> settings.
For instance, the following configuration changes the timeout to use to open a new <code>Bucket</code> and enables SSL support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.env.timeouts.connect=3000
spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
spring.couchbase.env.ssl.key-store-password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the <code>spring.couchbase.env.*</code> properties for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spring-data-couchbase-repositories">11.7.2. Spring Data Couchbase Repositories</h4>
<div class="paragraph">
<p>Spring Data includes repository support for Couchbase.
For complete details of Spring Data Couchbase, refer to the <a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/">reference documentation</a>.</p>
</div>
<div class="paragraph">
<p>You can inject an auto-configured <code>CouchbaseTemplate</code> instance as you would with any other Spring Bean, provided a <em>default</em> <code>CouchbaseConfigurer</code> is available (which happens when you enable Couchbase support, as explained earlier).</p>
</div>
<div class="paragraph">
<p>The following examples shows how to inject a Couchbase bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final CouchbaseTemplate template;

    @Autowired
    public MyBean(CouchbaseTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>CouchbaseTemplate</code> <code>@Bean</code> with a name of <code>couchbaseTemplate</code>.</p>
</li>
<li>
<p>An <code>IndexManager</code> <code>@Bean</code> with a name of <code>couchbaseIndexManager</code>.</p>
</li>
<li>
<p>A <code>CustomConversions</code> <code>@Bean</code> with a name of <code>couchbaseCustomConversions</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To avoid hard-coding those names in your own config, you can reuse <code>BeanNames</code> provided by Spring Data Couchbase.
For instance, you can customize the converters to use, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class SomeConfiguration {

    @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
    public CustomConversions myCustomConversions() {
        return new CustomConversions(...);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you want to fully bypass the auto-configuration for Spring Data Couchbase, provide your own implementation of <code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-ldap">11.8. LDAP</h3>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network.
Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>.</p>
</div>
<div class="paragraph">
<p>LDAP abstractions are provided by <a href="https://github.com/spring-projects/spring-data-ldap">Spring Data LDAP</a>.
There is a <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-connecting">11.8.1. Connecting to an LDAP Server</h4>
<div class="paragraph">
<p>To connect to an LDAP server, make sure you declare a dependency on the <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221; or <code>spring-ldap-core</code> and then declare the URLs of your server in your application.properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.urls=ldap://myserver:1235
spring.ldap.username=admin
spring.ldap.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to customize connection settings, you can use the <code>spring.ldap.base</code> and <code>spring.ldap.base-environment</code> properties.</p>
</div>
<div class="paragraph">
<p>An <code>LdapContextSource</code> is auto-configured based on these settings.
If a <code>DirContextAuthenticationStrategy</code> bean is available, it is associated to the auto-configured <code>LdapContextSource</code>.
If you need to customize it, for instance to use a <code>PooledContextSource</code>, you can still inject the auto-configured <code>LdapContextSource</code>.
Make sure to flag your customized <code>ContextSource</code> as <code>@Primary</code> so that the auto-configured <code>LdapTemplate</code> uses it.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-spring-data-repositories">11.8.2. Spring Data LDAP Repositories</h4>
<div class="paragraph">
<p>Spring Data includes repository support for LDAP.
For complete details of Spring Data LDAP, refer to the <a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">reference documentation</a>.</p>
</div>
<div class="paragraph">
<p>You can also inject an auto-configured <code>LdapTemplate</code> instance as you would with any other Spring Bean, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final LdapTemplate template;

    @Autowired
    public MyBean(LdapTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap-embedded">11.8.3. Embedded In-memory LDAP Server</h4>
<div class="paragraph">
<p>For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>.
To configure the server, add a dependency to <code>com.unboundid:unboundid-ldapsdk</code> and declare a
<code>spring.ldap.embedded.base-dn</code> property, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn=dc=spring,dc=io</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation.</p>
</div>
<div class="paragraph">
<p>In yaml files, you can use the yaml list notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">spring.ldap.embedded.base-dn:
  - dc=spring,dc=io
  - dc=pivotal,dc=io</code></pre>
</div>
</div>
<div class="paragraph">
<p>In properties files, you must include the index as part of the property name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the server starts on a random port and triggers the regular LDAP support.
There is no need to specify a <code>spring.ldap.urls</code> property.</p>
</div>
<div class="paragraph">
<p>If there is a <code>schema.ldif</code> file on your classpath, it is used to initialize the server.
If you want to load the initialization script from a different resource, you can also use the
<code>spring.ldap.embedded.ldif</code> property.</p>
</div>
<div class="paragraph">
<p>By default, a standard schema is used to validate <code>LDIF</code> files.
You can turn off validation altogether by setting the <code>spring.ldap.embedded.validation.enabled</code>
property.
If you have custom attributes, you can use <code>spring.ldap.embedded.validation.schema</code> to
define your custom attribute types or object classes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-influxdb">11.9. InfluxDB</h3>
<div class="paragraph">
<p><a href="https://www.influxdata.com/">InfluxDB</a>是一个开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，
物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。</p>
</div>
<div class="sect3">
<h4 id="boot-features-connecting-to-influxdb">11.9.1. 连接到InfluxDB</h4>
<div class="paragraph">
<p>只要 <code>influxdb-java</code> 客户端位于类路径上并设置了数据库的URL，Spring Boot就会自动配置 <code>InfluxDB</code> 实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.influx.url=https://172.0.0.1:8086</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与InfluxDB的连接需要用户和密码，则可以相应地设置 <code>spring.influx.user</code> 和 <code>spring.influx.password</code> 属性。</p>
</div>
<div class="paragraph">
<p>InfluxDB依赖OkHttp。如果需要在后台调整 <code>InfluxDB</code> 使用的http客户端，则可以注册 <code>InfluxDbOkHttpClientBuilderProvider</code> bean。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-caching">12. 缓存</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring框架提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。
缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过 <code>@EnableCaching</code> 注解启用了缓存支持，Spring Boot就会自动配置缓存基础设施。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
检查Spring Framework指南的 {spring-framework-docs}integration.html#cache[相关部分]以获取更多详细信息。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>简而言之，将缓存添加到服务的操作就像将相关注解添加到其方法一样容易，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MathService {

    @Cacheable("piDecimals")
    public int computePiDecimal(int i) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本示例说明了在潜在的昂贵操作上使用缓存的方法。在调用 <code>computePiDecimal</code> 之前，抽象将在 <code>piDecimals</code> 缓存中查找与 <code>i</code> 参数匹配的条目。
如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
你还可以透明地使用标准JSR-107（JCache）注解（例如：<code>@CacheResult</code>）。但是，我们强烈建议你不要混合使用Spring Cache和JCache注解。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不添加任何特定的缓存库，Spring Boot会自动配置一个使用内存中concurrent maps的<a href="#boot-features-caching-provider-simple">简单供应商</a>。
当需要缓存时（例如：上例中的 <code>piDecimals</code>），此供应商将为你创建它。实际上，不建议将该简单供应商用于生产环境，
但是它对于入门并确保你了解功能非常有用。确定要使用的缓存供应商后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。
几乎所有供应商都要求你显式配置在应用程序中使用的每个缓存。有些提供自定义 <code>spring.cache.cache-names</code> 属性来定义默认缓存的方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
还可以透明地 {spring-framework-docs}integration.html#cache-annotations-put[更新]或从缓存中
{spring-framework-docs}integration.html#cache-annotations-evict[驱逐]数据。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-caching-provider">12.1. 支持的缓存供应商</h3>
<div class="paragraph">
<p>缓存抽象不提供实际的存储，而是依赖于由 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口实现的抽象。</p>
</div>
<div class="paragraph">
<p>如果尚未定义 <code>CacheManager</code> 类型的Bean或名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>
（请参阅 {spring-framework-api}/cache/annotation/CachingConfigurer.html[<code>CachingConfigurer</code>]），
则Spring Boot尝试检测以下供应商（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#boot-features-caching-provider-generic">Generic</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, and others)</p>
</li>
<li>
<p><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-hazelcast">Hazelcast</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-infinispan">Infinispan</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-redis">Redis</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-caffeine">Caffeine</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-simple">Simple</a></p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
也可以通过设置 <code>spring.cache.type</code> 属性来 <em>强制</em> 指定特定的缓存供应商。如果你需要在某些环境（例如测试）中
<a href="#boot-features-caching-provider-none">完全禁用缓存</a>，请使用此属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>spring-boot-starter-cache</code> “<code>Starter</code>”快速添加基本的缓存依赖项。入门程序提供了 <code>spring-context-support</code>。
如果手动添加依赖项，则必须包括 <code>spring-context-support</code> 才能使用JCache，EhCache 2.x或Caffeine支持。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>CacheManager</code> 是由Spring Boot自动配置的，则可以通过公开实现 <code>CacheManagerCustomizer</code> 接口的bean，
在完全初始化之前进一步调整其配置。下面的示例设置一个标志，指示应该将 <code>null</code> 值向下传递到基础映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; cacheManagerCustomizer() {
    return new CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() {
        @Override
        public void customize(ConcurrentMapCacheManager cacheManager) {
            cacheManager.setAllowNullValues(false);
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在前面的示例中，需要一个自动配置的 <code>ConcurrentMapCacheManager</code>。
如果不是这种情况（你提供了自己的配置，或者自动配置了其他缓存供应商），则根本不会调用定制程序。
你可以根据需要拥有任意数量的定制程序，也可以使用 <code>@Order</code> 或 <code>Ordered</code> 对其进行排序。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-generic">12.1.1. 泛型</h4>
<div class="paragraph">
<p>如果上下文定义了 <em>至少一个</em> <code>org.springframework.cache.Cache</code> bean，则使用泛型缓存。
创建一个包装所有该类型Bean的 <code>CacheManager</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-jcache">12.1.2. JCache (JSR-107)</h4>
<div class="paragraph">
<p>通过在类路径上存在 <code>javax.cache.spi.CachingProvider</code> 引导 <a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>（即，在类路径上存在符合JSR-107的缓存库），
并且 <code>JCacheCacheManager</code> 由 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供。
提供了各种兼容的库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供了依赖管理。也可以添加任何其他兼容的库。</p>
</div>
<div class="paragraph">
<p>可能会出现多个供应商，在这种情况下，必须明确指定供应商。即使JSR-107标准没有强制采用标准化的方式来定义配置文件的位置，
Spring Boot也会尽其最大努力来容纳具有实现细节的缓存，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Only necessary if more than one provider is present
spring.cache.jcache.provider=com.acme.MyCachingProvider
spring.cache.jcache.config=classpath:acme.xml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当缓存库同时提供native实现和JSR-107支持时，Spring Boot会首选JSR-107支持，因此，如果你切换到其他JSR-107实现，则可以使用相同的功能。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot对<a href="#boot-features-hazelcast">Hazelcast具有常规支持</a>。
如果有单个 <code>HazelcastInstance</code> 可用，则除非指定了 <code>spring.cache.jcache.config</code> 属性，否则它也会自动用于 <code>CacheManager</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>自定义基础 <code>javax.cache.cacheManager</code> 有两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建缓存。
如果自定义了 <code>javax.cache.configuration.Configuration</code> Bean，则将其用于自定义它们。</p>
</li>
<li>
<p>使用 <code>CacheManager</code> 的引用调用 <code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code>
Bean以进行完全定制。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果定义了标准的 <code>javax.cache.CacheManager</code> bean，它将自动包装在抽象期望的 <code>org.springframework.cache
.CacheManager</code> 实现中。不再对其应用定制。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-ehcache2">12.1.3. EhCache 2.x</h4>
<div class="paragraph">
<p>如果可以在类路径的根目录下找到名为 <code>ehcache.xml</code> 的文件，则使用 <a href="https://www.ehcache.org/">EhCache</a> 2.x。
如果找到EhCache 2.x，则使用 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供的 <code>EhCacheCacheManager</code> 来引导缓存管理器。
也可以提供备用配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.ehcache.config=classpath:config/another-config.xml</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-hazelcast">12.1.4. Hazelcast</h4>
<div class="paragraph">
<p>Spring Boot对<a href="#boot-features-hazelcast">Hazelcast具有常规支持</a>。
如果已经自动配置了 <code>HazelcastInstance</code>，则将其自动包装在 <code>CacheManager</code> 中。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-infinispan">12.1.5. Infinispan</h4>
<div class="paragraph">
<p><a href="https://infinispan.org/">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.infinispan.config=infinispan.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建缓存。
如果定义了自定义 <code>ConfigurationBuilder</code> bean，则将其用于自定义缓存。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot对Infinispan的支持仅限于嵌入式模式，并且非常基础。
如果你需要更多选择，则应该使用官方的Infinispan Spring Boot启动器。有关更多详细信息，请参见
<a href="https://github.com/infinispan/infinispan-spring-boot">Infinispan的文档</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-couchbase">12.1.6. Couchbase</h4>
<div class="paragraph">
<p>如果可以使用 <a href="https://www.couchbase.com/">Couchbase</a> Java客户端和 <code>couchbase-spring-cache</code>
实现，并且<a href="#boot-features-couchbase">已配置</a>Couchbase，则将自动配置 <code>CouchbaseCacheManager</code>。
通过设置 <code>spring.cache.cache-names</code> 属性，还可以在启动时创建其他缓存。
这些缓存在自动配置的 <code>Bucket</code> 上运行。你 <em>还</em> 可以使用定制程序在另一个 <code>Bucket</code> 上创建其他缓存。
假设你在"main" <code>Bucket</code> 上需要两个缓存（<code>cache1</code> 和 <code>cache2</code>），在"another" <code>Bucket</code>
上需要一个自定义的存活时间为2秒的缓存（<code>cache3</code>）。
你可以通过配置创建前两个缓存，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以定义一个 <code>@Configuration</code> 类来配置额外的 <code>Bucket</code> 和 <code>cache3</code> 缓存，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class CouchbaseCacheConfiguration {

    private final Cluster cluster;

    public CouchbaseCacheConfiguration(Cluster cluster) {
        this.cluster = cluster;
    }

    @Bean
    public Bucket anotherBucket() {
        return this.cluster.openBucket("another", "secret");
    }

    @Bean
    public CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; cacheManagerCustomizer() {
        return c -&gt; {
            c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
                    .withExpiration(2));
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例配置重用了通过自动配置创建的 <code>Cluster</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-redis">12.1.7. Redis</h4>
<div class="paragraph">
<p>如果 <a href="https://redis.io/">Redis</a>可用并已配置，则 <code>RedisCacheManager</code> 将自动配置。
通过设置 <code>spring.cache.cache-names</code> 属性可以在启动时创建其他缓存，
并且可以使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值。
例如，以下配置创建的 <code>cache1</code> 和 <code>cache2</code> 缓存的 <em>存活时间</em> 为10分钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=600000</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
默认情况下，会添加键前缀，这样，如果两个单独的缓存使用相同的键，则Redis不会有重叠的键，也不会返回无效值。
如果你创建自己的 <code>RedisCacheManager</code>，我们强烈建议将此设置保持启用状态。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过添加自己的 <code>RedisCacheConfiguration</code> <code>@Bean</code> 来完全控制配置。如果你要自定义序列化策略，这可能会很有用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-caffeine">12.1.8. Caffeine</h4>
<div class="paragraph">
<p><a href="https://github.com/ben-manes/caffeine">Caffeine</a>是对Guava缓存的Java 8重写，取代了对Guava的支持。
如果存在Caffeine，则会自动配置 <code>CaffeineCacheManager</code>（由 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供）。
缓存可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建，并且可以通过以下方式之一自定义（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>由 <code>spring.cache.caffeine.spec</code> 定义的缓存规范</p>
</li>
<li>
<p>定义了一个 <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</p>
</li>
<li>
<p>定义了一个 <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如：以下配置将创建最大大小为500，<em>存活时间</em> 为10分钟的 <code>cache1</code> 和 <code>cache2</code> 缓存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了 <code>com.github.benmanes.caffeine.cache.CacheLoader</code> Bean，它将自动与 <code>CaffeineCacheManager</code> 关联。
由于 <code>CacheLoader</code> 将与由缓存管理器管理的 <em>所有</em> 缓存相关联，因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>。
自动配置将忽略任何其他泛型类型。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-simple">12.1.9. Simple</h4>
<div class="paragraph">
<p>如果找不到其他供应商，则配置使用 <code>ConcurrentHashMap</code> 作为缓存存储区的简单实现。如果你的应用程序中不存在任何缓存库，则这是默认设置。
默认情况下，将根据需要创建缓存，但是你可以通过设置 <code>cache-names</code> 属性来限制可用缓存的列表。
例如，如果只需要 <code>cache1</code> 和 <code>cache2</code> 高速缓存，请按如下所示设置 <code>cache-names</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这样做，并且你的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但在启动时不会失败。
这与使用未声明的缓存时“实际”缓存供应商的行为类似。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider-none">12.1.10. None</h4>
<div class="paragraph">
<p>当你的配置中存在 <code>@EnableCaching</code> 时，也需要合适的缓存配置。如果你需要在某些环境中完全禁用缓存，
请强制将缓存类型设置为 <code>none</code> 以使用no-op实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.type=none</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-messaging">13. 消息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework为与消息传递系统集成提供了广泛的支持，从使用 <code>JmsTemplate</code> 简化JMS API到使用完整的基础设施异步接收消息。
Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还为 <code>RabbitTemplate</code> 和RabbitMQ提供了自动配置选项。
Spring WebSocket本身就包含对STOMP消息的支持，而Spring Boot通过启动器和少量的自动配置对此提供了支持。
Spring Boot还支持Apache Kafka。</p>
</div>
<div class="sect2">
<h3 id="boot-features-jms">13.1. JMS</h3>
<div class="paragraph">
<p><code>javax.jms.ConnectionFactory</code> 接口提供了创建用于与JMS代理进行交互的 <code>javax.jms.Connection</code> 的标准方法。
尽管Spring需要一个 <code>ConnectionFactory</code> 来与JMS一起使用，但是你通常不需要自己直接使用它，而可以依赖于更高级别的消息传递抽象。
（有关详细信息，请参见Spring Framework参考文档的 {spring-framework-docs}integration.html#jms[相关部分]。）Spring
Boot还会自动配置必要的基础设施，以发送和接收消息。</p>
</div>
<div class="sect3">
<h4 id="boot-features-activemq">13.1.1. ActiveMQ支持</h4>
<div class="paragraph">
<p>当 <a href="https://activemq.apache.org/">ActiveMQ</a>在类路径上可用时，Spring Boot也可以配置 <code>ConnectionFactory</code>。
如果存在broker，则将自动启动和配置嵌入式broker（前提是未通过配置指定代理URL）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用 <code>spring-boot-starter-activemq</code>，则将提供连接或嵌入ActiveMQ实例所需的依赖关系，
以及与JMS集成的Spring基础设施。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ActiveMQ配置由 <code>spring.activemq.*</code> 中的外部配置属性控制。
例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>CachingConnectionFactory</code> 用适当的设置包装native <code>ConnectionFactory</code>，你可以通过 <code>spring.jms.*</code>
中的外部配置属性来控制这些设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想使用native池，则可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖项并相应地配置
<code>JmsPoolConnectionFactory</code> 来实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/jms/activemq/ActiveMQProperties.java[<code>ActiveMQProperties</code>]。
你还可以注册任意数量的实现 <code>ActiveMQConnectionFactoryCustomizer</code> 的Bean，以进行更高级的自定义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，如果destination尚不存在ActiveMQ会创建，以便根据其提供的名称来解析destinations。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-artemis">13.1.2. Artemis支持</h4>
<div class="paragraph">
<p>当Spring Boot检测到 <a href="https://activemq.apache.org/artemis/">Artemis</a>在类路径中可用时，它可以自动配置 <code>ConnectionFactory</code>。
如果存在broker，则将自动启动和配置嵌入式broker（除非已明确设置mode属性）。
受支持的模式是 <code>embedded</code>（以明确表明需要嵌入式broker，并且如果类路径上不存在该broker，则将发生错误）和
<code>native</code>（使用Netty传输协议连接到broker）。配置后者后，Spring Boot会配置一个 <code>ConnectionFactory</code>，
该工厂将使用默认设置连接到在本地计算机上运行的broker。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用 <code>spring-boot-starter-artemis</code>，则将提供连接到现有Artemis实例所需的依赖项，以及与JMS集成的Spring基础设施。
将 <code>org.apache.activemq:artemis-jms-server</code> 添加到你的应用程序中可以使你使用嵌入式模式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Artemis配置由 <code>spring.artemis.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.mode=native
spring.artemis.host=192.168.1.210
spring.artemis.port=9876
spring.artemis.user=admin
spring.artemis.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>嵌入broker时，可以选择是否要启用持久性并列出应使其可用的destinations。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，
或者你可以定义 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> 或
<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code> 类型的bean，分别用于高级队列和主题配置。</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>CachingConnectionFactory</code> 用适当的设置包装native <code>ConnectionFactory</code>，你可以通过
<code>spring.jms.*</code> 中的外部配置属性来控制这些设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想使用native池，则可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖项并相应地配置
<code>JmsPoolConnectionFactory</code> 来实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/jms/artemis/ArtemisProperties.java[<code>ArtemisProperties</code>]。</p>
</div>
<div class="paragraph">
<p>使用Artemis配置中的 <code>name</code> 属性或通过配置提供的名称，来根据destinations名称解析destinations，不涉及JNDI查找。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jms-jndi">13.1.3. 使用JNDI ConnectionFactory</h4>
<div class="paragraph">
<p>如果你正在应用程序服务器中运行应用程序，Spring Boot会尝试使用JNDI来查找JMS <code>ConnectionFactory</code>。
默认情况下，将检查 <code>java:/JmsXA</code> 和 <code>java:/XAConnectionFactory</code> 位置。
如果需要指定备用位置，则可以使用 <code>spring.jms.jndi-name</code> 属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.jndi-name=java:/MyConnectionFactory</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jms-sending">13.1.4. 发送消息</h4>
<div class="paragraph">
<p>Spring的 <code>JmsTemplate</code> 是自动配置的，你可以将其直接自动注入到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    @Autowired
    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
{spring-framework-api}/jms/core/JmsMessagingTemplate.html[<code>JmsMessagingTemplate</code>]可以类似的方式注入。
如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> bean，则将其自动关联到自动配置的 <code>JmsTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jms-receiving">13.1.5. 接收消息</h4>
<div class="paragraph">
<p>存在JMS基础设施时，可以使用 <code>@JmsListener</code> 注解任何bean以创建监听器端点。如果未定义 <code>JmsListenerContainerFactory</code>
，则会自动配置一个默认值。如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> Bean，则将其自动关联到默认工厂。</p>
</div>
<div class="paragraph">
<p>默认情况下，默认工厂是事务性的。如果你在存在 <code>JtaTransactionManager</code> 的基础设施中运行，则默认情况下它将与侦听器容器关联。
如果不是，则启用 <code>sessionTransacted</code> 标志。在后一种情况下，你可以通过在监听器方法（或其委托）上添加 <code>@Transactional</code>
来将本地数据存储事务与传入消息的处理相关联。这样可以确保本地事务完成后，接收的消息得到确认。这还包括发送已在同一JMS会话上执行的响应消息。</p>
</div>
<div class="paragraph">
<p>以下组件在 <code>someQueue</code> 目标上创建一个监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参见 {spring-framework-api}/jms/annotation/EnableJms.html[<code>@EnableJms</code> 的Javadoc]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你需要创建更多的 <code>JmsListenerContainerFactory</code> 实例，或者想要覆盖默认实例，Spring
Boot提供了一个 <code>DefaultJmsListenerContainerFactoryConfigurer</code>
，你可以使用它来初始化具有与自动配置相同设置的 <code>DefaultJmsListenerContainerFactory</code>。</p>
</div>
<div class="paragraph">
<p>例如，以下示例公开了另一个使用特定 <code>MessageConverter</code> 的工厂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class JmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory());
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以在任何 <code>@JmsListener</code> 注释的方法中使用工厂，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-amqp">13.2. AMQP</h3>
<div class="paragraph">
<p>Advanced Message Queuing Protocol (AMQP) 是面向消息中间件的与平台无关的有线级别协议。
Spring AMQP项目将Spring的核心概念应用于基于AMQP的消息传递解决方案的开发。
Spring Boot为通过RabbitMQ使用AMQP提供了许多便利，包括 <code>spring-boot-starter-amqp</code> “<code>Starter</code>”。</p>
</div>
<div class="sect3">
<h4 id="boot-features-rabbitmq">13.2.1. RabbitMQ支持</h4>
<div class="paragraph">
<p><a href="https://www.rabbitmq.com/">RabbitMQ</a>是基于AMQP协议的轻型，可靠，可伸缩和便携式消息broker。
Spring使用 <code>RabbitMQ</code> 通过AMQP协议进行通信。</p>
</div>
<div class="paragraph">
<p>RabbitMQ配置由 <code>spring.rabbitmq.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，你可以使用 <code>addresses</code> 属性配置相同的连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.addresses=amqp://admin:secret@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果上下文中存在 <code>ConnectionNameStrategy</code> Bean，它将自动用于命名由自动配置的 <code>ConnectionFactory</code> 创建的连接。
有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/amqp/RabbitProperties.java[<code>RabbitProperties</code>]。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参阅 <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">了解RabbitMQ使用的AMQP协议</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-amqp-sending">13.2.2. 发送消息</h4>
<div class="paragraph">
<p>Spring的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的，你可以将它们直接自动注入到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;
    private final AmqpTemplate amqpTemplate;

    @Autowired
    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
{spring-amqp-api}/rabbit/core/RabbitMessagingTemplate.html[<code>RabbitMessagingTemplate</code>]可以类似的方式注入。
如果定义了 <code>MessageConverter</code> bean，它将自动关联到自动配置的 <code>AmqpTemplate</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如有必要，任何定义为 <code>org.springframework.amqp.core.Queue</code> 的bean都会自动用于在RabbitMQ实例上声明相应的队列。</p>
</div>
<div class="paragraph">
<p>要重试操作，可以在 <code>AmqpTemplate</code> 上启用重试（例如，在broker连接丢失的情况下）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，重试是禁用的。你也可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean来以编程方式自定义 <code>RetryTemplate</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-amqp-receiving">13.2.3. 接收消息</h4>
<div class="paragraph">
<p>存在Rabbit基础设施时，可以使用 <code>@RabbitListener</code> 注解任何bean以创建监听器端点。
如果未定义 <code>RabbitListenerContainerFactory</code>，则会自动配置默认的 <code>SimpleRabbitListenerContainerFactory</code>，
你可以使用 <code>spring.rabbitmq.listener.type</code> 属性切换到直接容器。
如果定义了 <code>MessageConverter</code> 或 <code>MessageRecoverer</code> Bean，它将自动与默认工厂关联。</p>
</div>
<div class="paragraph">
<p>以下示例组件在 <code>someQueue</code> 队列上创建一个监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参见 {spring-amqp-api}/rabbit/annotation/EnableRabbit.html[<code>@EnableRabbit</code> 的Javadoc]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你需要创建更多 <code>RabbitListenerContainerFactory</code> 实例，或者想要覆盖默认实例，
Spring Boot提供了一个 <code>SimpleRabbitListenerContainerFactoryConfigurer</code>
和 <code>DirectRabbitListenerContainerFactoryConfigurer</code>，
你可以使用它们来初始化 <code>SimpleRabbitListenerContainerFactory</code> 和 <code>DirectRabbitListenerContainerFactory</code>
，其设置与自动配置所使用的工厂相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
选择哪种容器都没有关系。这两个bean通过自动配置公开。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，以下配置类公开了另一个使用特定 <code>MessageConverter</code> 的工厂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class RabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以在任何 <code>@RabbitListener</code> 注释的方法中使用工厂，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以启用重试来处理监听器引发异常的情况。默认情况下，使用 <code>RejectAndDontRequeueRecoverer</code>，
但是你可以定义自己的 <code>MessageRecoverer</code>。当重试耗尽时，消息将被拒绝，如果将broker配置为这样做，则消息将被丢弃或路由到死信交换器。
默认情况下，重试是禁用的。你也可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean来以编程方式自定义 <code>RetryTemplate</code>。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
默认情况下，如果禁用了重试，并且监听器抛出异常，则会无限期地重试传递。你可以通过两种方式修改此行为：
将 <code>defaultRequeueRejected</code> 属性设置为 <code>false</code>，以便尝试零次重新传递，或者引发
<code>AmqpRejectAndDontRequeueException</code> 以指示应拒绝该消息。后者是启用重试并达到最大传递尝试次数时使用的机制。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-kafka">13.3. Apache Kafka支持</h3>
<div class="paragraph">
<p>通过提供 <code>spring-kafka</code> 项目的自动配置来支持 <a href="https://kafka.apache.org/">Apache Kafka</a>。</p>
</div>
<div class="paragraph">
<p>Kafka配置由 <code>spring.kafka.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=myGroup</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在启动时创建主题，请添加 <code>NewTopic</code> 类型的Bean。如果该主题已经存在，则将忽略该Bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 {spring-boot-autoconfigure-module-code}/kafka/KafkaProperties.java[<code>KafkaProperties</code>]。</p>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-sending-a-message">13.3.1. 发送消息</h4>
<div class="paragraph">
<p>Spring的 <code>KafkaTemplate</code> 是自动配置的，你可以直接在自己的bean中自动对其进行注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final KafkaTemplate kafkaTemplate;

    @Autowired
    public MyBean(KafkaTemplate kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果定义了 <code>spring.kafka.producer.transaction-id-prefix</code> 属性，则会自动配置 <code>KafkaTransactionManager</code>。
另外，如果定义了 <code>RecordMessageConverter</code> bean，它将自动关联到自动配置的 <code>KafkaTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-receiving-a-message">13.3.2. 接收消息</h4>
<div class="paragraph">
<p>存在Apache Kafka基础设施时，可以使用 <code>@KafkaListener</code> 注释任何bean以创建监听器端点。
如果未定义 <code>KafkaListenerContainerFactory</code>，则会使用 <code>spring.kafka.listener.*</code> 中定义的键自动配置默认值。</p>
</div>
<div class="paragraph">
<p>以下组件在 <code>someTopic</code> 主题上创建监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @KafkaListener(topics = "someTopic")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了 <code>KafkaTransactionManager</code> bean，它将自动关联到容器工厂。同样，如果定义了 <code>ErrorHandler</code>，<code>AfterRollbackProcessor</code>
或 <code>ConsumerAwareRebalanceListener</code> bean，它将自动与默认工厂关联。</p>
</div>
<div class="paragraph">
<p>根据监听器类型，将 <code>RecordMessageConverter</code> 或 <code>BatchMessageConverter</code> bean与默认工厂关联。
如果对于批处理监听器仅存在一个 <code>RecordMessageConverter</code> bean，则将其包装在 <code>BatchMessageConverter</code> 中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
自定义 <code>ChainedKafkaTransactionManager</code> 必须标记为 <code>@Primary</code>，因为它通常引用自动配置的 <code>KafkaTransactionManager</code> bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-streams">13.3.3. Kafka流</h4>
<div class="paragraph">
<p>用于Apache Kafka的Spring提供了一个工厂bean来创建 <code>StreamsBuilder</code> 对象并管理其流的生命周期。
只要 <code>kafka-streams</code> 在类路径上并且通过 <code>@EnableKafkaStreams</code> 注解启用Kafka Streams，
Spring Boot就会自动配置所需的 <code>KafkaStreamsConfiguration</code> bean。</p>
</div>
<div class="paragraph">
<p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。
可以使用 <code>spring.kafka.streams.application-id</code> 来配置前者，如果未设置，则默认为 <code>spring.application.name</code>。
后者可以全局设置，也可以仅针对流进行覆盖。</p>
</div>
<div class="paragraph">
<p>使用专用属性可以获得几个附加属性。可以使用 <code>spring.kafka.streams.properties</code> 命名空间设置其他任意Kafka属性。
另请参见<a href="#boot-features-kafka-extra-props">Kafka的其他属性</a>。</p>
</div>
<div class="paragraph">
<p>要使用工厂bean，只需将 <code>StreamsBuilder</code> 连接到你的 <code>@Bean</code> 中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public static class KafkaStreamsExampleConfiguration {

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder streamsBuilder) {
        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream("ks1In");
        stream.map((k, v) -&gt; new KeyValue&lt;&gt;(k, v.toUpperCase())).to("ks1Out",
                Produced.with(Serdes.Integer(), new JsonSerde&lt;&gt;()));
        return stream;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，由它创建的 <code>StreamBuilder</code> 对象管理的流将自动启动。你可以使用 <code>spring.kafka.streams.auto-startup</code> 属性来自定义此行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka-extra-props">13.3.4. Kafka的其他属性</h4>
<div class="paragraph">
<p>自动配置支持的属性显示在 {spring-boot-docs}/htmlsingle/#common-application-properties[通用应用程序属性]中。
请注意，在大多数情况下，这些属性（hyphenated或camelCase）直接映射到Apache Kafka dotted属性。有关详细信息，请参阅Apache Kafka文档。</p>
</div>
<div class="paragraph">
<p>这些属性的前几个属性适用于所有组件（生产者，消费者，管理员和流），但如果你希望使用不同的值，则可以在组件级别上指定。
Apache Kafka指定属性的重要性为HIGH，MEDIUM或LOW。Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性以及任何没有默认值的属性。</p>
</div>
<div class="paragraph">
<p>通过 <code>KafkaProperties</code> 类可以直接使用Kafka支持的属性的子集。如果希望使用不直接支持的其他属性来配置生产者或消费者，请使用以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.properties.prop.one=first
spring.kafka.admin.properties.prop.two=second
spring.kafka.consumer.properties.prop.three=third
spring.kafka.producer.properties.prop.four=fourth
spring.kafka.streams.properties.prop.five=fifth</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将常见的 <code>prop.one</code> Kafka属性设置为 <code>first</code>（适用于生产者，消费者和管理员），<code>prop.two</code> 管理员属性设置为 <code>second</code>，
<code>prop.three</code> 消费者属性设置为 <code>third</code>，<code>prop.four</code> 生产者属性设置为 <code>fourth</code>，<code>prop.five</code> 流属性设置为 <code>fifth</code>。</p>
</div>
<div class="paragraph">
<p>你还可以如下配置Spring Kafka <code>JsonDeserializer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，你可以禁用 <code>JsonSerializer</code> 在头部发送类型信息的默认行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.add.type.headers=false</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
以这种方式设置的属性将覆盖Spring Boot显式支持的任何配置项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-kafka">13.3.5. 使用嵌入式Kafka进行测试</h4>
<div class="paragraph">
<p>Spring for Apache Kafka提供了一种使用嵌入式Apache Kafka broker测试项目的便捷方法。
要使用此功能，请在 <code>spring-kafka-test</code> 模块中使用 <code>@EmbeddedKafka</code> 注释测试类。
有关更多信息，请参阅Spring for Apache Kafka <a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation">参考手册</a>。</p>
</div>
<div class="paragraph">
<p>要使Spring Boot自动配置与上述嵌入式Apache Kafka broker一起使用，你需要将嵌入式broker地址（由 <code>EmbeddedKafkaBroker</code> 填充）
的系统属性重新映射到Apache Kafka的Spring Boot配置属性中。有几种方法可以做到这一点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供一个系统属性，以将嵌入式broker地址映射到测试类中的 <code>spring.kafka.bootstrap-servers</code> 中：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>@EmbeddedKafka</code> 注解上配置属性名称：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在配置属性中使用占位符：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-resttemplate">14. 使用 <code>RestTemplate</code> 调用REST服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你需要从应用程序中调用远程REST服务，则可以使用Spring Framework的 {spring-framework-api}/web/client/RestTemplate.html[<code>RestTemplate</code>]类。
由于 <code>RestTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>RestTemplate</code> bean。
但是，它确实会自动配置 <code>RestTemplateBuilder</code>，可在需要时将其用于创建 <code>RestTemplate</code> 实例。
自动配置的 <code>RestTemplateBuilder</code> 确保将明智的 <code>HttpMessageConverters</code> 应用于 <code>RestTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>RestTemplateBuilder</code> 包含许多有用的方法，可用于快速配置 <code>RestTemplate</code>。例如：要添加BASIC身份验证支持，
可以使用 <code>builder.basicAuthentication("user", "password").build()</code>。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-resttemplate-customization">14.1. RestTemplate自定义</h3>
<div class="paragraph">
<p><code>RestTemplate</code> 自定义有三种主要方法，具体取决于你要应用自定义的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。
每个方法调用都返回一个新的 <code>RestTemplateBuilder</code> 实例，因此自定义项仅影响此builder的使用。</p>
</div>
<div class="paragraph">
<p>要进行应用程序作用域的附加自定义，请使用 <code>RestTemplateCustomizer</code> bean。
所有此类bean都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 中，并应用于使用它构建的任何模板。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个定制程序，该定制程序为除 <code>192.168.0.5</code> 之外的所有主机配置使用代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code> bean。
这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置，并阻止使用任何 <code>RestTemplateCustomizer</code> Bean。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-webclient">15. 使用 <code>WebClient</code> 调用REST服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你的类路径中包含Spring WebFlux，则还可以选择使用 <code>WebClient</code> 调用远程REST服务。
与 <code>RestTemplate</code> 相比，此客户端具有更强的功能性，并且是完全响应性的。
你可以在 {spring-framework-docs}web-reactive.html#webflux-client[Spring Framework文档的专用部分]中了解有关 <code>WebClient</code> 的更多信息。</p>
</div>
<div class="paragraph">
<p>Spring Boot为你创建并预配置了 <code>WebClient.Builder</code>。强烈建议将其注入你的组件中，并使用它来创建 <code>WebClient</code> 实例。
Spring Boot将该builder配置为共享HTTP资源，以与服务器相同的方式反映编解码器的设置
（请参阅<a href="#boot-features-webflux-httpcodecs">WebFlux HTTP codecs自动配置</a>），等等。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name)
                        .retrieve().bodyToMono(Details.class);
    }

}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient-runtime">15.1. WebClient运行时</h3>
<div class="paragraph">
<p>Spring Boot将根据应用程序类路径上可用的库自动检测要使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>。
目前支持Reactor Netty和Jetty RS客户端。</p>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-webflux</code> 启动器默认情况下依赖于 <code>io.projectreactor.netty:reactor-netty</code>，
这带来了服务器和客户端的实现。如果选择使用Jetty作为响应式服务器，则应该添加对Jetty响应式HTTP客户端库
<code>org.eclipse.jetty:jetty-reactive-httpclient</code> 的依赖。
对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>JettyResourceFactory</code> 或 <code>ReactorResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>如果你希望为客户端覆盖该选项，则可以定义自己的 <code>ClientHttpConnector</code> bean，并完全控制客户端配置。</p>
</div>
<div class="paragraph">
<p>你可以 {spring-framework-docs}web-reactive.html#webflux-client-builder[在Spring Framework参考文档中了解有关 <code>WebClient</code> 配置选项]的更多信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient-customization">15.2. WebClient自定义</h3>
<div class="paragraph">
<p><code>WebClient</code> 自定义有三种主要方法，具体取决于你希望自定义应用的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>WebClient.Builder</code>，然后根据需要调用其方法。
<code>WebClient.Builder</code> 实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。
如果要使用同一构建器创建多个客户端，则还可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆该构建器。</p>
</div>
<div class="paragraph">
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用程序作用域的附加自定义，可以声明 <code>WebClientCustomizer</code> bean
并在注入点本地更改 <code>WebClient.Builder</code>。</p>
</div>
<div class="paragraph">
<p>最后，你可以回退到原始API并使用 <code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或 <code>WebClientCustomizer</code>。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-validation">16. 验证</h2>
<div class="sectionbody">
<div class="paragraph">
<p>只要JSR-303实现（例如：Hibernate验证器）位于类路径上，就会自动启用Bean验证1.1支持的方法验证功能。
这使bean方法的参数和/或返回值可以使用 <code>javax.validation</code> 约束进行注解。
具有此类注解方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行注释，以便在其方法中搜索内联约束注解。</p>
</div>
<div class="paragraph">
<p>例如：以下服务触发第一个参数的验证，确保其大小在8到10之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
@Validated
public class MyBean {

    public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
            Author author) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-email">17. 发送邮件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Framework通过使用 <code>JavaMailSender</code> 接口提供了用于发送电子邮件的简单抽象，Spring Boot为它提供了自动配置以及starter模块。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关如何使用 <code>JavaMailSender</code> 的详细说明，请参见 {spring-framework-docs}integration.html#mail[参考文档]。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>spring.mail.host</code> 和相关库（由 <code>spring-boot-starter-mail</code> 定义）可用，且不存在默认 <code>JavaMailSender</code>，
则创建一个。可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender。
有关更多详细信息，请参见 {spring-boot-autoconfigure-module-code}/mail/MailProperties.java[<code>MailProperties</code>]。</p>
</div>
<div class="paragraph">
<p>特别是，某些默认超时值是无限的，你可能需要更改此值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=3000
spring.mail.properties.mail.smtp.writetimeout=5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用来自JNDI的现有 <code>Session</code> 配置 <code>JavaMailSender</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.jndi-name=mail/Session</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置 <code>jndi-name</code> 时，它优先于所有其他与Session相关的其他设置。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-jta">18. JTA的分布式事务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过使用 <a href="https://www.atomikos.com/">Atomikos</a>或 <a href="https://github.com/bitronix/btm">Bitronix</a>嵌入式事务管理器，
Spring Boot支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE应用程序服务器时，还支持JTA事务。</p>
</div>
<div class="paragraph">
<p>当检测到JTA环境时，将使用Spring的 <code>JtaTransactionManager</code> 来管理事务。
自动配置的JMS，DataSource和JPA Bean已升级为支持XA事务。
你可以使用标准的Spring习惯用法（例如：<code>@Transactional</code>）来参与分布式事务。
如果你在JTA环境中，并且仍要使用本地事务，则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用JTA自动配置。</p>
</div>
<div class="sect2">
<h3 id="boot-features-jta-atomikos">18.1. 使用Atomikos事务管理器</h3>
<div class="paragraph">
<p><a href="https://www.atomikos.com/">Atomikos</a>是一种流行的开源事务管理器，可以嵌入到你的Spring Boot应用程序中。
你可以使用 <code>spring-boot-starter-jta-atomikos</code> 启动器引入相应的Atomikos库。
Spring Boot自动配置Atomikos，并确保将适当的 <code>depends-on</code> 设置应用于Spring Bean，以实现正确的启动和关闭顺序。</p>
</div>
<div class="paragraph">
<p>默认情况下，Atomikos事务日志将写入应用程序主目录（应用程序jar文件所在的目录）中的 <code>transaction-logs</code> 目录。
你可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。
以 <code>spring.jta.atomikos.properties</code> 开头的属性也可以用于自定义Atomikos <code>UserTransactionServiceImp</code>。
有关完整的详细信息，请参见 {spring-boot-module-api}/jta/atomikos/AtomikosProperties.html[<code>AtomikosProperties</code> Javadoc]。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Atomikos实例配置一个唯一的ID。
默认情况下，此ID是运行Atomikos的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-bitronix">18.2. 使用Bitronix事务管理器</h3>
<div class="paragraph">
<p><a href="https://github.com/bitronix/btm">Bitronix</a>是流行的开源JTA事务管理器实现。
你可以使用 <code>spring-boot-starter-jta-bitronix</code> 启动器将适当的Bitronix依赖项添加到项目中。
与Atomikos一样，Spring Boot自动配置Bitronix并对你的bean进行后处理，以确保启动和关闭顺序正确。</p>
</div>
<div class="paragraph">
<p>默认情况下，Bitronix事务日志文件（<code>part1.btm</code> 和 <code>part2.btm</code>）被写入应用程序主目录中的 <code>transaction-logs</code> 目录。
你可以通过设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。以 <code>spring.jta.bitronix.properties</code>
开头的属性也绑定到 <code>bitronix.tm.Configuration</code> Bean，从而可以进行完全自定义。
有关详细信息，请参见 <a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix文档</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Bitronix实例配置唯一的ID。
默认情况下，此ID是运行Bitronix的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-javaee">18.3. 使用Java EE托管事务管理器</h3>
<div class="paragraph">
<p>如果将Spring Boot应用程序打包为 <code>war</code> 或 <code>ear</code> 文件，并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。
Spring Boot通过查看常见的JNDI位置（<code>java:comp/UserTransaction</code>, <code>java:comp/TransactionManager</code> 等）来尝试自动配置事务管理器。
如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。
Spring Boot尝试通过在JNDI路径（<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>）中查找 <code>ConnectionFactory</code> 来自动配置JMS，
并且你可以使用 <a href="#boot-features-connecting-to-a-jndi-datasource"><code>spring.datasource.jndi-name</code> 属性</a>配置你的 <code>DataSource</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-mixed-jms">18.4. 混合XA和非XA JMS连接</h3>
<div class="paragraph">
<p>使用JTA时，主要的JMS <code>ConnectionFactory</code> bean是XA-aware，并参与分布式事务。
在某些情况下，你可能想通过使用非XA <code>ConnectionFactory</code> 处理某些JMS消息。
例如：你的JMS处理逻辑可能需要比XA超时更长的时间。</p>
</div>
<div class="paragraph">
<p>如果要使用非XA <code>ConnectionFactory</code>，则可以注入 <code>nonXaJmsConnectionFactory</code> bean，
而不是 <code>@Primary</code> <code>jmsConnectionFactory</code> bean。
为了保持一致性，还可使用bean别名 <code>xaJmsConnectionFactory</code> 提供了 <code>jmsConnectionFactory</code> bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何注入 <code>ConnectionFactory</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Inject the primary (XA aware) ConnectionFactory
@Autowired
private ConnectionFactory defaultConnectionFactory;

// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
@Autowired
@Qualifier("xaJmsConnectionFactory")
private ConnectionFactory xaConnectionFactory;

// Inject the non-XA aware ConnectionFactory
@Autowired
@Qualifier("nonXaJmsConnectionFactory")
private ConnectionFactory nonXaConnectionFactory;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta-supporting-alternative-embedded">18.5. 支持替代嵌入式事务管理器</h3>
<div class="paragraph">
<p>{spring-boot-module-code}/jms/XAConnectionFactoryWrapper.java[<code>XAConnectionFactoryWrapper</code>]和
{spring-boot-module-code}/jdbc/XADataSourceWrapper.java[<code>XADataSourceWrapper</code>]接口可用于支持其他嵌入式事务管理器。
这些接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> Bean，并将它们作为常规的 <code>ConnectionFactory</code> 和
<code>DataSource</code> Bean公开，以透明方式注册分布式事务。如果你在 <code>ApplicationContext</code> 中注册了
<code>JtaTransactionManager</code> bean和适当的XA包装bean，则 <code>DataSource</code> 和JMS自动配置使用JTA变体。</p>
</div>
<div class="paragraph">
<p>{spring-boot-module-code}/jta/bitronix/BitronixXAConnectionFactoryWrapper.java[BitronixXAConnectionFactoryWrapper]和
{spring-boot-module-code}/jta/bitronix/BitronixXADataSourceWrapper.java[BitronixXADataSourceWrapper]
提供了有关如何编写XA包装器的良好示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-hazelcast">19. Hazelcast</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果 <a href="https://hazelcast.com/">Hazelcast</a>位于类路径上，并且找到了合适的配置，
则Spring Boot会自动配置一个 <code>HazelcastInstance</code>，你可以将其注入应用程序中。</p>
</div>
<div class="paragraph">
<p>如果定义 <code>com.hazelcast.config.Config</code> bean，Spring Boot会使用它。
如果你的配置定义了一个实例名称，Spring Boot会尝试查找现有实例，而不是创建一个新实例。</p>
</div>
<div class="paragraph">
<p>你还可以通过配置指定使用的Hazelcast配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.hazelcast.config=classpath:config/my-hazelcast.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>否则，Spring Boot会尝试从默认位置查找Hazelcast配置：
工作目录中或类路径根目录中的 <code>hazelcast.xml</code>，或相同位置中的 <code>.yaml</code> 副本。
我们还检查是否设置了 <code>hazelcast.config</code> 系统属性。有关更多详细信息，请参见
<a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast文档</a>。</p>
</div>
<div class="paragraph">
<p>如果在类路径中存在 <code>hazelcast-client</code>，Spring Boot首先尝试通过检查以下配置选项来创建客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.client.config.ClientConfig</code> bean的存在。</p>
</li>
<li>
<p>由 <code>spring.hazelcast.config</code> 属性定义的配置文件。</p>
</li>
<li>
<p><code>hazelcast.client.config</code> 系统属性的存在。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.xml</code>。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.yaml</code>。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot还具有<a href="#boot-features-caching-provider-hazelcast">对Hazelcast的显式缓存支持</a>。
如果启用了缓存，则 <code>HazelcastInstance</code> 将自动包装在 <code>CacheManager</code> 实现中。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-quartz">20. Quartz调度器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为使用 <a href="https://www.quartz-scheduler.org/">Quartz scheduler</a>提供了许多便利，包括
<code>spring-boot-starter-quartz</code> &#8220;Starter&#8221;。如果Quartz可用，则自动配置 <code>Scheduler</code>（通过 <code>SchedulerFactoryBean</code> 抽象）。</p>
</div>
<div class="paragraph">
<p>以下类型的Bean将自动被拾取并与 <code>Scheduler</code> 关联：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JobDetail</code>: 定义一个特定的Job。
<code>JobDetail</code> 实例可以使用JobBuilder API构建。</p>
</li>
<li>
<p><code>Calendar</code>.</p>
</li>
<li>
<p><code>Trigger</code>: 定义何时触发特定job。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，使用内存中的 <code>JobStore</code>。但是，如果应用程序中有可用的 <code>DataSource</code> bean，并且相应地配置了
<code>spring.quartz.job-store-type</code> 属性，则可以配置基于JDBC的存储，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.job-store-type=jdbc</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JDBC存储时，可以在启动时初始化schema，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
默认情况下，使用Quartz库随附的标准脚本检测并初始化数据库。这些脚本将删除现有表，并在每次重新启动时删除所有触发器。
还可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使Quartz使用应用程序的主 <code>DataSource</code> 以外的 <code>DataSource</code>，
请声明一个 <code>DataSource</code> bean，并用 <code>@QuartzDataSource</code> 注解其 <code>@Bean</code> 方法。
这样可以确保 <code>SchedulerFactoryBean</code> 和Schema初始化都使用特定于Quartz的 <code>DataSource</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过配置创建的jobs将不会覆盖从持久性job存储中读取的已注册jobs。要启用覆盖现有作业定义的功能，
请设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean来定制Quartz Scheduler配置，
这允许以编程方式进行 <code>SchedulerFactoryBean</code> 定制。可以使用 <code>spring.quartz.properties.*</code> 自定义高级Quartz配置属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
特别是，<code>Executor</code> bean没有与调度程序关联，因为Quartz提供了一种通过 <code>spring.quartz.properties</code>
配置调度程序的方法。如果需要自定义任务执行程序，请考虑实现 <code>SchedulerFactoryBeanCustomizer</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jobs可以定义设置器以注入数据映射属性。常规beans也可以用类似的方式注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleJob extends QuartzJobBean {

    private MyService myService;

    private String name;

    // Inject "MyService" bean
    public void setMyService(MyService myService) { ... }

    // Inject the "name" job data property
    public void setName(String name) { ... }

    @Override
    protected void executeInternal(JobExecutionContext context)
            throws JobExecutionException {
        ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-task-execution-scheduling">21. 任务执行和调度</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上下文中没有 <code>Executor</code> bean的情况下，Spring Boot会使用合理的默认值自动配置 <code>ThreadPoolTaskExecutor</code>，
这些默认值可以自动与异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理相关联。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你在上下文中定义一个自定义 <code>Executor</code>，则常规任务执行（即 <code>@EnableAsync</code>）将透明地使用它，
但是Spring MVC支持将不会被配置，因为它需要一个 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>)。
根据你的目标安排，你可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code>，
或者定义一个 <code>ThreadPoolTaskExecutor</code> 和包装自定义 <code>Executor</code> 的 <code>AsyncConfigurer</code>。</p>
</div>
<div class="paragraph">
<p>自动配置的 <code>TaskExecutorBuilder</code> 可让你轻松创建实例，以重用默认情况下自动配置的功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>线程池使用8个核心线程，这些线程可以根据负载增长和收缩。可以使用 <code>spring.task.execution</code> 命名空间微调这些默认设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.task.execution.pool.max-size=16
spring.task.execution.pool.queue-capacity=100
spring.task.execution.pool.keep-alive=10s</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将线程池更改为使用有界队列，以便在队列已满（100个任务）时，线程池最多增加到16个线程。
池的收缩更加激进，因为当线程空闲10秒（而不是默认情况下的60秒）时，它们将被回收。</p>
</div>
<div class="paragraph">
<p>如果需要将 <code>ThreadPoolTaskScheduler</code> 与计划的任务执行（<code>@EnableScheduling</code>）关联，也可以对其进行自动配置。
线程池默认使用一个线程，可以使用 <code>spring.task.scheduling</code> 命名空间对这些设置进行微调。</p>
</div>
<div class="paragraph">
<p>如果需要创建自定义执行器或调度器，则可以在上下文中使用 <code>TaskExecutorBuilder</code> bean和 <code>TaskSchedulerBuilder</code> bean。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-integration">22. Spring Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为使用 {spring-integration}[Spring Integration]提供了许多便利，包括
<code>spring-boot-starter-integration</code> “<code>Starter</code>”。
Spring Integration提供消息传递以及其他传输（例如：HTTP，TCP等）的抽象。
如果Spring Integration在你的类路径中可用，则通过 <code>@EnableIntegration</code> 注解对其进行初始化。</p>
</div>
<div class="paragraph">
<p>Spring Boot还配置了一些功能，这些功能由其他Spring Integration模块的存在触发。
如果 <code>spring-integration-jmx</code> 也位于类路径上，则消息处理统计信息将通过JMX发布。
如果 <code>spring-integration-jdbc</code> 可用，则可以在启动时创建默认的数据库schema，如以下行所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.integration.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见 {spring-boot-autoconfigure-module-code}/integration/IntegrationAutoConfiguration.java[<code>IntegrationAutoConfiguration</code>]
和 {spring-boot-autoconfigure-module-code}/integration/IntegrationProperties.java[<code>IntegrationProperties</code>]类。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果存在Micrometer <code>meterRegistry</code> bean，那么Spring Integration指标将由Micrometer管理。
如果你希望使用旧版Spring Integration指标，请将 <code>DefaultMetricsFactory</code> bean添加到应用程序上下文中。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-session">23. Spring Session</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为各种数据存储提供了 {spring-session}[Spring Session]自动配置。在构建Servlet Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDBC</p>
</li>
<li>
<p>Redis</p>
</li>
<li>
<p>Hazelcast</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>构建响应式Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redis</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。
如果你有多个实现，则必须选择要用于存储会话的 {spring-boot-autoconfigure-module-code}/session/StoreType.java[<code>StoreType</code>]。
例如：要将JDBC用作后端存储，可以按以下方式配置应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.store-type=jdbc</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过将 <code>store-type</code> 设置为 <code>none</code> 来禁用Spring Session。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个存储都有特定的附加设置。例如：可以为JDBC存储定制表的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.jdbc.table-name=SESSIONS</code></pre>
</div>
</div>
<div class="paragraph">
<p>要设置会话的超时时间，可以使用 <code>spring.session.timeout</code> 属性。如果未设置该属性，则自动配置将降级到 <code>server.servlet.session.timeout</code> 的值。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-jmx">24. 通过JMX进行监视和管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java Management Extensions (JMX) 提供了监视和管理应用程序的标准机制。
Spring Boot将最合适的 <code>MBeanServer</code> 公开为ID为 <code>mbeanServer</code> 的bean。
带有Spring JMX注解（<code>@ManagedResource</code>，<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>）的任何bean都可以使用它。</p>
</div>
<div class="paragraph">
<p>如果你的平台提供了标准的 <code>MBeanServer</code>，则Spring Boot将使用该标准，并在必要时默认使用VM <code>MBeanServer</code>。
如果所有操作失败，将创建一个新的 <code>MBeanServer</code>。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅 {spring-boot-autoconfigure-module-code}/jmx/JmxAutoConfiguration.java[<code>JmxAutoConfiguration</code>]类。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-testing">25. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>请移步 {spring-boot-test-docs}[这里]。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-websockets">26. WebSockets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供了WebSockets自动配置。
如果将war文件部署到独立容器，Spring Boot会假定该容器负责其WebSocket支持的配置。</p>
</div>
<div class="paragraph">
<p>Spring Framework为MVC Web应用程序提供了 {spring-framework-docs}web.html#websocket[丰富的WebSocket支持]，
可以通过 <code>spring-boot-starter-websocket</code> 模块轻松访问。</p>
</div>
<div class="paragraph">
<p>WebSocket支持也可用于 {spring-framework-docs}web-reactive.html#webflux-websocket[响应式Web应用程序]，
需要在 <code>spring-boot-starter-webflux</code> 旁包含WebSocket API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-webservices">27. Web服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot提供了Web服务自动配置，因此你所要做的就是定义 <code>Endpoints</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>spring-boot-starter-webservices</code> 模块可以轻松访问 {spring-webservices-docs}[Spring Web Services功能]。</p>
</div>
<div class="paragraph">
<p>可以分别为你的WSDL和XSD自动创建 <code>SimpleWsdl11Definition</code> 和 <code>SimpleXsdSchema</code> Bean。为此请配置其位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webservices.wsdl-locations=classpath:/wsdl</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webservices-template">27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</h3>
<div class="paragraph">
<p>如果需要从应用程序中调用远程Web服务，则可以使用 {spring-webservices-docs}#client-web-service-template[<code>WebServiceTemplate</code>]类。
由于 <code>WebServiceTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>WebServiceTemplate</code> bean。
但是，它会自动配置 <code>WebServiceTemplateBuilder</code>，可在需要时将其用于创建 <code>WebServiceTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebServiceTemplate webServiceTemplate;

    public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
        this.webServiceTemplate = webServiceTemplateBuilder.build();
    }

    public DetailsResp someWsCall(DetailsReq detailsReq) {
         return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>WebServiceTemplateBuilder</code> 使用类路径上的可用HTTP客户端库来检测合适的基于HTTP的 <code>WebServiceMessageSender</code>。
你还可以像下面那样自定义读取和连接超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
    return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(5000).setReadTimeout(2000).build()).build();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-developing-auto-configuration">28. 创建自己的自动配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，并且仍由Spring Boot拾取。</p>
</div>
<div class="paragraph">
<p>自动配置可以与“<code>starter</code>”相关联，该“<code>starter</code>”提供自动配置代码以及你将使用的典型库。
我们首先介绍构建自己的自动配置所需的知识，然后继续介绍<a href="#boot-features-custom-starter">创建自定义启动器所需的典型步骤</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有一个 <a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">demo项目</a>可以展示如何逐步创建starter。
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="boot-features-understanding-auto-configured-beans">28.1. 了解自动配置的Bean</h3>
<div class="paragraph">
<p>在后台，自动配置是通过标准 <code>@Configuration</code> 类实现的。其他 <code>@Conditional</code> 注解用于约束何时应应用自动配置。
通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。
这样可以确保仅当找到相关的类并且没有声明自己的 <code>@Configuration</code> 时，才应用自动配置。</p>
</div>
<div class="paragraph">
<p>你可以浏览 {spring-boot-autoconfigure-module-code}[<code>spring-boot-autoconfigure</code>]的源代码以查看Spring提供的
<code>@Configuration</code> 类（请参阅 {spring-boot-code}/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories[<code>META-INF/spring.factories</code>]文件）。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-locating-auto-configuration-candidates">28.2. 查找自动配置候选人</h3>
<div class="paragraph">
<p>Spring Boot检查发布的jar中是否存在 <code>META-INF/spring.factories</code> 文件。
该文件应在 <code>EnableAutoConfiguration</code> 键下列出你的配置类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
自动配置 <em>只能</em> 以这种方式加载。
确保在特定的程序包空间中定义它们，并且决不要将它们作为组件扫描的目标。
此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的 <code>@Imports</code> 代替。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果需要按特定顺序应用配置，则可以使用 {spring-boot-autoconfigure-module-code}/AutoConfigureAfter.java[<code>@AutoConfigureAfter</code>]或
{spring-boot-autoconfigure-module-code}/AutoConfigureBefore.java[<code>@AutoConfigureBefore</code>]注解。
例如：如果你提供特定于Web的配置，则可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用你的类。</p>
</div>
<div class="paragraph">
<p>如果要排序某些彼此之间不具有任何直接了解的自动配置，则也可以使用 <code>@AutoConfigureOrder</code>。
该注解与常规 <code>@Order</code> 注解具有相同的语义，但为自动配置类提供了专用的顺序。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-condition-annotations">28.3. 条件注解</h3>
<div class="paragraph">
<p>你几乎总是希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解。
<code>@ConditionalOnMissingBean</code> 注解是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含许多 <code>@Conditional</code> 注解，你可以通过标注 <code>@Configuration</code> 类或单个 <code>@Bean</code> 方法在自己的代码中重用它。
这些注解包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#boot-features-class-conditions">Class条件</a></p>
</li>
<li>
<p><a href="#boot-features-bean-conditions">Bean条件</a></p>
</li>
<li>
<p><a href="#boot-features-property-conditions">Property条件</a></p>
</li>
<li>
<p><a href="#boot-features-resource-conditions">Resource条件</a></p>
</li>
<li>
<p><a href="#boot-features-web-application-conditions">Web应用条件</a></p>
</li>
<li>
<p><a href="#boot-features-spel-conditions">SpEL表达式条件</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="boot-features-class-conditions">28.3.1. Class条件</h4>
<div class="paragraph">
<p>通过 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解，可以根据是否存在特定类来包含 <code>@Configuration</code> 类。
由于注解元数据是通过使用 <a href="https://asm.ow2.org/">ASM</a>进行解析的，因此即使该类可能实际上未出现在正在运行的应用程序类路径上，
你也可以使用 <code>value</code> 属性来引用真实的类。如果你更喜欢通过使用 <code>String</code> 值来指定类名称，则也可以使用 <code>name</code> 属性。</p>
</div>
<div class="paragraph">
<p>这种机制不适用于通常将返回类型作为该条件目标的 <code>@Bean</code> 方法：在方法上的条件应用之前，JVM将加载该类和可能处理的方法引用，如果类不存在，这些引用将失败。</p>
</div>
<div class="paragraph">
<p>为了处理这种情况，可以使用单独的 <code>@Configuration</code> 类隔离条件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
// Some conditions
public class MyAutoConfiguration {

    // Auto-configured beans

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(EmbeddedAcmeService.class)
    static class EmbeddedConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public EmbeddedAcmeService embeddedAcmeService() { ... }

    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果在元注解中使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 来组成自己的组合注解，
则在不处理这种情况下，必须使用 <code>name</code> 来引用该类。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-bean-conditions">28.3.2. Bean条件</h4>
<div class="paragraph">
<p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据是否存在特定bean来包含bean。
你可以使用 <code>value</code> 属性按类型指定bean或使用 <code>name</code> 属性按名称指定bean。
<code>search</code> 属性使你可以限制在搜索bean时应考虑的 <code>ApplicationContext</code> 层次结构。</p>
</div>
<div class="paragraph">
<p>当放置在 <code>@Bean</code> 方法上时，目标类型默认为该方法的返回类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public MyService myService() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>ApplicationContext</code> 中没有包含 <code>MyService</code> 类型的bean，将创建 <code>myService</code> bean。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你要特别注意添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容来评估的。
出于这个原因，我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解
（因为可以保证在添加任何用户定义的bean定义后加载它们）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类。
在类级别使用这些条件与使用注解标记每个包含的 <code>@Bean</code> 方法之间的唯一区别是，如果条件不匹配，则前者会阻止将 <code>@Configuration</code> 类注册为bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-property-conditions">28.3.3. Property条件</h4>
<div class="paragraph">
<p><code>@ConditionalOnProperty</code> 注解允许基于Spring <code>Environment</code> 属性包含的配置，使用 <code>prefix</code> 和 <code>name</code> 属性指定应检查的属性。
默认情况下，将匹配存在且不等于 <code>false</code> 的任何属性。你也可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性来创建更高级的检查。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-resource-conditions">28.3.4. Resource条件</h4>
<div class="paragraph">
<p><code>@ConditionalOnResource</code> 注解仅在存在特定资源时才包含配置。可以使用常规的Spring约定来指定资源，
如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-web-application-conditions">28.3.5. Web应用条件</h4>
<div class="paragraph">
<p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为“Web应用程序”来包含配置。
基于Servlet的Web应用程序是使用Spring <code>WebApplicationContext</code>，定义 <code>session</code> 作用域或具有 <code>ConfigurableWebEnvironment</code> 的任何应用程序。
响应式Web应用程序是使用 <code>ReactiveWebApplicationContext</code> 或具有 <code>ConfigurableReactiveWebEnvironment</code> 的任何应用程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-spel-conditions">28.3.6. SpEL表达式条件</h4>
<div class="paragraph">
<p><code>@ConditionalOnExpression</code> 注解允许基于 {spring-framework-docs}core.html#expressions[SpEL表达式]的结果来包含配置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-test-autoconfig">28.4. 测试你的自动配置</h3>
<div class="paragraph">
<p>自动配置可能受许多因素影响：用户配置（<code>@Bean</code> 定义和 <code>Environment</code> 自定义），条件评估（存在特定库）以及其他因素。
具体而言，每个测试都应创建定义良好的 <code>ApplicationContext</code>，以表示这些自定义项的组合。
<code>ApplicationContextRunner</code> 提供了一种实现此目标的好方法。</p>
</div>
<div class="paragraph">
<p>通常将 <code>ApplicationContextRunner</code> 定义为测试类的字段，以收集基本的通用配置。
下面的示例确保始终调用 <code>UserServiceAutoConfiguration</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个测试都可以使用运行器来表示特定的用例。例如：下面的示例调用一个用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退出。
调用 <code>run</code> 提供了可与 <code>Assert4J</code> 一起使用的回调上下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void defaultServiceBacksOff() {
    this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context).getBean("myUserService").isSameAs(context.getBean(UserService.class));
    });
}

@Configuration(proxyBeanMethods = false)
static class UserConfiguration {

    @Bean
    UserService myUserService() {
        return new UserService("mine");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以轻松自定义 <code>Environment</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceNameCanBeConfigured() {
    this.contextRunner.withPropertyValues("user.name=test123").run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context.getBean(UserService.class).getName()).isEqualTo("test123");
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行器还可以用于显示 <code>ConditionEvaluationReport</code>。
可以以 <code>INFO</code> 或 <code>DEBUG</code> 级别打印报告。以下示例显示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
public void autoConfigTest {
    ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
            LogLevel.INFO);
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withInitializer(initializer).run((context) -&gt; {
                    // Do something...
            });
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_模拟一个web上下文">28.4.1. 模拟一个Web上下文</h4>
<div class="paragraph">
<p>如果你需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用
<code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_覆盖类路径">28.4.2. 覆盖类路径</h4>
<div class="paragraph">
<p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。
Spring Boot附带有 <code>FilteredClassLoader</code>，运行器可以轻松使用。
在以下示例中，我们断言，如果不存在 <code>UserService</code>，则会自动禁用自动配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceIsIgnoredIfLibraryIsNotPresent() {
    this.contextRunner.withClassLoader(new FilteredClassLoader(UserService.class))
            .run((context) -&gt; assertThat(context).doesNotHaveBean("userService"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-custom-starter">28.5. 创建自己的Starter</h3>
<div class="paragraph">
<p>一个库的完整Spring Boot starter可能包含以下组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>autoconfigure</code> 模块：包含自动配置代码。</p>
</li>
<li>
<p><code>starter</code> 模块：提供对 <code>autoconfigure</code> 模块以及其库的依赖，和通常有用的任何其他依赖项。
简而言之，添加starter应提供开始使用该库所需的一切。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不需要将这两个问题分开，则可以将自动配置代码和依赖管理组合在一起。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-naming">28.5.1. 命名</h4>
<div class="paragraph">
<p>你应该确保为启动器提供适当的命名空间。即使你使用其他Maven <code>groupId</code>，也不要以 <code>spring-boot</code> 开头模块名称。
将来，我们可能会为你自动配置的内容提供官方支持。</p>
</div>
<div class="paragraph">
<p>根据经验，你应该在启动器后命名一个组合模块。例如：假设你要为“acme”创建starter，
并命名自动配置模块 <code>acme-spring-boot-autoconfigure</code> 和启动器 <code>acme-spring-boot-starter</code>。
如果只有一个模块将两者结合在一起，则将其命名为 <code>acme-spring-boot-starter</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-configuration-keys">28.5.2. 配置键</h4>
<div class="paragraph">
<p>如果你的starter提供了配置键，请为其使用唯一的命名空间。
特别是，不要将键包含在Spring Boot使用的名称空间中（例如：<code>server</code>, <code>management</code>, <code>spring</code> 等）。
如果使用相同的命名空间，将来我们可能会以破坏模块的方式修改这些命名空间。
根据经验，所有键都必须拥有自己的命名空间（例如：<code>acme</code>）。</p>
</div>
<div class="paragraph">
<p>通过为每个属性添加字段javadoc来确保文档化配置键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    /**
     * Whether to check the location of acme resources.
     */
    private boolean checkLocation = true;

    /**
     * Timeout for establishing a connection to the acme server.
     */
    private Duration loginTimeout = Duration.ofSeconds(3);

    // getters &amp; setters

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你仅应将简单文本与 <code>@ConfigurationProperties</code> 字段Javadoc一起使用，因为在将它们添加到JSON之前不会对其进行处理。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这是我们内部遵循的一些规则，以确保描述一致：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请勿以“The”或“A”开头描述。</p>
</li>
<li>
<p>对于 <code>boolean</code> 类型，请以“Whether”或“Enable”开始描述。</p>
</li>
<li>
<p>对于基于集合的类型，请以“Comma-separated list”开始描述。</p>
</li>
<li>
<p>使用 <code>java.time.Duration</code> 而不是 <code>long</code>，如果它不为毫秒，请描述默认单位，例如：“If a duration suffix is not specified, seconds will be used”。</p>
</li>
<li>
<p>除非必须在运行时确定默认值，否则请不要在描述中提供默认值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保<a href="appendix-configuration-metadata.html#configuration-metadata-annotation-processor">触发元数据生成</a>，
以便IDE助手也可用于你的键。你可能需要查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>），
以确保正确记录了你的键。在兼容的IDE中使用自己的starter也是验证元数据质量的好主意。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-module-autoconfigure">28.5.3. <code>autoconfigure</code> 模块</h4>
<div class="paragraph">
<p><code>autoconfigure</code> 模块包含开始使用该库所需的所有内容。它还可能包含配置键定义（例如：<code>@ConfigurationProperties</code>）
和可用于进一步自定义组件初始化方式的任何回调接口。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你应该将对库的依赖项标记为optional，以便可以更轻松地在项目中包括 <code>autoconfigure</code> 模块。
如果这样做，则不提供该库，并且默认情况下，Spring Boot会回退。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot使用注解处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。
如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.5及更早版本，应在配置中使用 <code>compileOnly</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.6和更高版本，应在配置中使用 <code>annotationProcessor</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter-module-starter">28.5.4. starter模块</h4>
<div class="paragraph">
<p>Starter确实是一个空jar。其唯一目的是提供必要的依赖关系以使用库。你可以将其视为对入门所需。</p>
</div>
<div class="paragraph">
<p>不要对添加了启动器的项目做任何假设。如果你要自动配置的库通常需要其他启动器，请同时提及它们。
如果可选依赖项的数量很高，则提供一组适当的 <em>默认</em> 依赖项可能会很困难，因此你应该避免包括对于库的典型用法不必要的依赖项。
换句话说，你不应包括可选的依赖项。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无论哪种方式，你的starter都必须直接或间接引用（即如果你的starter依赖于另一个starter，则无需添加它）
核心Spring Boot starter（<code>spring-boot-starter</code>）。如果仅使用你的自定义starter创建项目，
则会通过使用该核心starter来支持Spring Boot的核心功能。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features-whats-next">29. 接下来要读什么</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你想了解有关本节中讨论的任何类的更多信息，可以查看 {spring-boot-api}[Spring Boot API文档]或
{spring-boot-code}[直接浏览源代码]。</p>
</div>
<div class="paragraph">
<p>如果你有特定问题，请查看 {spring-boot-docs}/htmlsingle/#howto[how-to]部分。</p>
</div>
<div class="paragraph">
<p>如果你对Spring Boot的核心功能感到满意，则可以继续阅读有关
{spring-boot-docs}/htmlsingle/#production-ready-endpoints[生产就绪功能]的信息。</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>