<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Version 5.2.2.RELEASE">
<title>基于Reactive栈的Web</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body id="spring-webflux" class="book toc2 toc-left">
<div id="header">
<h1>基于Reactive栈的Web</h1>
<div class="details">
<span id="author" class="author">Version 5.2.2.RELEASE</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#webflux">1. Spring WebFlux</a>
<ul class="sectlevel2">
<li><a href="#webflux-new-framework">1.1. 总览</a>
<ul class="sectlevel3">
<li><a href="#webflux-why-reactive">1.1.1. 定义 &#8220;Reactive&#8221;</a></li>
<li><a href="#webflux-reactive-api">1.1.2. Reactive API</a></li>
<li><a href="#webflux-programming-models">1.1.3. 编程模型</a></li>
<li><a href="#webflux-framework-choice">1.1.4. 适用性</a></li>
<li><a href="#webflux-server-choice">1.1.5. 服务器</a></li>
<li><a href="#webflux-performance">1.1.6. 性能</a></li>
<li><a href="#webflux-concurrency-model">1.1.7. 并发模型</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-spring-web">1.2. Reactive核心</a>
<ul class="sectlevel3">
<li><a href="#webflux-httphandler">1.2.1. <code>HttpHandler</code></a></li>
<li><a href="#webflux-web-handler-api">1.2.2. <code>WebHandler</code> API</a>
<ul class="sectlevel4">
<li><a href="#webflux-web-handler-api-special-beans">特殊bean类型</a></li>
<li><a href="#webflux-form-data">表单数据</a></li>
<li><a href="#webflux-multipart">Multipart数据</a></li>
<li><a href="#webflux-forwarded-headers">Forwarded请求头</a></li>
</ul>
</li>
<li><a href="#webflux-filters">1.2.3. 过滤器</a>
<ul class="sectlevel4">
<li><a href="#webflux-filters-cors">CORS</a></li>
</ul>
</li>
<li><a href="#webflux-exception-handler">1.2.4. 异常</a></li>
<li><a href="#webflux-codecs">1.2.5. 编解码器</a>
<ul class="sectlevel4">
<li><a href="#webflux-codecs-jackson">Jackson JSON</a></li>
<li><a href="#webflux-codecs-forms">表单数据</a></li>
<li><a href="#webflux-codecs-multipart">Multipart</a></li>
<li><a href="#webflux-codecs-limits">限制</a></li>
<li><a href="#webflux-codecs-streaming">Streaming</a></li>
<li><a href="#webflux-codecs-buffers"><code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#webflux-logging">1.2.6. 日志</a>
<ul class="sectlevel4">
<li><a href="#webflux-logging-id">日志Id</a></li>
<li><a href="#webflux-logging-sensitive-data">敏感数据</a></li>
<li><a href="#webflux-codecs-custom">自定义编解码器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">1.3. <code>DispatcherHandler</code></a>
<ul class="sectlevel3">
<li><a href="#webflux-special-bean-types">1.3.1. 特殊Bean类型</a></li>
<li><a href="#webflux-framework-config">1.3.2. WebFlux配置</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">1.3.3. 处理过程</a></li>
<li><a href="#webflux-resulthandling">1.3.4. 结果处理</a></li>
<li><a href="#webflux-dispatcher-exceptions">1.3.5. 异常</a></li>
<li><a href="#webflux-viewresolution">1.3.6. 视图解析</a>
<ul class="sectlevel4">
<li><a href="#webflux-viewresolution-handling">处理过程</a></li>
<li><a href="#webflux-redirecting-redirect-prefix">重定向</a></li>
<li><a href="#webflux-multiple-representations">内容协商</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-controller">1.4. 带注解的控制器</a>
<ul class="sectlevel3">
<li><a href="#webflux-ann-controller">1.4.1. <code>@Controller</code></a></li>
<li><a href="#webflux-ann-requestmapping">1.4.2. 请求映射</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-requestmapping-uri-templates">URI模式</a></li>
<li><a href="#webflux-ann-requestmapping-pattern-comparison">模式比较</a></li>
<li><a href="#webflux-ann-requestmapping-consumes">可消费的媒体类型</a></li>
<li><a href="#webflux-ann-requestmapping-produces">可生产的媒体类型</a></li>
<li><a href="#webflux-ann-requestmapping-params-and-headers">请求参数，请求头</a></li>
<li><a href="#webflux-ann-requestmapping-head-options">HTTP HEAD, OPTIONS</a></li>
<li><a href="#webflux-ann-requestmapping-composed">自定义注解</a></li>
<li><a href="#webflux-ann-requestmapping-registration">显式注册</a></li>
</ul>
</li>
<li><a href="#webflux-ann-methods">1.4.3. 处理程序方法</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-arguments">Method Arguments</a></li>
<li><a href="#webflux-ann-return-types">Return Values</a></li>
<li><a href="#webflux-ann-typeconversion">Type Conversion</a></li>
<li><a href="#webflux-ann-matrix-variables">Matrix Variables</a></li>
<li><a href="#webflux-ann-requestparam"><code>@RequestParam</code></a></li>
<li><a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a></li>
<li><a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a></li>
<li><a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a></li>
<li><a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a></li>
<li><a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a></li>
<li><a href="#webflux-multipart-forms">Multipart Content</a></li>
<li><a href="#webflux-ann-requestbody"><code>@RequestBody</code></a></li>
<li><a href="#webflux-ann-httpentity"><code>HttpEntity</code></a></li>
<li><a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a></li>
<li><a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a></li>
<li><a href="#webflux-ann-jackson">Jackson JSON</a></li>
</ul>
</li>
<li><a href="#webflux-ann-modelattrib-methods">1.4.4. <code>Model</code></a></li>
<li><a href="#webflux-ann-initbinder">1.4.5. <code>DataBinder</code></a></li>
<li><a href="#webflux-ann-controller-exceptions">1.4.6. 管理异常</a>
<ul class="sectlevel4">
<li><a href="#webflux-ann-rest-exceptions">REST API异常</a></li>
</ul>
</li>
<li><a href="#webflux-ann-controller-advice">1.4.7. 控制器通知</a></li>
</ul>
</li>
<li><a href="#webflux-fn">1.5. 函数式端点</a>
<ul class="sectlevel3">
<li><a href="#webflux-fn-overview">1.5.1. 概览</a></li>
<li><a href="#webflux-fn-handler-functions">1.5.2. HandlerFunction</a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-request"><code>ServerRequest</code></a></li>
<li><a href="#webflux-fn-response"><code>ServerResponse</code></a></li>
<li><a href="#webflux-fn-handler-classes">处理程序类</a></li>
<li><a href="#webflux-fn-handler-validation">验证</a></li>
</ul>
</li>
<li><a href="#webflux-fn-router-functions">1.5.3. <code>RouterFunction</code></a>
<ul class="sectlevel4">
<li><a href="#webflux-fn-predicates">谓词</a></li>
<li><a href="#webflux-fn-routes">路由</a></li>
<li><a href="#嵌套路由">嵌套路由</a></li>
</ul>
</li>
<li><a href="#webflux-fn-running">1.5.4. 运行服务器</a></li>
<li><a href="#webflux-fn-handler-filter-function">1.5.5. 过滤处理程序函数</a></li>
</ul>
</li>
<li><a href="#webflux-uri-building">1.6. URI链接</a>
<ul class="sectlevel3">
<li><a href="#web-uricomponents">1.6.1. UriComponents</a></li>
<li><a href="#web-uribuilder">1.6.2. UriBuilder</a></li>
<li><a href="#web-uri-encoding">1.6.3. URI编码</a></li>
</ul>
</li>
<li><a href="#webflux-cors">1.7. CORS</a>
<ul class="sectlevel3">
<li><a href="#webflux-cors-intro">1.7.1. 介绍</a></li>
<li><a href="#webflux-cors-processing">1.7.2. 处理过程</a></li>
<li><a href="#webflux-cors-controller">1.7.3. <code>@CrossOrigin</code></a></li>
<li><a href="#webflux-cors-global">1.7.4. 全局配置</a></li>
<li><a href="#webflux-cors-webfilter">1.7.5. CORS <code>WebFilter</code></a></li>
</ul>
</li>
<li><a href="#webflux-web-security">1.8. Web安全</a></li>
<li><a href="#webflux-view">1.9. 视图技术</a>
<ul class="sectlevel3">
<li><a href="#webflux-view-thymeleaf">1.9.1. Thymeleaf</a></li>
<li><a href="#webflux-view-freemarker">1.9.2. FreeMarker</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-freemarker-contextconfig">视图配置</a></li>
<li><a href="#webflux-views-freemarker">FreeMarker配置</a></li>
<li><a href="#webflux-view-freemarker-forms">表单处理</a></li>
</ul>
</li>
<li><a href="#webflux-view-script">1.9.3. 脚本视图</a>
<ul class="sectlevel4">
<li><a href="#webflux-view-script-dependencies">要求</a></li>
<li><a href="#webflux-view-script-integrate">脚本模板</a></li>
</ul>
</li>
<li><a href="#webflux-view-httpmessagewriter">1.9.4. JSON和XML</a></li>
</ul>
</li>
<li><a href="#webflux-caching">1.10. HTTP缓存</a>
<ul class="sectlevel3">
<li><a href="#webflux-caching-cachecontrol">1.10.1. <code>CacheControl</code></a></li>
<li><a href="#webflux-caching-etag-lastmodified">1.10.2. 控制器</a></li>
<li><a href="#webflux-caching-static-resources">1.10.3. 静态资源</a></li>
</ul>
</li>
<li><a href="#webflux-config">1.11. WebFlux配置</a>
<ul class="sectlevel3">
<li><a href="#webflux-config-enable">1.11.1. 启用WebFlux配置</a></li>
<li><a href="#webflux-config-customize">1.11.2. WebFlux配置API</a></li>
<li><a href="#webflux-config-conversion">1.11.3. 转换，格式化</a></li>
<li><a href="#webflux-config-validation">1.11.4. 检验</a></li>
<li><a href="#webflux-config-content-negotiation">1.11.5. 内容类型解析器</a></li>
<li><a href="#webflux-config-message-codecs">1.11.6. HTTP消息编解码器</a></li>
<li><a href="#webflux-config-view-resolvers">1.11.7. 视图解析器</a></li>
<li><a href="#webflux-config-static-resources">1.11.8. 静态资源</a></li>
<li><a href="#webflux-config-path-matching">1.11.9. 路径匹配</a></li>
<li><a href="#webflux-config-advanced-java">1.11.10. 高级配置模式</a></li>
</ul>
</li>
<li><a href="#webflux-http2">1.12. HTTP/2</a></li>
</ul>
</li>
<li><a href="#webflux-client">2. WebClient</a>
<ul class="sectlevel2">
<li><a href="#webflux-client-builder">2.1. 配置</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-builder-maxinmemorysize">2.1.1. MaxInMemorySize</a></li>
<li><a href="#webflux-client-builder-reactor">2.1.2. Reactor Netty</a>
<ul class="sectlevel4">
<li><a href="#webflux-client-builder-reactor-resources">资源</a></li>
<li><a href="#webflux-client-builder-reactor-timeout">超时</a></li>
</ul>
</li>
<li><a href="#webflux-client-builder-jetty">2.1.3. Jetty</a></li>
</ul>
</li>
<li><a href="#webflux-client-retrieve">2.2. <code>retrieve()</code></a></li>
<li><a href="#webflux-client-exchange">2.3. <code>exchange()</code></a></li>
<li><a href="#webflux-client-body">2.4. 请求体</a>
<ul class="sectlevel3">
<li><a href="#webflux-client-body-form">2.4.1. 表单数据</a></li>
<li><a href="#webflux-client-body-multipart">2.4.2. Multipart数据</a></li>
</ul>
</li>
<li><a href="#webflux-client-filter">2.5. 客户端过滤器</a></li>
<li><a href="#webflux-client-synchronous">2.6. 同步使用</a></li>
<li><a href="#webflux-client-testing">2.7. 测试</a></li>
</ul>
</li>
<li><a href="#webflux-test">3. 测试</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>文档的此部分涵盖对基于 <a href="http://www.reactive-streams.org/">Reactive Streams</a> API构建的响应式Web应用程序的支持，
该应用程序可在非阻塞服务器（例如：Netty，Undertow和Servlet 3.1+容器）上运行。各个章节涵盖了<a href="#webflux">Spring WebFlux</a>框架，
响应式<a href="#webflux-client"><code>WebClient</code></a>，对<a href="#webflux-test">测试</a>的支持以及<a href="#webflux-reactive-libraries">响应式库</a>。
对于Servlet Web应用程序，请参阅<a href="spring-mvc.html#spring-web">基于Servlet栈的Web</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux"><a class="anchor" href="#webflux"></a>1. Spring WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring框架中包含的原始Web框架Spring Web MVC是专门为Servlet API和Servlet容器而构建的。
响应式栈Web框架Spring WebFlux在更高版本5.0中添加。它是完全非阻塞的，
支持 <a href="http://www.reactive-streams.org/">Reactive Streams</a>背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。</p>
</div>
<div class="paragraph">
<p>这两个Web框架都反映了其源模块的名称
(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a> 和
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>)，
并在Spring Framework中并存。每个模块都是可选的。应用程序可以使用一个模块或另一个模块，或者在某些情况下同时使用这两个模块，
例如：带有响应式 <code>WebClient</code> 的Spring MVC控制器。</p>
</div>
<div class="sect2">
<h3 id="webflux-new-framework"><a class="anchor" href="#webflux-new-framework"></a>1.1. 总览</h3>
<div class="paragraph">
<p>为什么创建Spring WebFlux？</p>
</div>
<div class="paragraph">
<p>答案的一部分是需要一个非阻塞式的Web堆栈来处理少量线程的并发并使用更少的硬件资源进行扩展。
Servlet 3.1确实提供了用于非阻塞I/O的API。但是，使用它与Servlet API的其他部分不同，
后者的契约是同步的（<code>Filter</code>，<code>Servlet</code>）或阻塞的（<code>getParameter</code>，<code>getPart</code>）。
这是促使新的通用API成为所有非阻塞运行时的基础的动机。
这一点很重要，因为服务器（例如Netty）已在异步，非阻塞空间中得到了良好的建立。</p>
</div>
<div class="paragraph">
<p>答案的另一部分是函数式编程。就像在Java 5中添加注解会创造机会（例如：带注解的REST控制器或单元测试）一样，
在Java 8中添加lambda表达式也会为Java中的函数式API创造机会。这对于非阻塞的应用程序和流式API
（如由 <code>CompletableFuture</code> 和 <a href="http://reactivex.io/">ReactiveX</a>普及的API）来说是一个福音，这些API允许以声明方式组合异步逻辑。
在编程模型级别，Java 8使Spring WebFlux能够与带注解的控制器一起提供函数式的Web端点。</p>
</div>
<div class="sect3">
<h4 id="webflux-why-reactive"><a class="anchor" href="#webflux-why-reactive"></a>1.1.1. 定义 &#8220;Reactive&#8221;</h4>
<div class="paragraph">
<p>我们谈到了“非阻塞”和“函数式”，但是响应式意味着什么？</p>
</div>
<div class="paragraph">
<p>术语“响应式”是指围绕对变更做出响应的编程模型&#8212;&#8203;网络组件对I/O事件做出响应，UI控制器对鼠标事件做出响应等。
从这个意义上说，非阻塞是响应式的，因为随着操作完成或数据可用，我们现在处于响应通知的模式，而不是被阻塞。</p>
</div>
<div class="paragraph">
<p>我们Spring团队还有另一个重要机制与“响应式”相关联，这是非阻塞背压的机制。
在同步命令式代码中，阻塞调用是强制调用者等待的一种自然的背压形式。
在非阻塞代码中，控制事件的速率非常重要，这样快速的生产者就不会淹没其目的地。</p>
</div>
<div class="paragraph">
<p>Reactive Streams是一个 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">小的规范</a>
（在Java 9中也 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用了</a>），它定义了带有背压的异步组件之间的交互。
例如，数据存储库（充当 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">发布者</a>）
可以生成HTTP服务器（充当 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">订阅者</a>）
可以写入响应的数据。Reactive Streams的主要目的是让订阅者控制发布者生成数据的速度。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>常见问题：如果发布者不能放慢脚步怎么办？</strong><br>
Reactive Streams的目的仅仅是建立机制和边界。如果发布者无法放慢速度，则必须决定是缓冲，删除还是失败。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-reactive-api"><a class="anchor" href="#webflux-reactive-api"></a>1.1.2. Reactive API</h4>
<div class="paragraph">
<p>Reactive Streams对于互操作性起着重要作用。库和基础设施组件对此很感兴趣，但是由于它太底层了，它作为应用程序API的用处不大。
应用程序需要更高级别且功能更丰富的API来构成异步逻辑&#8212;&#8203;这与Java 8 <code>Stream</code> API相似，但不只是适用于集合。这就是响应式库的作用。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a>是Spring WebFlux的首选响应式库。
它提供了 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>和
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html"><code>Flux</code></a> API类型，
以通过与ReactiveX <a href="http://reactivex.io/documentation/operators.html">运算符词汇</a>对齐的丰富运算符集来处理
0..1 (<code>Mono</code>) 和 0..N (<code>Flux</code>)的数据序列。Reactor是Reactive Streams库，
因此，它的所有运算符都支持非阻塞背压。Reactor非常注重服务器端Java。它是与Spring紧密合作开发的。</p>
</div>
<div class="paragraph">
<p>WebFlux需要Reactor作为核心依赖项，但是它可以通过Reactive Streams与其他React库进行互操作。
通常，WebFlux API接受普通的 <code>Publisher</code> 作为输入，在内部将其适配成Reactor类型，使用它，然后返回 <code>Flux</code> 或 <code>Mono</code> 作为输出。
因此，你可以将任何 <code>Publisher</code> 作为输入传递，并且可以对输出应用操作，但是你需要调整输出以与其他响应式库一起使用。
只要可行（例如：带注解的控制器），WebFlux就会透明地适应RxJava或其他响应式库的使用。有关更多详细信息，请参见<a href="#webflux-reactive-libraries">[webflux-reactive-libraries]</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-programming-models"><a class="anchor" href="#webflux-programming-models"></a>1.1.3. 编程模型</h4>
<div class="paragraph">
<p><code>spring-web</code> 模块包含Spring WebFlux的响应式基础，包括HTTP抽象，用于支持的服务器的Reactive Streams<a href="#webflux-httphandler">适配器</a>，
<a href="#webflux-codecs">编解码器</a>以及与Servlet API相似但具有非阻塞契约的核心<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>。</p>
</div>
<div class="paragraph">
<p>在此基础上，Spring WebFlux提供了两种编程模型的选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">带注解的控制器</a>: 与Spring MVC一致，并基于 <code>spring-web</code> 模块中的相同注解。
Spring MVC和WebFlux控制器都支持响应式（Reactor和RxJava）返回类型，
因此，区分它们并不容易。一个显着的区别是WebFlux还支持响应式 <code>@RequestBody</code> 参数。</p>
</li>
<li>
<p><a href="#webflux-fn">函数式端点</a>: 基于Lambda的轻量级函数式编程模型。你可以将其视为一个小型库或一组实用工具，应用程序可以使用它们来路由和处理请求。
与带注解的控制器的最大区别在于，应用程序负责从头到尾的请求处理，而不是通过注解来声明意图并被回调。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-framework-choice"><a class="anchor" href="#webflux-framework-choice"></a>1.1.4. 适用性</h4>
<div class="paragraph">
<p>Spring MVC or WebFlux?</p>
</div>
<div class="paragraph">
<p>这是一个很自然的问题，但却产生了一个不合理的二分法。实际上，两者共同努力扩大了可用选项的范围。
两者的设计旨在实现彼此的连续性和一致性，它们可以并行使用，并且来自每一方的反馈对双方都有利。
下图显示了两者之间的关系，它们的共同点以及各自的独特支持：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-webflux/spring-mvc-and-webflux-venn.png" alt="spring mvc and webflux venn">
</div>
</div>
<div class="paragraph">
<p>我们建议你考虑以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果你有运行正常的Spring MVC应用程序，则无需更改。
命令式编程是编写，理解和调试代码的最简单方法。你有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>
</li>
<li>
<p>如果你已经在购买非阻塞Web堆栈，那么Spring WebFlux在此空间中提供的执行模型优势与其他模型相同，
并且还提供服务器选择（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），
编程模型选择（带注解的控制器和功能性Web端点），以及响应式库的选择（Reactor，RxJava或其他）。</p>
</li>
<li>
<p>如果你对与Java 8 lambda或Kotlin一起使用的轻量级函数式Web框架感兴趣，则可以使用Spring WebFlux函数式Web端点。
对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>
</li>
<li>
<p>在微服务架构中，你可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux函数式端点的应用程序。
两个框架都支持相同的基于注解的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>
</li>
<li>
<p>评估应用程序的一种简单方法是检查其依赖关系。如果你要使用阻塞性持久性API（JPA，JDBC）或网络API，
则Spring MVC至少是常见体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，
但你不会充分利用非阻塞Web堆栈。</p>
</li>
<li>
<p>如果你的Spring MVC应用程序具有对远程服务的调用，请尝试响应式 <code>WebClient</code>。你可以直接从Spring
MVC控制器方法返回响应式类型（Reactor，RxJava，<a href="#webflux-reactive-libraries">或其他</a>）。
每次调用的延迟或调用之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他响应式组件。</p>
</li>
<li>
<p>如果你有庞大的团队，请牢记向无阻塞，函数式和声明性编程过渡过程中陡峭的学习曲线。
一种无需完全切换即可开始的实用方法是使用响应式 <code>WebClient</code>。除此之外，从小处着手并衡量收益。
我们希望，对于广泛的应用程序，这种转变是不必要的。如果不确定要寻找什么好处，
请先了解非阻塞I/O的工作原理（例如：单线程Node.js上的并发性）及其影响。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-server-choice"><a class="anchor" href="#webflux-server-choice"></a>1.1.5. 服务器</h4>
<div class="paragraph">
<p>Tomcat，Jetty，Servlet 3.1+容器以及非Servlet运行时（例如：Netty和Undertow）都支持Spring WebFlux。
所有服务器都适应于低级<a href="#webflux-httphandler">通用API</a>，因此可以跨服务器支持更高级别的
<a href="#webflux-programming-models">编程模型</a>。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux不具有内置支持来启动或停止服务器。但是，从Spring配置和<a href="#webflux-config">WebFlux基础设施</a>
<a href="#webflux-web-handler-api">组装</a>一个应用程序并用几行代码<a href="#webflux-httphandler">运行它</a>很容易。</p>
</div>
<div class="paragraph">
<p>Spring Boot具有一个WebFlux启动器，可以自动执行这些步骤。默认情况下，starter使用Netty，
但通过更改Maven或Gradle依赖关系，可以轻松切换到Tomcat，Jetty或Undertow。
Spring Boot默认为Netty，因为它在异步，非阻塞空间中得到更广泛的使用，并允许客户端和服务器共享资源。</p>
</div>
<div class="paragraph">
<p>Tomcat和Jetty可以与Spring MVC和WebFlux一起使用。但是请记住，它们的使用方式非常不同。
Spring MVC依靠Servlet阻塞I/O，并允许应用程序在需要时直接使用Servlet API。
Spring WebFlux依赖于Servlet 3.1非阻塞I/O，并在底层适配器后面使用Servlet API，并且不公开供直接使用。</p>
</div>
<div class="paragraph">
<p>对于Undertow，Spring WebFlux直接使用Undertow API，而无需使用Servlet API。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-performance"><a class="anchor" href="#webflux-performance"></a>1.1.6. 性能</h4>
<div class="paragraph">
<p>性能具有许多特征和意义。响应式和非阻塞通常不会使应用程序运行得更快。
在某些情况下，它们可以（例如：如果使用 <code>WebClient</code> 并行执行远程调用）。
总体而言，以非阻塞方式进行操作需要更多的工作，这可能会稍微增加所需的处理时间。</p>
</div>
<div class="paragraph">
<p>响应式和非阻塞性的主要预期好处是能够以较少的固定数量的线程和较少的内存进行扩展。
这使应用程序在负载下更具弹性，因为它们以更可预测的方式扩展。
然而，为了能观察到这些好处，你需要一些延迟（包括缓慢的和不可预测的网络I/O）。
这就是响应式堆栈开始显示其优势的地方，差异可能是巨大的。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-concurrency-model"><a class="anchor" href="#webflux-concurrency-model"></a>1.1.7. 并发模型</h4>
<div class="paragraph">
<p>Spring MVC和Spring WebFlux都支持带注解的控制器，但是在并发模型以及对阻塞和线程的默认假设存在关键差异。</p>
</div>
<div class="paragraph">
<p>在Spring MVC（通常是servlet应用程序）中，假设应用程序可以阻塞当前线程（例如：用于远程调用），
因此，servlet容器使用大型线程池来吸收请求处理过程中可能出现的阻塞。</p>
</div>
<div class="paragraph">
<p>在Spring WebFlux（通常是非阻塞服务器）中，假设应用程序未阻塞，因此，非阻塞服务器使用固定大小的小型线程池
（事件循环工作器）来处理请求。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
“按比例缩放”和“少量线程”听起来可能是矛盾的，但是从不阻塞当前线程（而是依靠回调）意味着你不需要额外的线程，
因为没有阻塞调用可供吸收。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">调用阻塞API</div>
<p>如果确实需要使用阻止库怎么办？Reactor和RxJava都提供了 <code>publishOn</code> 运算符以继续在其他线程上进行处理。
这意味着容易逃生。但是请记住，阻塞式API不适用于此并发模型。</p>
</div>
<div class="paragraph">
<div class="title">可变状态</div>
<p>在Reactor和RxJava中，你可以通过运算符声明逻辑，然后在运行时形成一个响应式管道，在其中以不同的阶段顺序处理数据。
这样做的主要好处是，它使应用程序不必保护可变状态，因为该管道中的应用程序代码永远不会被同时调用。</p>
</div>
<div class="paragraph">
<div class="title">线程模型</div>
<p>你期望在运行Spring WebFlux的服务器上看到哪些线程？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在“原始” Spring WebFlux服务器上（例如：没有数据访问权限或其他可选依赖项），你可以期望该服务器有一个线程，
而其他几个线程则可以进行请求处理（通常与CPU核心数量一样多）。但是，Servlet容器可能以更多的线程
（例如：Tomcat上为10）开始，以同时支持servlet（阻塞）I/O和Servlet 3.1（非阻塞）I/O使用。</p>
</li>
<li>
<p>响应式 <code>WebClient</code> 以事件循环方式运行。因此，你可以看到与之相关的固定数量的处理线程
（例如，带有Reactor Netty连接器的 <code>react-http-nio-</code>）。但是，如果客户端和服务器都使用Reactor Netty，
则默认情况下，两者共享事件循环资源。</p>
</li>
<li>
<p>Reactor和RxJava提供称为调度程序的线程池抽象，以与 <code>publishOn</code> 运算符配合使用，该运算符用于将处理切换到其他线程池。
调度程序具有建议特定并发策略的名称&#8212;&#8203;例如：“<code>parallel</code>”（对于具有有限数量线程的CPU绑定工作）或“<code>elastic</code>”
（对于具有大量线程的I/O绑定）。如果看到这样的线程，则意味着某些代码正在使用特定的线程池 <code>Scheduler</code> 策略。</p>
</li>
<li>
<p>数据访问库和其他第三方依赖也可以创建和使用自己的线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">配置中</div>
<p>Spring框架不提供启动和停止<a href="#webflux-server-choice">服务器</a>的支持。要为服务器配置线程模型，你需要使用服务器特定的配置API，
或者，如果你使用的是Spring Boot，请检查每个服务器的Spring Boot配置选项。你可以直接
<a href="web-reactive.html#webflux-client-builder">配置</a> <code>WebClient</code>。对于所有其他库，请参阅其各自的文档。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-spring-web"><a class="anchor" href="#webflux-reactive-spring-web"></a>1.2. Reactive核心</h3>
<div class="paragraph">
<p><code>spring-web</code> 模块包含以下对响应式Web应用程序的基本支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于服务器请求处理，有两个级别的支持。</p>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a>: 具有非阻塞I/O和Reactive Streams背压的HTTP请求处理的基本契约，
以及Reactor Netty，Undertow，Tomcat，Jetty和任何Servlet 3.1+容器的适配器。</p>
</li>
<li>
<p><a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>: 稍高级别的通用Web API，用于处理请求，在此之上构建了具体的编程模型，例如：
带注解的控制器和函数式端点。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对于客户端，有一个基本的 <code>ClientHttpConnector</code> 契约，以执行具有非阻塞I/O和响应流背压的HTTP请求，
以及用于 <a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>和响应式
<a href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HttpClient</a>的适配器。
应用程序中使用的更高级别的<a href="web-reactive.html#webflux-client">WebClient</a>就基于此基本协定。</p>
</li>
<li>
<p>对于客户端和服务器，<a href="#webflux-codecs">编解码器</a>用于序列化和反序列化HTTP请求和响应内容。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="webflux-httphandler"><a class="anchor" href="#webflux-httphandler"></a>1.2.1. <code>HttpHandler</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>
是具有单个方法的简单契约，用于处理请求和响应。
它故意设计成最小的，它的主要也是唯一目的是成为对不同HTTP服务器API的最小抽象。</p>
</div>
<div class="paragraph">
<p>下表描述了受支持的服务器API：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">使用的服务器API</th>
<th class="tableblock halign-left valign-top">Reactive Streams支持</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Undertow to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O；读写ByteBuffers与byte[]的Tomcat API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O；写ByteBuffers与byte[]的Jetty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表描述了服务器依赖（另请参阅
<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">受支持的版本</a>）：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">Group id</th>
<th class="tableblock halign-left valign-top">Artifact name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor-netty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">undertow-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tomcat-embed-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jetty-server, jetty-servlet</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面的代码段显示了如何将 <code>HttpHandler</code> 适配器与每个服务器API一起使用：</p>
</div>
<div class="paragraph">
<p><strong>Reactor Netty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create(host, port).newHandler(adapter).block();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Undertow</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tomcat</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Jetty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Servlet 3.1+ 容器</strong></p>
</div>
<div class="paragraph">
<p>要将其作为WAR部署到任何Servlet 3.1+容器，你可以继承
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html"><code>AbstractReactiveWebInitializer</code></a>
并将其包括在WAR中。该类使用 <code>ServletHttpHandlerAdapter</code> 包装 <code>HttpHandler</code> 并将其注册为 <code>Servlet</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api"><a class="anchor" href="#webflux-web-handler-api"></a>1.2.2. <code>WebHandler</code> API</h4>
<div class="paragraph">
<p><code>org.springframework.web.server</code> 包基于<a href="#webflux-httphandler"><code>HttpHandler</code></a>契约构建，以提供通用的Web
API，以通过多个 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html"><code>WebExceptionHandler</code></a>，
多个 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html"><code>WebFilter</code></a>和
单个 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html"><code>WebHandler</code></a>组件组成的链来处理请求。
通过简单地指向<a href="#webflux-web-handler-api-special-beans">自动检测</a>组件的Spring <code>ApplicationContext</code>
和/或通过向构建器注册组件，可以将该链与 <code>WebHttpHandlerBuilder</code> 放在一起。</p>
</div>
<div class="paragraph">
<p>尽管 <code>HttpHandler</code> 的目标很简单，即抽象化不同HTTP服务器的使用，但 <code>WebHandler</code> API
的目的是提供Web应用程序中常用的更广泛的功能集，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有属性的用户会话。</p>
</li>
<li>
<p>请求属性。</p>
</li>
<li>
<p>已解析请求的 <code>Locale</code> 或 <code>Principal</code>。</p>
</li>
<li>
<p>访问已解析和缓存的表单数据。</p>
</li>
<li>
<p>multipart数据的抽象。</p>
</li>
<li>
<p>和更多..</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-web-handler-api-special-beans"><a class="anchor" href="#webflux-web-handler-api-special-beans"></a>特殊bean类型</h5>
<div class="paragraph">
<p>下表列出了 <code>WebHttpHandlerBuilder</code> 可以在Spring <code>ApplicationContext</code> 中自动检测的组件，
或者可以直接向其注册的组件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12%;">
<col style="width: 37%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean名称</th>
<th class="tableblock halign-left valign-top">Bean类型</th>
<th class="tableblock halign-left valign-top">计数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对来自 <code>WebFilter</code> 实例链和目标 <code>WebHandler</code> 的异常的处理。有关更多详细信息，请参见<a href="#webflux-exception-handler">异常</a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在其余的过滤器链和目标 <code>WebHandler</code> 之前和之后应用拦截样式逻辑。有关更多详细信息，请参见<a href="#webflux-filters">过滤器</a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的处理程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <code>ServerWebExchange</code> 上的方法公开的 <code>WebSession</code> 实例的管理器。默认情况下为 <code>DefaultWebSessionManager</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serverCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问 <code>HttpMessageReader</code> 实例以解析表单数据和multipart数据，然后通过 <code>ServerWebExchange</code>
  上的方法公开这些数据。默认情况下为 <code>ServerCodecConfigurer.create()</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localeContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <code>ServerWebExchange</code> 上的方法公开的 <code>LocaleContext</code> 解析程序。默认情况下为 <code>AcceptHeaderLocaleContextResolver</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理转发的类型标头，可以提取和删除它们，也可以只删除它们。默认情况下不使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-form-data"><a class="anchor" href="#webflux-form-data"></a>表单数据</h5>
<div class="paragraph">
<p><code>ServerWebExchange</code> 公开以下访问表单数据的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code> 使用配置的 <code>HttpMessageReader</code> 将表单数据（<code>application/x-www-form-urlencoded</code>）
解析为 <code>MultiValueMap</code>。默认情况下，<code>FormHttpMessageReader</code> 配置为由 <code>ServerCodecConfigurer</code> Bean使用
（请参阅<a href="#webflux-web-handler-api">Web Handler API</a>）。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart"><a class="anchor" href="#webflux-multipart"></a>Multipart数据</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multipart">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerWebExchange</code> 公开以下访问multipart数据的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code> 使用配置的 <code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code> 将
<code>multipart/form-data</code> 内容解析为 <code>MultiValueMap</code>。当前，
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的第三方库，
并且是我们知道的用于非阻塞解析multipart请求的唯一库。
通过 <code>ServerCodecConfigurer</code> bean启用它（请参阅<a href="#webflux-web-handler-api">Web Handler API</a>）。</p>
</div>
<div class="paragraph">
<p>要以流方式解析multipart数据，可以使用从 <code>HttpMessageReader&lt;Part&gt;</code> 返回的 <code>Flux&lt;Part&gt;</code>。
例如：在带注解的控制器中，使用 <code>@RequestPart</code> 意味着按名称对各个parts进行类似于
<code>Map</code> 的访问，因此需要完全解析multipart数据。相反，你可以使用 <code>@RequestBody</code> 将内容解码为
<code>Flux&lt;Part&gt;</code> 而不收集到 <code>MultiValueMap</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-forwarded-headers"><a class="anchor" href="#webflux-forwarded-headers"></a>Forwarded请求头</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters-forwarded-headers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如：负载均衡器）进行处理时，host，port和scheme可能会更改，
这使得从客户端角度创建指向正确的host，port和scheme的链接成为挑战。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可以用来提供有关原始请求信息的 <code>Forwarded</code> HTTP头。
还有其他非标准请求头，包括 <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>,
<code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code> 和 <code>X-Forwarded-Prefix</code>。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderTransformer</code> 是一个组件，可根据转发的头部修改请求的host，port和scheme，然后删除这些头部。
你可以将其声明为名称为 <code>forwardedHeaderTransformer</code> 的Bean，并对其进行<a href="#webflux-web-handler-api-special-beans">检测</a>和使用。</p>
</div>
<div class="paragraph">
<p>对于转发的头部，存在安全方面的考虑，因为应用程序无法知道头部是由代理添加的，还是由恶意客户端添加的。
这就是为什么应配置信任边界处的代理以删除来自外部的不受信任的 <code>Forwarded</code> 头的原因。
你还可以使用 <code>removeOnly=true</code> 配置 <code>ForwardedHeaderTransformer</code>，在这种情况下，它将删除但不使用头。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在5.1版本中，<code>ForwardedHeaderFilter</code> 被 <code>ForwardedHeaderTransformer</code> 取代并弃用，
因此可以在创建exchange之前更早地处理forwarded头。如果仍然配置了过滤器，则将其从过滤器列表中删除，
而改用 <code>ForwardedHeaderTransformer</code>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-filters"><a class="anchor" href="#webflux-filters"></a>1.2.3. 过滤器</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中，可以使用 <code>WebFilter</code> 在过滤器和目标 <code>WebHandler</code>
的处理链的其余部分之前和之后应用拦截样式的逻辑。使用<a href="#webflux-config">WebFlux配置</a>时，注册 <code>WebFilter</code> 就像将其声明为Spring bean一样简单，
并且（可选）通过在bean声明上使用 <code>@Order</code> 或实现 <code>Ordered</code> 来表达优先级。</p>
</div>
<div class="sect4">
<h5 id="webflux-filters-cors"><a class="anchor" href="#webflux-filters-cors"></a>CORS</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters-cors">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux通过控制器上的注解为CORS配置提供了细粒度的支持。
但是，当你将其与Spring Security结合使用时，我们建议你依赖内置的 <code>CorsFilter</code>，
它必须排在Spring Security的过滤器链之前。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="#webflux-cors">CORS</a>和<a href="#webflux-cors-webfilter">CORS <code>WebFilter</code></a>部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-exception-handler"><a class="anchor" href="#webflux-exception-handler"></a>1.2.4. 异常</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-customer-servlet-container-error-page">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中，可以使用 <code>WebExceptionHandler</code> 来处理 <code>WebFilter</code>
实例和目标 <code>WebHandler</code> 链中的异常。使用<a href="#webflux-config">WebFlux配置</a>时，
注册 <code>WebExceptionHandler</code> 就像将其声明为Spring bean一样简单，
并且（可选）通过在bean声明上使用 <code>@Order</code> 或实现 <code>Ordered</code> 来表达优先级。</p>
</div>
<div class="paragraph">
<p>下表描述了可用的 <code>WebExceptionHandler</code> 实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">异常处理程序</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过将响应设置为异常的HTTP状态码，提供对
  <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html"><code>ResponseStatusException</code></a>
  类型的异常的处理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFluxResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code> 的扩展，它也可以确定任何异常时 <code>@ResponseStatus</code> 所注解的HTTP状态码。
</p><p class="tableblock">  该异常处理程序在<a href="#webflux-config">WebFlux配置</a>中声明。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-codecs"><a class="anchor" href="#webflux-codecs"></a>1.2.5. 编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/integration.html#rest-message-conversion">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>spring-web</code> 和 <code>spring-core</code> 模块提供支持，通过具有Reactive Streams背压的非阻塞I/O，
可以将字节内容与更高级别的对象之间的字节序列进行序列化和反序列化。以下介绍了此支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html"><code>Encoder</code></a> 和
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html"><code>Decoder</code></a> 是底层协议，用于独立于HTTP编码和解码内容。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html"><code>HttpMessageReader</code></a> 和
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html"><code>HttpMessageWriter</code></a> 是对HTTP消息内容进行编码和解码的契约。</p>
</li>
<li>
<p>可以使用 <code>EncoderHttpMessageWriter</code> 来包装 <code>Encoder</code>，以使其适合在Web应用程序中使用，也可以使用
<code>DecoderHttpMessageReader</code> 来包装 <code>Decoder</code>。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html"><code>DataBuffer</code></a>
抽象了不同的字节缓冲区表示形式（例如：Netty <code>ByteBuf</code>，<code>java.nio.ByteBuffer</code> 等），
并且是所有编解码器都在处理的内容。有关此主题的更多信息，请参见“Spring Core”中的
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#databuffers">数据缓冲区和编解码器</a>部分。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>spring-core</code> 模块提供 <code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code> 和 <code>String</code> 编码器和解码器实现。
<code>spring-web</code> 模块提供了Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers和其他编码器和解码器，
以及web-only的HTTP消息读取器和写入器实现，用于表单数据，multipart内容，服务器发送事件等。</p>
</div>
<div class="paragraph">
<p><code>ClientCodecConfigurer</code> 和 <code>ServerCodecConfigurer</code> 通常用于配置和自定义要在应用程序中使用的编解码器。
请参阅有关配置<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>部分。</p>
</div>
<div class="sect4">
<h5 id="webflux-codecs-jackson"><a class="anchor" href="#webflux-codecs-jackson"></a>Jackson JSON</h5>
<div class="paragraph">
<p>当存在Jackson库时，JSON和二进制JSON（ <a href="https://github.com/FasterXML/smile-format-specification">Smile</a>）都被支持。</p>
</div>
<div class="paragraph">
<p><code>Jackson2Decoder</code> 的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson的异步，非阻塞解析器用于将字节块流聚合到 <code>TokenBuffer</code> 的每个块中，每个块代表一个JSON对象。</p>
</li>
<li>
<p>每个 <code>TokenBuffer</code> 都传递给Jackson的 <code>ObjectMapper</code> 以创建更高级别的对象。</p>
</li>
<li>
<p>当解码为单值发布者（例如： <code>Mono</code>）时，有一个 <code>TokenBuffer</code>。</p>
</li>
<li>
<p>当解码为多值发布者（例如： <code>Flux</code>）时，一旦为一个完整的对象接收到足够的字节，每个 <code>TokenBuffer</code> 就会传递给 <code>ObjectMapper</code>。
输入内容可以是JSON数组，如果内容类型为“application/stream+json”，则可以是行分隔的JSON。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Jackson2Encoder</code> 的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于单个值发布者（例如： <code>Mono</code>），只需通过 <code>ObjectMapper</code> 对其进行序列化即可。</p>
</li>
<li>
<p>对于具有“application/json”的多值发布者，默认情况下使用 <code>Flux#collectToList()</code> 收集值，然后序列化结果集合。</p>
</li>
<li>
<p>对于具有流媒体类型（例如：<code>application/stream+json</code> 或 <code>application/stream+x-jackson-smile</code>）的多值发布者，
请使用 <a href="https://en.wikipedia.org/wiki/JSON_streaming">行分隔的JSON</a>格式分别编码，写入和刷新每个值。</p>
</li>
<li>
<p>对于SSE，将为每个事件调用 <code>Jackson2Encoder</code>，并刷新输出以确保交付没有延迟。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，<code>Jackson2Encoder</code> 和 <code>Jackson2Decoder</code> 都不支持 <code>String</code> 类型的元素。
相反，默认假设是一个字符串或一系列字符串表示要由 <code>CharSequenceEncoder</code> 呈现的序列化JSON内容。
如果你需要从 <code>Flux&lt;String&gt;</code> 呈现JSON数组，请使用 <code>Flux#collectToList()</code> 并对 <code>Mono&lt;List&lt;String&gt;&gt;</code> 进行编码。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-forms"><a class="anchor" href="#webflux-codecs-forms"></a>表单数据</h5>
<div class="paragraph">
<p><code>FormHttpMessageReader</code> 和 <code>FormHttpMessageWriter</code> 支持对“application/x-www-form-urlencoded”内容进行解码和编码。</p>
</div>
<div class="paragraph">
<p>在经常需要从多个位置访问表单内容的服务器端，<code>ServerWebExchange</code> 提供了专用的 <code>getFormData()</code> 方法，该方法通过
<code>FormHttpMessageReader</code> 解析内容，然后缓存结果以进行重复访问。请参阅<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分中的<a href="#webflux-form-data">表单数据</a>。</p>
</div>
<div class="paragraph">
<p>一旦使用 <code>getFormData()</code>，就无法再从请求正文中读取最初的原始内容。
因此，应用程序应始终通过 <code>ServerWebExchange</code> 来访问缓存的表单数据，而不是从原始请求正文中进行读取。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-multipart"><a class="anchor" href="#webflux-codecs-multipart"></a>Multipart</h5>
<div class="paragraph">
<p><code>MultipartHttpMessageReader</code> 和 <code>MultipartHttpMessageWriter</code> 支持对“multipart/form-data”内容进行解码和编码。
反过来，<code>MultipartHttpMessageReader</code> 委托给另一个 <code>HttpMessageReader</code> 进行实际解析为 <code>Flux&lt;Part&gt;</code>，
然后将这些parts简单地收集到 <code>MultiValueMap</code> 中。目前，
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>
被用于实际解析。</p>
</div>
<div class="paragraph">
<p>在可能需要从多个位置访问multipart表单内容的服务器端，<code>ServerWebExchange</code> 提供了专用的 <code>getMultipartData()</code> 方法，
该方法通过 <code>MultipartHttpMessageReader</code> 解析内容，然后缓存结果以进行重复访问。
请参阅<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分中的<a href="#webflux-multipart">Multipart数据</a>。</p>
</div>
<div class="paragraph">
<p>一旦使用 <code>getMultipartData()</code>，就无法再从请求正文中读取最初的原始内容。
因此，应用程序必须始终使用 <code>getMultipartData()</code> 来重复，类似于map的方式访问parts，否则必须依靠
<code>SynchronossPartHttpMessageReader</code> 来一次性访问 <code>Flux&lt;Part&gt;</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-limits"><a class="anchor" href="#webflux-codecs-limits"></a>限制</h5>
<div class="paragraph">
<p>可以对缓冲部分或全部输入流的 <code>Decoder</code> 和 <code>HttpMessageReader</code> 实现进行配置，并限制要在内存中缓冲的最大字节数。
在某些情况下，由于输入被汇总并表示为单个对象而发生缓冲，例如：具有 <code>@RequestBody byte[]</code>，
<code>x-www-form-urlencoded</code> 数据的控制器方法，等等。在分割输入流（例如：定界文本，JSON对象流等）时，流处理也会发生缓冲。
对于那些流情况，该限制适用于与流中一个对象关联的字节数。</p>
</div>
<div class="paragraph">
<p>要配置缓冲区大小，你可以检查给定的 <code>Decoder</code> 或 <code>HttpMessageReader</code> 是否公开了 <code>maxInMemorySize</code> 属性，
如果有，则Javadoc将具有有关默认值的详细信息。在WebFlux中，<code>ServerCodecConfigurer</code> 通过默认编解码器的
<code>maxInMemorySize</code> 属性，提供了<a href="#webflux-config-message-codecs">一个位置</a>设置所有的编解码器。在客户端，可以在
<a href="#webflux-client-builder-maxinmemorysize">WebClient.Builder</a>中更改限制。</p>
</div>
<div class="paragraph">
<p>对于Multipart解析，<code>maxInMemorySize</code> 属性限制了非文件parts的大小。对于文件parts，它确定将part写入磁盘的阈值。
对于写入磁盘的文件part，还有一个额外的 <code>maxDiskUsagePerPart</code> 属性可限制每个part的磁盘空间量。
还有一个 <code>maxParts</code> 属性，用于限制multipart请求中的parts总数。要在WebFlux中配置所有均为3个，你需要向
<code>ServerCodecConfigurer</code> 提供一个预先配置的 <code>MultipartHttpMessageReader</code> 实例。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-streaming"><a class="anchor" href="#webflux-codecs-streaming"></a>Streaming</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-async-http-streaming">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在流式传输HTTP响应（例如：<code>text/event-stream</code>, <code>application/stream+json</code>）时，定期发送数据很重要，
这样才能尽快（而不是稍后）可靠地检测到断开连接的客户端。这样的发送可以是仅注释，空的SSE事件或任何其他可以有效充当心跳的“无操作”数据。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-buffers"><a class="anchor" href="#webflux-codecs-buffers"></a><code>DataBuffer</code></h5>
<div class="paragraph">
<p><code>DataBuffer</code> 是WebFlux中字节缓冲区的表示形式。参考的Spring Core部分在 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#databuffers">数据缓冲区和编解码器</a>一节中对此有更多的介绍。
要注意的关键点是，在诸如Netty之类的某些服务器上，字节缓冲区被池化并且对引用进行计数，
并且在消耗字节缓冲区时必须将其释放以避免内存泄漏。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序通常不需要关心此类问题，除非它们直接使用或产生数据缓冲区，而不是依赖于编解码器与更高级别的对象之间进行转换，
或者除非它们选择创建自定义编解码器。对于这种情况，请查看 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#databuffers">数据缓冲区和编解码器</a>中的信息，
尤其是有关 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#databuffers-using">使用数据缓冲区</a>部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-logging"><a class="anchor" href="#webflux-logging"></a>1.2.6. 日志</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-logging">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中的DEBUG级别日志记录被设计为紧凑，最小化和人性化。它侧重于反复有用的高价值信息，
而其他信息则仅在调试特定问题时才有用。</p>
</div>
<div class="paragraph">
<p>TRACE级别的日志记录通常遵循与DEBUG相同的原则（例如：也不应成为firehose），但可用于调试任何问题。
另外，某些日志消息在TRACE vs DEBUG上可能显示不同级别的详细信息。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果你发现任何不符合既定目标的地方，请告诉我们。</p>
</div>
<div class="sect4">
<h5 id="webflux-logging-id"><a class="anchor" href="#webflux-logging-id"></a>日志Id</h5>
<div class="paragraph">
<p>在WebFlux中，单个请求可以在多个线程上执行，并且线程ID对于关联属于特定请求的日志消息没有用。
这就是为什么WebFlux日志消息默认情况下带有特定于请求的ID的原因。</p>
</div>
<div class="paragraph">
<p>在服务器端，日志ID存储在 <code>ServerWebExchange</code> 属性
（ <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a>）
中，而可从 <code>ServerWebExchange#getLogPrefix()</code> 获得基于该ID的完整格式前缀。
在 <code>WebClient</code> 端，日志ID存储在 <code>ClientRequest</code> 属性
（ <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE"><code>LOG_ID_ATTRIBUTE</code></a>）
中，而完整格式的前缀可从 <code>ClientRequest#logPrefix()</code> 获得。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-logging-sensitive-data"><a class="anchor" href="#webflux-logging-sensitive-data"></a>敏感数据</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-logging-sensitive-data">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DEBUG</code> 和 <code>TRACE</code> 日志记录可以记录敏感信息。这就是默认情况下屏蔽表单参数和头部的原因，并且必须显式启用它们以记录完整日志。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对服务器端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对客户端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())
        .build();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-codecs-custom"><a class="anchor" href="#webflux-codecs-custom"></a>自定义编解码器</h5>
<div class="paragraph">
<p>应用程序可以注册自定义编解码器以支持其他媒体类型，也可以注册默认编解码器不支持的特定行为。</p>
</div>
<div class="paragraph">
<p>开发人员表示的某些配置选项在默认编解码器上强制执行。自定义编解码器可能希望有机会与这些首选项保持一致，例如：
<a href="#webflux-codecs-limits">强制执行缓冲限制</a>或<a href="#webflux-logging-sensitive-data">记录敏感数据</a>。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对客户端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt; {
        CustomDecoder customDecoder = new CustomDecoder();
        configurer.customCodecs().decoder(customDecoder);
        configurer.customCodecs().withDefaultCodecConfig(config -&gt;
            customDecoder.maxInMemorySize(config.maxInMemorySize())
        );
}

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -&gt; strategies.codecs(consumer))
        .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler"><a class="anchor" href="#webflux-dispatcher-handler"></a>1.3. <code>DispatcherHandler</code></h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux与Spring MVC类似，是围绕前端控制器模式设计的，其中中央 <code>WebHandler</code> <code>DispatcherHandler</code>
提供了用于请求处理的共享算法，而实际工作是由可配置的委托组件执行的。该模型非常灵活，并支持多种工作流程。</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 从Spring配置中发现所需的委托组件。它还被设计为Spring Bean本身，并实现
<code>ApplicationContextAware</code> 来访问其运行的上下文。如果以 <code>webHandler</code> 的bean名称声明了 <code>DispatcherHandler</code>
，则 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/server/adapter/WebHttpHandlerBuilder.html"><code>WebHttpHandlerBuilder</code></a>会发现它，
而 <code>WebHttpHandlerBuilder</code> 会将其与请求处理链组合在一起，如<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中所述。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序中的Spring配置通常包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bean名称为 <code>webHandler</code> 的 <code>DispatcherHandler</code></p>
</li>
<li>
<p><code>WebFilter</code> 和 <code>WebExceptionHandler</code> beans</p>
</li>
<li>
<p><a href="#webflux-special-bean-types"><code>DispatcherHandler</code> 特殊beans</a></p>
</li>
<li>
<p>其它</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将配置提供给 <code>WebHttpHandlerBuilder</code> 以构建处理链，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的 <code>HttpHandler</code> 已准备好与<a href="#webflux-httphandler">服务器适配器</a>一起使用。</p>
</div>
<div class="sect3">
<h4 id="webflux-special-bean-types"><a class="anchor" href="#webflux-special-bean-types"></a>1.3.1. 特殊Bean类型</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-special-bean-types">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 委托给特殊的Bean处理请求并渲染适当的响应。
所谓“特殊bean”，是指实现WebFlux框架契约的Spring管理对象实例。
这些通常带有内置契约，但是你可以自定义它们的属性，扩展它们或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了 <code>DispatcherHandler</code> 检测到的特殊bean。请注意，在较低级别还检测到其他一些bean
（请参阅Web Handler API中的<a href="#webflux-web-handler-api-special-beans">特殊bean类型</a>）。</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求映射到处理程序。映射基于某些条件，这些条件的详细信息因 <code>HandlerMapping</code> 实现而有所不同
  --带有注解的控制器，简单的URL模式映射以及其他。
</p><p class="tableblock">  主要的 <code>HandlerMapping</code> 实现是用于 <code>@RequestMapping</code> 注解方法的 <code>RequestMappingHandlerMapping</code>
  ，用于函数式端点路由的 <code>RouterFunctionMapping</code> 和用于URI路径模式和 <code>WebHandler</code> 实例的显式注册的
  <code>SimpleUrlHandlerMapping</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">帮助 <code>DispatcherHandler</code> 调用映射到请求的处理程序，而不管实际如何调用该处理程序。
  例如：调用带注解的控制器需要解析注解。<code>HandlerAdapter</code> 的主要目的是使 <code>DispatcherHandler</code> 免受此类细节的影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理来自处理程序调用的结果，并最终确定响应。请参阅<a href="#webflux-resulthandling">结果处理</a>。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-framework-config"><a class="anchor" href="#webflux-framework-config"></a>1.3.2. WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-config">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明处理请求所需的基础设施bean（在<a href="#webflux-web-handler-api-special-beans">Web Handler API</a>
和<a href="#webflux-special-bean-types"><code>DispatcherHandler</code></a>下列出）。
但是，在大多数情况下，<a href="#webflux-config">WebFlux配置</a>是最佳起点。它声明了所需的bean，并提供了更高级别的配置回调API来对其进行自定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot依靠WebFlux配置来配置Spring WebFlux，并且还提供了许多额外的方便选项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-handler-sequence"><a class="anchor" href="#webflux-dispatcher-handler-sequence"></a>1.3.3. 处理过程</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-sequence">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 处理请求的方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要求每个 <code>HandlerMapping</code> 查找一个匹配的处理程序，并使用第一个匹配项。</p>
</li>
<li>
<p>如果找到处理程序，则通过适当的 <code>HandlerAdapter</code> 执行该处理程序，该处理程序将执行的返回值公开为 <code>HandlerResult</code>。</p>
</li>
<li>
<p>通过直接写入响应或使用视图渲染，将 <code>HandlerResult</code> 提供给适当的 <code>HandlerResultHandler</code> 以完成处理。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-resulthandling"><a class="anchor" href="#webflux-resulthandling"></a>1.3.4. 结果处理</h4>
<div class="paragraph">
<p>通过 <code>HandlerAdapter</code> 调用处理程序的返回值连同其他一些上下文一起包装为 <code>HandlerResult</code>，
并传递给第一个支持该处理程序的 <code>HandlerResultHandler</code>。
下表显示了可用的 <code>HandlerResultHandler</code> 实现，所有实现都在<a href="#webflux-config">WebFlux配置</a>中声明：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果处理程序类型</th>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">默认顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntityResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntity</code>, 通常来自 <code>@Controller</code> 实例。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponseResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponse</code>, 通常来自函数式端点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理 <code>@ResponseBody</code> 方法或 <code>@RestController</code> 类的返回值。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolutionResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code>, <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html"><code>View</code></a>,
  <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/ui/Model.html">Model</a>, <code>Map</code>,
  <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>,
  或任何其他 <code>Object</code> 被视为模型属性。
</p><p class="tableblock">  另请参阅<a href="#webflux-viewresolution">视图解析</a>。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer.MAX_VALUE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-dispatcher-exceptions"><a class="anchor" href="#webflux-dispatcher-exceptions"></a>1.3.5. 异常</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-exceptionhandlers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>从 <code>HandlerAdapter</code> 返回的 <code>HandlerResult</code> 可以公开基于某些特定于处理程序的机制进行错误处理的函数。
在以下情况下将调用此错误函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理程序（例如： <code>@Controller</code>）调用失败。</p>
</li>
<li>
<p>通过 <code>HandlerResultHandler</code> 处理处理程序返回值失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只要在从处理程序返回的响应式类型产生任何数据项之前发生错误信号，错误函数就可以更改响应（例如：更改为错误状态）。</p>
</div>
<div class="paragraph">
<p>这就是支持 <code>@Controller</code> 类中的 <code>@ExceptionHandler</code> 方法的方式。相比之下，Spring
MVC中对相同功能的支持建立在 <code>HandlerExceptionResolver</code> 之上。这通常不重要。但是，请记住，在WebFlux中，不能使用
<code>@ControllerAdvice</code> 来处理在选择处理程序之前发生的异常。</p>
</div>
<div class="paragraph">
<p>另请参见“带注解的控制器”部分中的<a href="#webflux-ann-controller-exceptions">管理异常</a>或WebHandler API部分中的<a href="#webflux-exception-handler">异常</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-viewresolution"><a class="anchor" href="#webflux-viewresolution"></a>1.3.6. 视图解析</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-viewresolver">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>视图解析使你可以使用HTML模板和模型渲染到浏览器，而无需将你与特定的视图技术联系在一起。
在Spring WebFlux中，通过专用的 <code>HandlerResultHandler</code> 支持视图解析，
该 <code>HandlerResultHandler</code> 使用 <code>ViewResolver</code> 实例将 <code>String</code>（表示逻辑视图名称）映射到 <code>View</code> 实例。然后使用 <code>View</code> 渲染响应。</p>
</div>
<div class="sect4">
<h5 id="webflux-viewresolution-handling"><a class="anchor" href="#webflux-viewresolution-handling"></a>处理过程</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-handling">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>传递给 <code>ViewResolutionResultHandler</code> 的 <code>HandlerResult</code> 包含处理程序的返回值和包含请求处理期间添加的属性的模型。
返回值将作为以下值之一进行处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code>, <code>CharSequence</code>：通过配置的 <code>ViewResolver</code> 实现列表解析为 <code>View</code> 的逻辑视图名称。</p>
</li>
<li>
<p><code>void</code>：根据请求路径选择默认视图名称，减去前导斜杠和尾部斜杠，然后将其解析为视图。
当未提供视图名称（例如：返回模型属性）或异步返回值（例如：Mono完成为空）时，也会发生同样的情况。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">Rendering</a>:
用于视图解析方案的API。通过IDE中的代码完成探索其选项。</p>
</li>
<li>
<p><code>Model</code>, <code>Map</code>：额外的模型属性将添加到请求的模型中。</p>
</li>
<li>
<p>任何其他：任何其他返回值（由 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>
确定的简单类型除外）都将被视为要添加到模型的模型属性。属性名称是通过使用 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>
从类名称派生的，除非在处理程序方法上存在 <code>@ModelAttribute</code> 注解。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该模型可以包含异步，响应式类型（例如：来自Reactor或RxJava）。在渲染之前，<code>AbstractView</code> 将此类模型属性解析为具体值并更新模型。
单值响应式类型被解析为单个值或无值（如果为空），而多值响应式类型（例如：<code>Flux&lt;T&gt;</code>）被收集并解析为 <code>List&lt;T&gt;</code>。</p>
</div>
<div class="paragraph">
<p>配置视图解析就像在Spring配置中添加 <code>ViewResolutionResultHandler</code> bean一样简单。
<a href="#webflux-config-view-resolvers">WebFlux Config</a>提供了专用于视图解析的配置API。</p>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">视图技术</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-redirecting-redirect-prefix"><a class="anchor" href="#webflux-redirecting-redirect-prefix"></a>重定向</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-redirecting-redirect-prefix">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>视图名称中的特殊 <code>redirect:</code> 前缀使你可以执行重定向。<code>UrlBasedViewResolver</code>（和子类）将其识别为需要重定向的指令。
视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>最终效果与控制器已返回 <code>RedirectView</code> 或 <code>Rendering.redirectTo("abc").build()</code> 相同，
但是现在控制器本身可以根据逻辑视图名称进行操作。视图名称（例如：<code>redirect:/some/resource</code>）是相对于当前应用程序的，
而视图名称（例如：<code>redirect:http://example.com/arbitrary/path</code>）将重定向到绝对URL。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multiple-representations"><a class="anchor" href="#webflux-multiple-representations"></a>内容协商</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multiple-representations">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ViewResolutionResultHandler</code> 支持内容协商。它将请求媒体类型与每个所选视图支持的媒体类型进行比较。
使用支持请求的媒体类型的第一个视图。</p>
</div>
<div class="paragraph">
<p>为了支持JSON和XML之类的媒体类型，Spring WebFlux提供了 <code>HttpMessageWriterView</code>，这是一个通过<a href="#webflux-codecs">HttpMessageWriter</a>渲染的特殊 <code>View</code>。
通常，你可以通过<a href="#webflux-config-view-resolvers">WebFlux配置</a>将其配置为默认视图。
如果默认视图与请求的媒体类型匹配，则始终会选择和使用它们。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-controller"><a class="anchor" href="#webflux-controller"></a>1.4. 带注解的控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-controller">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux提供了一个基于注解的编程模型，其中 <code>@Controller</code> 和 <code>@RestController</code>
组件使用注解来表达请求映射，请求输入，处理异常等。带注解的控制器具有灵活的方法签名，无需扩展基类或实现特定的接口。</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个基本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class HelloController {

    @GetMapping("/hello")
    public String handle() {
        return "Hello WebFlux";
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法返回要写入响应体的 <code>String</code>。</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller"><a class="anchor" href="#webflux-ann-controller"></a>1.4.1. <code>@Controller</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-controller">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用标准的Spring bean定义来定义控制器bean。<code>@Controller</code> 构造型允许自动检测，并且与Spring常规支持保持一致，
以支持在类路径中检测 <code>@Component</code> 类并为其自动注册Bean定义。它还充当带注解类的构造型，表明其作为Web组件的作用。</p>
</div>
<div class="paragraph">
<p>要启用对此类 <code>@Controller</code> bean的自动检测，可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan("org.example.web") <i class="conum" data-value="1"></i><b>(1)</b>
public class WebConfig {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>扫描 <code>org.example.web</code> 软件包。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@RestController</code> 是一个<a href="spring-core.html#beans-meta-annotations">组合式注解</a>，其本身使用 <code>@Controller</code> 和
<code>@ResponseBody</code> 进行了元注解，表示一个控制器，其每个方法都继承了类型级别的 <code>@ResponseBody</code> 注解，
因此直接将其写入响应体，而不是使用HTML模板进行视图解析和渲染。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping"><a class="anchor" href="#webflux-ann-requestmapping"></a>1.4.2. 请求映射</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> 注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。
你可以在类级别使用它来表示共享的映射，也可以在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> 还有特定于HTTP方法的快捷方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的注解是提供的<a href="#webflux-ann-requestmapping-composed">自定义注解</a>，因为可以说，大多数控制器方法应该映射到特定的HTTP方法，
而不是使用 <code>@RequestMapping</code>，后者默认情况下与所有HTTP方法匹配。同时，在类级别仍需要 <code>@RequestMapping</code> 来表示共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例使用类型和方法级别的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-uri-templates"><a class="anchor" href="#webflux-ann-requestmapping-uri-templates"></a>URI模式</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-uri-templates">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用全局模式和通配符来映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code> 匹配一个字符</p>
</li>
<li>
<p><code>*</code> 匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code> 匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你还可以声明URI变量并使用 <code>@PathVariable</code> 访问其值，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/owners/{ownerId}") <i class="conum" data-value="1"></i><b>(1)</b>
public class OwnerController {

    @GetMapping("/pets/{petId}") <i class="conum" data-value="2"></i><b>(2)</b>
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>类级URI映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>方法级URI映射。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>URI变量会自动转换为适当的类型，或者引发 <code>TypeMismatchException</code>。默认情况下支持简单类型（<code>int</code>，<code>long</code>，<code>Date</code>
等），你可以注册对任何其他数据类型的支持。请参阅<a href="#webflux-ann-typeconversion">Type Conversion</a>和<a href="#webflux-ann-initbinder"><code>DataBinder</code></a>。</p>
</div>
<div class="paragraph">
<p>你可以显式地命名URI变量（例如，<code>@PathVariable("customId")</code>），但是如果名称相同并且你的代码是使用调试信息或
Java 8上的 <code>-parameters</code> 编译器标志进行编译的，则可以省略该详细信息。</p>
</div>
<div class="paragraph">
<p>语法 <code>{*varName}</code> 声明了一个与零个或多个剩余路径段匹配的URI变量。例如：<code>/resources/{*path}</code> 匹配所有文件
<code>/resources/</code> ，并且“<code>path</code>”变量捕获完整的相对路径。</p>
</div>
<div class="paragraph">
<p>语法 <code>{varName:regex}</code> 声明带有正则表达式的URI变量，语法为 <code>{varName:regex}</code>。例如，给定URL
<code>"/spring-web-3.0.5.jar"</code>，以下方法提取名称，版本和文件扩展名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI路径模式也可以嵌入 <code>${&#8230;&#8203;}</code> 占位符，这些占位符在启动时通过针对本地，系统，环境和其他属性源使用
<code>PropertyPlaceHolderConfigurer</code> 进行解析。例如，你可以使用它来基于一些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring WebFlux使用 <code>PathPattern</code> 和 <code>PathPatternParser</code> 获得URI路径匹配支持。
这两个类都位于 <code>spring-web</code> 中，它们是专门为web应用程序中的HTTP URL路径设计的，
用于在运行时匹配大量的URI路径模式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux不支持后缀模式匹配&#8212;&#8203;这与Spring MVC不同，后者的映射（例如 <code>/person</code>）也匹配到 <code>/person.*</code>。
对于基于URL的内容协商，如果需要，我们建议使用查询参数，它更简单，更明确，并且不易受到基于URL路径的攻击。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-pattern-comparison"><a class="anchor" href="#webflux-ann-requestmapping-pattern-comparison"></a>模式比较</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-pattern-comparison">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须将它们进行比较以找到最佳匹配。这是通过 <code>PathPattern.SPECIFICITY_COMPARATOR</code> 完成的，该工具查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>对于每个模式，都会根据URI变量和通配符的数量计算得分，其中URI变量的得分低于通配符。总得分较低的模式将获胜。如果两个模式的分数相同，则选择较长的模式。</p>
</div>
<div class="paragraph">
<p>包罗万象的模式（例如： <code>**</code>, <code>{*varName}</code>）不计入评分，而是始终排在最后。如果两种模式都适用，则选择较长的模式。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-consumes"><a class="anchor" href="#webflux-ann-requestmapping-consumes"></a>可消费的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-consumes">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据请求的 <code>Content-Type</code> 缩小请求映射，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping(path = "/pets", <strong>consumes = "application/json"</strong>)
public void addPet(@RequestBody Pet pet) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>consumes</code> 属性还支持否定表达式&#8201;&#8212;&#8201;例如，<code>!text/plain</code> 表示除 <code>text/plain</code> 之外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以在类级别上声明一个共享的 <code>consumes</code> 属性。但是，与大多数其他请求映射属性不同，同时使用类级别和方法级别时，
方法级别 <code>consumes</code> 属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> 为常用的媒体类型提供常量，例如 <code>APPLICATION_JSON_VALUE</code> 和 <code>APPLICATION_XML_VALUE</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-produces"><a class="anchor" href="#webflux-ann-requestmapping-produces"></a>可生产的媒体类型</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-produces">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据 <code>Accept</code> 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", <strong>produces = "application/json;charset=UTF-8"</strong>)
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定的表达式&#8201;&#8212;&#8201;例如，<code>!text/plain</code> 表示除 <code>text/plain</code> 之外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以在类级别声明共享的 <code>produces</code> 属性。但是，与大多数其他请求映射属性不同，同时使用类级别和方法级别时，
方法级别 <code>produces</code> 属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> 为常用的媒体类型提供常量，例如 <code>APPLICATION_JSON_VALUE</code> 和 <code>APPLICATION_XML_VALUE</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-params-and-headers"><a class="anchor" href="#webflux-ann-requestmapping-params-and-headers"></a>请求参数，请求头</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-params-and-headers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据查询参数条件来缩小请求映射。你可以测试是否存在查询参数（<code>myParam</code>），或不存在查询参数（<code>!myParam</code>）
或查询参数有特定值（<code>myParam=myValue</code>）。以下示例显示如何测试特定值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>测试 <code>myParam</code> 是否等于 <code>myValue</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以将其与请求头条件一起使用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets", headers = "myHeader=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>测试 <code>myHeader</code> 是否等于 <code>myValue</code>。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-head-options"><a class="anchor" href="#webflux-ann-requestmapping-head-options"></a>HTTP HEAD, OPTIONS</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-head-options">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> (和 <code>@RequestMapping(method=HttpMethod.GET)</code>) 透明地支持HTTP HEAD以进行请求映射。
控制器方法无需更改。<code>HttpHandler</code> 服务器适配器中应用的响应包装器确保将 <code>Content-Length</code> 标头设置为写入的字节数，而无需实际写入响应。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过将 <code>Allow</code> 响应头设置为所有具有匹配URL模式的 <code>@RequestMapping</code> 方法中列出的HTTP方法列表
来处理HTTP OPTIONS。</p>
</div>
<div class="paragraph">
<p>对于没有HTTP方法声明的 <code>@RequestMapping</code>，将 <code>Allow</code> 响应头设置为 <code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。
建议控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：<code>@GetMapping</code>，<code>@PostMapping</code> 等）。</p>
</div>
<div class="paragraph">
<p>你可以将 <code>@RequestMapping</code> 方法显式映射到HTTP HEAD和HTTP OPTIONS，但这通常不是必需的。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-composed"><a class="anchor" href="#webflux-ann-requestmapping-composed"></a>自定义注解</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-composed">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux支持将<a href="spring-core.html#beans-meta-annotations">组合注解</a>用于请求映射。
这些注解本身使用 <code>@RequestMapping</code> 进行元注解，并且旨在以更狭窄，
更具体的用途重新声明 <code>@RequestMapping</code> 属性的子集（或全部）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> 和 <code>@PatchMapping</code> 是组合注解的示例。
之所以提供它们，是因为可以说，大多数控制器方法都应该映射到特定的HTTP方法，
而不是使用 <code>@RequestMapping</code>，后者默认情况下与所有HTTP方法都匹配。如果需要组合注解的示例，请查看如何声明它们。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还支持带有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，
它需要子类化 <code>RequestMappingHandlerMapping</code> 并覆盖 <code>getCustomMethodCondition</code>
方法，你可以在其中检查自定义属性并返回自己的 <code>RequestCondition</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestmapping-registration"><a class="anchor" href="#webflux-ann-requestmapping-registration"></a>显式注册</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-registration">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以通过编程方式注册Handler方法，你可以将其用于动态注册或高级案例，
例如同一处理程序在不同URL下的不同实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

        Method method = UserHandler.class.getMethod("getUser", Long.class); <i class="conum" data-value="3"></i><b>(3)</b>

        mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>添加注册。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-methods"><a class="anchor" href="#webflux-ann-methods"></a>1.4.3. 处理程序方法</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-methods">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-arguments"><a class="anchor" href="#webflux-ann-arguments"></a>Method Arguments</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-arguments">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method arguments.</p>
</div>
<div class="paragraph">
<p>Reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>) are
supported on arguments that require blocking I/O (for example, reading the request body) to
be resolved. This is marked in the Description column. Reactive types are not expected
on arguments that do not require blocking.</p>
</div>
<div class="paragraph">
<p>JDK 1.8&#8217;s <code>java.util.Optional</code> is supported as a method argument in combination with
annotations that have a <code>required</code> attribute (for example, <code>@RequestParam</code>, <code>@RequestHeader</code>,
and others) and is equivalent to <code>required=false</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the full <code>ServerWebExchange</code>&#8201;&#8212;&#8201;container for the HTTP request and response,
  request and session attributes, <code>checkNotModified</code> methods, and others.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code>, <code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the HTTP request or response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the session. This does not force the start of a new session unless attributes
  are added. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently authenticated user&#8201;&#8212;&#8201;possibly a specific <code>Principal</code> implementation class if known.
  Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http.HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available&#8201;&#8212;&#8201;in
  effect, the configured <code>LocaleResolver</code>/<code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to URI template variables. See <a href="#webflux-ann-requestmapping-uri-templates">URI模式</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to name-value pairs in URI path segments. See <a href="#webflux-ann-matrix-variables">Matrix Variables</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to Servlet request parameters. Parameter values are converted to the declared
  method argument type. See <a href="#webflux-ann-requestparam"><code>@RequestParam</code></a>.
</p><p class="tableblock">  Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers. Header values are converted to the declared method argument
  type. See <a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to cookies. Cookie values are converted to the declared method argument type.
  See <a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the HTTP request body. Body content is converted to the declared method
  argument type by using <code>HttpMessageReader</code> instances. Supports reactive types.
  See <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers and body. The body is converted with <code>HttpMessageReader</code> instances.
  Supports reactive types. See <a href="#webflux-ann-httpentity"><code>HttpEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a part in  a <code>multipart/form-data</code> request. Supports reactive types.
  See <a href="#webflux-multipart-forms">Multipart Content</a> and <a href="#webflux-multipart">Multipart数据</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, and <code>org.springframework.ui.ModelMap</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the model that is used in HTML controllers and is exposed to templates as
  part of view rendering.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to an existing attribute in the model (instantiated if not present) with
  data binding and validation applied. See <a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well
  as <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a> and <a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.
</p><p class="tableblock">  Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code>, <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to errors from validation and data binding for a command object
  (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or
  <code>@RequestPart</code> argument. An <code>Errors</code>, or <code>BindingResult</code> argument must be declared
  immediately after the validated method argument.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For marking form processing complete, which triggers cleanup of session attributes
  declared through a class-level <code>@SessionAttributes</code> annotation.
  See <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For preparing a URL relative to the current request&#8217;s host, port, scheme, and path.
  See <a href="#webflux-uri-building">URI链接</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute&#8201;&#8212;&#8201;in contrast to model attributes stored in the session
  as a result of a class-level <code>@SessionAttributes</code> declaration. See
  <a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes. See <a href="#webflux-ann-requestattrib">[webflux-ann-requestattrib]</a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a method argument is not matched to any of the above, it is, by default, resolved as
  a <code>@RequestParam</code> if it is a simple type, as determined by
  <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>,
  or as a <code>@ModelAttribute</code>, otherwise.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-return-types"><a class="anchor" href="#webflux-ann-return-types"></a>Return Values</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-return-types">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method return values. Note that reactive types
from libraries such as Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a> are
generally supported for all return values.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is encoded through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value specifies the full response, including HTTP headers, and the body is encoded
  through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For returning a response with headers and no body.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code> instances and used together with the implicit
  model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods. The handler
  method can also programmatically enrich the model by declaring a <code>Model</code> argument
  (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
  through command objects and <code>@ModelAttribute</code> methods. The handler method can also
  programmatically enrich the model by declaring a <code>Model</code> argument (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model, with the view name implicitly determined
  based on the request path.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An attribute to be added to the model, with the view name implicitly determined based
  on the request path.
</p><p class="tableblock">  Note that <code>@ModelAttribute</code> is optional. See &#8220;Any other return value&#8221; later in
  this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Rendering</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An API for model and view rendering scenarios.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code>, possibly asynchronous (for example, <code>Mono&lt;Void&gt;</code>), return type (or a <code>null</code> return
  value) is considered to have fully handled the response if it also has a <code>ServerHttpResponse</code>,
  a <code>ServerWebExchange</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true
  if the controller has made a positive ETag or <code>lastModified</code> timestamp check.
  // TODO: See <a href="#webflux-caching-etag-lastmodified">控制器</a> for details.
</p><p class="tableblock">  If none of the above is true, a <code>void</code> return type can also indicate &#8220;no response body&#8221; for
  REST controllers or default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;ServerSentEvent&gt;</code>, <code>Observable&lt;ServerSentEvent&gt;</code>, or other reactive type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emit server-sent events. The <code>ServerSentEvent</code> wrapper can be omitted when only data needs
  to be written (however, <code>text/event-stream</code> must be requested or declared in the mapping
  through the <code>produces</code> attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a return value is not matched to any of the above, it is, by default, treated as a view
  name, if it is <code>String</code> or <code>void</code> (default view name selection applies), or as a model
  attribute to be added to the model, unless it is a simple type, as determined by
  <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>,
  in which case it remains unresolved.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="webflux-ann-typeconversion"><a class="anchor" href="#webflux-ann-typeconversion"></a>Type Conversion</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-typeconversion">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Some annotated controller method arguments that represent String-based request input (for example,
<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>)
can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</div>
<div class="paragraph">
<p>For such cases, type conversion is automatically applied based on the configured converters.
By default, simple types (such as <code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. Type conversion
can be customized through a <code>WebDataBinder</code> (see <a href="#mvc-ann-initbinder">[mvc-ann-initbinder]</a>) or by registering
<code>Formatters</code> with the <code>FormattingConversionService</code> (see
<a href="core.html#format">Spring Field Formatting</a>).</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-matrix-variables"><a class="anchor" href="#webflux-ann-matrix-variables"></a>Matrix Variables</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-matrix-variables">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> discusses name-value pairs in
path segments. In Spring WebFlux, we refer to those as &#8220;matrix variables&#8221; based on an
<a href="http://www.w3.org/DesignIssues/MatrixURIs.html">&#8220;old post&#8221;</a> by Tim Berners-Lee, but they
can be also be referred to as URI path parameters.</p>
</div>
<div class="paragraph">
<p>Matrix variables can appear in any path segment, with each variable separated by a semicolon and
multiple values separated by commas&#8201;&#8212;&#8201;for example, <code>"/cars;color=red,green;year=2012"</code>. Multiple
values can also be specified through repeated variable names&#8201;&#8212;&#8201;for example,
<code>"color=red;color=green;color=blue"</code>.</p>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does
not affect request mappings. In other words, you are not required to use a URI variable
to mask variable content. That said, if you want to access matrix variables from a
controller method, you need to add a URI variable to the path segment where matrix
variables are expected. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that all path segments can contain matrix variables, you may sometimes need to
disambiguate which path variable the matrix variable is expected to be in,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define a matrix variable may be defined as optional and specify a default value
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get all matrix variables, use a <code>MultiValueMap</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
        @MatrixVariable(pathVar="petId"") MultiValueMap&lt;String, String&gt; petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestparam"><a class="anchor" href="#webflux-ann-requestparam"></a><code>@RequestParam</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestparam">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestParam</code> annotation to bind query parameters to a method argument in a
controller. The following code snippet shows the usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestParam</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Servlet API &#8220;request parameter&#8221; concept conflates query parameters, form
data, and multiparts into one. However, in WebFlux, each is accessed individually through
<code>ServerWebExchange</code>. While <code>@RequestParam</code> binds to query parameters only, you can use
data binding to apply query parameters, form data, and multiparts to a
<a href="#webflux-ann-modelattrib-method-args">command object</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Method parameters that use the <code>@RequestParam</code> annotation are required by default, but
you can specify that a method parameter is optional by setting the required flag of a <code>@RequestParam</code>
to <code>false</code> or by declaring the argument with a <code>java.util.Optional</code>
wrapper.</p>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestParam</code> annotation is declared on a <code>Map&lt;String, String&gt;</code> or
<code>MultiValueMap&lt;String, String&gt;</code> argument, the map is populated with all query parameters.</p>
</div>
<div class="paragraph">
<p>Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes. By
default, any argument that is a simple value type (as determined by
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>)
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@RequestParam</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestheader"><a class="anchor" href="#webflux-ann-requestheader"></a><code>@RequestHeader</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestheader">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a
controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with headers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
<div class="paragraph">
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestHeader("Keep-Alive") long keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>Accept-Encoging</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the value of the <code>Keep-Alive</code> header.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestHeader</code> annotation is used on a <code>Map&lt;String, String&gt;</code>,
<code>MultiValueMap&lt;String, String&gt;</code>, or <code>HttpHeaders</code> argument, the map is populated
with all header values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with <code>@RequestHeader("Accept")</code> may be of type
<code>String</code> but also of <code>String[]</code> or <code>List&lt;String&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-cookievalue"><a class="anchor" href="#webflux-ann-cookievalue"></a><code>@CookieValue</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-cookievalue">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@CookieValue</code> annotation to bind the value of an HTTP cookie to a method argument
in a controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with a cookie:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
<div class="paragraph">
<p>The following code sample demonstrates how to get the cookie value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
    //...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the cookie value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-modelattrib-method-args"><a class="anchor" href="#webflux-ann-modelattrib-method-args"></a><code>@ModelAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-modelattrib-method-args">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation on a method argument to access an attribute from the
model or have it instantiated if not present. The model attribute is also overlain with
the values of query parameters and form fields whose names match to field names. This is
referred to as data binding, and it saves you from having to deal with parsing and
converting individual query parameters and form fields. The following example binds an instance of <code>Pet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bind an instance of <code>Pet</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Pet</code> instance in the preceding example is resolved as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From the model if already added through <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a>.</p>
</li>
<li>
<p>From the HTTP session through <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</li>
<li>
<p>From the invocation of a default constructor.</p>
</li>
<li>
<p>From the invocation of a &#8220;primary constructor&#8221; with arguments that match query
parameters or form fields. Argument names are determined through JavaBeans
<code>@ConstructorProperties</code> or through runtime-retained parameter names in the bytecode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After the model attribute instance is obtained, data binding is applied. The
<code>WebExchangeDataBinder</code> class matches names of query parameters and form fields to field
names on the target <code>Object</code>. Matching fields are populated after type conversion is applied
where necessary. For more on data binding (and validation), see
<a href="core.html#validation">Validation</a>. For more on customizing data binding, see
<a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>Data binding can result in errors. By default, a <code>WebExchangeBindException</code> is raised, but,
to check for such errors in the controller method, you can add a <code>BindingResult</code> argument
immediately next to the <code>@ModelAttribute</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a <code>BindingResult</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can automatically apply validation after data binding by adding the
<code>javax.validation.Valid</code> annotation or Spring&#8217;s <code>@Validated</code> annotation (see also
<a href="core.html#validation-beanvalidation">Bean validation</a> and
<a href="core.html#validation">Spring validation</a>). The following example uses the <code>@Valid</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(<strong>@Valid @ModelAttribute("pet") Pet pet</strong>, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@Valid</code> on a model attribute argument.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux, unlike Spring MVC, supports reactive types in the model&#8201;&#8212;&#8201;for example,
<code>Mono&lt;Account&gt;</code> or <code>io.reactivex.Single&lt;Account&gt;</code>. You can declare a <code>@ModelAttribute</code> argument
with or without a reactive type wrapper, and it will be resolved accordingly,
to the actual value if necessary. However, note that, to use a <code>BindingResult</code>
argument, you must declare the <code>@ModelAttribute</code> argument before it without a reactive
type wrapper, as shown earlier. Alternatively, you can handle any errors through the
reactive type, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public Mono&lt;String&gt; processSubmit(@Valid @ModelAttribute("pet") Mono&lt;Pet&gt; petMono) {
    return petMono
        .flatMap(pet -&gt; {
            // ...
        })
        .onErrorResume(ex -&gt; {
            // ...
        });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
By default, any argument that is not a simple value type( as determined by
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-">BeanUtils#isSimpleProperty</a>)
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@ModelAttribute</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattributes"><a class="anchor" href="#webflux-ann-sessionattributes"></a><code>@SessionAttributes</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-sessionattributes">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code> is used to store model attributes in the <code>WebSession</code> between
requests. It is a type-level annotation that declares session attributes used by a
specific controller. This typically lists the names of model attributes or types of
model attributes that should be transparently stored in the session for subsequent
requests to access.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the first request, when a model attribute with the name, <code>pet</code>, is added to the model,
it is automatically promoted to and saved in the <code>WebSession</code>. It remains there until
another controller method uses a <code>SessionStatus</code> method argument to clear the storage,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) { <i class="conum" data-value="2"></i><b>(2)</b>
        if (errors.hasErrors) {
            // ...
        }
            status.setComplete();
            // ...
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>SessionStatus</code> variable.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-sessionattribute"><a class="anchor" href="#webflux-ann-sessionattribute"></a><code>@SessionAttribute</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-sessionattribute">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>If you need access to pre-existing session attributes that are managed globally
(that is, outside the controller&#8201;&#8212;&#8201;for example, by a filter) and may or may not be present,
you can use the <code>@SessionAttribute</code> annotation on a method parameter, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@SessionAttribute User user) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@SessionAttribute</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For use cases that require adding or removing session attributes, consider injecting
<code>WebSession</code> into the controller method.</p>
</div>
<div class="paragraph">
<p>For temporary storage of model attributes in the session as part of a controller
workflow, consider using <code>SessionAttributes</code>, as described in
<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</div>
<div id="webflux-ann-requestattrib" class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestattrib">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Similarly to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotation to
access pre-existing request attributes created earlier (for example, by a <code>WebFilter</code>),
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestAttribute</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-multipart-forms"><a class="anchor" href="#webflux-multipart-forms"></a>Multipart Content</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multipart-forms">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>As explained in <a href="#webflux-multipart">Multipart数据</a>, <code>ServerWebExchange</code> provides access to multipart
content. The best way to handle a file upload form (for example, from a browser) in a controller
is through data binding to a <a href="#webflux-ann-modelattrib-method-args">command object</a>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyForm {

    private String name;

    private MultipartFile file;

    // ...

}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also submit multipart requests from non-browser clients in a RESTful service
scenario. The following example uses a file along with JSON:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
    "name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
<div class="paragraph">
<p>You can access individual parts with <code>@RequestPart</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") Part metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        @RequestPart("file-data") FilePart file) { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>@RequestPart</code> to get the file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To deserialize the raw part content (for example, to JSON&#8201;&#8212;&#8201;similar to <code>@RequestBody</code>),
you can declare a concrete target <code>Object</code>, instead of <code>Part</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use <code>@RequestPart</code> combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or <code>BindingResult</code> argument, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata, <i class="conum" data-value="1"></i><b>(1)</b>
        BindingResult result) { <i class="conum" data-value="2"></i><b>(2)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>@Valid</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>BindingResult</code> argument.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To access all multipart data as a <code>MultiValueMap</code>, you can use <code>@RequestBody</code>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To access multipart data sequentially, in streaming fashion, you can use <code>@RequestBody</code> with
<code>Flux&lt;Part&gt;</code> instead, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Flux&lt;Part&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-requestbody"><a class="anchor" href="#webflux-ann-requestbody"></a><code>@RequestBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestbody">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestBody</code> annotation to have the request body read and deserialized into an
<code>Object</code> through an <a href="#webflux-codecs">HttpMessageReader</a>.
The following example uses a <code>@RequestBody</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the <code>@RequestBody</code> method argument supports reactive types
and fully non-blocking reading and (client-to-server) streaming. The following example
uses a <code>Mono</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Mono&lt;Account&gt; account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP消息编解码器</a> option of the <a href="#webflux-config">WebFlux配置</a> to
configure or customize message readers.</p>
</div>
<div class="paragraph">
<p>You can use <code>@RequestBody</code> in combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or a <code>BindingResult</code> argument. The following
example uses a <code>BindingResult</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-httpentity"><a class="anchor" href="#webflux-ann-httpentity"></a><code>HttpEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-httpentity">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code> is more or less identical to using <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a> but is based on a
container object that exposes request headers and the body. The following example uses an
<code>HttpEntity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responsebody"><a class="anchor" href="#webflux-ann-responsebody"></a><code>@ResponseBody</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-responsebody">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ResponseBody</code> annotation on a method to have the return serialized to the
response body through an <a href="#webflux-codecs">HttpMessageWriter</a>. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of <code>@RestController</code>, which is nothing more
than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> supports reactive types, which means you can return Reactor or RxJava
types and have the asynchronous values they produce rendered to the response.
For additional details, see <a href="#webflux-codecs-streaming">Streaming</a> and
<a href="#webflux-codecs-jackson">JSON rendering</a>.</p>
</div>
<div class="paragraph">
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views.
See <a href="#webflux-ann-jackson">Jackson JSON</a> for details.</p>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP消息编解码器</a> option of the <a href="#webflux-config">WebFlux配置</a> to
configure or customize message writing.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-responseentity"><a class="anchor" href="#webflux-ann-responseentity"></a><code>ResponseEntity</code></h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-responseentity">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code> is like <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux supports using a single value <a href="#webflux-reactive-libraries">reactive type</a> to
produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types
for the body.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-ann-jackson"><a class="anchor" href="#webflux-ann-jackson"></a>Jackson JSON</h5>
<div class="paragraph">
<p>Spring offers support for the Jackson JSON library.</p>
</div>
<div class="sect5">
<h6 id="webflux-ann-jsonview"><a class="anchor" href="#webflux-ann-jsonview"></a>Jackson Serialization Views</h6>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-jackson">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides built-in support for
<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson&#8217;s Serialization Views</a>,
which allows rendering only a subset of all fields in an <code>Object</code>. To use it with
<code>@ResponseBody</code> or <code>ResponseEntity</code> controller methods, you can use Jackson&#8217;s
<code>@JsonView</code> annotation to activate a serialization view class, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@JsonView</code> allows an array of view classes but you can only specify only one per
controller method. Use a composite interface if you need to activate multiple views.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-modelattrib-methods"><a class="anchor" href="#webflux-ann-modelattrib-methods"></a>1.4.4. <code>Model</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-modelattrib-methods">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@ModelAttribute</code> 注解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>@RequestMapping</code> 方法中的<a href="#webflux-ann-modelattrib-method-args">方法参数</a>上，
可从模型创建或访问 <code>Object</code>，并将其通过 <code>WebDataBinder</code> 绑定到请求。</p>
</li>
<li>
<p>作为 <code>@Controller</code> 或 <code>@ControllerAdvice</code> 类中的方法级注解，可在任何 <code>@RequestMapping</code> 方法调用之前帮助初始化模型。</p>
</li>
<li>
<p>在 <code>@RequestMapping</code> 方法上标记它的返回值是一个模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论 <code>@ModelAttribute</code> 方法&#8201;&#8212;&#8201;前面列表中的第二项。控制器可以具有任意数量的 <code>@ModelAttribute</code> 方法。
所有此类方法均在同一控制器中的 <code>@RequestMapping</code> 方法之前调用。也可以通过 <code>@ControllerAdvice</code> 在控制器之间共享
<code>@ModelAttribute</code> 方法。有关更多详细信息，请参阅<a href="#webflux-ann-controller-advice">控制器通知</a>部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code> 方法具有灵活的方法签名。它们支持与 <code>@RequestMapping</code> 方法相同的许多参数，除了
<code>@ModelAttribute</code> 本身或与请求正文相关的任何东西。</p>
</div>
<div class="paragraph">
<p>下面的示例使用 <code>@ModelAttribute</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果未明确指定名称，则根据类型选择默认名称，如 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/Conventions.html"><code>Conventions</code></a>的javadoc中所述。
你始终可以使用重载的 <code>addAttribute</code> 方法或通过 <code>@ModelAttribute</code> 上的 <code>name</code> 属性（用于返回值）来分配显式名称。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux在模型中显式支持响应式类型（例如：<code>Mono&lt;Account&gt;</code> 或 <code>io.reactivex.Single&lt;Account&gt;</code>）。
可以在 <code>@RequestMapping</code> 调用时将此类异步模型属性透明地解析（并更新模型）为其实际值，
只要声明了 <code>@ModelAttribute</code> 参数而没有包装，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void addAccount(@RequestParam String number) {
    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);
    model.addAttribute("account", accountMono);
}

@PostMapping("/accounts")
public String handle(@ModelAttribute Account account, BindingResult errors) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，任何具有响应式类型包装器的模型属性都将在视图渲染之前解析为其实际值（并更新了模型）。</p>
</div>
<div class="paragraph">
<p>你也可以将 <code>@ModelAttribute</code> 用作 <code>@RequestMapping</code> 方法上的方法级注释，
在这种情况下，<code>@RequestMapping</code> 方法的返回值将解释为模型属性。通常不需要这样做，因为它是HTML控制器的默认行为，
除非返回值是一个 <code>String</code>，不这样做它将被解释为视图名称。<code>@ModelAttribute</code> 还可以自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-initbinder"><a class="anchor" href="#webflux-ann-initbinder"></a>1.4.5. <code>DataBinder</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-initbinder">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> 或 <code>@ControllerAdvice</code> 类可以具有用于初始化 <code>WebDataBinder</code> 实例的 <code>@InitBinder</code> 方法，而这些方法又可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单或查询数据）绑定到模型对象。</p>
</li>
<li>
<p>将基于字符串的请求值（例如请求参数，路径变量，请求头，Cookie等）转换为控制器方法参数的目标类型。</p>
</li>
<li>
<p>呈现HTML表单时，将模型对象的值格式化为 <code>String</code> 值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> 方法可以注册特定于控制器的 <code>java.bean.PropertyEditor</code> 或
Spring <code>Converter</code> 和 <code>Formatter</code> 组件。另外，你可以使用<a href="#webflux-config-conversion">WebFlux Java配置</a>在全局共享的
<code>FormattingConversionService</code> 中注册 <code>Converter</code> 和 <code>Formatter</code> 类型。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> 方法支持与 <code>@RequestMapping</code> 方法相同的许多参数，除了 <code>@ModelAttribute</code>（命令对象）参数。
通常，它们使用 <code>WebDataBinder</code> 参数（用于注册）和 <code>void</code> 返回值声明。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>@InitBinder</code> 注解。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外，当通过共享的 <code>FormattingConversionService</code> 使用基于
<code>Formatter</code> 的设置时，可以重新使用相同的方法并注册特定于控制器的 <code>Formatter</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加自定义格式化器（在这种情况下为 <code>DateFormatter</code>）。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-exceptions"><a class="anchor" href="#webflux-ann-controller-exceptions"></a>1.4.6. 管理异常</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-exceptionhandler">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> 和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以具有 <code>@ExceptionHandler</code> 方法来处理来自控制器方法的异常。
下面的示例包括这样的处理程序方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class SimpleController {

    // ...

    @ExceptionHandler <i class="conum" data-value="1"></i><b>(1)</b>
    public ResponseEntity&lt;String&gt; handle(IOException ex) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>声明一个 <code>@ExceptionHandler</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>该异常可能与正在传播的顶级异常（即直接抛出 <code>IOException</code>）匹配，也可能与顶级包装器异常（例如，包装在 <code>IllegalStateException</code> 内部的
<code>IOException</code>）内的直接cause匹配。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。或者，注解声明可以缩小异常类型以使其匹配。
我们通常建议在参数签名中尽可能具体，并在以相应顺序优先的 <code>@ControllerAdvice</code> 上声明你的主要root异常映射。
有关详细信息，请参见<a href="spring-mvc.html#mvc-ann-exceptionhandler">MVC部分</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
WebFlux中的 <code>@ExceptionHandler</code> 方法支持与 <code>@RequestMapping</code> 方法相同的方法参数和返回值，
但与请求体和 <code>@ModelAttribute</code> 相关的方法参数除外。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>HandlerAdapter</code> 为 <code>@RequestMapping</code> 方法提供对Spring WebFlux中 <code>@ExceptionHandler</code> 方法的支持。
有关更多详细信息，请参见<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>。</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-rest-exceptions"><a class="anchor" href="#webflux-ann-rest-exceptions"></a>REST API异常</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-rest-exceptions">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的常见要求是在响应正文中包含错误详细信息。Spring框架不会自动执行此操作，
因为响应主体中错误详细信息的表示是特定于应用程序的。但是，<code>@RestController</code> 可以将 <code>@ExceptionHandler</code>
方法与 <code>ResponseEntity</code> 返回值一起使用，以设置响应的状态和主体。也可以在 <code>@ControllerAdvice</code>
类中声明此类方法，以将其全局应用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意，Spring WebFlux与Spring MVC <code>ResponseEntityExceptionHandler</code> 没有等效项，
因为WebFlux仅引发 <code>ResponseStatusException</code>（或其子类），并且不需要将其转换为HTTP状态码。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-controller-advice"><a class="anchor" href="#webflux-ann-controller-advice"></a>1.4.7. 控制器通知</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-controller-advice">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code> 和 <code>@ModelAttribute</code> 方法在声明它们的 <code>@Controller</code> 类
（或类层次结构）中应用。如果希望此类方法在全局范围内（跨控制器）应用，则可以在带有 <code>@ControllerAdvice</code>
或 <code>@RestControllerAdvice</code> 注解的类中声明它们。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code> 带有 <code>@Component</code> 注解，这意味着可以通过
<a href="spring-core.html#beans-java-instantiating-container-scan">组件扫描</a>将此类注册为Spring Bean。
<code>@RestControllerAdvice</code> 是由 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 注解的组合注解，
这实际上意味着 <code>@ExceptionHandler</code> 方法通过消息转换（相对于视图解析或模板渲染）呈现给响应体的。</p>
</div>
<div class="paragraph">
<p>启动时，<code>@RequestMapping</code> 和 <code>@ExceptionHandler</code> 方法的基础结构类将检测使用 <code>@ControllerAdvice</code> 注解的Spring bean，
然后在运行时应用其方法。全局 <code>@ExceptionHandler</code> 方法（来自 <code>@ControllerAdvice</code>）在本地方法（来自 <code>@Controller</code>）
<em>之后</em> 应用。相比之下，全局 <code>@ModelAttribute</code> 和 <code>@InitBinder</code> 方法在本地方法 <em>之前</em> 应用。</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>@ControllerAdvice</code> 方法适用于每个请求（即所有控制器），但是你可以通过使用注解上的属性将其范围缩小
到控制器的子集，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html"><code>@ControllerAdvice</code></a>javadoc。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-fn"><a class="anchor" href="#webflux-fn"></a>1.5. 函数式端点</h3>
<div class="paragraph">
<p>Spring WebFlux包含WebFlux.fn，这是一个轻量级的函数式编程模型，其中的函数用于路由和处理请求，
而契约则是为不变性而设计的。它是基于注解的编程模型的替代方案，但可以在相同的
<a href="#webflux-reactive-spring-web">Reactive核心</a>基础上运行。</p>
</div>
<div class="sect3">
<h4 id="webflux-fn-overview"><a class="anchor" href="#webflux-fn-overview"></a>1.5.1. 概览</h4>
<div class="paragraph">
<p>在WebFlux.fn中，HTTP请求由 <code>HandlerFunction</code> 处理：该函数接受 <code>ServerRequest</code> 并返回延迟的 <code>ServerResponse</code>
（即 <code>Mono&lt;ServerResponse&gt;</code>）。请求和响应对象都有不可变的契约，这些契约提供对HTTP请求和响应的JDK 8友好访问。
<code>HandlerFunction</code> 等效于基于注解的编程模型中 <code>@RequestMapping</code> 方法的主体。</p>
</div>
<div class="paragraph">
<p>传入的请求通过 <code>RouterFunction</code> 路由到处理程序函数：该函数接受 <code>ServerRequest</code> 并返回延迟的 <code>HandlerFunction</code>
（即 <code>Mono&lt;HandlerFunction&gt;</code>）。当路由器函数匹配时，返回处理程序函数。否则为空Mono。
<code>RouterFunction</code> 等效于 <code>@RequestMapping</code> 注解，但主要区别在于路由器函数不仅提供数据，还提供行为。</p>
</div>
<div class="paragraph">
<p><code>RouterFunctions.route()</code> 提供了一个路由器构建器，可简化路由器的创建过程，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople)
    .POST("/person", handler::createPerson)
    .build();


public class PersonHandler {

    // ...

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>RouterFunction</code> 的一种方法是将其转换为 <code>HttpHandler</code> 并通过内置
<a href="#webflux-httphandler">服务器适配器</a>之一进行安装：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数应用程序都可以通过WebFlux Java配置运行，请参阅<a href="#webflux-fn-running">运行服务器</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-functions"><a class="anchor" href="#webflux-fn-handler-functions"></a>1.5.2. HandlerFunction</h4>
<div class="paragraph">
<p><code>ServerRequest</code> 和 <code>ServerResponse</code> 是不可变的接口，它们提供JDK 8友好的HTTP请求和响应访问。
请求和响应都提供对主体流的 <a href="http://www.reactive-streams.org">Reactive Streams</a>背压。请求主体用Reactor <code>Flux</code> 或 <code>Mono</code> 表示。
响应主体由任何Reactive Streams <code>Publisher</code> 组成，包括 <code>Flux</code> 和 <code>Mono</code>。有关更多信息，请参见
<a href="#webflux-reactive-libraries">响应式库</a>。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-request"><a class="anchor" href="#webflux-fn-request"></a><code>ServerRequest</code></h5>
<div class="paragraph">
<p><code>ServerRequest</code> 提供对HTTP方法，URI，标头和查询参数的访问，而通过 <code>body</code> 方法提供对主体的访问。</p>
</div>
<div class="paragraph">
<p>下面的示例将请求体提取到 <code>Mono&lt;String&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; string = request.bodyToMono(String.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例将主体提取到 <code>Flux&lt;Person&gt;</code>（或Kotlin中的 <code>Flux&lt;Person&gt;</code>），其中 <code>Person</code> 对象从某种序列化形式（例如：JSON或XML）解码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例是使用更通用的 <code>ServerRequest.body(BodyExtractor)</code> 的快捷方式，该请求接受
<code>BodyExtractor</code> 函数式策略接口。实用工具类 <code>BodyExtractors</code> 提供对许多实例的访问。例如，前面的示例也可以编写如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; string = request.body(BodyExtractors.toMono(String.class));
Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示如何访问表单数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, String&gt; map = request.formData();</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何以map形式访问multipart数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, Part&gt; map = request.multipartData();</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何以流方式一次访问multiparts：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Flux&lt;Part&gt; parts = request.body(BodyExtractos.toParts());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-response"><a class="anchor" href="#webflux-fn-response"></a><code>ServerResponse</code></h5>
<div class="paragraph">
<p><code>ServerResponse</code> 提供对HTTP响应的访问，并且由于它是不可变的，因此你可以使用 <code>build</code> 方法来创建它。
你可以使用构建器来设置响应状态，添加响应头或提供响应体。以下示例使用JSON内容创建200（OK）响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何构建一个具有 <code>Location</code> 标头且没有正文的201（CREATED）响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI location = ...
ServerResponse.created(location).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据所使用的编解码器，可以传递提示参数以自定义主体的序列化或反序列化方式。例如，要指定
<a href="https://www.baeldung.com/jackson-json-view-annotation">Jackson JSON视图</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-classes"><a class="anchor" href="#webflux-fn-handler-classes"></a>处理程序类</h5>
<div class="paragraph">
<p>我们可以将处理程序函数编写为lambda，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HandlerFunction&lt;ServerResponse&gt; helloWorld =
  request -&gt; ServerResponse.ok().body(fromObject("Hello World"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>这很方便，但是在应用程序中我们需要多个函数，并且多个内联lambda可能会变得凌乱。
因此，将相关的处理程序函数分组到一个处理程序类中很有用，该类的作用与基于注解的应用程序中的
<code>@Controller</code> 相似。例如，以下类公开了响应式类型 <code>Person</code> 存储库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.ServerResponse.ok;
import static org.springframework.web.reactive.function.BodyInserters.fromObject;

public class PersonHandler {

    private final PersonRepository repository;

    public PersonHandler(PersonRepository repository) {
        this.repository = repository;
    }

    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) { <i class="conum" data-value="1"></i><b>(1)</b>
        Flux&lt;Person&gt; people = repository.allPeople();
        return ok().contentType(APPLICATION_JSON).body(people, Person.class);
    }

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) { <i class="conum" data-value="2"></i><b>(2)</b>
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);
        return ok().build(repository.savePerson(person));
    }

    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) { <i class="conum" data-value="3"></i><b>(3)</b>
        int personId = Integer.valueOf(request.pathVariable("id"));
        return repository.getPerson(personId)
            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).body(fromObject(person)))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>listPeople</code> 是一个处理函数，它以JSON格式返回存储库中找到的所有 <code>Person</code> 对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>createPerson</code> 是一个处理函数，用于存储请求正文中包含的新 <code>Person</code>。请注意，<code>PersonRepository.savePerson(Person)</code>
返回 <code>Mono&lt;Void&gt;</code>：一个空的 <code>Mono</code>，当从请求中读取并存储此人时，它将发出完成信号。
因此，当接收到完成信号时（即 <code>Person</code> 保存完毕时），我们使用 <code>build(Publisher&lt;Void&gt;)</code> 方法发送响应。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>getPerson</code> 是一个处理程序函数，它返回由 <code>id</code> 路径变量标识的单个人。我们从存储库中检索该
<code>Person</code> 并创建一个JSON响应（如果找到）。如果未找到，则使用 <code>switchIfEmpty(Mono&lt;T&gt;)</code>
返回404 Not Found响应。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-handler-validation"><a class="anchor" href="#webflux-fn-handler-validation"></a>验证</h5>
<div class="paragraph">
<p>函数式端点可以使用Spring的 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#validation">验证工具</a>将验证应用于请求体。
例如，给定 <code>Person</code> 的自定义Spring <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#validation">Validator</a>实现：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class PersonHandler {

    private final Validator validator = new PersonValidator(); <i class="conum" data-value="1"></i><b>(1)</b>

    // ...

    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) {
        Mono&lt;Person&gt; person = request.bodyToMono(Person.class).doOnNext(this::validate); <i class="conum" data-value="2"></i><b>(2)</b>
        return ok().build(repository.savePerson(person));
    }

    private void validate(Person person) {
        Errors errors = new BeanPropertyBindingResult(body, "person");
        validator.validate(body, errors);
        if (errors.hasErrors) {
            throw new ServerWebInputException(errors.toString()); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建 <code>Validator</code> 实例。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>应用验证。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>引发400响应的异常。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>处理程序还可以通过基于 <code>LocalValidatorFactoryBean</code> 创建和注入全局 <code>Validator</code> 实例来使用标准Bean验证API（JSR-303）。
请参阅 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#validation-beanvalidation">Spring Validation</a>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-router-functions"><a class="anchor" href="#webflux-fn-router-functions"></a>1.5.3. <code>RouterFunction</code></h4>
<div class="paragraph">
<p>路由器函数用于将请求路由到相应的 <code>HandlerFunction</code>。通常，你不是自己编写路由器函数，
而是使用 <code>RouterFunctions</code> 实用工具类上的方法来创建一个。<code>RouterFunctions.route()</code>（无参数）
为你提供了流式生成器，用于创建路由器函数，而 <code>RouterFunctions.route(RequestPredicate，HandlerFunction)</code>
提供了直接创建路由器的方法。</p>
</div>
<div class="paragraph">
<p>通常，建议使用 <code>route()</code> 构建器，因为它为典型的映射方案提供了便捷的快捷方式，而无需难以发现的静态导入。
例如，路由器函数构建器提供了 <code>GET(String, HandlerFunction)</code> 方法来为GET请求创建映射，
和 <code>POST(String, HandlerFunction)</code> 来为POST请求创建映射。</p>
</div>
<div class="paragraph">
<p>除了基于HTTP方法的映射外，路由构建器还提供了一种在映射到请求时引入其他谓词的方法。
对于每个HTTP方法，都有一个重载的变体，它以 <code>RequestPredicate</code> 作为参数，但是可以表示哪些额外的约束。</p>
</div>
<div class="sect4">
<h5 id="webflux-fn-predicates"><a class="anchor" href="#webflux-fn-predicates"></a>谓词</h5>
<div class="paragraph">
<p>你可以编写自己的 <code>RequestPredicate</code>，但是 <code>RequestPredicates</code> 实用工具类根据请求路径，HTTP方法，
内容类型等提供许多常用的实现。以下示例使用请求谓词基于 <code>Accept</code> 头创建约束：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()
    .GET("/hello-world", accept(MediaType.TEXT_PLAIN),
        request -&gt; Response.ok().body(fromObject("Hello World")));</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用以下命令组合多个请求谓词：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RequestPredicate.and(RequestPredicate)</code>&#8201;&#8212;&#8201;两者必须匹配。</p>
</li>
<li>
<p><code>RequestPredicate.or(RequestPredicate)</code>&#8201;&#8212;&#8201;任何一个匹配即可。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>RequestPredicates</code> 中的许多谓词都是组合的。例如，<code>RequestPredicates.GET(String)</code> 由
<code>RequestPredicates.method(HttpMethod)</code> 和 <code>RequestPredicates.path(String)</code> 组合。
上面显示的示例还使用了两个请求谓词，因为构建器在内部使用 <code>RequestPredicates.GET</code> 并将其与 <code>accept</code> 谓词组合在一起。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-fn-routes"><a class="anchor" href="#webflux-fn-routes"></a>路由</h5>
<div class="paragraph">
<p>路由器函数按顺序评估：如果第一个路由不匹配，则评估第二个路由，依此类推。
因此，在通用路由之前声明更具体的路由是有意义的。请注意，此行为不同于基于注解的编程模型，在该模型中，将自动选择“最特定”的控制器方法。</p>
</div>
<div class="paragraph">
<p>使用路由器函数生成器时，所有定义的路由都组成一个 <code>RouterFunction</code>，从 <code>build()</code> 返回。还有其他方法可以将多个路由器函数组合在一起：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>RouterFunctions.route()</code> 构建器上执行 <code>add(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.and(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code>&#8201;&#8212;&#8201;具有嵌套 <code>RouterFunctions.route()</code> 的 <code>RouterFunction.and()</code> 的快捷方式。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了四种路由的组合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction&lt;ServerResponse&gt; otherRoute = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) <i class="conum" data-value="1"></i><b>(1)</b>
    .GET("/person", accept(APPLICATION_JSON), handler::listPeople) <i class="conum" data-value="2"></i><b>(2)</b>
    .POST("/person", handler::createPerson) <i class="conum" data-value="3"></i><b>(3)</b>
    .add(otherRoute) <i class="conum" data-value="4"></i><b>(4)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>带有与JSON匹配的 <code>Accept</code> 标头的 <code>GET /person/{id}</code> 被路由到 <code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>带有与JSON匹配的 <code>Accept</code> 标头的 <code>GET /person</code> 被路由到 <code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>没有其他谓词的 <code>POST /person</code> 被路由到 <code>PersonHandler.createPerson</code>，并且</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>otherRoute</code> 是在其他地方创建的路由器函数，并将其添加到构建的路由中。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="嵌套路由"><a class="anchor" href="#嵌套路由"></a>嵌套路由</h5>
<div class="paragraph">
<p>一组路由器函数通常具有共享谓词，例如：共享路径。在上面的示例中，共享谓词将是与 <code>/person</code> 匹配的路径谓词，由三个路由使用。
使用注解时，你可以通过使用映射到 <code>/person</code> 的类级别 <code>@RequestMapping</code> 注解来删除此重复项。
在WebFlux.fn中，可以通过路由器函数构建器上的 <code>path</code> 方法共享路径谓词。
例如，以上示例的最后几行可以通过使用嵌套路由以以下方式进行改进：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", builder -&gt; builder
        .GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
        .GET("", accept(APPLICATION_JSON), handler::listPeople)
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，<code>path</code> 的第二个参数是使用路由器构建器的消费者。</p>
</div>
<div class="paragraph">
<p>尽管基于路径的嵌套是最常见的，但是你可以通过使用构建器上的 <code>nest</code> 方法来嵌套在任何种类的谓词上。
上面的内容仍然包含一些以共享的 <code>Accept</code>-header 谓词形式出现的重复。通过将 <code>nest</code> 方法与 <code>accept</code> 一起使用，我们可以进一步改进：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .build();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-running"><a class="anchor" href="#webflux-fn-running"></a>1.5.4. 运行服务器</h4>
<div class="paragraph">
<p>如何在HTTP服务器中运行路由器函数？一个简单的选项是使用以下方法之一将路由器函数转换为 <code>HttpHandler</code>：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction)</code></p>
</li>
<li>
<p><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后，可以通过遵循<a href="#webflux-httphandler">HttpHandler</a>来获取特定于服务器的指令，将返回的
<code>HttpHandler</code> 与许多服务器适配器一起使用。</p>
</div>
<div class="paragraph">
<p>Spring Boot还使用了一个更典型的选项，即通过<a href="#webflux-config">WebFlux配置</a>使用基于
<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>的设置来运行，
该配置使用Spring配置声明处理请求所需的组件。WebFlux Java配置声明以下基础设施组件以支持函数式端点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RouterFunctionMapping</code>: 在Spring配置中检测一个或多个 <code>RouterFunction&lt;?&gt;</code> bean，通过 <code>RouterFunction.andOther</code> 组合它们，
并将请求路由到生成的组合 <code>RouterFunction</code>。</p>
</li>
<li>
<p><code>HandlerFunctionAdapter</code>: 简单的适配器，使 <code>DispatcherHandler</code> 调用映射到请求的 <code>HandlerFunction</code>。</p>
</li>
<li>
<p><code>ServerResponseResultHandler</code>: 通过调用 <code>ServerResponse</code> 的 <code>writeTo</code> 方法来处理 <code>HandlerFunction</code> 调用的结果。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的组件使函数式端点适合于 <code>DispatcherHandler</code> 请求处理生命周期，并且（如果有）声明的控制器也可以（可能）与带注解的控制器并排运行。
这也是Spring Boot WebFlux starter启用函数式端点的方式。</p>
</div>
<div class="paragraph">
<p>以下示例显示了WebFlux Java配置（有关如何运行它，请参见<a href="#webflux-dispatcher-handler">DispatcherHandler</a>）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionA() {
        // ...
    }

    @Bean
    public RouterFunction&lt;?&gt; routerFunctionB() {
        // ...
    }

    // ...

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // configure message conversion...
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // configure CORS...
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // configure view resolution for HTML rendering...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-fn-handler-filter-function"><a class="anchor" href="#webflux-fn-handler-filter-function"></a>1.5.5. 过滤处理程序函数</h4>
<div class="paragraph">
<p>你可以使用路由函数构建器上的 <code>before</code>，<code>after</code> 或 <code>filter</code> 方法来过滤处理程序函数。使用注解，可以通过使用
<code>@ControllerAdvice</code>，<code>ServletFilter</code> 或同时使用两者来实现类似的功能。该过滤器将应用于构建器构建的所有路由。
这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople)
            .before(request -&gt; ServerRequest.from(request) <i class="conum" data-value="1"></i><b>(1)</b>
                .header("X-RequestHeader", "Value")
                .build()))
        .POST("/person", handler::createPerson))
    .after((request, response) -&gt; logResponse(response)) <i class="conum" data-value="2"></i><b>(2)</b>
    .build();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加自定义请求头的 <code>before</code> 过滤器仅应用于两个GET路由。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>记录响应的 <code>after</code> 过滤器将应用于所有路由，包括嵌套路由。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>路由器构建器上的 <code>filter</code> 方法采用 <code>HandlerFilterFunction</code>：
该函数采用 <code>ServerRequest</code> 和 <code>HandlerFunction</code> 并返回 <code>ServerResponse</code>。处理程序函数参数代表链中的下一个元素。
这通常是路由到的处理程序，但是如果应用了多个，它也可以是另一个过滤器。</p>
</div>
<div class="paragraph">
<p>现在，我们可以在路由中添加一个简单的安全过滤器，假设我们拥有一个可以确定是否允许特定路径的 <code>SecurityManager</code>。
以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">SecurityManager securityManager = ...

RouterFunction&lt;ServerResponse&gt; route = route()
    .path("/person", b1 -&gt; b1
        .nest(accept(APPLICATION_JSON), b2 -&gt; b2
            .GET("/{id}", handler::getPerson)
            .GET("", handler::listPeople))
        .POST("/person", handler::createPerson))
    .filter((request, next) -&gt; {
        if (securityManager.allowAccessTo(request.path())) {
            return next.handle(request);
        }
        else {
            return ServerResponse.status(UNAUTHORIZED).build();
        }
    })
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例演示了调用 <code>next.handle(ServerRequest)</code> 是可选的。当允许访问时，我们才允许执行处理函数。</p>
</div>
<div class="paragraph">
<p>除了在路由器函数构建器上使用 <code>filter</code> 方法之外，还可以通过 <code>RouterFunction.filter(HandlerFilterFunction)</code>
将过滤器应用于现有路由器函数。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过专用的<a href="#webflux-cors-webfilter"><code>CorsWebFilter</code></a>提供对函数式端点的CORS支持。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-uri-building"><a class="anchor" href="#webflux-uri-building"></a>1.6. URI链接</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-uri-building">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>本节描述了Spring框架中用于准备URIs的各种选项。</p>
</div>
<div class="sect3">
<h4 id="web-uricomponents"><a class="anchor" href="#web-uricomponents"></a>1.6.1. UriComponents</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> 有助于从具有变量的URI模板中构建URI，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">UriComponents uriComponents = UriComponentsBuilder
        .fromUriString("http://example.com/hotels/{hotel}")  <i class="conum" data-value="1"></i><b>(1)</b>
        .queryParam("q", "{q}")  <i class="conum" data-value="2"></i><b>(2)</b>
        .encode() <i class="conum" data-value="3"></i><b>(3)</b>
        .build(); <i class="conum" data-value="4"></i><b>(4)</b>

URI uri = uriComponents.expand("Westin", "123").toUri();  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>带有URI模板的静态工厂方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>添加或替换URI组件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>请求对URI模板和URI变量进行编码。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构建一个 <code>UriComponents</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>设置变量并获取 <code>URI</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以将前面的示例合并为一个链，并通过 <code>buildAndExpand</code> 进行缩短，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("http://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .encode()
        .buildAndExpand("Westin", "123")
        .toUri();</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过直接传入URI（这意味着编码）来进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("http://example.com/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder
        .fromUriString("http://example.com/hotels/{hotel}?q={q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uribuilder"><a class="anchor" href="#web-uribuilder"></a>1.6.2. UriBuilder</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><a href="#web-uricomponents"><code>UriComponentsBuilder</code></a> 实现了 <code>UriBuilder</code>。
你可以依次使用 <code>UriBuilderFactory</code> 创建 <code>UriBuilder</code>。<code>UriBuilderFactory</code> 和 <code>UriBuilder</code>
一起提供了一种可插入的机制，可以基于共享配置（例如基本URL，编码首选项和其他详细信息）从URI模板构建URI。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>UriBuilderFactory</code> 配置 <code>RestTemplate</code> 和 <code>WebClient</code> 为自定义URI做准备。
<code>DefaultUriBuilderFactory</code> 是 <code>UriBuilderFactory</code> 的默认实现，该实现在内部使用 <code>UriComponentsBuilder</code>
并公开共享的配置选项。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何配置 <code>RestTemplate</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "http://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例配置一个 <code>WebClient</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;

String baseUrl = "http://example.org";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);

WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，你也可以直接使用 <code>DefaultUriBuilderFactory</code>。
它类似于使用 <code>UriComponentsBuilder</code>，但不是静态工厂方法，它是一个包含配置和首选项的实际实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "http://example.com";
DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);

URI uri = uriBuilderFactory.uriString("/hotels/{hotel}")
        .queryParam("q", "{q}")
        .build("Westin", "123");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="web-uri-encoding"><a class="anchor" href="#web-uri-encoding"></a>1.6.3. URI编码</h4>
<div class="paragraph">
<p><span class="small">Spring MVC and Spring WebFlux</span></p>
</div>
<div class="paragraph">
<p><code>UriComponentsBuilder</code> 在两个级别公开了编码选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#encode--">UriComponentsBuilder#encode()</a>:
首先对URI模板进行预编码，然后在扩展时严格对URI变量进行编码。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>:
扩展URI变量 <em>后</em> 编码URI组件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这两个选项都用转义的八位字节替换非ASCII和非法字符。但是，第一个选项还会替换出现在URI变量中的具有保留含义的字符。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
考虑“;”，这在路径上是合法的，但具有保留的含义。第一个选项将URI变量中“;”替换为“%3B”，但URI模板中的没有。
相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在大多数情况下，第一个选项可能会产生预期的结果，因为它将URI变量视为要完全编码的不透明数据，
而选项2仅在URI变量有意要包含保留字符的情况下才有用。</p>
</div>
<div class="paragraph">
<p>以下示例使用第一个选项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
            .queryParam("q", "{q}")
            .encode()
            .buildAndExpand("New York", "foo+bar")
            .toUri();

    // Result is "/hotel%20list/New%20York?q=foo%2Bbar"</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过直接传入URI（这意味着编码）来缩短前面的示例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}")
            .queryParam("q", "{q}")
            .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用完整的URI模板进一步缩短它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">URI uri = UriComponentsBuilder.fromPath("/hotel list/{city}?q={q}")
            .build("New York", "foo+bar")</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebClient</code> 和 <code>RestTemplate</code> 通过 <code>UriBuilderFactory</code> 策略在内部扩展和编码URI模板。
两者都可以使用自定义策略进行配置。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">String baseUrl = "http://example.com";
DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)
factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);

// Customize the RestTemplate..
RestTemplate restTemplate = new RestTemplate();
restTemplate.setUriTemplateHandler(factory);

// Customize the WebClient..
WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultUriBuilderFactory</code> 实现在内部使用 <code>UriComponentsBuilder</code> 来扩展和编码URI模板。
作为工厂，它提供了一个位置，可以根据以下一种编码模式来配置编码方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TEMPLATE_AND_VALUES</code>: 使用 <code>UriComponentsBuilder#encode()</code>
（对应于先前列表中的第一个选项）对URI模板进行预编码，并在扩展时严格编码URI变量。</p>
</li>
<li>
<p><code>VALUES_ONLY</code>: 不对URI模板进行编码，而是在将其扩展到模板之前通过
<code>UriUtils#encodeUriUriVariables</code> 对URI变量进行严格编码。</p>
</li>
<li>
<p><code>URI_COMPONENTS</code>: 在扩展URI变量之后，使用对应于先前列表中第二个选项的
<code>UriComponents#encode()</code> 来编码URI组件值。</p>
</li>
<li>
<p><code>NONE</code>: 不应用编码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于历史原因和向后兼容性，将 <code>RestTemplate</code> 设置为 <code>EncodingMode.URI_COMPONENTS</code>。<code>WebClient</code> 依赖于
<code>DefaultUriBuilderFactory</code> 中的默认值，该默认值已从5.0.x中的 <code>EncodingMode.URI_COMPONENTS</code>
更改为5.1中的 <code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-cors"><a class="anchor" href="#webflux-cors"></a>1.7. CORS</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux使你可以处理CORS（跨源资源共享）。本节介绍如何执行此操作。</p>
</div>
<div class="sect3">
<h4 id="webflux-cors-intro"><a class="anchor" href="#webflux-cors-intro"></a>1.7.1. 介绍</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors-intro">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>出于安全原因，浏览器禁止AJAX调用当前来源以外的资源。
例如，你可以将你的银行帐户放在一个tab中，将evil.com放在另一个tab中。
来自evil.com的脚本不能使用你的凭据向你的银行API发出AJAX请求&#8212;&#8203;例如，从你的帐户中提取资金！</p>
</div>
<div class="paragraph">
<p>跨域资源共享（CORS）是 <a href="http://caniuse.com/#feat=cors">大多数浏览器</a>实施的 <a href="http://www.w3.org/TR/cors/">W3C规范</a>，
可让你指定授权哪种类型的跨域请求，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通办法。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-processing"><a class="anchor" href="#webflux-cors-processing"></a>1.7.2. 处理过程</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors-processing">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>CORS规范分为预检，简单和实际请求。要了解CORS的工作原理，你可以阅读
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>以及其他内容，或者参阅规范以获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux <code>HandlerMapping</code> 实现为CORS提供内置支持。
成功将请求映射到处理程序后，<code>HandlerMapping</code> 将检查给定请求和处理程序的CORS配置，并采取进一步的措施。
预检请求直接处理，而简单和实际的CORS请求被拦截，验证并设置了所需的CORS响应头。</p>
</div>
<div class="paragraph">
<p>为了启用跨域请求（即存在 <code>Origin</code> 标头，并且与请求的主机不同），你需要具有一些显式声明的CORS配置。
如果找不到匹配的CORS配置，则预检请求将被拒绝。没有将CORS标头添加到简单和实际CORS请求的响应中，因此，浏览器拒绝了它们。</p>
</div>
<div class="paragraph">
<p>可以使用基于URL模式的 <code>CorsConfiguration</code> 映射分别
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-">配置</a>每个 <code>HandlerMapping</code>。
在大多数情况下，应用程序使用WebFlux Java配置声明此类映射，从而导致将单个全局映射传递给所有 <code>HandlerMapping</code> 实现。</p>
</div>
<div class="paragraph">
<p>你可以将 <code>HandlerMapping</code> 级别的全局CORS配置与更细粒度的处理程序级别的CORS配置结合使用。
例如，带注解的控制器可以使用类或方法级别的 <code>@CrossOrigin</code> 注解（其他处理程序可以实现 <code>CorsConfigurationSource</code>）。</p>
</div>
<div class="paragraph">
<p>全局和本地配置组合的规则通常是相加的&#8212;&#8203;例如，所有全局和所有本地origins。对于仅接受单个值的那些属性
（例如： <code>allowCredentials</code> 和 <code>maxAge</code>），局部属性值将覆盖全局值。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-"><code>CorsConfiguration#combine(CorsConfiguration)</code></a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要从源码中了解更多信息或进行高级自定义，请参阅：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CorsConfiguration</code></p>
</li>
<li>
<p><code>CorsProcessor</code> 和 <code>DefaultCorsProcessor</code></p>
</li>
<li>
<p><code>AbstractHandlerMapping</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-controller"><a class="anchor" href="#webflux-cors-controller"></a>1.7.3. <code>@CrossOrigin</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors-controller">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>
注解启用带注解的控制器方法上的跨域请求，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin
    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>@CrossOrigin</code> 允许：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有源。</p>
</li>
<li>
<p>所有头。</p>
</li>
<li>
<p>控制器方法映射到的所有HTTP方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，<code>allowedCredentials</code> 未启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息
（例如：cookie和CSRF tokens），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> 设置为30分钟。</p>
</div>
<div class="paragraph">
<p><code>@CrossOrigin</code> 在类级别上也受支持，并且被所有方法继承。以下示例指定了一个特定域，并将 <code>maxAge</code> 设置为一个小时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(origins = "http://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在类和方法级别使用 <code>@CrossOrigin</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@CrossOrigin(maxAge = 3600) <i class="conum" data-value="1"></i><b>(1)</b>
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin("http://domain2.com") <i class="conum" data-value="2"></i><b>(2)</b>
    @GetMapping("/{id}")
    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) {
        // ...
    }

    @DeleteMapping("/{id}")
    public Mono&lt;Void&gt; remove(@PathVariable Long id) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在类级别使用 <code>@CrossOrigin</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在方法级别使用 <code>@CrossOrigin</code>。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-global"><a class="anchor" href="#webflux-cors-global"></a>1.7.4. 全局配置</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors-global">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>除了细粒度的控制器方法级配置外，你可能还想定义一些全局CORS配置。
你可以在任何 <code>HandlerMapping</code> 上分别设置基于URL的 <code>CorsConfiguration</code> 映射。
但是，大多数应用程序都使用WebFlux Java配置来执行此操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，全局配置启用以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有源。</p>
</li>
<li>
<p>所有头。</p>
</li>
<li>
<p><code>GET</code>, <code>HEAD</code> 和 <code>POST</code> 方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，<code>allowedCredentials</code> 未启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息
（例如：cookie和CSRF tokens），并且仅在适当的地方使用。</p>
</div>
<div class="paragraph">
<p><code>maxAge</code> 设置为30分钟。</p>
</div>
<div class="paragraph">
<p>要在WebFlux Java配置中启用CORS，可以使用 <code>CorsRegistry</code> 回调，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {

        registry.addMapping("/api/**")
            .allowedOrigins("http://domain2.com")
            .allowedMethods("PUT", "DELETE")
            .allowedHeaders("header1", "header2", "header3")
            .exposedHeaders("header1", "header2")
            .allowCredentials(true).maxAge(3600);

        // Add more mappings...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-cors-webfilter"><a class="anchor" href="#webflux-cors-webfilter"></a>1.7.5. CORS <code>WebFilter</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-cors-filter">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以通过内置的 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html"><code>CorsWebFilter</code></a>
应用CORS支持，该功能非常适合<a href="#webflux-fn">函数式端点</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你尝试将 <code>CorsFilter</code> 与Spring Security一起使用，请记住Spring Security <a href="https://docs.spring.io/spring-security/site/docs/current/reference#cors">内置</a>了对CORS的支持。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要配置过滤器，可以声明一个 <code>CorsWebFilter</code> bean并将 <code>CorsConfigurationSource</code> 传递给其构造函数，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
CorsWebFilter corsFilter() {

    CorsConfiguration config = new CorsConfiguration();

    // Possibly...
    // config.applyPermitDefaultValues()

    config.setAllowCredentials(true);
    config.addAllowedOrigin("http://domain1.com");
    config.addAllowedHeader("*");
    config.addAllowedMethod("*");

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", config);

    return new CorsWebFilter(source);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-web-security"><a class="anchor" href="#webflux-web-security"></a>1.8. Web安全</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-web-security">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://projects.spring.io/spring-security/">Spring Security</a>
项目提供了保护Web应用程序免受恶意利用的支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#jc-webflux">WebFlux安全</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-webflux">WebFlux测试支持</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF保护</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">安全响应头</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-view"><a class="anchor" href="#webflux-view"></a>1.9. 视图技术</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-view">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中视图技术的使用是可插拔的。是否决定使用Thymeleaf，FreeMarker或其他某种视图技术主要取决于配置更改。
本章介绍了与Spring WebFlux集成的视图技术。我们假设你已经熟悉<a href="#webflux-viewresolution">视图解析</a>。</p>
</div>
<div class="sect3">
<h4 id="webflux-view-thymeleaf"><a class="anchor" href="#webflux-view-thymeleaf"></a>1.9.1. Thymeleaf</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-view-thymeleaf">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Thymeleaf是一种现代的服务器端Java模板引擎，它强调可以通过双击在浏览器中预览自然HTML模板，
这对于独立处理UI模板（例如，由设计人员）而无需使用正在运行的服务器非常有用。
Thymeleaf提供了广泛的功能集，并且正在积极地开发和维护。有关更完整的介绍，请参见
<a href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
</div>
<div class="paragraph">
<p>Thymeleaf与Spring WebFlux的集成由Thymeleaf项目管理。该配置涉及一些bean声明，例如：
<code>SpringResourceTemplateResolver</code>，<code>SpringWebFluxTemplateEngine</code> 和 <code>ThymeleafReactiveViewResolver</code>。
有关更多详细信息，请参见 <a href="http://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a>和
WebFlux集成 <a href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">公告</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-freemarker"><a class="anchor" href="#webflux-view-freemarker"></a>1.9.2. FreeMarker</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-view-freemarker">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://www.freemarker.org">Apache FreeMarker</a>是一个模板引擎，用于生成从HTML到电子邮件等的任何类型的文本输出。
Spring框架具有内置的集成，可以将Spring WebFlux与FreeMarker模板一起使用。</p>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-contextconfig"><a class="anchor" href="#webflux-view-freemarker-contextconfig"></a>视图配置</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-view-freemarker-contextconfig">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何将FreeMarker配置作为一种视图技术：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freemarker();
    }

    // Configure FreeMarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你的模板需要存储在 <code>FreeMarkerConfigurer</code> 指定的目录中，如上例所示。给定上述配置，如果你的控制器返回视图名称 <code>welcome</code>，
则解析器将查找 <code>classpath:/templates/freemarker/welcome.ftl</code> 模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-views-freemarker"><a class="anchor" href="#webflux-views-freemarker"></a>FreeMarker配置</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-views-freemarker">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以通过在 <code>FreeMarkerConfigurer</code> bean上设置适当的bean属性，
将FreeMarker的“Settings”和“SharedVariables”直接传递给FreeMarker <code>Configuration</code> 对象（由Spring管理）。
<code>freemarkerSettings</code> 属性需要一个 <code>java.util.Properties</code> 对象，而 <code>freemarkerVariables</code> 属性需要一个 <code>java.util.Map</code>。
以下示例显示了如何使用 <code>FreeMarkerConfigurer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    // ...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;();
        variables.put("xml_escape", new XmlEscape());

        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        configurer.setFreemarkerVariables(variables);
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关将settings和variables应用于 <code>Configuration</code> 对象的详细信息，请参见FreeMarker文档。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-freemarker-forms"><a class="anchor" href="#webflux-view-freemarker-forms"></a>表单处理</h5>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-freemarker-forms">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring提供了一个供JSP使用的标签库，其中包含一个 <code>&lt;spring:bind/&gt;</code> 元素。该元素主要允许表单显示来自表单支持对象的值，
并显示来自Web或业务层中 <code>Validator</code> 的验证失败的结果。Spring还支持FreeMarker中的相同功能，并带有用于生成表单输入元素本身的附加便利宏。</p>
</div>
<div class="sect5">
<h6 id="webflux-view-bind-macros"><a class="anchor" href="#webflux-view-bind-macros"></a>绑定宏</h6>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-bind-macros">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>FreeMarker的 <code>spring-webflux.jar</code> 文件中维护了一组标准宏，因此它们始终可用于经过适当配置的应用程序。</p>
</div>
<div class="paragraph">
<p>Spring模板库中定义的某些宏被视为内部（私有）宏，但是在宏定义中不存在这种作用域，这使得所有宏对于调用代码和用户模板都是可见的。
以下各节仅关注你需要在模板中直接调用的宏。如果你希望直接查看宏代码，则该文件名为 <code>spring.ftl</code>，位于
<code>org.springframework.web.reactive.result.view.freemarker</code> 包中。</p>
</div>
<div class="paragraph">
<p>有关绑定支持的更多详细信息，请参见Spring MVC的 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-simple-binding">简单绑定</a>。</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-views-form-macros"><a class="anchor" href="#webflux-views-form-macros"></a>表单宏</h6>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-views-form-macros">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>有关Spring对FreeMarker模板的表单宏支持的详细信息，请参阅Spring MVC文档的以下部分。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-views-form-macros">输入宏</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-views-form-macros-input">输入字段</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-views-form-macros-select">选择字段</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-views-form-macros-html-escaping">HTML转义</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-script"><a class="anchor" href="#webflux-view-script"></a>1.9.3. 脚本视图</h4>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-script">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring框架具有内置的集成，可以将Spring WebFlux与可以在 <a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a>
Java脚本引擎之上运行的任何模板库一起使用。下表显示了我们在不同脚本引擎上测试过的模板库：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">脚本库</th>
<th class="tableblock halign-left valign-top">脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://handlebarsjs.com/">Handlebars</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://mustache.github.io/">Mustache</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://facebook.github.io/react/">React</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.embeddedjs.com/">EJS</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.stuartellis.eu/articles/erb/">ERB</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://jruby.org">JRuby</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.python.org/2/library/string.html#template-strings">String templates</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.jython.org/">Jython</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://kotlinlang.org/">Kotlin</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
集成任何其他脚本引擎的基本规则是，它必须实现 <code>ScriptEngine</code> 和 <code>Invocable</code> 接口。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="webflux-view-script-dependencies"><a class="anchor" href="#webflux-view-script-dependencies"></a>要求</h5>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-script-dependencies">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你需要在类路径上具有脚本引擎，其细节因脚本引擎而异：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 8+随附了 <a href="http://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript引擎。强烈建议使用可用的最新release版本。</p>
</li>
<li>
<p>应该将 <a href="http://jruby.org">JRuby</a>添加为对Ruby支持的依赖。</p>
</li>
<li>
<p>应该将 <a href="http://www.jython.org">Jython</a>添加为对Python支持的依赖。</p>
</li>
<li>
<p>应该添加 <code>org.jetbrains.kotlin:kotlin-script-util</code> 依赖和包含
<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code>
行的 <code>META-INF/services/javax.script.ScriptEngineFactory</code> 文件。有关更多详细信息，请参见
<a href="https://github.com/sdeleuze/kotlin-script-templating">此示例</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你需要具有脚本模板库。针对Javascript的一种方法是通过 <a href="http://www.webjars.org/">WebJars</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-view-script-integrate"><a class="anchor" href="#webflux-view-script-integrate"></a>脚本模板</h5>
<div class="paragraph">
<p><span class="small"><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.html#mvc-view-script-integrate">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以声明一个 <code>ScriptTemplateConfigurer</code> bean来指定要使用的脚本引擎，要加载的脚本文件，
要调用什么函数来渲染模板等等。以下示例使用Mustache模板和Nashorn JavaScript引擎：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("mustache.js");
        configurer.setRenderObject("Mustache");
        configurer.setRenderFunction("render");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下参数调用 <code>render</code> 函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String template</code>: 模板内容</p>
</li>
<li>
<p><code>Map model</code>: 视图模型</p>
</li>
<li>
<p><code>RenderingContext renderingContext</code>: <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html"><code>RenderingContext</code></a>
用于访问应用程序上下文，语言环境，模板加载器和URL（从5.0开始）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Mustache.render()</code> 与该签名本地兼容，所以你可以直接调用它。</p>
</div>
<div class="paragraph">
<p>如果你的模板技术需要一些自定义，则可以提供一个实现自定义渲染函数的脚本。
例如， <a href="http://handlebarsjs.com">Handlerbars</a>需要在使用模板之前先对其进行编译，
并且需要使用 <a href="http://en.wikipedia.org/wiki/Polyfill">polyfill</a>来模拟服务器端脚本引擎中不可用的某些浏览器功能。
以下示例显示如何设置自定义渲染函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
        configurer.setRenderFunction("render");
        configurer.setSharedEngine(false);
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当使用非线程安全脚本引擎和非并发设计的模板库时，需要将 <code>sharedEngine</code> 属性设置为 <code>false</code>，
例如：Nashorn上运行的Handlebars或React。在这种情况下，由于
<a href="https://bugs.openjdk.java.net/browse/JDK-8076099">此bug</a>，需要Java 8u60或更高版本，
但通常建议在任何情况下都使用最新的Java SE修补程序版本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>polyfill.js</code> 只定义了Handlebars正常运行所需要的 <code>window</code> 对象，如下面的代码片段所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">var window = {};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个基本的 <code>render.js</code> 实现在使用模板之前先对其进行编译。生产就绪的实现还应该存储和重用缓存的模板或预编译的模板。
这可以在脚本端以及你需要的任何自定义（例如，管理模板引擎配置）上完成。以下示例显示了如何编译模板：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript" data-lang="javascript">function render(template, model) {
    var compiledTemplate = Handlebars.compile(template);
    return compiledTemplate(model);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>查看Spring Framework单元测试，
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a> 和
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">resources</a>,
以获取更多配置示例。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-view-httpmessagewriter"><a class="anchor" href="#webflux-view-httpmessagewriter"></a>1.9.4. JSON和XML</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-view-jackson">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>出于<a href="#webflux-multiple-representations">内容协商</a>的目的，根据客户端请求的内容类型，能够在使用HTML模板呈现模型和以其他格式(如JSON或XML)呈现模型之间进行切换是很有用的。
为了支持此操作，Spring WebFlux提供了 <code>HttpMessageWriterView</code>，你可以使用它插入 <code>spring-web</code> 中的任何可用编解码器，
例如：<code>Jackson2JsonEncoder</code>，<code>Jackson2SmileEncoder</code> 或 <code>Jaxb2XmlEncoder</code>。</p>
</div>
<div class="paragraph">
<p>与其他视图技术不同，<code>HttpMessageWriterView</code> 不需要 <code>ViewResolver</code>，而是<a href="#webflux-config-view-resolvers">配置</a>为默认视图。
你可以配置一个或多个此类默认视图，并包装不同的 <code>HttpMessageWriter</code> 实例或 <code>Encoder</code> 实例。
与请求的内容类型相匹配的内容类型在运行时使用。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，模型包含多个属性。要确定要序列化的对象，可以使用模型属性的名称配置 <code>HttpMessageWriterView</code> 进行渲染。如果模型仅包含一个属性，则使用该属性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching"><a class="anchor" href="#webflux-caching"></a>1.10. HTTP缓存</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显著提高Web应用程序的性能。HTTP缓存围绕 <code>Cache-Control</code> 响应头和后续的条件请求头，
如 <code>Last-Modified</code> 和 <code>ETag</code> 进行。<code>Cache-Control</code> 建议私有（例如浏览器）和公共（例如代理）缓存如何缓存和重用响应。
<code>ETag</code> 标头用于发出条件请求，如果内容未更改，则可能导致返回没有响应体的304（NOT_MODIFIED）状态。
<code>ETag</code> 可以看作是 <code>Last-Modified</code> 头的更复杂后继者。</p>
</div>
<div class="paragraph">
<p>本节介绍了Spring WebFlux中与HTTP缓存相关的选项。</p>
</div>
<div class="sect3">
<h4 id="webflux-caching-cachecontrol"><a class="anchor" href="#webflux-caching-cachecontrol"></a>1.10.1. <code>CacheControl</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-cachecontrol">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/http/CacheControl.html"><code>CacheControl</code></a>
支持配置与 <code>Cache-Control</code> 标头相关的设置，并在许多地方作为参数被接受：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#webflux-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管 <a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了
<code>Cache-Control</code> 响应头的所有可能的指令，但 <code>CacheControl</code> 类型采用了面向用例的方法，着重于常见场景：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

// Prevent caching - "Cache-Control: no-store"
CacheControl ccNoStore = CacheControl.noStore();

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-etag-lastmodified"><a class="anchor" href="#webflux-caching-etag-lastmodified"></a>1.10.2. 控制器</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-etag-lastmodified">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。
我们建议你这样做，因为需要先计算资源的 <code>lastModified</code> 或 <code>ETag</code> 值，然后才能将其与条件请求头进行比较。
控制器可以将 <code>ETag</code> 和 <code>Cache-Control</code> 设置添加到 <code>ResponseEntity</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/book/{id}")
public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) {

    Book book = findBook(id);
    String version = book.getVersion();

    return ResponseEntity
            .ok()
            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
            .eTag(version) // lastModified is also available
            .body(book);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求头的比较表明内容未更改，则前面的示例发送带有空主体的304（NOT_MODIFIED）响应。
否则，<code>ETag</code> 和 <code>Cache-Control</code> 标头将添加到响应中。</p>
</div>
<div class="paragraph">
<p>你还可以在控制器中针对条件请求头进行检查，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping
public String myHandleMethod(ServerWebExchange exchange, Model model) {

    long eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

    if (exchange.checkNotModified(eTag)) {
        return null; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
    return "myViewName";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）。无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用三种变体来检查针对 <code>eTag</code> 值，<code>lastModified</code> 值或混合两者的条件请求。
对于有条件的 <code>GET</code> 和 <code>HEAD</code> 请求，可以将响应设置为304（NOT_MODIFIED）。
对于条件 <code>POST</code>，<code>PUT</code> 和 <code>DELETE</code>，你可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-caching-static-resources"><a class="anchor" href="#webflux-caching-static-resources"></a>1.10.3. 静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-static-resources">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你应该将静态资源与 <code>Cache-Control</code> 和条件响应头一起提供，以实现最佳性能。请参阅有关配置<a href="#webflux-config-static-resources">静态资源</a>的部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config"><a class="anchor" href="#webflux-config"></a>1.11. WebFlux配置</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>WebFlux Java配置声明使用带注解的控制器或函数式端点来声明处理请求所必需的组件，并且它提供了用于自定义配置的API。
这意味着你不需要了解Java配置创建的基础bean。但是，如果你想了解它们，则可以在 <code>WebFluxConfigurationSupport</code>
中查看它们，或阅读有关<a href="#webflux-special-bean-types">特殊Bean类型</a>中的更多信息。</p>
</div>
<div class="paragraph">
<p>对于配置API中没有的更高级的自定义设置，你可以通过<a href="#webflux-config-advanced-java">高级配置模式</a>完全控制配置。</p>
</div>
<div class="sect3">
<h4 id="webflux-config-enable"><a class="anchor" href="#webflux-config-enable"></a>1.11.1. 启用WebFlux配置</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-enable">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以在Java配置中使用 <code>@EnableWebFlux</code> 注解，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring WebFlux<a href="#mvc-webflux-special-bean-types">基础设施Bean</a>，
并适配了classpath上可用的依赖项&#8212;&#8203;对于JSON，XML等。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-customize"><a class="anchor" href="#webflux-config-customize"></a>1.11.2. WebFlux配置API</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-customize">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，可以实现 <code>WebFluxConfigurer</code> 接口，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    // Implement configuration methods...

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-conversion"><a class="anchor" href="#webflux-config-conversion"></a>1.11.3. 转换，格式化</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-conversion">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，将安装 <code>Number</code> 和 <code>Date</code> 类型的格式化程序，包括对 <code>@NumberFormat</code> 和 <code>@DateTimeFormat</code> 注解的支持。
如果类路径中存在Joda-Time，则还将安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何注册自定义格式化器和转换器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关何时使用 <code>FormatterRegistrar</code> 实现的更多信息，请参见
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#format-FormatterRegistrar-SPI"><code>FormatterRegistrar</code> SPI</a>和
<code>FormattingConversionServiceFactoryBean</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-validation"><a class="anchor" href="#webflux-config-validation"></a>1.11.4. 检验</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-validation">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-overview">Bean验证</a>存在于类路径中
（例如：Hibernate Validator），则 <code>LocalValidatorFactoryBean</code> 将注册为全局
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#validator">验证器</a>，以与 <code>@Valid</code> 和 <code>@Controller</code> 方法参数中的 <code>Validated</code> 一起使用。</p>
</div>
<div class="paragraph">
<p>在Java配置中，你可以自定义全局 <code>Validator</code> 实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public Validator getValidator(); {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你还可以在本地注册 <code>Validator</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addValidators(new FooValidator());
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要在某处注入 <code>LocalValidatorFactoryBean</code>，请创建一个bean并用 <code>@Primary</code> 进行注解，以避免与MVC配置中声明的bean发生冲突。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-content-negotiation"><a class="anchor" href="#webflux-config-content-negotiation"></a>1.11.5. 内容类型解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-content-negotiation">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以配置Spring WebFlux如何根据请求为 <code>@Controller</code> 实例确定所请求的媒体类型。
默认情况下，仅选中 <code>Accept</code> 标头，但你也可以启用基于查询参数的策略。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义请求的内容类型解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-message-codecs"><a class="anchor" href="#webflux-config-message-codecs"></a>1.11.6. HTTP消息编解码器</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-message-converters">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义读取请求体和写入响应体的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code> 提供了一组默认的读取器和写入器。你可以使用它来添加更多的读取器和写入器，
自定义默认的读取器或完全替换默认的读取器和写入器。</p>
</div>
<div class="paragraph">
<p>对于Jackson JSON和XML，请考虑使用
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html"><code>Jackson2ObjectMapperBuilder</code></a>，
该工具使用以下属性自定义Jackson的默认属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a>被禁用。</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a>被禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到以下知名模块，它还将自动注册以下知名模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a>: 支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a>: 支持Java 8日期和时间API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a>: 支持其他Java 8类型，例如 <code>Optional</code>。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-module-kotlin"><code>jackson-module-kotlin</code></a>: 支持Kotlin类和数据类。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-view-resolvers"><a class="anchor" href="#webflux-config-view-resolvers"></a>1.11.7. 视图解析器</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-view-resolvers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>下面的示例显示如何配置视图解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ViewResolverRegistry</code> 具有与Spring Framework集成的视图技术的快捷方式。
以下示例使用FreeMarker（这也需要配置基础FreeMarker视图技术）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure Freemarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("classpath:/templates");
        return configurer;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以插入任何 <code>ViewResolver</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        ViewResolver resolver = ... ;
        registry.viewResolver(resolver);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了支持<a href="#webflux-multiple-representations">内容协商</a>并通过视图解析（HTML之外）渲染其他格式，
你可以基于 <code>HttpMessageWriterView</code> 实现配置一个或多个默认视图，该实现接受 <code>spring-web</code> 中的任何可用<a href="#webflux-codecs">编解码器</a>。
以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();

        Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
        registry.defaultViews(new HttpMessageWriterView(encoder));
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">视图技术</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-static-resources"><a class="anchor" href="#webflux-config-static-resources"></a>1.11.8. 静态资源</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-static-resources">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种方便的方法来从基于 <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a>的位置列表中提供静态资源。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定一个以 <code>/resources</code> 开头的请求，相对路径用于在类路径上查找和提供相对于 <code>/static</code> 的静态资源。
资源的有效期为一年，以确保最大程度地利用浏览器缓存并减少浏览器发出的HTTP请求。
还评估 <code>Last-Modified</code> 头，如果存在，则返回304状态码。以下列表显示了示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
            .addResourceLocations("/public", "classpath:/static/")
            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>资源处理程序还支持一系列
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html"><code>ResourceResolver</code></a>实现和
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html"><code>ResourceTransformer</code></a>实现，
可用于创建用于处理优化资源的工具链。</p>
</div>
<div class="paragraph">
<p>你可以根据从内容，固定应用程序版本或其他信息计算出的MD5哈希，将 <code>VersionResourceResolver</code> 用于版本化的资源URL。
<code>ContentVersionStrategy</code>（MD5哈希）是一个不错的选择，但有一些值得注意的例外（例如：与模块加载器一起使用的JavaScript资源）。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java配置中使用 <code>VersionResourceResolver</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/public/")
                .resourceChain(true)
                .addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>ResourceUrlProvider</code> 重写URL并应用完整的解析器和转换器链（例如：插入版本）。
WebFlux配置提供了 <code>ResourceUrlProvider</code>，以便可以将其注入其他资源。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，目前，在WebFlux中，由于没有视图技术可以利用解析器和转换器的非阻塞链，
因此无法透明地重写静态资源URL。当仅提供本地资源时，解决方法是直接使用 <code>ResourceUrlProvider</code>（例如：通过自定义元素）并进行阻止。</p>
</div>
<div class="paragraph">
<p>请注意，在同时使用 <code>EncodedResourceResolver</code>（例如：Gzip，Brotli编码）和 <code>VersionedResourceResolver</code>
时，必须按该顺序注册，以确保始终基于未编码文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a> 还通过 <code>WebJarsResourceResolver</code> 支持，当
<code>org.webjars:webjars-locator-core</code> 库存在于类路径中时，WebJars将自动注册。
解析程序可以重写URL以包括jar的版本，并且还可以与没有版本的传入URL进行匹配（例如：从 <code>/jquery/jquery.min.js</code>
到 <code>/jquery/1.2.0/jquery.min.js</code>）。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-path-matching"><a class="anchor" href="#webflux-config-path-matching"></a>1.11.9. 路径匹配</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-path-matching">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以自定义与路径匹配有关的选项。有关各个选项的详细信息，请参见
<a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc。
以下示例显示如何使用 <code>PathMatchConfigurer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        configurer
            .setUseCaseSensitiveMatch(true)
            .setUseTrailingSlashMatch(false)
            .addPathPrefix("/api",
                    HandlerTypePredicate.forAnnotation(RestController.class));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux依赖于请求路径的解析表示形式来访问解码的路径段值，该请求路径称为 <code>RequestPath</code>，
并且已删除了分号内容（即路径或矩阵变量）。这意味着，与Spring MVC不同，你无需指示是否解码请求路径，
也无需指示是否出于路径匹配目的而删除分号内容。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还不支持后缀模式匹配，这与Spring MVC不同，在Spring MVC中，我们也
<a href="spring-mvc.html#mvc-ann-requestmapping-suffix-pattern-match">建议</a>不要依赖它。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-config-advanced-java"><a class="anchor" href="#webflux-config-advanced-java"></a>1.11.10. 高级配置模式</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-advanced-java">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code> 导入 <code>DelegatingWebFluxConfiguration</code> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为WebFlux应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委托给 <code>WebFluxConfigurer</code> 实现以自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，你可以删除 <code>@EnableWebFlux</code> 并直接从 <code>DelegatingWebFluxConfiguration</code>
继承而不是实现 <code>WebFluxConfigurer</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebConfig extends DelegatingWebFluxConfiguration {

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以将现有方法保留在 <code>WebConfig</code> 中，但是现在你还可以覆盖基类中的bean声明，
并且在类路径上仍然具有任意数量的其他 <code>WebMvcConfigurer</code> 实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http2"><a class="anchor" href="#webflux-http2"></a>1.12. HTTP/2</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-http2">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4容器需要支持HTTP/2，并且Spring Framework 5与Servlet API 4兼容。
从编程模型的角度来看，应用程序不需要做任何特定的事情。但是，有一些与服务器配置有关的注意事项。
有关更多详细信息，请参见
<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 Wiki页面</a>。</p>
</div>
<div class="paragraph">
<p>当前，Spring WebFlux不支持Netty的HTTP/2。也没有支持以编程方式将资源推送到客户端。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-client"><a class="anchor" href="#webflux-client"></a>2. WebClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring WebFlux包括用于HTTP请求的响应式，非阻塞 <code>WebClient</code>。客户端具有函数式，流利的API，
具有用于声明式组合的响应式类型，请参见 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries">响应式类库</a>。
WebFlux客户端和服务器依靠相同的非阻塞<a href="#webflux-codecs">编解码器</a>对请求和响应内容进行编码和解码。</p>
</div>
<div class="paragraph">
<p><code>WebClient</code> 在内部委托给HTTP客户端库。默认情况下，它使用 <a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>，
内置了对Jetty <a href="https://github.com/jetty-project/jetty-reactive-httpclient">响应式HttpClient</a>的支持，其
他的则可以通过 <code>ClientHttpConnector</code> 插入。</p>
</div>
<div class="sect2">
<h3 id="webflux-client-builder"><a class="anchor" href="#webflux-client-builder"></a>2.1. 配置</h3>
<div class="paragraph">
<p>创建 <code>WebClient</code> 的最简单方法是通过静态工厂方法之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WebClient.create()</code></p>
</li>
<li>
<p><code>WebClient.create(String baseUrl)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上面的方法使用默认设置的Reactor Netty <code>HttpClient</code>，并期望 <code>io.projectreactor.netty:reactor-netty</code> 位于类路径上。</p>
</div>
<div class="paragraph">
<p>你还可以将 <code>WebClient.builder()</code> 与其他选项一起使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>uriBuilderFactory</code>: 自定义的 <code>UriBuilderFactory</code> 用作基本URL。</p>
</li>
<li>
<p><code>defaultHeader</code>: 每个请求的头部。</p>
</li>
<li>
<p><code>defaultCookie</code>: 每个请求的Cookie。</p>
</li>
<li>
<p><code>defaultRequest</code>: <code>Consumer</code> 可以定制每个请求。</p>
</li>
<li>
<p><code>filter</code>: 每个请求的客户端过滤器。</p>
</li>
<li>
<p><code>exchangeStrategies</code>: HTTP消息读取器/写入器定制。</p>
</li>
<li>
<p><code>clientConnector</code>: HTTP客户端库设置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例配置<a href="#webflux-codecs">HTTP编解码器</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    WebClient client = WebClient.builder()
          .exchangeStrategies(builder -&gt; {
                  return builder.codecs(codecConfigurer -&gt; {
                      //...
                  });
          })
          .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>构建后，<code>WebClient</code> 实例是不可变的。但是，你可以克隆它并构建修改后的副本，而不会影响原始实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    WebClient client1 = WebClient.builder()
            .filter(filterA).filter(filterB).build();

    WebClient client2 = client1.mutate()
            .filter(filterC).filter(filterD).build();

    // client1 has filterA, filterB

    // client2 has filterA, filterB, filterC, filterD</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-maxinmemorysize"><a class="anchor" href="#webflux-client-builder-maxinmemorysize"></a>2.1.1. MaxInMemorySize</h4>
<div class="paragraph">
<p>Spring WebFlux配置了在编解码器中缓冲内存中数据的限制，以避免应用程序内存问题。默认情况下，此配置为256KB，
如果这不足以满足你的用例，你将看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>org.springframework.core.io.buffer.DataBufferLimitException: Exceeded limit on max bytes to buffer</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用以下代码示例在所有默认编解码器上配置此限制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    WebClient webClient = WebClient.builder()
          .exchangeStrategies(builder -&gt;
              builder.codecs(codecs -&gt;
                  codecs.defaultCodecs().maxInMemorySize(2 * 1024 * 1024)
              )
          )
          .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-reactor"><a class="anchor" href="#webflux-client-builder-reactor"></a>2.1.2. Reactor Netty</h4>
<div class="paragraph">
<p>要自定义Reactor Netty设置，只需提供一个预先配置的 <code>HttpClient</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    HttpClient httpClient = HttpClient.create().secure(sslSpec -&gt; ...);

    WebClient webClient = WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-resources"><a class="anchor" href="#webflux-client-builder-reactor-resources"></a>资源</h5>
<div class="paragraph">
<p>默认情况下，<code>HttpClient</code> 会参与 <code>reactor.netty.http.HttpResources</code> 中包含的全局Reactor Netty资源，
包括事件循环线程和连接池。这是推荐的模式，因为固定的共享资源是事件循环并发的首选。在这种模式下，全局资源将保持活动状态，直到进程退出。</p>
</div>
<div class="paragraph">
<p>如果服务器与进程同步，通常不需要显式关闭。但是，如果服务器可以启动或停止进程内（例如：部署为WAR的Spring MVC应用程序），
则可以声明类型为 <code>ReactorResourceFactory</code> 的Spring托管Bean，其中 <code>globalResources=true</code>（默认值）以确保
Reactor关闭Spring <code>ApplicationContext</code> 时，将关闭Netty全局资源，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    @Bean
    public ReactorResourceFactory reactorResourceFactory() {
        return new ReactorResourceFactory();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以选择不参与全局Reactor Netty资源。但是，在这种模式下，确保所有Reactor Netty客户端和服务器实例使用共享资源是你的重担，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    @Bean
    public ReactorResourceFactory resourceFactory() {
        ReactorResourceFactory factory = new ReactorResourceFactory();
        factory.setGlobalResources(false); <i class="conum" data-value="1"></i><b>(1)</b>
        return factory;
    }

    @Bean
    public WebClient webClient() {

        Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt; {
            // Further customizations...
        };

        ClientHttpConnector connector =
                new ReactorClientHttpConnector(resourceFactory(), mapper); <i class="conum" data-value="2"></i><b>(2)</b>

        return WebClient.builder().clientConnector(connector).build(); <i class="conum" data-value="3"></i><b>(3)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建独立于全局资源的资源。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将 <code>ReactorClientHttpConnector</code> 构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将连接器插入 <code>WebClient.Builder</code>。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-client-builder-reactor-timeout"><a class="anchor" href="#webflux-client-builder-reactor-timeout"></a>超时</h5>
<div class="paragraph">
<p>要配置连接超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import io.netty.channel.ChannelOption;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000));</code></pre>
</div>
</div>
<div class="paragraph">
<p>要配置读取和/或写入超时值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import io.netty.handler.timeout.ReadTimeoutHandler;
import io.netty.handler.timeout.WriteTimeoutHandler;

HttpClient httpClient = HttpClient.create()
        .tcpConfiguration(client -&gt;
                client.doOnConnected(conn -&gt; conn
                        .addHandlerLast(new ReadTimeoutHandler(10))
                        .addHandlerLast(new WriteTimeoutHandler(10))));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-builder-jetty"><a class="anchor" href="#webflux-client-builder-jetty"></a>2.1.3. Jetty</h4>
<div class="paragraph">
<p>以下示例显示如何自定义Jetty <code>HttpClient</code> 设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    HttpClient httpClient = new HttpClient();
    httpClient.setCookieStore(...);
    ClientHttpConnector connector = new JettyClientHttpConnector(httpClient);

    WebClient webClient = WebClient.builder().clientConnector(connector).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>HttpClient</code> 创建自己的资源（<code>Executor</code>, <code>ByteBufferPool</code>, <code>Scheduler</code>），这些资源将保持活动状态，
直到进程退出或调用 <code>stop()</code> 为止。</p>
</div>
<div class="paragraph">
<p>你可以在Jetty客户端（和服务器）的多个实例之间共享资源，并通过声明 <code>JettyResourceFactory</code>
类型的Spring托管bean来确保在关闭Spring <code>ApplicationContext</code> 时关闭资源，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    @Bean
    public JettyResourceFactory resourceFactory() {
        return new JettyResourceFactory();
    }

    @Bean
    public WebClient webClient() {

        HttpClient httpClient = new HttpClient();
        // Further customizations...

        ClientHttpConnector connector =
                new JettyClientHttpConnector(httpClient, resourceFactory());<i class="conum" data-value="1"></i><b>(1)</b>

        return WebClient.builder().clientConnector(connector).build();<i class="conum" data-value="2"></i><b>(2)</b>
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将 <code>JettyClientHttpConnector</code> 构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将连接器插入 <code>WebClient.Builder</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-retrieve"><a class="anchor" href="#webflux-client-retrieve"></a>2.2. <code>retrieve()</code></h3>
<div class="paragraph">
<p><code>retrieve()</code> 方法是获取响应体并将其解码的最简单方法。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    WebClient client = WebClient.create("http://example.org");

    Mono&lt;Person&gt; result = client.get()
            .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以从响应中解码出一个对象流，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Flux&lt;Quote&gt; result = client.get()
            .uri("/quotes").accept(MediaType.TEXT_EVENT_STREAM)
            .retrieve()
            .bodyToFlux(Quote.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，具有4xx或5xx状态码的响应会导致 <code>WebClientResponseException</code> 或其HTTP状态特定的子类之一，
例如：<code>WebClientResponseException.BadRequest</code>，<code>WebClientResponseException.NotFound</code> 等。
你还可以使用 <code>onStatus</code> 方法来自定义结果异常，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
            .retrieve()
            .onStatus(HttpStatus::is4xxServerError, response -&gt; ...)
            .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)
            .bodyToMono(Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>onStatus</code> 时，如果期望响应包含内容，则 <code>onStatus</code> 回调应使用它。否则，内容将自动耗尽以确保释放资源。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-exchange"><a class="anchor" href="#webflux-client-exchange"></a>2.3. <code>exchange()</code></h3>
<div class="paragraph">
<p>与 <code>retrieve</code> 方法相比，<code>exchange()</code> 方法提供了更多的控制。以下示例等效于 <code>retrieve()</code>，但也提供了对 <code>ClientResponse</code> 的访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Mono&lt;Person&gt; result = client.get()
            .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.bodyToMono(Person.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此级别，你还可以创建完整的 <code>ResponseEntity</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()
            .uri("/persons/{id}", id).accept(MediaType.APPLICATION_JSON)
            .exchange()
            .flatMap(response -&gt; response.toEntity(Person.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意（与 <code>retrieve()</code> 不同），对于 <code>exchange()</code>，没有针对4xx和5xx响应的自动错误信号。你必须检查状态码并决定如何处理。</p>
</div>
<div class="paragraph">
<p>CAUTION:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>使用 <code>exchange()</code> 时，即使在发生异常时，也必须确保主体始终被消耗或释放（请参阅
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#databuffers-using">使用DataBuffer</a>）。
通常，你可以通过在 <code>ClientResponse</code> 上调用 <code>bodyTo*</code> 或 <code>toEntity*</code> 来将主体转换为所需类型的对象来执行此操作，
但是你也可以调用 <code>releaseBody()</code> 来丢弃主体内容而不使用它，或者可以调用 <code>toBodilessEntity()</code> 来获取主体状态和标头（同时丢弃正文）。</p>
</div>
<div class="paragraph">
<p>最后，有 <code>bodyToMono(Void.class)</code>，仅在没有响应内容的情况下才应使用。如果响应中确实包含内容，则该连接将关闭并且不会放回池中，因为该连接不会处于可重用状态。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-body"><a class="anchor" href="#webflux-client-body"></a>2.4. 请求体</h3>
<div class="paragraph">
<p>可以使用 <code>ReactiveAdapterRegistry</code> 处理的任何异步类型对请求体进行编码，例如：<code>Mono</code> 或Kotlin Coroutines的 <code>Deferred</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Mono&lt;Person&gt; personMono = ... ;

    Mono&lt;Void&gt; result = client.post()
            .uri("/persons/{id}", id)
            .contentType(MediaType.APPLICATION_JSON)
            .body(personMono, Person.class)
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以对对象流进行编码，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Flux&lt;Person&gt; personFlux = ... ;

    Mono&lt;Void&gt; result = client.post()
            .uri("/persons/{id}", id)
            .contentType(MediaType.APPLICATION_STREAM_JSON)
            .body(personFlux, Person.class)
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，如果你具有实际值，则可以使用 <code>bodyValue</code> 快捷方式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    Person person = ... ;

    Mono&lt;Void&gt; result = client.post()
            .uri("/persons/{id}", id)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(person)
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-form"><a class="anchor" href="#webflux-client-body-form"></a>2.4.1. 表单数据</h4>
<div class="paragraph">
<p>要发送表单数据，可以提供 <code>MultiValueMap&lt;String, String&gt;</code> 作为正文。
请注意，内容由 <code>FormHttpMessageWriter</code> 自动设置为 <code>application/x-www-form-urlencoded</code>。
下面的示例演示如何使用 <code>MultiValueMap&lt;String, String&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    MultiValueMap&lt;String, String&gt; formData = ... ;

    Mono&lt;Void&gt; result = client.post()
            .uri("/path", id)
            .bodyValue(formData)
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>BodyInserters</code> 内联提供表单数据，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    import static org.springframework.web.reactive.function.BodyInserters.*;

    Mono&lt;Void&gt; result = client.post()
            .uri("/path", id)
            .body(fromFormData("k1", "v1").with("k2", "v2"))
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-client-body-multipart"><a class="anchor" href="#webflux-client-body-multipart"></a>2.4.2. Multipart数据</h4>
<div class="paragraph">
<p>要发送multipart数据，你需要提供一个 <code>MultiValueMap&lt;String, ?&gt;</code>，其值可以是代表part内容的对象实例或代表part内容和标头的 <code>HttpEntity</code> 实例。
<code>MultipartBodyBuilder</code> 提供了一个方便的API来准备multipart请求。下面的示例演示如何创建 <code>MultiValueMap&lt;String, ?&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    MultipartBodyBuilder builder = new MultipartBodyBuilder();
    builder.part("fieldPart", "fieldValue");
    builder.part("filePart", new FileSystemResource("...logo.png"));
    builder.part("jsonPart", new Person("Jason"));

    MultiValueMap&lt;String, HttpEntity&lt;?&gt;&gt; parts = builder.build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在大多数情况下，你不必为每个part指定 <code>Content-Type</code>。内容类型是根据选择用于对其进行序列化的 <code>HttpMessageWriter</code> 自动确定的，
对于 <code>Resource</code> 而言，取决于文件扩展名。如有必要，你可以通过重载的构建器 <code>part</code> 方法之一显式提供 <code>MediaType</code> 以供每个part使用。</p>
</div>
<div class="paragraph">
<p>准备好 <code>MultiValueMap</code> 之后，将其传递给 <code>WebClient</code> 的最简单方法是通过 <code>body</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    MultipartBodyBuilder builder = ...;

    Mono&lt;Void&gt; result = client.post()
            .uri("/path", id)
            .body(builder.build())
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>MultiValueMap</code> 包含至少一个非 <code>String</code> 值，该值也可以表示常规表单数据（即 <code>application/x-www-form-urlencoded</code>），
则无需将 <code>Content-Type</code> 设置为 <code>multipart/form-data</code>。在使用 <code>MultipartBodyBuilder</code> 时总是这样，这确保了 <code>HttpEntity</code>
包装器。</p>
</div>
<div class="paragraph">
<p>作为 <code>MultipartBodyBuilder</code> 的替代方案，你还可以通过内置的 <code>BodyInserters</code> 提供内联样式的multipart内容，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">    import static org.springframework.web.reactive.function.BodyInserters.*;

    Mono&lt;Void&gt; result = client.post()
            .uri("/path", id)
            .body(fromMultipartData("fieldPart", "value").with("filePart", resource))
            .retrieve()
            .bodyToMono(Void.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-filter"><a class="anchor" href="#webflux-client-filter"></a>2.5. 客户端过滤器</h3>
<div class="paragraph">
<p>你可以通过 <code>WebClient.Builder</code> 注册客户端过滤器（<code>ExchangeFilterFunction</code>），以拦截和修改请求，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {

            ClientRequest filtered = ClientRequest.from(request)
                    .header("foo", "bar")
                    .build();

            return next.exchange(filtered);
        })
        .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可以用于跨领域的关注，例如：身份验证。以下示例使用过滤器通过静态工厂方法进行基本身份验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;

WebClient client = WebClient.builder()
        .filter(basicAuthentication("user", "password"))
        .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>过滤器全局应用于每个请求。要更改特定请求的过滤器行为，你可以将请求属性添加到 <code>ClientRequest</code>，然后链中的所有过滤器都可以访问该请求属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">WebClient client = WebClient.builder()
        .filter((request, next) -&gt; {
            Optional&lt;Object&gt; usr = request.attribute("myAttribute");
            // ...
        })
        .build();

client.get().uri("http://example.org/")
        .attribute("myAttribute", "...")
        .retrieve()
        .bodyToMono(Void.class);

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以复制现有的 <code>WebClient</code>，插入新的过滤器或删除已注册的过滤器。以下示例在索引0处插入一个基本身份验证过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;

WebClient client = webClient.mutate()
        .filters(filterList -&gt; {
            filterList.add(0, basicAuthentication("user", "password"));
        })
        .build();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-synchronous"><a class="anchor" href="#webflux-client-synchronous"></a>2.6. 同步使用</h3>
<div class="paragraph">
<p>通过在结果末尾进行阻塞，可以以同步方式使用 <code>WebClient</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Person person = client.get().uri("/person/{id}", i).retrieve()
    .bodyToMono(Person.class)
    .block();

List&lt;Person&gt; persons = client.get().uri("/persons").retrieve()
    .bodyToFlux(Person.class)
    .collectList()
    .block();</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果需要进行多次请求，则可以避免单独阻塞每个响应，而等待合并的结果，这样会更有效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;Person&gt; personMono = client.get().uri("/person/{id}", personId)
        .retrieve().bodyToMono(Person.class);

Mono&lt;List&lt;Hobby&gt;&gt; hobbiesMono = client.get().uri("/person/{id}/hobbies", personId)
        .retrieve().bodyToFlux(Hobby.class).collectList();

Map&lt;String, Object&gt; data = Mono.zip(personMono, hobbiesMono, (person, hobbies) -&gt; {
            Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;();
            map.put("person", person);
            map.put("hobbies", hobbies);
            return map;
        })
        .block();</code></pre>
</div>
</div>
<div class="paragraph">
<p>以上仅是一个示例。还有许多其他模式和运算符可用于构建响应式管道，该响应式管道可进行许多远程调用（可能是嵌套的，相互依赖的），而不会阻塞到最后。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用 <code>Flux</code> 或 <code>Mono</code>，你永远不必阻塞Spring MVC或Spring WebFlux控制器。
只需从控制器方法返回结果的响应式类型。相同的原则适用于Kotlin Coroutines和Spring WebFlux，只需在控制器方法中使用suspending function或返回 <code>Flow</code> 即可。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-client-testing"><a class="anchor" href="#webflux-client-testing"></a>2.7. 测试</h3>
<div class="paragraph">
<p>要测试使用 <code>WebClient</code> 的代码，可以使用模拟Web服务器，例如： <a href="https://github.com/square/okhttp#mockwebserver">OkHttp MockWebServer</a>。
要查看其用法示例，请查看Spring Framework测试套件中的
<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java"><code>WebClientIntegrationTests</code></a>
或OkHttp存储库中的 <a href="https://github.com/square/okhttp/tree/master/samples/static-server"><code>static-server</code></a>示例。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-test"><a class="anchor" href="#webflux-test"></a>3. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#testing">与Spring MVC相同</a></span></p>
</div>
<div class="paragraph">
<p><code>spring-test</code> 模块提供 <code>ServerHttpRequest</code>，<code>ServerHttpResponse</code> 和 <code>ServerWebExchange</code> 的Mock实现。
有关模拟对象的讨论，请参见<a href="spring-test.html#mock-objects-web-reactive">Spring Web Reactive</a>。</p>
</div>
<div class="paragraph">
<p><a href="spring-test.html#webtestclient"><code>WebTestClient</code></a>
建立在这些模拟请求和响应对象的基础上，以提供对测试不使用HTTP服务器的WebFlux应用程序的支持。
你也可以将 <code>WebTestClient</code> 用于端到端集成测试。</p>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</div>
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>