<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<title>Spring WebFlux</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body id="webflux" class="book toc2 toc-left">
<div id="header">
<h1>Spring WebFlux</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#webflux-new-framework">1. 总览</a>
<ul class="sectlevel2">
<li><a href="#webflux-why-reactive">1.1. 定义 &#8220;Reactive&#8221;</a></li>
<li><a href="#webflux-reactive-api">1.2. Reactive API</a></li>
<li><a href="#webflux-programming-models">1.3. 编程模型</a></li>
<li><a href="#webflux-framework-choice">1.4. 适用性</a></li>
<li><a href="#webflux-server-choice">1.5. 服务器</a></li>
<li><a href="#webflux-performance">1.6. 性能</a></li>
<li><a href="#webflux-concurrency-model">1.7. 并发模型</a></li>
</ul>
</li>
<li><a href="#webflux-reactive-spring-web">2. Reactive核心</a>
<ul class="sectlevel2">
<li><a href="#webflux-httphandler">2.1. <code>HttpHandler</code></a></li>
<li><a href="#webflux-web-handler-api">2.2. <code>WebHandler</code> API</a></li>
<li><a href="#webflux-filters">2.3. 过滤器</a></li>
<li><a href="#webflux-exception-handler">2.4. 异常</a></li>
<li><a href="#webflux-codecs">2.5. 编解码器</a></li>
<li><a href="#webflux-logging">2.6. 日志</a></li>
</ul>
</li>
<li><a href="#webflux-dispatcher-handler">3. <code>DispatcherHandler</code></a>
<ul class="sectlevel2">
<li><a href="#webflux-special-bean-types">3.1. 特殊Bean类型</a></li>
<li><a href="#webflux-framework-config">3.2. WebFlux配置</a></li>
<li><a href="#webflux-dispatcher-handler-sequence">3.3. 处理过程</a></li>
<li><a href="#webflux-resulthandling">3.4. 结果处理</a></li>
<li><a href="#webflux-dispatcher-exceptions">3.5. 异常</a></li>
<li><a href="#webflux-viewresolution">3.6. 视图解析</a></li>
</ul>
</li>
<li><a href="#webflux-controller">4. 带注解的控制器</a>
<ul class="sectlevel2">
<li><a href="#webflux-ann-controller">4.1. <code>@Controller</code></a></li>
<li><a href="#webflux-ann-requestmapping">4.2. 请求映射</a></li>
<li><a href="#webflux-ann-methods">4.3. 处理程序方法</a></li>
<li><a href="#webflux-ann-modelattrib-methods">4.4. <code>Model</code></a></li>
<li><a href="#webflux-ann-initbinder">4.5. <code>DataBinder</code></a></li>
<li><a href="#webflux-ann-controller-exceptions">4.6. 管理异常</a></li>
<li><a href="#webflux-ann-controller-advice">4.7. 控制器通知</a></li>
</ul>
</li>
<li><a href="#webflux-uri-building">5. URI链接</a></li>
<li><a href="#webflux-web-security">6. Web安全</a></li>
<li><a href="#webflux-caching">7. HTTP缓存</a>
<ul class="sectlevel2">
<li><a href="#webflux-caching-cachecontrol">7.1. <code>CacheControl</code></a></li>
<li><a href="#webflux-caching-etag-lastmodified">7.2. 控制器</a></li>
<li><a href="#webflux-caching-static-resources">7.3. 静态资源</a></li>
</ul>
</li>
<li><a href="#webflux-config">8. WebFlux配置</a>
<ul class="sectlevel2">
<li><a href="#webflux-config-enable">8.1. 启用WebFlux配置</a></li>
<li><a href="#webflux-config-customize">8.2. WebFlux配置API</a></li>
<li><a href="#webflux-config-conversion">8.3. 转换，格式化</a></li>
<li><a href="#webflux-config-validation">8.4. 检验</a></li>
<li><a href="#webflux-config-content-negotiation">8.5. 内容类型解析器</a></li>
<li><a href="#webflux-config-message-codecs">8.6. HTTP消息编解码器</a></li>
<li><a href="#webflux-config-view-resolvers">8.7. 视图解析器</a></li>
<li><a href="#webflux-config-static-resources">8.8. 静态资源</a></li>
<li><a href="#webflux-config-path-matching">8.9. 路径匹配</a></li>
<li><a href="#webflux-config-advanced-java">8.10. 高级配置模式</a></li>
</ul>
</li>
<li><a href="#webflux-http2">9. HTTP/2</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring框架中包含的原始Web框架Spring Web MVC是专门为Servlet API和Servlet容器而构建的。
响应式栈Web框架Spring WebFlux在更高版本5.0中添加。它是完全非阻塞的，
支持 <a href="http://www.reactive-streams.org/">Reactive Streams</a>背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。</p>
</div>
<div class="paragraph">
<p>这两个Web框架都反映了其源模块的名称
(<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a> 和
<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>)，
并在Spring Framework中并存。每个模块都是可选的。应用程序可以使用一个模块或另一个模块，或者在某些情况下同时使用这两个模块，
例如：带有响应式 <code>WebClient</code> 的Spring MVC控制器。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-new-framework">1. 总览</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为什么创建Spring WebFlux？</p>
</div>
<div class="paragraph">
<p>答案的一部分是需要一个非阻塞式的Web堆栈来处理少量线程的并发并使用更少的硬件资源进行扩展。
Servlet 3.1确实提供了用于非阻塞I/O的API。但是，使用它与Servlet API的其他部分不同，
后者的契约是同步的（<code>Filter</code>，<code>Servlet</code>）或阻塞的（<code>getParameter</code>，<code>getPart</code>）。
这是促使新的通用API成为所有非阻塞运行时的基础的动机。
这一点很重要，因为服务器（例如Netty）已在异步，非阻塞空间中得到了良好的建立。</p>
</div>
<div class="paragraph">
<p>答案的另一部分是函数式编程。就像在Java 5中添加注解会创造机会（例如：带注解的REST控制器或单元测试）一样，
在Java 8中添加lambda表达式也会为Java中的函数式API创造机会。这对于非阻塞的应用程序和流式API
（如由 <code>CompletableFuture</code> 和 <a href="http://reactivex.io/">ReactiveX</a>普及的API）来说是一个福音，这些API允许以声明方式组合异步逻辑。
在编程模型级别，Java 8使Spring WebFlux能够与带注解的控制器一起提供函数式的Web端点。</p>
</div>
<div class="sect2">
<h3 id="webflux-why-reactive">1.1. 定义 &#8220;Reactive&#8221;</h3>
<div class="paragraph">
<p>我们谈到了“非阻塞”和“函数式”，但是响应式意味着什么？</p>
</div>
<div class="paragraph">
<p>术语“响应式”是指围绕对变更做出响应的编程模型&#8212;&#8203;网络组件对I/O事件做出响应，UI控制器对鼠标事件做出响应等。
从这个意义上说，非阻塞是响应式的，因为随着操作完成或数据可用，我们现在处于响应通知的模式，而不是被阻塞。</p>
</div>
<div class="paragraph">
<p>我们Spring团队还有另一个重要机制与“响应式”相关联，这是非阻塞背压的机制。
在同步命令式代码中，阻塞调用是强制调用者等待的一种自然的背压形式。
在非阻塞代码中，控制事件的速率非常重要，这样快速的生产者就不会淹没其目的地。</p>
</div>
<div class="paragraph">
<p>Reactive Streams是一个 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">小的规范</a>
（在Java 9中也 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用了</a>），它定义了带有背压的异步组件之间的交互。
例如，数据存储库（充当 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">发布者</a>）
可以生成HTTP服务器（充当 <a href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">订阅者</a>）
可以写入响应的数据。Reactive Streams的主要目的是让订阅者控制发布者生成数据的速度。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>常见问题：如果发布者不能放慢脚步怎么办？</strong><br>
Reactive Streams的目的仅仅是建立机制和边界。如果发布者无法放慢速度，则必须决定是缓冲，删除还是失败。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-reactive-api">1.2. Reactive API</h3>
<div class="paragraph">
<p>Reactive Streams对于互操作性起着重要作用。库和基础设施组件对此很感兴趣，但是由于它太底层了，它作为应用程序API的用处不大。
应用程序需要更高级别且功能更丰富的API来构成异步逻辑&#8212;&#8203;这与Java 8 <code>Stream</code> API相似，但不只是适用于集合。这就是响应式库的作用。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor">Reactor</a>是Spring WebFlux的首选响应式库。
它提供了 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>和
<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html"><code>Flux</code></a> API类型，
以通过与ReactiveX <a href="http://reactivex.io/documentation/operators.html">运算符词汇</a>对齐的丰富运算符集来处理
0..1 (<code>Mono</code>) 和 0..N (<code>Flux</code>)的数据序列。Reactor是Reactive Streams库，
因此，它的所有运算符都支持非阻塞背压。Reactor非常注重服务器端Java。它是与Spring紧密合作开发的。</p>
</div>
<div class="paragraph">
<p>WebFlux需要Reactor作为核心依赖项，但是它可以通过Reactive Streams与其他React库进行互操作。
通常，WebFlux API接受普通的 <code>Publisher</code> 作为输入，在内部将其适配成Reactor类型，使用它，然后返回 <code>Flux</code> 或 <code>Mono</code> 作为输出。
因此，你可以将任何 <code>Publisher</code> 作为输入传递，并且可以对输出应用操作，但是你需要调整输出以与其他响应式库一起使用。
只要可行（例如：带注解的控制器），WebFlux就会透明地适应RxJava或其他响应式库的使用。有关更多详细信息，请参见<a href="#webflux-reactive-libraries">[webflux-reactive-libraries]</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-programming-models">1.3. 编程模型</h3>
<div class="paragraph">
<p><code>spring-web</code> 模块包含Spring WebFlux的响应式基础，包括HTTP抽象，用于支持的服务器的Reactive Streams<a href="#webflux-httphandler">适配器</a>，
<a href="#webflux-codecs">编解码器</a>以及与Servlet API相似但具有非阻塞契约的核心<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>。</p>
</div>
<div class="paragraph">
<p>在此基础上，Spring WebFlux提供了两种编程模型的选择：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-controller">带注解的控制器</a>: 与Spring MVC一致，并基于 <code>spring-web</code> 模块中的相同注解。
Spring MVC和WebFlux控制器都支持响应式（Reactor和RxJava）返回类型，
因此，区分它们并不容易。一个显着的区别是WebFlux还支持响应式 <code>@RequestBody</code> 参数。</p>
</li>
<li>
<p><a href="#webflux-fn">[webflux-fn]</a>: 基于Lambda的轻量级函数式编程模型。你可以将其视为一个小型库或一组实用工具，应用程序可以使用它们来路由和处理请求。
与带注解的控制器的最大区别在于，应用程序负责从头到尾的请求处理，而不是通过注解来声明意图并被回调。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-framework-choice">1.4. 适用性</h3>
<div class="paragraph">
<p>Spring MVC or WebFlux?</p>
</div>
<div class="paragraph">
<p>这是一个很自然的问题，但却产生了一个不合理的二分法。实际上，两者共同努力扩大了可用选项的范围。
两者的设计旨在实现彼此的连续性和一致性，它们可以并行使用，并且来自每一方的反馈对双方都有利。
下图显示了两者之间的关系，它们的共同点以及各自的独特支持：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-webflux/spring-mvc-and-webflux-venn.png" alt="spring mvc and webflux venn">
</div>
</div>
<div class="paragraph">
<p>我们建议你考虑以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果你有运行正常的Spring MVC应用程序，则无需更改。
命令式编程是编写，理解和调试代码的最简单方法。你有最大的库选择空间，因为从历史上看，大多数库都是阻塞的。</p>
</li>
<li>
<p>如果你已经在购买非阻塞Web堆栈，那么Spring WebFlux在此空间中提供的执行模型优势与其他模型相同，
并且还提供服务器选择（Netty，Tomcat，Jetty，Undertow和Servlet 3.1+容器），
编程模型选择（带注解的控制器和功能性Web端点），以及响应式库的选择（Reactor，RxJava或其他）。</p>
</li>
<li>
<p>如果你对与Java 8 lambda或Kotlin一起使用的轻量级函数式Web框架感兴趣，则可以使用Spring WebFlux函数式Web端点。
对于要求较低复杂性的较小应用程序或微服务（可以受益于更高的透明度和控制）而言，这也是一个不错的选择。</p>
</li>
<li>
<p>在微服务架构中，你可以混合使用带有Spring MVC或Spring WebFlux控制器或带有Spring WebFlux函数式端点的应用程序。
两个框架都支持相同的基于注解的编程模型，这使得重用知识变得更加容易，同时还为正确的工作选择了正确的工具。</p>
</li>
<li>
<p>评估应用程序的一种简单方法是检查其依赖关系。如果你要使用阻塞性持久性API（JPA，JDBC）或网络API，
则Spring MVC至少是常见体系结构的最佳选择。使用Reactor和RxJava在单独的线程上执行阻塞调用在技术上是可行的，
但你不会充分利用非阻塞Web堆栈。</p>
</li>
<li>
<p>如果你的Spring MVC应用程序具有对远程服务的调用，请尝试响应式 <code>WebClient</code>。你可以直接从Spring
MVC控制器方法返回响应式类型（Reactor，RxJava，<a href="#webflux-reactive-libraries">或其他</a>）。
每次调用的延迟或调用之间的相互依赖性越大，好处就越明显。Spring MVC控制器也可以调用其他响应式组件。</p>
</li>
<li>
<p>如果你有庞大的团队，请牢记向无阻塞，函数式和声明性编程过渡过程中陡峭的学习曲线。
一种无需完全切换即可开始的实用方法是使用响应式 <code>WebClient</code>。除此之外，从小处着手并衡量收益。
我们希望，对于广泛的应用程序，这种转变是不必要的。如果不确定要寻找什么好处，
请先了解非阻塞I/O的工作原理（例如：单线程Node.js上的并发性）及其影响。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-server-choice">1.5. 服务器</h3>
<div class="paragraph">
<p>Tomcat，Jetty，Servlet 3.1+容器以及非Servlet运行时（例如：Netty和Undertow）都支持Spring WebFlux。
所有服务器都适应于低级<a href="#webflux-httphandler">通用API</a>，因此可以跨服务器支持更高级别的
<a href="#webflux-programming-models">编程模型</a>。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux不具有内置支持来启动或停止服务器。但是，从Spring配置和<a href="#webflux-config">WebFlux基础设施</a>
<a href="#webflux-web-handler-api">组装</a>一个应用程序并用几行代码<a href="#webflux-httphandler">运行它</a>很容易。</p>
</div>
<div class="paragraph">
<p>Spring Boot具有一个WebFlux启动器，可以自动执行这些步骤。默认情况下，starter使用Netty，
但通过更改Maven或Gradle依赖关系，可以轻松切换到Tomcat，Jetty或Undertow。
Spring Boot默认为Netty，因为它在异步，非阻塞空间中得到更广泛的使用，并允许客户端和服务器共享资源。</p>
</div>
<div class="paragraph">
<p>Tomcat和Jetty可以与Spring MVC和WebFlux一起使用。但是请记住，它们的使用方式非常不同。
Spring MVC依靠Servlet阻塞I/O，并允许应用程序在需要时直接使用Servlet API。
Spring WebFlux依赖于Servlet 3.1非阻塞I/O，并在底层适配器后面使用Servlet API，并且不公开供直接使用。</p>
</div>
<div class="paragraph">
<p>对于Undertow，Spring WebFlux直接使用Undertow API，而无需使用Servlet API。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-performance">1.6. 性能</h3>
<div class="paragraph">
<p>性能具有许多特征和意义。响应式和非阻塞通常不会使应用程序运行得更快。
在某些情况下，它们可以（例如：如果使用 <code>WebClient</code> 并行执行远程调用）。
总体而言，以非阻塞方式进行操作需要更多的工作，这可能会稍微增加所需的处理时间。</p>
</div>
<div class="paragraph">
<p>响应式和非阻塞性的主要预期好处是能够以较少的固定数量的线程和较少的内存进行扩展。
这使应用程序在负载下更具弹性，因为它们以更可预测的方式扩展。
然而，为了能观察到这些好处，你需要一些延迟（包括缓慢的和不可预测的网络I/O）。
这就是响应式堆栈开始显示其优势的地方，差异可能是巨大的。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-concurrency-model">1.7. 并发模型</h3>
<div class="paragraph">
<p>Spring MVC和Spring WebFlux都支持带注解的控制器，但是在并发模型以及对阻塞和线程的默认假设存在关键差异。</p>
</div>
<div class="paragraph">
<p>在Spring MVC（通常是servlet应用程序）中，假设应用程序可以阻塞当前线程（例如：用于远程调用），
因此，servlet容器使用大型线程池来吸收请求处理过程中可能出现的阻塞。</p>
</div>
<div class="paragraph">
<p>在Spring WebFlux（通常是非阻塞服务器）中，假设应用程序未阻塞，因此，非阻塞服务器使用固定大小的小型线程池
（事件循环工作器）来处理请求。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
“按比例缩放”和“少量线程”听起来可能是矛盾的，但是从不阻塞当前线程（而是依靠回调）意味着你不需要额外的线程，
因为没有阻塞调用可供吸收。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">调用阻塞API</div>
<p>如果确实需要使用阻止库怎么办？Reactor和RxJava都提供了 <code>publishOn</code> 运算符以继续在其他线程上进行处理。
这意味着容易逃生。但是请记住，阻塞式API不适用于此并发模型。</p>
</div>
<div class="paragraph">
<div class="title">可变状态</div>
<p>在Reactor和RxJava中，你可以通过运算符声明逻辑，然后在运行时形成一个响应式管道，在其中以不同的阶段顺序处理数据。
这样做的主要好处是，它使应用程序不必保护可变状态，因为该管道中的应用程序代码永远不会被同时调用。</p>
</div>
<div class="paragraph">
<div class="title">线程模型</div>
<p>你期望在运行Spring WebFlux的服务器上看到哪些线程？</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在“原始” Spring WebFlux服务器上（例如：没有数据访问权限或其他可选依赖项），你可以期望该服务器有一个线程，
而其他几个线程则可以进行请求处理（通常与CPU核心数量一样多）。但是，Servlet容器可能以更多的线程
（例如：Tomcat上为10）开始，以同时支持servlet（阻塞）I/O和Servlet 3.1（非阻塞）I/O使用。</p>
</li>
<li>
<p>响应式 <code>WebClient</code> 以事件循环方式运行。因此，你可以看到与之相关的固定数量的处理线程
（例如，带有Reactor Netty连接器的 <code>react-http-nio-</code>）。但是，如果客户端和服务器都使用Reactor Netty，
则默认情况下，两者共享事件循环资源。</p>
</li>
<li>
<p>Reactor和RxJava提供称为调度程序的线程池抽象，以与 <code>publishOn</code> 运算符配合使用，该运算符用于将处理切换到其他线程池。
调度程序具有建议特定并发策略的名称&#8212;&#8203;例如：“<code>parallel</code>”（对于具有有限数量线程的CPU绑定工作）或“<code>elastic</code>”
（对于具有大量线程的I/O绑定）。如果看到这样的线程，则意味着某些代码正在使用特定的线程池 <code>Scheduler</code> 策略。</p>
</li>
<li>
<p>数据访问库和其他第三方依赖也可以创建和使用自己的线程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">配置中</div>
<p>Spring框架不提供启动和停止<a href="#webflux-server-choice">服务器</a>的支持。要为服务器配置线程模型，你需要使用服务器特定的配置API，
或者，如果你使用的是Spring Boot，请检查每个服务器的Spring Boot配置选项。你可以直接
<a href="web-reactive.html#webflux-client-builder">配置</a> <code>WebClient</code>。对于所有其他库，请参阅其各自的文档。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-reactive-spring-web">2. Reactive核心</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>spring-web</code> 模块包含以下对响应式Web应用程序的基本支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于服务器请求处理，有两个级别的支持。</p>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-httphandler">HttpHandler</a>: 具有非阻塞I/O和Reactive Streams背压的HTTP请求处理的基本契约，
以及Reactor Netty，Undertow，Tomcat，Jetty和任何Servlet 3.1+容器的适配器。</p>
</li>
<li>
<p><a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>: 稍高级别的通用Web API，用于处理请求，在此之上构建了具体的编程模型，例如：
带注解的控制器和函数式端点。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对于客户端，有一个基本的 <code>ClientHttpConnector</code> 契约，以执行具有非阻塞I/O和响应流背压的HTTP请求，
以及用于 <a href="https://github.com/reactor/reactor-netty">Reactor Netty</a>和响应式
<a href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HttpClient</a>的适配器。
应用程序中使用的更高级别的<a href="web-reactive.html#webflux-client">WebClient</a>就基于此基本协定。</p>
</li>
<li>
<p>对于客户端和服务器，<a href="#webflux-codecs">编解码器</a>用于序列化和反序列化HTTP请求和响应内容。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="webflux-httphandler">2.1. <code>HttpHandler</code></h3>
<div class="paragraph">
<p>{api-spring-framework}/http/server/reactive/HttpHandler.html[HttpHandler]
是具有单个方法的简单契约，用于处理请求和响应。
它故意设计成最小的，它的主要也是唯一目的是成为对不同HTTP服务器API的最小抽象。</p>
</div>
<div class="paragraph">
<p>下表描述了受支持的服务器API：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">使用的服务器API</th>
<th class="tableblock halign-left valign-top">Reactive Streams支持</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Netty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/reactor/reactor-netty">Reactor Netty</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Undertow to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O；读写ByteBuffers与byte[]的Tomcat API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O；写ByteBuffers与byte[]的Jetty API</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servlet 3.1 非阻塞I/O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表描述了服务器依赖（另请参阅
<a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework">受支持的版本</a>）：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务器名称</th>
<th class="tableblock halign-left valign-top">Group id</th>
<th class="tableblock halign-left valign-top">Artifact name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactor Netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.projectreactor.netty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reactor-netty</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">io.undertow</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">undertow-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tomcat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.tomcat.embed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tomcat-embed-core</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.eclipse.jetty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">jetty-server, jetty-servlet</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下面的代码段显示了如何将 <code>HttpHandler</code> 适配器与每个服务器API一起使用：</p>
</div>
<div class="paragraph">
<p><strong>Reactor Netty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create(host, port).newHandler(adapter).block();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Undertow</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Tomcat</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Jetty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Servlet 3.1+ 容器</strong></p>
</div>
<div class="paragraph">
<p>要将其作为WAR部署到任何Servlet 3.1+容器，你可以继承
{api-spring-framework}/web/server/adapter/AbstractReactiveWebInitializer.html[<code>AbstractReactiveWebInitializer</code>]
并将其包括在WAR中。该类使用 <code>ServletHttpHandlerAdapter</code> 包装 <code>HttpHandler</code> 并将其注册为 <code>Servlet</code>。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-web-handler-api">2.2. <code>WebHandler</code> API</h3>
<div class="paragraph">
<p><code>org.springframework.web.server</code> 包基于<a href="#webflux-httphandler"><code>HttpHandler</code></a>契约构建，以提供通用的Web
API，以通过多个 {api-spring-framework}/web/server/WebExceptionHandler.html[<code>WebExceptionHandler</code>]，
多个 {api-spring-framework}/web/server/WebFilter.html[<code>WebFilter</code>]和
单个 {api-spring-framework}/web/server/WebHandler.html[<code>WebHandler</code>]组件组成的链来处理请求。
通过简单地指向<a href="#webflux-web-handler-api-special-beans">自动检测</a>组件的Spring <code>ApplicationContext</code>
和/或通过向构建器注册组件，可以将该链与 <code>WebHttpHandlerBuilder</code> 放在一起。</p>
</div>
<div class="paragraph">
<p>尽管 <code>HttpHandler</code> 的目标很简单，即抽象化不同HTTP服务器的使用，但 <code>WebHandler</code> API
的目的是提供Web应用程序中常用的更广泛的功能集，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有属性的用户会话。</p>
</li>
<li>
<p>请求属性。</p>
</li>
<li>
<p>已解析请求的 <code>Locale</code> 或 <code>Principal</code>。</p>
</li>
<li>
<p>访问已解析和缓存的表单数据。</p>
</li>
<li>
<p>multipart数据的抽象。</p>
</li>
<li>
<p>和更多..</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="webflux-web-handler-api-special-beans">2.2.1. 特殊bean类型</h4>
<div class="paragraph">
<p>下表列出了 <code>WebHttpHandlerBuilder</code> 可以在Spring <code>ApplicationContext</code> 中自动检测的组件，
或者可以直接向其注册的组件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 12%;">
<col style="width: 37%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean名称</th>
<th class="tableblock halign-left valign-top">Bean类型</th>
<th class="tableblock halign-left valign-top">计数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提供对来自 <code>WebFilter</code> 实例链和目标 <code>WebHandler</code> 的异常的处理。有关更多详细信息，请参见<a href="#webflux-exception-handler">异常</a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在其余的过滤器链和目标 <code>WebHandler</code> 之前和之后应用拦截样式逻辑。有关更多详细信息，请参见<a href="#webflux-filters">过滤器</a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的处理程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>webSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSessionManager</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <code>ServerWebExchange</code> 上的方法公开的 <code>WebSession</code> 实例的管理器。默认情况下为 <code>DefaultWebSessionManager</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serverCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerCodecConfigurer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于访问 <code>HttpMessageReader</code> 实例以解析表单数据和multipart数据，然后通过 <code>ServerWebExchange</code>
  上的方法公开这些数据。默认情况下为 <code>ServerCodecConfigurer.create()</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>localeContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleContextResolver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <code>ServerWebExchange</code> 上的方法公开的 <code>LocaleContext</code> 解析程序。默认情况下为 <code>AcceptHeaderLocaleContextResolver</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ForwardedHeaderTransformer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于处理转发的类型标头，可以提取和删除它们，也可以只删除它们。默认情况下不使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-form-data">2.2.2. 表单数据</h4>
<div class="paragraph">
<p><code>ServerWebExchange</code> 公开以下访问表单数据的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code> 使用配置的 <code>HttpMessageReader</code> 将表单数据（<code>application/x-www-form-urlencoded</code>）
解析为 <code>MultiValueMap</code>。默认情况下，<code>FormHttpMessageReader</code> 配置为由 <code>ServerCodecConfigurer</code> Bean使用
（请参阅<a href="#webflux-web-handler-api">Web Handler API</a>）。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-multipart">2.2.3. Multipart数据</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multipart">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ServerWebExchange</code> 公开以下访问multipart数据的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DefaultServerWebExchange</code> 使用配置的 <code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code> 将
<code>multipart/form-data</code> 内容解析为 <code>MultiValueMap</code>。当前，
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的第三方库，
并且是我们知道的用于非阻塞解析multipart请求的唯一库。
通过 <code>ServerCodecConfigurer</code> bean启用它（请参阅<a href="#webflux-web-handler-api">Web Handler API</a>）。</p>
</div>
<div class="paragraph">
<p>要以流方式解析multipart数据，可以使用从 <code>HttpMessageReader&lt;Part&gt;</code> 返回的 <code>Flux&lt;Part&gt;</code>。
例如：在带注解的控制器中，使用 <code>@RequestPart</code> 意味着按名称对各个parts进行类似于
<code>Map</code> 的访问，因此需要完全解析multipart数据。相反，你可以使用 <code>@RequestBody</code> 将内容解码为
<code>Flux&lt;Part&gt;</code> 而不收集到 <code>MultiValueMap</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-forwarded-headers">2.2.4. Forwarded请求头</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters-forwarded-headers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>当请求通过代理（例如：负载均衡器）进行处理时，host，port和scheme可能会更改，
这使得从客户端角度创建指向正确的host，port和scheme的链接成为挑战。</p>
</div>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可以用来提供有关原始请求信息的 <code>Forwarded</code> HTTP头。
还有其他非标准请求头，包括 <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>,
<code>X-Forwarded-Proto</code>, <code>X-Forwarded-Ssl</code> 和 <code>X-Forwarded-Prefix</code>。</p>
</div>
<div class="paragraph">
<p><code>ForwardedHeaderTransformer</code> 是一个组件，可根据转发的头部修改请求的host，port和scheme，然后删除这些头部。
你可以将其声明为名称为 <code>forwardedHeaderTransformer</code> 的Bean，并对其进行<a href="#webflux-web-handler-api-special-beans">检测</a>和使用。</p>
</div>
<div class="paragraph">
<p>对于转发的头部，存在安全方面的考虑，因为应用程序无法知道头部是由代理添加的，还是由恶意客户端添加的。
这就是为什么应配置信任边界处的代理以删除来自外部的不受信任的 <code>Forwarded</code> 头的原因。
你还可以使用 <code>removeOnly=true</code> 配置 <code>ForwardedHeaderTransformer</code>，在这种情况下，它将删除但不使用头。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在5.1版本中，<code>ForwardedHeaderFilter</code> 被 <code>ForwardedHeaderTransformer</code> 取代并弃用，
因此可以在创建exchange之前更早地处理forwarded头。如果仍然配置了过滤器，则将其从过滤器列表中删除，
而改用 <code>ForwardedHeaderTransformer</code>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-filters">2.3. 过滤器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中，可以使用 <code>WebFilter</code> 在过滤器和目标 <code>WebHandler</code>
的处理链的其余部分之前和之后应用拦截样式的逻辑。使用<a href="#webflux-config">WebFlux配置</a>时，注册 <code>WebFilter</code> 就像将其声明为Spring bean一样简单，
并且（可选）通过在bean声明上使用 <code>@Order</code> 或实现 <code>Ordered</code> 来表达优先级。</p>
</div>
<div class="sect3">
<h4 id="webflux-filters-cors">2.3.1. CORS</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#filters-cors">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux通过控制器上的注解为CORS配置提供了细粒度的支持。
但是，当你将其与Spring Security结合使用时，我们建议你依赖内置的 <code>CorsFilter</code>，
它必须排在Spring Security的过滤器链之前。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见<a href="#webflux-cors">[webflux-cors]</a>和<a href="#webflux-cors-webfilter">[webflux-cors-webfilter]</a>部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-exception-handler">2.4. 异常</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-customer-servlet-container-error-page">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中，可以使用 <code>WebExceptionHandler</code> 来处理 <code>WebFilter</code>
实例和目标 <code>WebHandler</code> 链中的异常。使用<a href="#webflux-config">WebFlux配置</a>时，
注册 <code>WebExceptionHandler</code> 就像将其声明为Spring bean一样简单，
并且（可选）通过在bean声明上使用 <code>@Order</code> 或实现 <code>Ordered</code> 来表达优先级。</p>
</div>
<div class="paragraph">
<p>下表描述了可用的 <code>WebExceptionHandler</code> 实现：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">异常处理程序</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过将响应设置为异常的HTTP状态码，提供对
  {api-spring-framework}/web/server/ResponseStatusException.html[<code>ResponseStatusException</code>]
  类型的异常的处理。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFluxResponseStatusExceptionHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseStatusExceptionHandler</code> 的扩展，它也可以确定任何异常时 <code>@ResponseStatus</code> 所注解的HTTP状态码。
</p><p class="tableblock">  该异常处理程序在<a href="#webflux-config">WebFlux配置</a>中声明。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="webflux-codecs">2.5. 编解码器</h3>
<div class="paragraph">
<p><span class="small">{doc-spring-integration}#rest-message-conversion[Web MVC]</span></p>
</div>
<div class="paragraph">
<p><code>spring-web</code> 和 <code>spring-core</code> 模块提供支持，通过具有Reactive Streams背压的非阻塞I/O，
可以将字节内容与更高级别的对象之间的字节序列进行序列化和反序列化。以下介绍了此支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{api-spring-framework}/core/codec/Encoder.html[<code>Encoder</code>] 和
{api-spring-framework}/core/codec/Decoder.html[<code>Decoder</code>] 是底层协议，用于独立于HTTP编码和解码内容。</p>
</li>
<li>
<p>{api-spring-framework}/http/codec/HttpMessageReader.html[<code>HttpMessageReader</code>] 和
{api-spring-framework}/http/codec/HttpMessageWriter.html[<code>HttpMessageWriter</code>] 是对HTTP消息内容进行编码和解码的契约。</p>
</li>
<li>
<p>可以使用 <code>EncoderHttpMessageWriter</code> 来包装 <code>Encoder</code>，以使其适合在Web应用程序中使用，也可以使用
<code>DecoderHttpMessageReader</code> 来包装 <code>Decoder</code>。</p>
</li>
<li>
<p>{api-spring-framework}/core/io/buffer/DataBuffer.html[<code>DataBuffer</code>]
抽象了不同的字节缓冲区表示形式（例如：Netty <code>ByteBuf</code>，<code>java.nio.ByteBuffer</code> 等），
并且是所有编解码器都在处理的内容。有关此主题的更多信息，请参见“Spring Core”中的
{doc-spring-core}#databuffers[数据缓冲区和编解码器]部分。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>spring-core</code> 模块提供 <code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code> 和 <code>String</code> 编码器和解码器实现。
<code>spring-web</code> 模块提供了Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers和其他编码器和解码器，
以及web-only的HTTP消息读取器和写入器实现，用于表单数据，multipart内容，服务器发送事件等。</p>
</div>
<div class="paragraph">
<p><code>ClientCodecConfigurer</code> 和 <code>ServerCodecConfigurer</code> 通常用于配置和自定义要在应用程序中使用的编解码器。
请参阅有关配置<a href="#webflux-config-message-codecs">HTTP消息编解码器</a>部分。</p>
</div>
<div class="sect3">
<h4 id="webflux-codecs-jackson">2.5.1. Jackson JSON</h4>
<div class="paragraph">
<p>当存在Jackson库时，JSON和二进制JSON（ <a href="https://github.com/FasterXML/smile-format-specification">Smile</a>）都被支持。</p>
</div>
<div class="paragraph">
<p><code>Jackson2Decoder</code> 的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson的异步，非阻塞解析器用于将字节块流聚合到 <code>TokenBuffer</code> 的每个块中，每个块代表一个JSON对象。</p>
</li>
<li>
<p>每个 <code>TokenBuffer</code> 都传递给Jackson的 <code>ObjectMapper</code> 以创建更高级别的对象。</p>
</li>
<li>
<p>当解码为单值发布者（例如： <code>Mono</code>）时，有一个 <code>TokenBuffer</code>。</p>
</li>
<li>
<p>当解码为多值发布者（例如： <code>Flux</code>）时，一旦为一个完整的对象接收到足够的字节，每个 <code>TokenBuffer</code> 就会传递给 <code>ObjectMapper</code>。
输入内容可以是JSON数组，如果内容类型为“application/stream+json”，则可以是行分隔的JSON。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Jackson2Encoder</code> 的工作方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于单个值发布者（例如： <code>Mono</code>），只需通过 <code>ObjectMapper</code> 对其进行序列化即可。</p>
</li>
<li>
<p>对于具有“application/json”的多值发布者，默认情况下使用 <code>Flux#collectToList()</code> 收集值，然后序列化结果集合。</p>
</li>
<li>
<p>对于具有流媒体类型（例如：<code>application/stream+json</code> 或 <code>application/stream+x-jackson-smile</code>）的多值发布者，
请使用 <a href="https://en.wikipedia.org/wiki/JSON_streaming">行分隔的JSON</a>格式分别编码，写入和刷新每个值。</p>
</li>
<li>
<p>对于SSE，将为每个事件调用 <code>Jackson2Encoder</code>，并刷新输出以确保交付没有延迟。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，<code>Jackson2Encoder</code> 和 <code>Jackson2Decoder</code> 都不支持 <code>String</code> 类型的元素。
相反，默认假设是一个字符串或一系列字符串表示要由 <code>CharSequenceEncoder</code> 呈现的序列化JSON内容。
如果你需要从 <code>Flux&lt;String&gt;</code> 呈现JSON数组，请使用 <code>Flux#collectToList()</code> 并对 <code>Mono&lt;List&lt;String&gt;&gt;</code> 进行编码。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-forms">2.5.2. 表单数据</h4>
<div class="paragraph">
<p><code>FormHttpMessageReader</code> 和 <code>FormHttpMessageWriter</code> 支持对“application/x-www-form-urlencoded”内容进行解码和编码。</p>
</div>
<div class="paragraph">
<p>在经常需要从多个位置访问表单内容的服务器端，<code>ServerWebExchange</code> 提供了专用的 <code>getFormData()</code> 方法，该方法通过
<code>FormHttpMessageReader</code> 解析内容，然后缓存结果以进行重复访问。请参阅<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分中的<a href="#webflux-form-data">表单数据</a>。</p>
</div>
<div class="paragraph">
<p>一旦使用 <code>getFormData()</code>，就无法再从请求正文中读取最初的原始内容。
因此，应用程序应始终通过 <code>ServerWebExchange</code> 来访问缓存的表单数据，而不是从原始请求正文中进行读取。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-multipart">2.5.3. Multipart</h4>
<div class="paragraph">
<p><code>MultipartHttpMessageReader</code> 和 <code>MultipartHttpMessageWriter</code> 支持对“multipart/form-data”内容进行解码和编码。
反过来，<code>MultipartHttpMessageReader</code> 委托给另一个 <code>HttpMessageReader</code> 进行实际解析为 <code>Flux&lt;Part&gt;</code>，
然后将这些parts简单地收集到 <code>MultiValueMap</code> 中。目前，
<a href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>
被用于实际解析。</p>
</div>
<div class="paragraph">
<p>在可能需要从多个位置访问multipart表单内容的服务器端，<code>ServerWebExchange</code> 提供了专用的 <code>getMultipartData()</code> 方法，
该方法通过 <code>MultipartHttpMessageReader</code> 解析内容，然后缓存结果以进行重复访问。
请参阅<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>部分中的<a href="#webflux-multipart">Multipart数据</a>。</p>
</div>
<div class="paragraph">
<p>一旦使用 <code>getMultipartData()</code>，就无法再从请求正文中读取最初的原始内容。
因此，应用程序必须始终使用 <code>getMultipartData()</code> 来重复，类似于map的方式访问parts，否则必须依靠
<code>SynchronossPartHttpMessageReader</code> 来一次性访问 <code>Flux&lt;Part&gt;</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-limits">2.5.4. 限制</h4>
<div class="paragraph">
<p>可以对缓冲部分或全部输入流的 <code>Decoder</code> 和 <code>HttpMessageReader</code> 实现进行配置，并限制要在内存中缓冲的最大字节数。
在某些情况下，由于输入被汇总并表示为单个对象而发生缓冲，例如：具有 <code>@RequestBody byte[]</code>，
<code>x-www-form-urlencoded</code> 数据的控制器方法，等等。在分割输入流（例如：定界文本，JSON对象流等）时，流处理也会发生缓冲。
对于那些流情况，该限制适用于与流中一个对象关联的字节数。</p>
</div>
<div class="paragraph">
<p>要配置缓冲区大小，你可以检查给定的 <code>Decoder</code> 或 <code>HttpMessageReader</code> 是否公开了 <code>maxInMemorySize</code> 属性，
如果有，则Javadoc将具有有关默认值的详细信息。在WebFlux中，<code>ServerCodecConfigurer</code> 通过默认编解码器的
<code>maxInMemorySize</code> 属性，提供了<a href="#webflux-config-message-codecs">一个位置</a>设置所有的编解码器。在客户端，可以在
<a href="#webflux-client-builder-maxinmemorysize">WebClient.Builder</a>中更改限制。</p>
</div>
<div class="paragraph">
<p>对于Multipart解析，<code>maxInMemorySize</code> 属性限制了非文件parts的大小。对于文件parts，它确定将part写入磁盘的阈值。
对于写入磁盘的文件part，还有一个额外的 <code>maxDiskUsagePerPart</code> 属性可限制每个part的磁盘空间量。
还有一个 <code>maxParts</code> 属性，用于限制multipart请求中的parts总数。要在WebFlux中配置所有均为3个，你需要向
<code>ServerCodecConfigurer</code> 提供一个预先配置的 <code>MultipartHttpMessageReader</code> 实例。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-streaming">2.5.5. Streaming</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-async-http-streaming">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在流式传输HTTP响应（例如：<code>text/event-stream</code>, <code>application/stream+json</code>）时，定期发送数据很重要，
这样才能尽快（而不是稍后）可靠地检测到断开连接的客户端。这样的发送可以是仅注释，空的SSE事件或任何其他可以有效充当心跳的“无操作”数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-buffers">2.5.6. <code>DataBuffer</code></h4>
<div class="paragraph">
<p><code>DataBuffer</code> 是WebFlux中字节缓冲区的表示形式。参考的Spring Core部分在 {doc-spring-core}#databuffers[数据缓冲区和编解码器]一节中对此有更多的介绍。
要注意的关键点是，在诸如Netty之类的某些服务器上，字节缓冲区被池化并且对引用进行计数，
并且在消耗字节缓冲区时必须将其释放以避免内存泄漏。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序通常不需要关心此类问题，除非它们直接使用或产生数据缓冲区，而不是依赖于编解码器与更高级别的对象之间进行转换，
或者除非它们选择创建自定义编解码器。对于这种情况，请查看 {doc-spring-core}#databuffers[数据缓冲区和编解码器]中的信息，
尤其是有关 {doc-spring-core}#databuffers-using[使用数据缓冲区]部分。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-logging">2.6. 日志</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-logging">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux中的DEBUG级别日志记录被设计为紧凑，最小化和人性化。它侧重于反复有用的高价值信息，
而其他信息则仅在调试特定问题时才有用。</p>
</div>
<div class="paragraph">
<p>TRACE级别的日志记录通常遵循与DEBUG相同的原则（例如：也不应成为firehose），但可用于调试任何问题。
另外，某些日志消息在TRACE vs DEBUG上可能显示不同级别的详细信息。</p>
</div>
<div class="paragraph">
<p>良好的日志记录来自使用日志的经验。如果你发现任何不符合既定目标的地方，请告诉我们。</p>
</div>
<div class="sect3">
<h4 id="webflux-logging-id">2.6.1. 日志Id</h4>
<div class="paragraph">
<p>在WebFlux中，单个请求可以在多个线程上执行，并且线程ID对于关联属于特定请求的日志消息没有用。
这就是为什么WebFlux日志消息默认情况下带有特定于请求的ID的原因。</p>
</div>
<div class="paragraph">
<p>在服务器端，日志ID存储在 <code>ServerWebExchange</code> 属性
（ {api-spring-framework}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[<code>LOG_ID_ATTRIBUTE</code>]）
中，而可从 <code>ServerWebExchange#getLogPrefix()</code> 获得基于该ID的完整格式前缀。
在 <code>WebClient</code> 端，日志ID存储在 <code>ClientRequest</code> 属性
（ {api-spring-framework}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[<code>LOG_ID_ATTRIBUTE</code>]）
中，而完整格式的前缀可从 <code>ClientRequest#logPrefix()</code> 获得。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-logging-sensitive-data">2.6.2. 敏感数据</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-logging-sensitive-data">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DEBUG</code> 和 <code>TRACE</code> 日志记录可以记录敏感信息。这就是默认情况下屏蔽表单参数和头部的原因，并且必须显式启用它们以记录完整日志。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何对服务器端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

	@Override
	public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
		configurer.defaultCodecs().enableLoggingRequestDetails(true);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对客户端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;
		configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
		.exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())
		.build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-codecs-custom">2.6.3. 自定义编解码器</h4>
<div class="paragraph">
<p>应用程序可以注册自定义编解码器以支持其他媒体类型，也可以注册默认编解码器不支持的特定行为。</p>
</div>
<div class="paragraph">
<p>开发人员表示的某些配置选项在默认编解码器上强制执行。自定义编解码器可能希望有机会与这些首选项保持一致，例如：
<a href="#webflux-codecs-limits">强制执行缓冲限制</a>或<a href="#webflux-logging-sensitive-data">记录敏感数据</a>。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何针对客户端请求执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt; {
        CustomDecoder customDecoder = new CustomDecoder();
        configurer.customCodecs().decoder(customDecoder);
        configurer.customCodecs().withDefaultCodecConfig(config -&gt;
            customDecoder.maxInMemorySize(config.maxInMemorySize())
        );
}

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -&gt; strategies.codecs(consumer))
        .build();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-dispatcher-handler">3. <code>DispatcherHandler</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux与Spring MVC类似，是围绕前端控制器模式设计的，其中中央 <code>WebHandler</code> <code>DispatcherHandler</code>
提供了用于请求处理的共享算法，而实际工作是由可配置的委托组件执行的。该模型非常灵活，并支持多种工作流程。</p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 从Spring配置中发现所需的委托组件。它还被设计为Spring Bean本身，并实现
<code>ApplicationContextAware</code> 来访问其运行的上下文。如果以 <code>webHandler</code> 的bean名称声明了 <code>DispatcherHandler</code>
，则 {api-spring-framework}/web/server/adapter/WebHttpHandlerBuilder.html[<code>WebHttpHandlerBuilder</code>]会发现它，
而 <code>WebHttpHandlerBuilder</code> 会将其与请求处理链组合在一起，如<a href="#webflux-web-handler-api"><code>WebHandler</code> API</a>中所述。</p>
</div>
<div class="paragraph">
<p>WebFlux应用程序中的Spring配置通常包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bean名称为 <code>webHandler</code> 的 <code>DispatcherHandler</code></p>
</li>
<li>
<p><code>WebFilter</code> 和 <code>WebExceptionHandler</code> beans</p>
</li>
<li>
<p><a href="#webflux-special-bean-types"><code>DispatcherHandler</code> 特殊beans</a></p>
</li>
<li>
<p>其它</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将配置提供给 <code>WebHttpHandlerBuilder</code> 以构建处理链，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">ApplicationContext context = ...
HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的 <code>HttpHandler</code> 已准备好与<a href="#webflux-httphandler">服务器适配器</a>一起使用。</p>
</div>
<div class="sect2">
<h3 id="webflux-special-bean-types">3.1. 特殊Bean类型</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-special-bean-types">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 委托给特殊的Bean处理请求并渲染适当的响应。
所谓“特殊bean”，是指实现WebFlux框架契约的Spring管理对象实例。
这些通常带有内置契约，但是你可以自定义它们的属性，扩展它们或替换它们。</p>
</div>
<div class="paragraph">
<p>下表列出了 <code>DispatcherHandler</code> 检测到的特殊bean。请注意，在较低级别还检测到其他一些bean
（请参阅Web Handler API中的<a href="#webflux-web-handler-api-special-beans">特殊bean类型</a>）。</p>
</div>
<table id="webflux-special-beans-table" class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Bean类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerMapping</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将请求映射到处理程序。映射基于某些条件，这些条件的详细信息因 <code>HandlerMapping</code> 实现而有所不同
  --带有注解的控制器，简单的URL模式映射以及其他。
</p><p class="tableblock">  主要的 <code>HandlerMapping</code> 实现是用于 <code>@RequestMapping</code> 注解方法的 <code>RequestMappingHandlerMapping</code>
  ，用于函数式端点路由的 <code>RouterFunctionMapping</code> 和用于URI路径模式和 <code>WebHandler</code> 实例的显式注册的
  <code>SimpleUrlHandlerMapping</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerAdapter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">帮助 <code>DispatcherHandler</code> 调用映射到请求的处理程序，而不管实际如何调用该处理程序。
  例如：调用带注解的控制器需要解析注解。<code>HandlerAdapter</code> 的主要目的是使 <code>DispatcherHandler</code> 免受此类细节的影响。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HandlerResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理来自处理程序调用的结果，并最终确定响应。请参阅<a href="#webflux-resulthandling">结果处理</a>。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="webflux-framework-config">3.2. WebFlux配置</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-config">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>应用程序可以声明处理请求所需的基础设施bean（在<a href="#webflux-web-handler-api-special-beans">Web Handler API</a>
和<a href="#webflux-special-bean-types"><code>DispatcherHandler</code></a>下列出）。
但是，在大多数情况下，<a href="#webflux-config">WebFlux配置</a>是最佳起点。它声明了所需的bean，并提供了更高级别的配置回调API来对其进行自定义。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot依靠WebFlux配置来配置Spring WebFlux，并且还提供了许多额外的方便选项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-handler-sequence">3.3. 处理过程</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-servlet-sequence">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>DispatcherHandler</code> 处理请求的方式如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要求每个 <code>HandlerMapping</code> 查找一个匹配的处理程序，并使用第一个匹配项。</p>
</li>
<li>
<p>如果找到处理程序，则通过适当的 <code>HandlerAdapter</code> 执行该处理程序，该处理程序将执行的返回值公开为 <code>HandlerResult</code>。</p>
</li>
<li>
<p>通过直接写入响应或使用视图渲染，将 <code>HandlerResult</code> 提供给适当的 <code>HandlerResultHandler</code> 以完成处理。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-resulthandling">3.4. 结果处理</h3>
<div class="paragraph">
<p>通过 <code>HandlerAdapter</code> 调用处理程序的返回值连同其他一些上下文一起包装为 <code>HandlerResult</code>，
并传递给第一个支持该处理程序的 <code>HandlerResultHandler</code>。
下表显示了可用的 <code>HandlerResultHandler</code> 实现，所有实现都在<a href="#webflux-config">WebFlux配置</a>中声明：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">结果处理程序类型</th>
<th class="tableblock halign-left valign-top">返回值</th>
<th class="tableblock halign-left valign-top">默认顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntityResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseEntity</code>, 通常来自 <code>@Controller</code> 实例。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponseResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerResponse</code>, 通常来自函数式端点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResponseBodyResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理 <code>@ResponseBody</code> 方法或 <code>@RestController</code> 类的返回值。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ViewResolutionResultHandler</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CharSequence</code>, {api-spring-framework}/web/reactive/result/view/View.html[<code>View</code>],
  {api-spring-framework}/ui/Model.html[Model], <code>Map</code>,
  {api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering],
  或任何其他 <code>Object</code> 被视为模型属性。
</p><p class="tableblock">  另请参阅<a href="#webflux-viewresolution">视图解析</a>。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Integer.MAX_VALUE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="webflux-dispatcher-exceptions">3.5. 异常</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-exceptionhandlers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>从 <code>HandlerAdapter</code> 返回的 <code>HandlerResult</code> 可以公开基于某些特定于处理程序的机制进行错误处理的函数。
在以下情况下将调用此错误函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理程序（例如： <code>@Controller</code>）调用失败。</p>
</li>
<li>
<p>通过 <code>HandlerResultHandler</code> 处理处理程序返回值失败。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>只要在从处理程序返回的响应式类型产生任何数据项之前发生错误信号，错误函数就可以更改响应（例如：更改为错误状态）。</p>
</div>
<div class="paragraph">
<p>这就是支持 <code>@Controller</code> 类中的 <code>@ExceptionHandler</code> 方法的方式。相比之下，Spring
MVC中对相同功能的支持建立在 <code>HandlerExceptionResolver</code> 之上。这通常不重要。但是，请记住，在WebFlux中，不能使用
<code>@ControllerAdvice</code> 来处理在选择处理程序之前发生的异常。</p>
</div>
<div class="paragraph">
<p>另请参见“带注解的控制器”部分中的<a href="#webflux-ann-controller-exceptions">管理异常</a>或WebHandler API部分中的<a href="#webflux-exception-handler">异常</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-viewresolution">3.6. 视图解析</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-viewresolver">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>视图解析使你可以使用HTML模板和模型渲染到浏览器，而无需将你与特定的视图技术联系在一起。
在Spring WebFlux中，通过专用的 <code>HandlerResultHandler</code> 支持视图解析，
该 <code>HandlerResultHandler</code> 使用 <code>ViewResolver</code> 实例将 <code>String</code>（表示逻辑视图名称）映射到 <code>View</code> 实例。然后使用 <code>View</code> 渲染响应。</p>
</div>
<div class="sect3">
<h4 id="webflux-viewresolution-handling">3.6.1. 处理过程</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-handling">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>传递给 <code>ViewResolutionResultHandler</code> 的 <code>HandlerResult</code> 包含处理程序的返回值和包含请求处理期间添加的属性的模型。
返回值将作为以下值之一进行处理：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String</code>, <code>CharSequence</code>：通过配置的 <code>ViewResolver</code> 实现列表解析为 <code>View</code> 的逻辑视图名称。</p>
</li>
<li>
<p><code>void</code>：根据请求路径选择默认视图名称，减去前导斜杠和尾部斜杠，然后将其解析为视图。
当未提供视图名称（例如：返回模型属性）或异步返回值（例如：Mono完成为空）时，也会发生同样的情况。</p>
</li>
<li>
<p>{api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering]:
用于视图解析方案的API。通过IDE中的代码完成探索其选项。</p>
</li>
<li>
<p><code>Model</code>, <code>Map</code>：额外的模型属性将添加到请求的模型中。</p>
</li>
<li>
<p>任何其他：任何其他返回值（由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]
确定的简单类型除外）都将被视为要添加到模型的模型属性。属性名称是通过使用 {api-spring-framework}/core/Conventions.html[约定]
从类名称派生的，除非在处理程序方法上存在 <code>@ModelAttribute</code> 注解。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该模型可以包含异步，响应式类型（例如：来自Reactor或RxJava）。在渲染之前，<code>AbstractView</code> 将此类模型属性解析为具体值并更新模型。
单值响应式类型被解析为单个值或无值（如果为空），而多值响应式类型（例如：<code>Flux&lt;T&gt;</code>）被收集并解析为 <code>List&lt;T&gt;</code>。</p>
</div>
<div class="paragraph">
<p>配置视图解析就像在Spring配置中添加 <code>ViewResolutionResultHandler</code> bean一样简单。
<a href="#webflux-config-view-resolvers">WebFlux Config</a>提供了专用于视图解析的配置API。</p>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">[webflux-view]</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-redirecting-redirect-prefix">3.6.2. 重定向</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-redirecting-redirect-prefix">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>视图名称中的特殊 <code>redirect:</code> 前缀使你可以执行重定向。<code>UrlBasedViewResolver</code>（和子类）将其识别为需要重定向的指令。
视图名称的其余部分是重定向URL。</p>
</div>
<div class="paragraph">
<p>最终效果与控制器已返回 <code>RedirectView</code> 或 <code>Rendering.redirectTo("abc").build()</code> 相同，
但是现在控制器本身可以根据逻辑视图名称进行操作。视图名称（例如：<code>redirect:/some/resource</code>）是相对于当前应用程序的，
而视图名称（例如：<code>redirect:http://example.com/arbitrary/path</code>）将重定向到绝对URL。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-multiple-representations">3.6.3. 内容协商</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multiple-representations">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ViewResolutionResultHandler</code> 支持内容协商。它将请求媒体类型与每个所选视图支持的媒体类型进行比较。
使用支持请求的媒体类型的第一个视图。</p>
</div>
<div class="paragraph">
<p>为了支持JSON和XML之类的媒体类型，Spring WebFlux提供了 <code>HttpMessageWriterView</code>，这是一个通过<a href="#webflux-codecs">HttpMessageWriter</a>渲染的特殊 <code>View</code>。
通常，你可以通过<a href="#webflux-config-view-resolvers">WebFlux配置</a>将其配置为默认视图。
如果默认视图与请求的媒体类型匹配，则始终会选择和使用它们。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-controller">4. 带注解的控制器</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-controller">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux提供了一个基于注解的编程模型，其中 <code>@Controller</code> 和 <code>@RestController</code>
组件使用注解来表达请求映射，请求输入，处理异常等。带注解的控制器具有灵活的方法签名，无需扩展基类或实现特定的接口。</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个基本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class HelloController {

	@GetMapping("/hello")
	public String handle() {
		return "Hello WebFlux";
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，该方法返回要写入响应体的 <code>String</code>。</p>
</div>
<div class="sect2">
<h3 id="webflux-ann-controller">4.1. <code>@Controller</code></h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-controller">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用标准的Spring bean定义来定义控制器bean。<code>@Controller</code> 构造型允许自动检测，并且与Spring常规支持保持一致，
以支持在类路径中检测 <code>@Component</code> 类并为其自动注册Bean定义。它还充当带注解类的构造型，表明其作为Web组件的作用。</p>
</div>
<div class="paragraph">
<p>要启用对此类 <code>@Controller</code> bean的自动检测，可以将组件扫描添加到Java配置中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@ComponentScan("org.example.web") <i class="conum" data-value="1"></i><b>(1)</b>
public class WebConfig {

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>扫描 <code>org.example.web</code> 软件包。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@RestController</code> 是一个<a href="spring-core.html#beans-meta-annotations">组合式注解</a>，其本身使用 <code>@Controller</code> 和
<code>@ResponseBody</code> 进行了元注解，表示一个控制器，其每个方法都继承了类型级别的 <code>@ResponseBody</code> 注解，
因此直接将其写入响应体，而不是使用HTML模板进行视图解析和渲染。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-requestmapping">4.2. 请求映射</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> 注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL，HTTP方法，请求参数，标头和媒体类型进行匹配。
你可以在类级别使用它来表示共享的映射，也可以在方法级别使用它来缩小到特定的端点映射。</p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> 还有特定于HTTP方法的快捷方式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@GetMapping</code></p>
</li>
<li>
<p><code>@PostMapping</code></p>
</li>
<li>
<p><code>@PutMapping</code></p>
</li>
<li>
<p><code>@DeleteMapping</code></p>
</li>
<li>
<p><code>@PatchMapping</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>前面的注解是提供的<a href="#webflux-ann-requestmapping-composed">自定义注解</a>，因为可以说，大多数控制器方法应该映射到特定的HTTP方法，
而不是使用 <code>@RequestMapping</code>，后者默认情况下与所有HTTP方法匹配。同时，在类级别仍需要 <code>@RequestMapping</code> 来表示共享映射。</p>
</div>
<div class="paragraph">
<p>以下示例使用类型和方法级别的映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/persons")
class PersonController {

	@GetMapping("/{id}")
	public Person getPerson(@PathVariable Long id) {
		// ...
	}

	@PostMapping
	@ResponseStatus(HttpStatus.CREATED)
	public void add(@RequestBody Person person) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-uri-templates">4.2.1. URI模式</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-uri-templates">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用全局模式和通配符来映射请求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code> 匹配一个字符</p>
</li>
<li>
<p><code>*</code> 匹配路径段中的零个或多个字符</p>
</li>
<li>
<p><code>**</code> 匹配零个或多个路径段</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你还可以声明URI变量并使用 <code>@PathVariable</code> 访问其值，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在类和方法级别声明URI变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/owners/{ownerId}") <i class="conum" data-value="1"></i><b>(1)</b>
public class OwnerController {

	@GetMapping("/pets/{petId}") <i class="conum" data-value="2"></i><b>(2)</b>
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>类级URI映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>方法级URI映射。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>URI变量会自动转换为适当的类型，或者引发 <code>TypeMismatchException</code>。默认情况下支持简单类型（<code>int</code>，<code>long</code>，<code>Date</code>
等），你可以注册对任何其他数据类型的支持。请参阅<a href="#webflux-ann-typeconversion">Type Conversion</a>和<a href="#webflux-ann-initbinder"><code>DataBinder</code></a>。</p>
</div>
<div class="paragraph">
<p>你可以显式地命名URI变量（例如，<code>@PathVariable("customId")</code>），但是如果名称相同并且你的代码是使用调试信息或
Java 8上的 <code>-parameters</code> 编译器标志进行编译的，则可以省略该详细信息。</p>
</div>
<div class="paragraph">
<p>语法 <code>{*varName}</code> 声明了一个与零个或多个剩余路径段匹配的URI变量。例如：<code>/resources/{*path}</code> 匹配所有文件
<code>/resources/</code> ，并且“<code>path</code>”变量捕获完整的相对路径。</p>
</div>
<div class="paragraph">
<p>语法 <code>{varName:regex}</code> 声明带有正则表达式的URI变量，语法为 <code>{varName:regex}</code>。例如，给定URL
<code>"/spring-web-3.0.5.jar"</code>，以下方法提取名称，版本和文件扩展名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>URI路径模式也可以嵌入 <code>${&#8230;&#8203;}</code> 占位符，这些占位符在启动时通过针对本地，系统，环境和其他属性源使用
<code>PropertyPlaceHolderConfigurer</code> 进行解析。例如，你可以使用它来基于一些外部配置参数化基本URL。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring WebFlux使用 <code>PathPattern</code> 和 <code>PathPatternParser</code> 获得URI路径匹配支持。
这两个类都位于 <code>spring-web</code> 中，它们是专门为web应用程序中的HTTP URL路径设计的，
用于在运行时匹配大量的URI路径模式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux不支持后缀模式匹配&#8212;&#8203;这与Spring MVC不同，后者的映射（例如 <code>/person</code>）也匹配到 <code>/person.*</code>。
对于基于URL的内容协商，如果需要，我们建议使用查询参数，它更简单，更明确，并且不易受到基于URL路径的攻击。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-pattern-comparison">4.2.2. 模式比较</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-pattern-comparison">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>当多个模式与URL匹配时，必须将它们进行比较以找到最佳匹配。这是通过 <code>PathPattern.SPECIFICITY_COMPARATOR</code> 完成的，该工具查找更具体的模式。</p>
</div>
<div class="paragraph">
<p>对于每个模式，都会根据URI变量和通配符的数量计算得分，其中URI变量的得分低于通配符。总得分较低的模式将获胜。如果两个模式的分数相同，则选择较长的模式。</p>
</div>
<div class="paragraph">
<p>包罗万象的模式（例如： <code>**</code>, <code>{*varName}</code>）不计入评分，而是始终排在最后。如果两种模式都适用，则选择较长的模式。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-consumes">4.2.3. 可消费的媒体类型</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-consumes">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据请求的 <code>Content-Type</code> 缩小请求映射，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping(path = "/pets", <strong>consumes = "application/json"</strong>)
public void addPet(@RequestBody Pet pet) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>consumes</code> 属性还支持否定表达式&#8201;&#8212;&#8201;例如，<code>!text/plain</code> 表示除 <code>text/plain</code> 之外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以在类级别上声明一个共享的 <code>consumes</code> 属性。但是，与大多数其他请求映射属性不同，同时使用类级别和方法级别时，
方法级别 <code>consumes</code> 属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> 为常用的媒体类型提供常量，例如 <code>APPLICATION_JSON_VALUE</code> 和 <code>APPLICATION_XML_VALUE</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-produces">4.2.4. 可生产的媒体类型</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-produces">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据 <code>Accept</code> 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", <strong>produces = "application/json;charset=UTF-8"</strong>)
@ResponseBody
public Pet getPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>媒体类型可以指定字符集。支持否定的表达式&#8201;&#8212;&#8201;例如，<code>!text/plain</code> 表示除 <code>text/plain</code> 之外的任何内容类型。</p>
</div>
<div class="paragraph">
<p>你可以在类级别声明共享的 <code>produces</code> 属性。但是，与大多数其他请求映射属性不同，同时使用类级别和方法级别时，
方法级别 <code>produces</code> 属性覆盖而不是扩展类级别声明。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>MediaType</code> 为常用的媒体类型提供常量，例如 <code>APPLICATION_JSON_VALUE</code> 和 <code>APPLICATION_XML_VALUE</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-params-and-headers">4.2.5. 请求参数，请求头</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-params-and-headers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以根据查询参数条件来缩小请求映射。你可以测试是否存在查询参数（<code>myParam</code>），或不存在查询参数（<code>!myParam</code>）
或查询参数有特定值（<code>myParam=myValue</code>）。以下示例显示如何测试特定值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>测试 <code>myParam</code> 是否等于 <code>myValue</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以将其与请求头条件一起使用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping(path = "/pets", headers = "myHeader=myValue") <i class="conum" data-value="1"></i><b>(1)</b>
public void findPet(@PathVariable String petId) {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>测试 <code>myHeader</code> 是否等于 <code>myValue</code>。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-head-options">4.2.6. HTTP HEAD, OPTIONS</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-head-options">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code> (和 <code>@RequestMapping(method=HttpMethod.GET)</code>) 透明地支持HTTP HEAD以进行请求映射。
控制器方法无需更改。<code>HttpHandler</code> 服务器适配器中应用的响应包装器确保将 <code>Content-Length</code> 标头设置为写入的字节数，而无需实际写入响应。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过将 <code>Allow</code> 响应头设置为所有具有匹配URL模式的 <code>@RequestMapping</code> 方法中列出的HTTP方法列表
来处理HTTP OPTIONS。</p>
</div>
<div class="paragraph">
<p>对于没有HTTP方法声明的 <code>@RequestMapping</code>，将 <code>Allow</code> 响应头设置为 <code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。
建议控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：<code>@GetMapping</code>，<code>@PostMapping</code> 等）。</p>
</div>
<div class="paragraph">
<p>你可以将 <code>@RequestMapping</code> 方法显式映射到HTTP HEAD和HTTP OPTIONS，但这通常不是必需的。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-composed">4.2.7. 自定义注解</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-composed">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux支持将<a href="spring-core.html#beans-meta-annotations">组合注解</a>用于请求映射。
这些注解本身使用 <code>@RequestMapping</code> 进行元注解，并且旨在以更狭窄，
更具体的用途重新声明 <code>@RequestMapping</code> 属性的子集（或全部）。</p>
</div>
<div class="paragraph">
<p><code>@GetMapping</code>, <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code> 和 <code>@PatchMapping</code> 是组合注解的示例。
之所以提供它们，是因为可以说，大多数控制器方法都应该映射到特定的HTTP方法，
而不是使用 <code>@RequestMapping</code>，后者默认情况下与所有HTTP方法都匹配。如果需要组合注解的示例，请查看如何声明它们。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还支持带有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，
它需要子类化 <code>RequestMappingHandlerMapping</code> 并覆盖 <code>getCustomMethodCondition</code>
方法，你可以在其中检查自定义属性并返回自己的 <code>RequestCondition</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestmapping-registration">4.2.8. 显式注册</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestmapping-registration">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以通过编程方式注册Handler方法，你可以将其用于动态注册或高级案例，
例如同一处理程序在不同URL下的不同实例。以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class MyConfig {

	@Autowired
	public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) <i class="conum" data-value="1"></i><b>(1)</b>
			throws NoSuchMethodException {

		RequestMappingInfo info = RequestMappingInfo
				.paths("/user/{id}").methods(RequestMethod.GET).build(); <i class="conum" data-value="2"></i><b>(2)</b>

		Method method = UserHandler.class.getMethod("getUser", Long.class); <i class="conum" data-value="3"></i><b>(3)</b>

		mapping.registerMapping(info, handler, method); <i class="conum" data-value="4"></i><b>(4)</b>
	}

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注入目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>添加注册。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-methods">4.3. 处理程序方法</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-methods">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@RequestMapping</code> handler methods have a flexible signature and can choose from a range of
supported controller method arguments and return values.</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-arguments">4.3.1. Method Arguments</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-arguments">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method arguments.</p>
</div>
<div class="paragraph">
<p>Reactive types (Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a>) are
supported on arguments that require blocking I/O (for example, reading the request body) to
be resolved. This is marked in the Description column. Reactive types are not expected
on arguments that do not require blocking.</p>
</div>
<div class="paragraph">
<p>JDK 1.8&#8217;s <code>java.util.Optional</code> is supported as a method argument in combination with
annotations that have a <code>required</code> attribute (for example, <code>@RequestParam</code>, <code>@RequestHeader</code>,
and others) and is equivalent to <code>required=false</code>.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method argument</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerWebExchange</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the full <code>ServerWebExchange</code>&#8201;&#8212;&#8201;container for the HTTP request and response,
  request and session attributes, <code>checkNotModified</code> methods, and others.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpRequest</code>, <code>ServerHttpResponse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the HTTP request or response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSession</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access to the session. This does not force the start of a new session unless attributes
  are added. Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.security.Principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The currently authenticated user&#8201;&#8212;&#8201;possibly a specific <code>Principal</code> implementation class if known.
  Supports reactive types.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.http.HttpMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The HTTP method of the request.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Locale</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The current request locale, determined by the most specific <code>LocaleResolver</code> available&#8201;&#8212;&#8201;in
  effect, the configured <code>LocaleResolver</code>/<code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@PathVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to URI template variables. See <a href="#webflux-ann-requestmapping-uri-templates">URI模式</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@MatrixVariable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to name-value pairs in URI path segments. See <a href="#webflux-ann-matrix-variables">Matrix Variables</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestParam</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to Servlet request parameters. Parameter values are converted to the declared
  method argument type. See <a href="#webflux-ann-requestparam"><code>@RequestParam</code></a>.
</p><p class="tableblock">  Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestHeader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers. Header values are converted to the declared method argument
  type. See <a href="#webflux-ann-requestheader"><code>@RequestHeader</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@CookieValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to cookies. Cookie values are converted to the declared method argument type.
  See <a href="#webflux-ann-cookievalue"><code>@CookieValue</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the HTTP request body. Body content is converted to the declared method
  argument type by using <code>HttpMessageReader</code> instances. Supports reactive types.
  See <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request headers and body. The body is converted with <code>HttpMessageReader</code> instances.
  Supports reactive types. See <a href="#webflux-ann-httpentity"><code>HttpEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestPart</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to a part in  a <code>multipart/form-data</code> request. Supports reactive types.
  See <a href="#webflux-multipart-forms">Multipart Content</a> and <a href="#webflux-multipart">Multipart数据</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, and <code>org.springframework.ui.ModelMap</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to the model that is used in HTML controllers and is exposed to templates as
  part of view rendering.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to an existing attribute in the model (instantiated if not present) with
  data binding and validation applied. See <a href="#webflux-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> as well
  as <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a> and <a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.
</p><p class="tableblock">  Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
  See &#8220;Any other argument&#8221; later in this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Errors</code>, <code>BindingResult</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to errors from validation and data binding for a command object
  (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or
  <code>@RequestPart</code> argument. An <code>Errors</code>, or <code>BindingResult</code> argument must be declared
  immediately after the validated method argument.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For marking form processing complete, which triggers cleanup of session attributes
  declared through a class-level <code>@SessionAttributes</code> annotation.
  See <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UriComponentsBuilder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For preparing a URL relative to the current request&#8217;s host, port, scheme, and path.
  See <a href="#webflux-uri-building">URI链接</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@SessionAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to any session attribute&#8201;&#8212;&#8201;in contrast to model attributes stored in the session
  as a result of a class-level <code>@SessionAttributes</code> declaration. See
  <a href="#webflux-ann-sessionattribute"><code>@SessionAttribute</code></a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@RequestAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For access to request attributes. See <a href="#webflux-ann-requestattrib">[webflux-ann-requestattrib]</a> for more details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a method argument is not matched to any of the above, it is, by default, resolved as
  a <code>@RequestParam</code> if it is a simple type, as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
  or as a <code>@ModelAttribute</code>, otherwise.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-ann-return-types">4.3.2. Return Values</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-return-types">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>The following table shows the supported controller method return values. Note that reactive types
from libraries such as Reactor, RxJava, <a href="#webflux-reactive-libraries">or other</a> are
generally supported for all return values.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Controller method return value</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ResponseBody</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value is encoded through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpEntity&lt;B&gt;</code>, <code>ResponseEntity&lt;B&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The return value specifies the full response, including HTTP headers, and the body is encoded
  through <code>HttpMessageWriter</code> instances and written to the response.
  See <a href="#webflux-ann-responseentity"><code>ResponseEntity</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For returning a response with headers and no body.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A view name to be resolved with <code>ViewResolver</code> instances and used together with the implicit
  model&#8201;&#8212;&#8201;determined through command objects and <code>@ModelAttribute</code> methods. The handler
  method can also programmatically enrich the model by declaring a <code>Model</code> argument
  (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>View</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>View</code> instance to use for rendering together with the implicit model&#8201;&#8212;&#8201;determined
  through command objects and <code>@ModelAttribute</code> methods. The handler method can also
  programmatically enrich the model by declaring a <code>Model</code> argument (described <a href="#webflux-viewresolution-handling">earlier</a>).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attributes to be added to the implicit model, with the view name implicitly determined
  based on the request path.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ModelAttribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An attribute to be added to the model, with the view name implicitly determined based
  on the request path.
</p><p class="tableblock">  Note that <code>@ModelAttribute</code> is optional. See &#8220;Any other return value&#8221; later in
  this table.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Rendering</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An API for model and view rendering scenarios.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A method with a <code>void</code>, possibly asynchronous (for example, <code>Mono&lt;Void&gt;</code>), return type (or a <code>null</code> return
  value) is considered to have fully handled the response if it also has a <code>ServerHttpResponse</code>,
  a <code>ServerWebExchange</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true
  if the controller has made a positive ETag or <code>lastModified</code> timestamp check.
  // TODO: See <a href="#webflux-caching-etag-lastmodified">控制器</a> for details.
</p><p class="tableblock">  If none of the above is true, a <code>void</code> return type can also indicate &#8220;no response body&#8221; for
  REST controllers or default view name selection for HTML controllers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;ServerSentEvent&gt;</code>, <code>Observable&lt;ServerSentEvent&gt;</code>, or other reactive type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Emit server-sent events. The <code>ServerSentEvent</code> wrapper can be omitted when only data needs
  to be written (however, <code>text/event-stream</code> must be requested or declared in the mapping
  through the <code>produces</code> attribute).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any other return value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If a return value is not matched to any of the above, it is, by default, treated as a view
  name, if it is <code>String</code> or <code>void</code> (default view name selection applies), or as a model
  attribute to be added to the model, unless it is a simple type, as determined by
  {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
  in which case it remains unresolved.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="webflux-ann-typeconversion">4.3.3. Type Conversion</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-typeconversion">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Some annotated controller method arguments that represent String-based request input (for example,
<code>@RequestParam</code>, <code>@RequestHeader</code>, <code>@PathVariable</code>, <code>@MatrixVariable</code>, and <code>@CookieValue</code>)
can require type conversion if the argument is declared as something other than <code>String</code>.</p>
</div>
<div class="paragraph">
<p>For such cases, type conversion is automatically applied based on the configured converters.
By default, simple types (such as <code>int</code>, <code>long</code>, <code>Date</code>, and others) are supported. Type conversion
can be customized through a <code>WebDataBinder</code> (see <a href="#mvc-ann-initbinder">[mvc-ann-initbinder]</a>) or by registering
<code>Formatters</code> with the <code>FormattingConversionService</code> (see
<a href="core.html#format">Spring Field Formatting</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-matrix-variables">4.3.4. Matrix Variables</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-matrix-variables">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://tools.ietf.org/html/rfc3986#section-3.3">RFC 3986</a> discusses name-value pairs in
path segments. In Spring WebFlux, we refer to those as &#8220;matrix variables&#8221; based on an
<a href="http://www.w3.org/DesignIssues/MatrixURIs.html">&#8220;old post&#8221;</a> by Tim Berners-Lee, but they
can be also be referred to as URI path parameters.</p>
</div>
<div class="paragraph">
<p>Matrix variables can appear in any path segment, with each variable separated by a semicolon and
multiple values separated by commas&#8201;&#8212;&#8201;for example, <code>"/cars;color=red,green;year=2012"</code>. Multiple
values can also be specified through repeated variable names&#8201;&#8212;&#8201;for example,
<code>"color=red;color=green;color=blue"</code>.</p>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does
not affect request mappings. In other words, you are not required to use a URI variable
to mask variable content. That said, if you want to access matrix variables from a
controller method, you need to add a URI variable to the path segment where matrix
variables are expected. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

	// petId == 42
	// q == 11
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that all path segments can contain matrix variables, you may sometimes need to
disambiguate which path variable the matrix variable is expected to be in,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
		@MatrixVariable(name="q", pathVar="ownerId") int q1,
		@MatrixVariable(name="q", pathVar="petId") int q2) {

	// q1 == 11
	// q2 == 22
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define a matrix variable may be defined as optional and specify a default value
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

	// q == 1
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get all matrix variables, use a <code>MultiValueMap</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
		@MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,
		@MatrixVariable(pathVar="petId"") MultiValueMap&lt;String, String&gt; petMatrixVars) {

	// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
	// petMatrixVars: ["q" : 22, "s" : 23]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestparam">4.3.5. <code>@RequestParam</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestparam">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestParam</code> annotation to bind query parameters to a method argument in a
controller. The following code snippet shows the usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/pets")
public class EditPetForm {

	// ...

	@GetMapping
	public String setupForm(@RequestParam("petId") int petId, Model model) { <i class="conum" data-value="1"></i><b>(1)</b>
		Pet pet = this.clinic.loadPet(petId);
		model.addAttribute("pet", pet);
		return "petForm";
	}

	// ...

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestParam</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The Servlet API &#8220;request parameter&#8221; concept conflates query parameters, form
data, and multiparts into one. However, in WebFlux, each is accessed individually through
<code>ServerWebExchange</code>. While <code>@RequestParam</code> binds to query parameters only, you can use
data binding to apply query parameters, form data, and multiparts to a
<a href="#webflux-ann-modelattrib-method-args">command object</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Method parameters that use the <code>@RequestParam</code> annotation are required by default, but
you can specify that a method parameter is optional by setting the required flag of a <code>@RequestParam</code>
to <code>false</code> or by declaring the argument with a <code>java.util.Optional</code>
wrapper.</p>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestParam</code> annotation is declared on a <code>Map&lt;String, String&gt;</code> or
<code>MultiValueMap&lt;String, String&gt;</code> argument, the map is populated with all query parameters.</p>
</div>
<div class="paragraph">
<p>Note that use of <code>@RequestParam</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes. By
default, any argument that is a simple value type (as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@RequestParam</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestheader">4.3.6. <code>@RequestHeader</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestheader">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestHeader</code> annotation to bind a request header to a method argument in a
controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with headers:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300</pre>
</div>
</div>
<div class="paragraph">
<p>The following example gets the value of the <code>Accept-Encoding</code> and <code>Keep-Alive</code> headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(
		@RequestHeader("Accept-Encoding") String encoding, <i class="conum" data-value="1"></i><b>(1)</b>
		@RequestHeader("Keep-Alive") long keepAlive) { <i class="conum" data-value="2"></i><b>(2)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the value of the <code>Accept-Encoging</code> header.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Get the value of the <code>Keep-Alive</code> header.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
<div class="paragraph">
<p>When a <code>@RequestHeader</code> annotation is used on a <code>Map&lt;String, String&gt;</code>,
<code>MultiValueMap&lt;String, String&gt;</code>, or <code>HttpHeaders</code> argument, the map is populated
with all header values.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Built-in support is available for converting a comma-separated string into an
array or collection of strings or other types known to the type conversion system. For
example, a method parameter annotated with <code>@RequestHeader("Accept")</code> may be of type
<code>String</code> but also of <code>String[]</code> or <code>List&lt;String&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-cookievalue">4.3.7. <code>@CookieValue</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-cookievalue">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@CookieValue</code> annotation to bind the value of an HTTP cookie to a method argument
in a controller.</p>
</div>
<div class="paragraph">
<p>The following example shows a request with a cookie:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</pre>
</div>
</div>
<div class="paragraph">
<p>The following code sample demonstrates how to get the cookie value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { <i class="conum" data-value="1"></i><b>(1)</b>
	//...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Get the cookie value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type conversion is applied automatically if the target method parameter type is not
<code>String</code>. See <a href="#mvc-ann-typeconversion">[mvc-ann-typeconversion]</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-modelattrib-method-args">4.3.8. <code>@ModelAttribute</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-modelattrib-method-args">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ModelAttribute</code> annotation on a method argument to access an attribute from the
model or have it instantiated if not present. The model attribute is also overlain with
the values of query parameters and form fields whose names match to field names. This is
referred to as data binding, and it saves you from having to deal with parsing and
converting individual query parameters and form fields. The following example binds an instance of <code>Pet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bind an instance of <code>Pet</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Pet</code> instance in the preceding example is resolved as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From the model if already added through <a href="#webflux-ann-modelattrib-methods"><code>Model</code></a>.</p>
</li>
<li>
<p>From the HTTP session through <a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</li>
<li>
<p>From the invocation of a default constructor.</p>
</li>
<li>
<p>From the invocation of a &#8220;primary constructor&#8221; with arguments that match query
parameters or form fields. Argument names are determined through JavaBeans
<code>@ConstructorProperties</code> or through runtime-retained parameter names in the bytecode.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>After the model attribute instance is obtained, data binding is applied. The
<code>WebExchangeDataBinder</code> class matches names of query parameters and form fields to field
names on the target <code>Object</code>. Matching fields are populated after type conversion is applied
where necessary. For more on data binding (and validation), see
<a href="core.html#validation">Validation</a>. For more on customizing data binding, see
<a href="#webflux-ann-initbinder"><code>DataBinder</code></a>.</p>
</div>
<div class="paragraph">
<p>Data binding can result in errors. By default, a <code>WebExchangeBindException</code> is raised, but,
to check for such errors in the controller method, you can add a <code>BindingResult</code> argument
immediately next to the <code>@ModelAttribute</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm";
	}
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Adding a <code>BindingResult</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can automatically apply validation after data binding by adding the
<code>javax.validation.Valid</code> annotation or Spring&#8217;s <code>@Validated</code> annotation (see also
<a href="core.html#validation-beanvalidation">Bean validation</a> and
<a href="core.html#validation">Spring validation</a>). The following example uses the <code>@Valid</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(<strong>@Valid @ModelAttribute("pet") Pet pet</strong>, BindingResult result) { <i class="conum" data-value="1"></i><b>(1)</b>
	if (result.hasErrors()) {
		return "petForm";
	}
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@Valid</code> on a model attribute argument.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring WebFlux, unlike Spring MVC, supports reactive types in the model&#8201;&#8212;&#8201;for example,
<code>Mono&lt;Account&gt;</code> or <code>io.reactivex.Single&lt;Account&gt;</code>. You can declare a <code>@ModelAttribute</code> argument
with or without a reactive type wrapper, and it will be resolved accordingly,
to the actual value if necessary. However, note that, to use a <code>BindingResult</code>
argument, you must declare the <code>@ModelAttribute</code> argument before it without a reactive
type wrapper, as shown earlier. Alternatively, you can handle any errors through the
reactive type, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public Mono&lt;String&gt; processSubmit(@Valid @ModelAttribute("pet") Mono&lt;Pet&gt; petMono) {
	return petMono
		.flatMap(pet -&gt; {
			// ...
		})
		.onErrorResume(ex -&gt; {
			// ...
		});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that use of <code>@ModelAttribute</code> is optional&#8201;&#8212;&#8201;for example, to set its attributes.
By default, any argument that is not a simple value type( as determined by
{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty])
and is not resolved by any other argument resolver is treated as if it were annotated
with <code>@ModelAttribute</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-sessionattributes">4.3.9. <code>@SessionAttributes</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-sessionattributes">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@SessionAttributes</code> is used to store model attributes in the <code>WebSession</code> between
requests. It is a type-level annotation that declares session attributes used by a
specific controller. This typically lists the names of model attributes or types of
model attributes that should be transparently stored in the session for subsequent
requests to access.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the first request, when a model attribute with the name, <code>pet</code>, is added to the model,
it is automatically promoted to and saved in the <code>WebSession</code>. It remains there until
another controller method uses a <code>SessionStatus</code> method argument to clear the storage,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
@SessionAttributes("pet") <i class="conum" data-value="1"></i><b>(1)</b>
public class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	public String handle(Pet pet, BindingResult errors, SessionStatus status) { <i class="conum" data-value="2"></i><b>(2)</b>
		if (errors.hasErrors) {
			// ...
		}
			status.setComplete();
			// ...
		}
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>@SessionAttributes</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>SessionStatus</code> variable.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-sessionattribute">4.3.10. <code>@SessionAttribute</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-sessionattribute">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>If you need access to pre-existing session attributes that are managed globally
(that is, outside the controller&#8201;&#8212;&#8201;for example, by a filter) and may or may not be present,
you can use the <code>@SessionAttribute</code> annotation on a method parameter, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@SessionAttribute User user) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@SessionAttribute</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For use cases that require adding or removing session attributes, consider injecting
<code>WebSession</code> into the controller method.</p>
</div>
<div class="paragraph">
<p>For temporary storage of model attributes in the session as part of a controller
workflow, consider using <code>SessionAttributes</code>, as described in
<a href="#webflux-ann-sessionattributes"><code>@SessionAttributes</code></a>.</p>
</div>
<div id="webflux-ann-requestattrib" class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestattrib">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Similarly to <code>@SessionAttribute</code>, you can use the <code>@RequestAttribute</code> annotation to
access pre-existing request attributes created earlier (for example, by a <code>WebFilter</code>),
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String handle(@RequestAttribute Client client) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestAttribute</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-multipart-forms">4.3.11. Multipart Content</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-multipart-forms">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>As explained in <a href="#webflux-multipart">Multipart数据</a>, <code>ServerWebExchange</code> provides access to multipart
content. The best way to handle a file upload form (for example, from a browser) in a controller
is through data binding to a <a href="#webflux-ann-modelattrib-method-args">command object</a>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class MyForm {

	private String name;

	private MultipartFile file;

	// ...

}

@Controller
public class FileUploadController {

	@PostMapping("/form")
	public String handleFormUpload(MyForm form, BindingResult errors) {
		// ...
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also submit multipart requests from non-browser clients in a RESTful service
scenario. The following example uses a file along with JSON:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...</pre>
</div>
</div>
<div class="paragraph">
<p>You can access individual parts with <code>@RequestPart</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") Part metadata, <i class="conum" data-value="1"></i><b>(1)</b>
		@RequestPart("file-data") FilePart file) { <i class="conum" data-value="2"></i><b>(2)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using <code>@RequestPart</code> to get the file.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To deserialize the raw part content (for example, to JSON&#8201;&#8212;&#8201;similar to <code>@RequestBody</code>),
you can declare a concrete target <code>Object</code>, instead of <code>Part</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestPart</code> to get the metadata.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use <code>@RequestPart</code> combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or <code>BindingResult</code> argument, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata, <i class="conum" data-value="1"></i><b>(1)</b>
		BindingResult result) { <i class="conum" data-value="2"></i><b>(2)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>@Valid</code> annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Using a <code>BindingResult</code> argument.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To access all multipart data as a <code>MultiValueMap</code>, you can use <code>@RequestBody</code>,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To access multipart data sequentially, in streaming fashion, you can use <code>@RequestBody</code> with
<code>Flux&lt;Part&gt;</code> instead, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/")
public String handle(@RequestBody Flux&lt;Part&gt; parts) { <i class="conum" data-value="1"></i><b>(1)</b>
	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>@RequestBody</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-requestbody">4.3.12. <code>@RequestBody</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-requestbody">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@RequestBody</code> annotation to have the request body read and deserialized into an
<code>Object</code> through an <a href="#webflux-codecs">HttpMessageReader</a>.
The following example uses a <code>@RequestBody</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike Spring MVC, in WebFlux, the <code>@RequestBody</code> method argument supports reactive types
and fully non-blocking reading and (client-to-server) streaming. The following example
uses a <code>Mono</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@RequestBody Mono&lt;Account&gt; account) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP消息编解码器</a> option of the <a href="#webflux-config">WebFlux配置</a> to
configure or customize message readers.</p>
</div>
<div class="paragraph">
<p>You can use <code>@RequestBody</code> in combination with <code>javax.validation.Valid</code> or Spring&#8217;s
<code>@Validated</code> annotation, which causes Standard Bean Validation to be applied.
By default, validation errors cause a <code>WebExchangeBindException</code>, which is turned
into a 400 (<code>BAD_REQUEST</code>) response. Alternatively, you can handle validation errors locally
within the controller through an <code>Errors</code> or a <code>BindingResult</code> argument. The following
example uses a <code>BindingResult</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-httpentity">4.3.13. <code>HttpEntity</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-httpentity">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>HttpEntity</code> is more or less identical to using <a href="#webflux-ann-requestbody"><code>@RequestBody</code></a> but is based on a
container object that exposes request headers and the body. The following example uses an
<code>HttpEntity</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@PostMapping("/accounts")
public void handle(HttpEntity&lt;Account&gt; entity) {
	// ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-responsebody">4.3.14. <code>@ResponseBody</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-responsebody">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>You can use the <code>@ResponseBody</code> annotation on a method to have the return serialized to the
response body through an <a href="#webflux-codecs">HttpMessageWriter</a>. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> is also supported at the class level, in which case it is inherited by
all controller methods. This is the effect of <code>@RestController</code>, which is nothing more
than a meta-annotation marked with <code>@Controller</code> and <code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p><code>@ResponseBody</code> supports reactive types, which means you can return Reactor or RxJava
types and have the asynchronous values they produce rendered to the response.
For additional details, see <a href="#webflux-codecs-streaming">Streaming</a> and
<a href="#webflux-codecs-jackson">JSON rendering</a>.</p>
</div>
<div class="paragraph">
<p>You can combine <code>@ResponseBody</code> methods with JSON serialization views.
See <a href="#webflux-ann-jackson">Jackson JSON</a> for details.</p>
</div>
<div class="paragraph">
<p>You can use the <a href="#webflux-config-message-codecs">HTTP消息编解码器</a> option of the <a href="#webflux-config">WebFlux配置</a> to
configure or customize message writing.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-responseentity">4.3.15. <code>ResponseEntity</code></h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-responseentity">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>ResponseEntity</code> is like <a href="#webflux-ann-responsebody"><code>@ResponseBody</code></a> but with status and headers. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/something")
public ResponseEntity&lt;String&gt; handle() {
	String body = ... ;
	String etag = ... ;
	return ResponseEntity.ok().eTag(etag).build(body);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux supports using a single value <a href="#webflux-reactive-libraries">reactive type</a> to
produce the <code>ResponseEntity</code> asynchronously, and/or single and multi-value reactive types
for the body.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-ann-jackson">4.3.16. Jackson JSON</h4>
<div class="paragraph">
<p>Spring offers support for the Jackson JSON library.</p>
</div>
<div class="sect4">
<h5 id="webflux-ann-jsonview">Jackson Serialization Views</h5>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-jackson">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Spring WebFlux provides built-in support for
<a href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson&#8217;s Serialization Views</a>,
which allows rendering only a subset of all fields in an <code>Object</code>. To use it with
<code>@ResponseBody</code> or <code>ResponseEntity</code> controller methods, you can use Jackson&#8217;s
<code>@JsonView</code> annotation to activate a serialization view class, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
public class UserController {

	@GetMapping("/user")
	@JsonView(User.WithoutPasswordView.class)
	public User getUser() {
		return new User("eric", "7!jd#h23");
	}
}

public class User {

	public interface WithoutPasswordView {};
	public interface WithPasswordView extends WithoutPasswordView {};

	private String username;
	private String password;

	public User() {
	}

	public User(String username, String password) {
		this.username = username;
		this.password = password;
	}

	@JsonView(WithoutPasswordView.class)
	public String getUsername() {
		return this.username;
	}

	@JsonView(WithPasswordView.class)
	public String getPassword() {
		return this.password;
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@JsonView</code> allows an array of view classes but you can only specify only one per
controller method. Use a composite interface if you need to activate multiple views.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-modelattrib-methods">4.4. <code>Model</code></h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-modelattrib-methods">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@ModelAttribute</code> 注解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>@RequestMapping</code> 方法中的<a href="#webflux-ann-modelattrib-method-args">方法参数</a>上，
可从模型创建或访问 <code>Object</code>，并将其通过 <code>WebDataBinder</code> 绑定到请求。</p>
</li>
<li>
<p>作为 <code>@Controller</code> 或 <code>@ControllerAdvice</code> 类中的方法级注解，可在任何 <code>@RequestMapping</code> 方法调用之前帮助初始化模型。</p>
</li>
<li>
<p>在 <code>@RequestMapping</code> 方法上标记它的返回值是一个模型属性。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节讨论 <code>@ModelAttribute</code> 方法&#8201;&#8212;&#8201;前面列表中的第二项。控制器可以具有任意数量的 <code>@ModelAttribute</code> 方法。
所有此类方法均在同一控制器中的 <code>@RequestMapping</code> 方法之前调用。也可以通过 <code>@ControllerAdvice</code> 在控制器之间共享
<code>@ModelAttribute</code> 方法。有关更多详细信息，请参阅<a href="#webflux-ann-controller-advice">控制器通知</a>部分。</p>
</div>
<div class="paragraph">
<p><code>@ModelAttribute</code> 方法具有灵活的方法签名。它们支持与 <code>@RequestMapping</code> 方法相同的许多参数，除了
<code>@ModelAttribute</code> 本身或与请求正文相关的任何东西。</p>
</div>
<div class="paragraph">
<p>下面的示例使用 <code>@ModelAttribute</code> 方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
	model.addAttribute(accountRepository.findAccount(number));
	// add more ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例仅添加一个属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public Account addAccount(@RequestParam String number) {
	return accountRepository.findAccount(number);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果未明确指定名称，则根据类型选择默认名称，如 {api-spring-framework}/core/Conventions.html[<code>Conventions</code>]的javadoc中所述。
你始终可以使用重载的 <code>addAttribute</code> 方法或通过 <code>@ModelAttribute</code> 上的 <code>name</code> 属性（用于返回值）来分配显式名称。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与Spring MVC不同，Spring WebFlux在模型中显式支持响应式类型（例如：<code>Mono&lt;Account&gt;</code> 或 <code>io.reactivex.Single&lt;Account&gt;</code>）。
可以在 <code>@RequestMapping</code> 调用时将此类异步模型属性透明地解析（并更新模型）为其实际值，
只要声明了 <code>@ModelAttribute</code> 参数而没有包装，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ModelAttribute
public void addAccount(@RequestParam String number) {
    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);
    model.addAttribute("account", accountMono);
}

@PostMapping("/accounts")
public String handle(@ModelAttribute Account account, BindingResult errors) {
	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，任何具有响应式类型包装器的模型属性都将在视图渲染之前解析为其实际值（并更新了模型）。</p>
</div>
<div class="paragraph">
<p>你也可以将 <code>@ModelAttribute</code> 用作 <code>@RequestMapping</code> 方法上的方法级注释，
在这种情况下，<code>@RequestMapping</code> 方法的返回值将解释为模型属性。通常不需要这样做，因为它是HTML控制器的默认行为，
除非返回值是一个 <code>String</code>，不这样做它将被解释为视图名称。<code>@ModelAttribute</code> 还可以自定义模型属性名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
	// ...
	return account;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-initbinder">4.5. <code>DataBinder</code></h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-initbinder">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> 或 <code>@ControllerAdvice</code> 类可以具有用于初始化 <code>WebDataBinder</code> 实例的 <code>@InitBinder</code> 方法，而这些方法又可以：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将请求参数（即表单或查询数据）绑定到模型对象。</p>
</li>
<li>
<p>将基于字符串的请求值（例如请求参数，路径变量，请求头，Cookie等）转换为控制器方法参数的目标类型。</p>
</li>
<li>
<p>呈现HTML表单时，将模型对象的值格式化为 <code>String</code> 值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> 方法可以注册特定于控制器的 <code>java.bean.PropertyEditor</code> 或
Spring <code>Converter</code> 和 <code>Formatter</code> 组件。另外，你可以使用<a href="#webflux-config-conversion">WebFlux Java配置</a>在全局共享的
<code>FormattingConversionService</code> 中注册 <code>Converter</code> 和 <code>Formatter</code> 类型。</p>
</div>
<div class="paragraph">
<p><code>@InitBinder</code> 方法支持与 <code>@RequestMapping</code> 方法相同的许多参数，除了 <code>@ModelAttribute</code>（命令对象）参数。
通常，它们使用 <code>WebDataBinder</code> 参数（用于注册）和 <code>void</code> 返回值声明。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

	@InitBinder <i class="conum" data-value="1"></i><b>(1)</b>
	public void initBinder(WebDataBinder binder) {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		dateFormat.setLenient(false);
		binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>@InitBinder</code> 注解。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外，当通过共享的 <code>FormattingConversionService</code> 使用基于
<code>Formatter</code> 的设置时，可以重新使用相同的方法并注册特定于控制器的 <code>Formatter</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class FormController {

	@InitBinder
	protected void initBinder(WebDataBinder binder) {
		binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <i class="conum" data-value="1"></i><b>(1)</b>
	}

	// ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加自定义格式化器（在这种情况下为 <code>DateFormatter</code>）。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-controller-exceptions">4.6. 管理异常</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-exceptionhandler">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@Controller</code> 和<a href="#mvc-ann-controller-advice">@ControllerAdvice</a>类可以具有 <code>@ExceptionHandler</code> 方法来处理来自控制器方法的异常。
下面的示例包括这样的处理程序方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class SimpleController {

	// ...

	@ExceptionHandler <i class="conum" data-value="1"></i><b>(1)</b>
	public ResponseEntity&lt;String&gt; handle(IOException ex) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>声明一个 <code>@ExceptionHandler</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>该异常可能与正在传播的顶级异常（即直接抛出 <code>IOException</code>）匹配，也可能与顶级包装器异常（例如，包装在 <code>IllegalStateException</code> 内部的
<code>IOException</code>）内的直接cause匹配。</p>
</div>
<div class="paragraph">
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。或者，注解声明可以缩小异常类型以使其匹配。
我们通常建议在参数签名中尽可能具体，并在以相应顺序优先的 <code>@ControllerAdvice</code> 上声明你的主要root异常映射。
有关详细信息，请参见<a href="spring-mvc.html#mvc-ann-exceptionhandler">MVC部分</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
WebFlux中的 <code>@ExceptionHandler</code> 方法支持与 <code>@RequestMapping</code> 方法相同的方法参数和返回值，
但与请求体和 <code>@ModelAttribute</code> 相关的方法参数除外。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>HandlerAdapter</code> 为 <code>@RequestMapping</code> 方法提供对Spring WebFlux中 <code>@ExceptionHandler</code> 方法的支持。
有关更多详细信息，请参见<a href="#webflux-dispatcher-handler"><code>DispatcherHandler</code></a>。</p>
</div>
<div class="sect3">
<h4 id="webflux-ann-rest-exceptions">4.6.1. REST API异常</h4>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-rest-exceptions">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>REST服务的常见要求是在响应正文中包含错误详细信息。Spring框架不会自动执行此操作，
因为响应主体中错误详细信息的表示是特定于应用程序的。但是，<code>@RestController</code> 可以将 <code>@ExceptionHandler</code>
方法与 <code>ResponseEntity</code> 返回值一起使用，以设置响应的状态和主体。也可以在 <code>@ControllerAdvice</code>
类中声明此类方法，以将其全局应用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意，Spring WebFlux与Spring MVC <code>ResponseEntityExceptionHandler</code> 没有等效项，
因为WebFlux仅引发 <code>ResponseStatusException</code>（或其子类），并且不需要将其转换为HTTP状态码。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-ann-controller-advice">4.7. 控制器通知</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-ann-controller-advice">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code> 和 <code>@ModelAttribute</code> 方法在声明它们的 <code>@Controller</code> 类
（或类层次结构）中应用。如果希望此类方法在全局范围内（跨控制器）应用，则可以在带有 <code>@ControllerAdvice</code>
或 <code>@RestControllerAdvice</code> 注解的类中声明它们。</p>
</div>
<div class="paragraph">
<p><code>@ControllerAdvice</code> 带有 <code>@Component</code> 注解，这意味着可以通过
<a href="spring-core.html#beans-java-instantiating-container-scan">组件扫描</a>将此类注册为Spring Bean。
<code>@RestControllerAdvice</code> 是由 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 注解的组合注解，
这实际上意味着 <code>@ExceptionHandler</code> 方法通过消息转换（相对于视图解析或模板渲染）呈现给响应体的。</p>
</div>
<div class="paragraph">
<p>启动时，<code>@RequestMapping</code> 和 <code>@ExceptionHandler</code> 方法的基础结构类将检测使用 <code>@ControllerAdvice</code> 注解的Spring bean，
然后在运行时应用其方法。全局 <code>@ExceptionHandler</code> 方法（来自 <code>@ControllerAdvice</code>）在本地方法（来自 <code>@Controller</code>）
<em>之后</em> 应用。相比之下，全局 <code>@ModelAttribute</code> 和 <code>@InitBinder</code> 方法在本地方法 <em>之前</em> 应用。</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>@ControllerAdvice</code> 方法适用于每个请求（即所有控制器），但是你可以通过使用注解上的属性将其范围缩小
到控制器的子集，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。有关更多详细信息，请参见
{api-spring-framework}/web/bind/annotation/ControllerAdvice.html[<code>@ControllerAdvice</code>]javadoc。</p>
</div>
<div class="paragraph">
<p>Unresolved directive in webflux.adoc - include::webflux-functional.adoc[leveloffset=+1]</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-uri-building">5. URI链接</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-uri-building">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>本节描述了Spring框架中用于准备URIs的各种选项。</p>
</div>
<div class="paragraph">
<p>Unresolved directive in webflux.adoc - include::../spring-mvc/web-uris.adoc[leveloffset=+1]</p>
</div>
<div class="paragraph">
<p>Unresolved directive in webflux.adoc - include::webflux-cors.adoc[leveloffset=+1]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-web-security">6. Web安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-web-security">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><a href="http://projects.spring.io/spring-security/">Spring Security</a>
项目提供了保护Web应用程序免受恶意利用的支持。请参阅Spring Security参考文档，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#jc-webflux[WebFlux安全]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#test-webflux[WebFlux测试支持]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#csrf[CSRF保护]</p>
</li>
<li>
<p>{doc-root}/spring-security/site/docs/current/reference/html5/#headers[安全响应头]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unresolved directive in webflux.adoc - include::webflux-view.adoc[leveloffset=+1]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-caching">7. HTTP缓存</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>HTTP缓存可以显著提高Web应用程序的性能。HTTP缓存围绕 <code>Cache-Control</code> 响应头和后续的条件请求头，
如 <code>Last-Modified</code> 和 <code>ETag</code> 进行。<code>Cache-Control</code> 建议私有（例如浏览器）和公共（例如代理）缓存如何缓存和重用响应。
<code>ETag</code> 标头用于发出条件请求，如果内容未更改，则可能导致返回没有响应体的304（NOT_MODIFIED）状态。
<code>ETag</code> 可以看作是 <code>Last-Modified</code> 头的更复杂后继者。</p>
</div>
<div class="paragraph">
<p>本节介绍了Spring WebFlux中与HTTP缓存相关的选项。</p>
</div>
<div class="sect2">
<h3 id="webflux-caching-cachecontrol">7.1. <code>CacheControl</code></h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-cachecontrol">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>{api-spring-framework}/http/CacheControl.html[<code>CacheControl</code>]
支持配置与 <code>Cache-Control</code> 标头相关的设置，并在许多地方作为参数被接受：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-caching-etag-lastmodified">控制器</a></p>
</li>
<li>
<p><a href="#webflux-caching-static-resources">静态资源</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管 <a href="https://tools.ietf.org/html/rfc7234#section-5.2.2">RFC 7234</a>描述了
<code>Cache-Control</code> 响应头的所有可能的指令，但 <code>CacheControl</code> 类型采用了面向用例的方法，着重于常见场景：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Cache for an hour - "Cache-Control: max-age=3600"
CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

// Prevent caching - "Cache-Control: no-store"
CacheControl ccNoStore = CacheControl.noStore();

// Cache for ten days in public and private caches,
// public caches should not transform the response
// "Cache-Control: max-age=864000, public, no-transform"
CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching-etag-lastmodified">7.2. 控制器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-etag-lastmodified">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>控制器可以添加对HTTP缓存的显式支持。
我们建议你这样做，因为需要先计算资源的 <code>lastModified</code> 或 <code>ETag</code> 值，然后才能将其与条件请求头进行比较。
控制器可以将 <code>ETag</code> 和 <code>Cache-Control</code> 设置添加到 <code>ResponseEntity</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@GetMapping("/book/{id}")
public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) {

	Book book = findBook(id);
	String version = book.getVersion();

	return ResponseEntity
			.ok()
			.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
			.eTag(version) // lastModified is also available
			.body(book);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与条件请求头的比较表明内容未更改，则前面的示例发送带有空主体的304（NOT_MODIFIED）响应。
否则，<code>ETag</code> 和 <code>Cache-Control</code> 标头将添加到响应中。</p>
</div>
<div class="paragraph">
<p>你还可以在控制器中针对条件请求头进行检查，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RequestMapping
public String myHandleMethod(ServerWebExchange exchange, Model model) {

	long eTag = ... <i class="conum" data-value="1"></i><b>(1)</b>

	if (exchange.checkNotModified(eTag)) {
		return null; <i class="conum" data-value="2"></i><b>(2)</b>
	}

	model.addAttribute(...); <i class="conum" data-value="3"></i><b>(3)</b>
	return "myViewName";
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>特定于应用程序的计算。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>响应已设置为304（NOT_MODIFIED）。无需进一步处理。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>继续进行请求处理。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用三种变体来检查针对 <code>eTag</code> 值，<code>lastModified</code> 值或混合两者的条件请求。
对于有条件的 <code>GET</code> 和 <code>HEAD</code> 请求，可以将响应设置为304（NOT_MODIFIED）。
对于条件 <code>POST</code>，<code>PUT</code> 和 <code>DELETE</code>，你可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-caching-static-resources">7.3. 静态资源</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-caching-static-resources">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你应该将静态资源与 <code>Cache-Control</code> 和条件响应头一起提供，以实现最佳性能。请参阅有关配置<a href="#webflux-config-static-resources">静态资源</a>的部分。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-config">8. WebFlux配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>WebFlux Java配置声明使用带注解的控制器或函数式端点来声明处理请求所必需的组件，并且它提供了用于自定义配置的API。
这意味着你不需要了解Java配置创建的基础bean。但是，如果你想了解它们，则可以在 <code>WebFluxConfigurationSupport</code>
中查看它们，或阅读有关<a href="#webflux-special-bean-types">特殊Bean类型</a>中的更多信息。</p>
</div>
<div class="paragraph">
<p>对于配置API中没有的更高级的自定义设置，你可以通过<a href="#webflux-config-advanced-java">高级配置模式</a>完全控制配置。</p>
</div>
<div class="sect2">
<h3 id="webflux-config-enable">8.1. 启用WebFlux配置</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-enable">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以在Java配置中使用 <code>@EnableWebFlux</code> 注解，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例注册了许多Spring WebFlux<a href="#mvc-webflux-special-bean-types">基础设施Bean</a>，
并适配了classpath上可用的依赖项&#8212;&#8203;对于JSON，XML等。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-customize">8.2. WebFlux配置API</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-customize">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>在Java配置中，可以实现 <code>WebFluxConfigurer</code> 接口，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	// Implement configuration methods...

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-conversion">8.3. 转换，格式化</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-conversion">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，将安装 <code>Number</code> 和 <code>Date</code> 类型的格式化程序，包括对 <code>@NumberFormat</code> 和 <code>@DateTimeFormat</code> 注解的支持。
如果类路径中存在Joda-Time，则还将安装对Joda-Time格式库的完全支持。</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何注册自定义格式化器和转换器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void addFormatters(FormatterRegistry registry) {
		// ...
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关何时使用 <code>FormatterRegistrar</code> 实现的更多信息，请参见
{doc-spring-core}#format-FormatterRegistrar-SPI[<code>FormatterRegistrar</code> SPI]和
<code>FormattingConversionServiceFactoryBean</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-validation">8.4. 检验</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-validation">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>默认情况下，如果 {doc-spring-core}#validation-beanvalidation-overview[Bean验证]存在于类路径中
（例如：Hibernate Validator），则 <code>LocalValidatorFactoryBean</code> 将注册为全局
{doc-spring-core}#validator[验证器]，以与 <code>@Valid</code> 和 <code>@Controller</code> 方法参数中的 <code>Validated</code> 一起使用。</p>
</div>
<div class="paragraph">
<p>在Java配置中，你可以自定义全局 <code>Validator</code> 实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public Validator getValidator(); {
		// ...
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，你还可以在本地注册 <code>Validator</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Controller
public class MyController {

	@InitBinder
	protected void initBinder(WebDataBinder binder) {
		binder.addValidators(new FooValidator());
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要在某处注入 <code>LocalValidatorFactoryBean</code>，请创建一个bean并用 <code>@Primary</code> 进行注解，以避免与MVC配置中声明的bean发生冲突。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-content-negotiation">8.5. 内容类型解析器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-content-negotiation">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以配置Spring WebFlux如何根据请求为 <code>@Controller</code> 实例确定所请求的媒体类型。
默认情况下，仅选中 <code>Accept</code> 标头，但你也可以启用基于查询参数的策略。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义请求的内容类型解析：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
		// ...
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-message-codecs">8.6. HTTP消息编解码器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-message-converters">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>以下示例显示如何自定义读取请求体和写入响应体的方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ServerCodecConfigurer</code> 提供了一组默认的读取器和写入器。你可以使用它来添加更多的读取器和写入器，
自定义默认的读取器或完全替换默认的读取器和写入器。</p>
</div>
<div class="paragraph">
<p>对于Jackson JSON和XML，请考虑使用
{api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[<code>Jackson2ObjectMapperBuilder</code>]，
该工具使用以下属性自定义Jackson的默认属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES"><code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code></a>被禁用。</p>
</li>
<li>
<p><a href="http://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION"><code>MapperFeature.DEFAULT_VIEW_INCLUSION</code></a>被禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果在类路径中检测到以下知名模块，它还将自动注册以下知名模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-joda"><code>jackson-datatype-joda</code></a>: 支持Joda-Time类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jsr310"><code>jackson-datatype-jsr310</code></a>: 支持Java 8日期和时间API类型。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-datatype-jdk8"><code>jackson-datatype-jdk8</code></a>: 支持其他Java 8类型，例如 <code>Optional</code>。</p>
</li>
<li>
<p><a href="https://github.com/FasterXML/jackson-module-kotlin"><code>jackson-module-kotlin</code></a>: 支持Kotlin类和数据类。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-view-resolvers">8.7. 视图解析器</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-view-resolvers">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>下面的示例显示如何配置视图解析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		// ...
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ViewResolverRegistry</code> 具有与Spring Framework集成的视图技术的快捷方式。
以下示例使用FreeMarker（这也需要配置基础FreeMarker视图技术）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.freeMarker();
	}

	// Configure Freemarker...

	@Bean
	public FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		configurer.setTemplateLoaderPath("classpath:/templates");
		return configurer;
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以插入任何 <code>ViewResolver</code> 实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		ViewResolver resolver = ... ;
		registry.viewResolver(resolver);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了支持<a href="#webflux-multiple-representations">内容协商</a>并通过视图解析（HTML之外）渲染其他格式，
你可以基于 <code>HttpMessageWriterView</code> 实现配置一个或多个默认视图，该实现接受 <code>spring-web</code> 中的任何可用<a href="#webflux-codecs">编解码器</a>。
以下示例显示了如何执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {


	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		registry.freeMarker();

		Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
		registry.defaultViews(new HttpMessageWriterView(encoder));
	}

	// ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关与Spring WebFlux集成的视图技术的更多信息，请参见<a href="#webflux-view">[webflux-view]</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-static-resources">8.8. 静态资源</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-static-resources">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>此选项提供了一种方便的方法来从基于 {api-spring-framework}/core/io/Resource.html[<code>Resource</code>]的位置列表中提供静态资源。</p>
</div>
<div class="paragraph">
<p>在下一个示例中，给定一个以 <code>/resources</code> 开头的请求，相对路径用于在类路径上查找和提供相对于 <code>/static</code> 的静态资源。
资源的有效期为一年，以确保最大程度地利用浏览器缓存并减少浏览器发出的HTTP请求。
还评估 <code>Last-Modified</code> 头，如果存在，则返回304状态码。以下列表显示了示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/resources/**")
			.addResourceLocations("/public", "classpath:/static/")
			.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>资源处理程序还支持一系列
{api-spring-framework}/web/reactive/resource/ResourceResolver.html[<code>ResourceResolver</code>]实现和
{api-spring-framework}/web/reactive/resource/ResourceTransformer.html[<code>ResourceTransformer</code>]实现，
可用于创建用于处理优化资源的工具链。</p>
</div>
<div class="paragraph">
<p>你可以根据从内容，固定应用程序版本或其他信息计算出的MD5哈希，将 <code>VersionResourceResolver</code> 用于版本化的资源URL。
<code>ContentVersionStrategy</code>（MD5哈希）是一个不错的选择，但有一些值得注意的例外（例如：与模块加载器一起使用的JavaScript资源）。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在Java配置中使用 <code>VersionResourceResolver</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public/")
				.resourceChain(true)
				.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>ResourceUrlProvider</code> 重写URL并应用完整的解析器和转换器链（例如：插入版本）。
WebFlux配置提供了 <code>ResourceUrlProvider</code>，以便可以将其注入其他资源。</p>
</div>
<div class="paragraph">
<p>与Spring MVC不同，目前，在WebFlux中，由于没有视图技术可以利用解析器和转换器的非阻塞链，
因此无法透明地重写静态资源URL。当仅提供本地资源时，解决方法是直接使用 <code>ResourceUrlProvider</code>（例如：通过自定义元素）并进行阻止。</p>
</div>
<div class="paragraph">
<p>请注意，在同时使用 <code>EncodedResourceResolver</code>（例如：Gzip，Brotli编码）和 <code>VersionedResourceResolver</code>
时，必须按该顺序注册，以确保始终基于未编码文件可靠地计算基于内容的版本。</p>
</div>
<div class="paragraph">
<p><a href="http://www.webjars.org/documentation">WebJars</a> 还通过 <code>WebJarsResourceResolver</code> 支持，当
<code>org.webjars:webjars-locator-core</code> 库存在于类路径中时，WebJars将自动注册。
解析程序可以重写URL以包括jar的版本，并且还可以与没有版本的传入URL进行匹配（例如：从 <code>/jquery/jquery.min.js</code>
到 <code>/jquery/1.2.0/jquery.min.js</code>）。</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-path-matching">8.9. 路径匹配</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-path-matching">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>你可以自定义与路径匹配有关的选项。有关各个选项的详细信息，请参见
{api-spring-framework}/web/reactive/config/PathMatchConfigurer.html[<code>PathMatchConfigurer</code>] javadoc。
以下示例显示如何使用 <code>PathMatchConfigurer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void configurePathMatch(PathMatchConfigurer configurer) {
		configurer
			.setUseCaseSensitiveMatch(true)
			.setUseTrailingSlashMatch(false)
			.addPathPrefix("/api",
					HandlerTypePredicate.forAnnotation(RestController.class));
	}

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring WebFlux依赖于请求路径的解析表示形式来访问解码的路径段值，该请求路径称为 <code>RequestPath</code>，
并且已删除了分号内容（即路径或矩阵变量）。这意味着，与Spring MVC不同，你无需指示是否解码请求路径，
也无需指示是否出于路径匹配目的而删除分号内容。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux还不支持后缀模式匹配，这与Spring MVC不同，在Spring MVC中，我们也
<a href="spring-mvc.html#mvc-ann-requestmapping-suffix-pattern-match">建议</a>不要依赖它。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="webflux-config-advanced-java">8.10. 高级配置模式</h3>
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-config-advanced-java">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p><code>@EnableWebFlux</code> 导入 <code>DelegatingWebFluxConfiguration</code> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为WebFlux应用程序提供默认的Spring配置</p>
</li>
<li>
<p>检测并委托给 <code>WebFluxConfigurer</code> 实现以自定义该配置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于高级模式，你可以删除 <code>@EnableWebFlux</code> 并直接从 <code>DelegatingWebFluxConfiguration</code>
继承而不是实现 <code>WebFluxConfigurer</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration
public class WebConfig extends DelegatingWebFluxConfiguration {

	// ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以将现有方法保留在 <code>WebConfig</code> 中，但是现在你还可以覆盖基类中的bean声明，
并且在类路径上仍然具有任意数量的其他 <code>WebMvcConfigurer</code> 实现。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-http2">9. HTTP/2</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="small"><a href="spring-mvc.html#mvc-http2">Web MVC</a></span></p>
</div>
<div class="paragraph">
<p>Servlet 4容器需要支持HTTP/2，并且Spring Framework 5与Servlet API 4兼容。
从编程模型的角度来看，应用程序不需要做任何特定的事情。但是，有一些与服务器配置有关的注意事项。
有关更多详细信息，请参见
<a href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 Wiki页面</a>。</p>
</div>
<div class="paragraph">
<p>当前，Spring WebFlux不支持Netty的HTTP/2。也没有支持以编程方式将资源推送到客户端。</p>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>