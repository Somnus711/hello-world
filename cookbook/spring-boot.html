<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Version 2.2.2.RELEASE">
<title>Spring Boot</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body id="boot-documentation" class="book toc2 toc-left">
<div id="header">
<h1>Spring Boot</h1>
<div class="details">
<span id="author" class="author">Version 2.2.2.RELEASE</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#using-boot">1. Spring Boot</a>
<ul class="sectlevel2">
<li><a href="#using-boot-build-systems">1.1. 构建系统</a>
<ul class="sectlevel3">
<li><a href="#using-boot-dependency-management">1.1.1. 依赖管理</a></li>
<li><a href="#using-boot-maven">1.1.2. Maven</a>
<ul class="sectlevel4">
<li><a href="#using-boot-maven-parent-pom">继承Starter Parent</a></li>
<li><a href="#using-boot-maven-without-a-parent">在没有父POM的情况下使用Spring Boot</a></li>
<li><a href="#using-boot-maven-plugin">使用Spring Boot Maven插件</a></li>
</ul>
</li>
<li><a href="#using-boot-gradle">1.1.3. Gradle</a></li>
<li><a href="#using-boot-ant">1.1.4. Ant</a></li>
<li><a href="#using-boot-starter">1.1.5. Starters</a></li>
</ul>
</li>
<li><a href="#using-boot-structuring-your-code">1.2. 结构化你的代码</a>
<ul class="sectlevel3">
<li><a href="#using-boot-using-the-default-package">1.2.1. 使用“<code>default</code>”包</a></li>
<li><a href="#using-boot-locating-the-main-class">1.2.2. 找到应用程序主类</a></li>
</ul>
</li>
<li><a href="#using-boot-configuration-classes">1.3. 配置类</a>
<ul class="sectlevel3">
<li><a href="#using-boot-importing-configuration">1.3.1. 导入其他配置类</a></li>
<li><a href="#using-boot-importing-xml-configuration">1.3.2. 导入XML配置</a></li>
</ul>
</li>
<li><a href="#using-boot-auto-configuration">1.4. 自动配置</a>
<ul class="sectlevel3">
<li><a href="#using-boot-replacing-auto-configuration">1.4.1. 逐渐取代自动配置</a></li>
<li><a href="#using-boot-disabling-specific-auto-configuration">1.4.2. 禁用特定的自动配置类</a></li>
</ul>
</li>
<li><a href="#using-boot-spring-beans-and-dependency-injection">1.5. Spring Beans和依赖注入</a></li>
<li><a href="#using-boot-using-springbootapplication-annotation">1.6. 使用@SpringBootApplication注解</a></li>
<li><a href="#using-boot-running-your-application">1.7. 运行你的应用程序</a>
<ul class="sectlevel3">
<li><a href="#using-boot-running-from-an-ide">1.7.1. 从IDE运行</a></li>
<li><a href="#using-boot-running-as-a-packaged-application">1.7.2. 作为打包的应用程序运行</a></li>
<li><a href="#using-boot-running-with-the-maven-plugin">1.7.3. 使用Maven插件</a></li>
<li><a href="#using-boot-running-with-the-gradle-plugin">1.7.4. 使用Gradle插件</a></li>
<li><a href="#using-boot-hot-swapping">1.7.5. 热交换</a></li>
</ul>
</li>
<li><a href="#using-boot-devtools">1.8. 开发者工具</a>
<ul class="sectlevel3">
<li><a href="#using-boot-devtools-property-defaults">1.8.1. 属性默认值</a></li>
<li><a href="#using-boot-devtools-restart">1.8.2. 自动重启</a>
<ul class="sectlevel4">
<li><a href="#using-boot-devtools-restart-logging-condition-delta">记录条件评估中的更改</a></li>
<li><a href="#using-boot-devtools-restart-exclude">排除资源</a></li>
<li><a href="#using-boot-devtools-restart-additional-paths">监视其他路径</a></li>
<li><a href="#using-boot-devtools-restart-disable">禁用重启</a></li>
<li><a href="#using-boot-devtools-restart-triggerfile">使用触发文件</a></li>
<li><a href="#using-boot-devtools-customizing-classload">自定义重启类加载器</a></li>
<li><a href="#using-boot-devtools-known-restart-limitations">已知局限性</a></li>
</ul>
</li>
<li><a href="#using-boot-devtools-livereload">1.8.3. LiveReload</a></li>
<li><a href="#using-boot-devtools-globalsettings">1.8.4. 全局设置</a></li>
<li><a href="#using-boot-devtools-remote">1.8.5. 远程应用</a>
<ul class="sectlevel4">
<li><a href="#运行远程客户端应用程序">运行远程客户端应用程序</a></li>
<li><a href="#using-boot-devtools-remote-update">远程更新</a></li>
<li><a href="#configuring-file-system-watcher">配置文件系统观察器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-boot-packaging-for-production">1.9. 打包你的应用程序用于生产</a></li>
<li><a href="#using-boot-whats-next">1.10. 接下来要读什么</a></li>
</ul>
</li>
<li><a href="#boot-features">2. Spring Boot特性</a>
<ul class="sectlevel2">
<li><a href="#boot-features-spring-application">2.1. SpringApplication</a>
<ul class="sectlevel3">
<li><a href="#boot-features-startup-failure">2.1.1. 启动失败</a></li>
<li><a href="#boot-features-lazy-initialization">2.1.2. 延迟初始化</a></li>
<li><a href="#boot-features-banner">2.1.3. 自定义横幅</a></li>
<li><a href="#boot-features-customizing-spring-application">2.1.4. 自定义SpringApplication</a></li>
<li><a href="#boot-features-fluent-builder-api">2.1.5. 流式构建器API</a></li>
<li><a href="#boot-features-application-events-and-listeners">2.1.6. 应用程序事件和监听器</a></li>
<li><a href="#boot-features-web-environment">2.1.7. Web环境</a></li>
<li><a href="#boot-features-application-arguments">2.1.8. 访问应用程序参数</a></li>
<li><a href="#boot-features-command-line-runner">2.1.9. 使用ApplicationRunner或CommandLineRunner</a></li>
<li><a href="#boot-features-application-exit">2.1.10. 应用程序退出</a></li>
<li><a href="#boot-features-application-admin">2.1.11. 管理员功能</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config">2.2. 外部化配置</a>
<ul class="sectlevel3">
<li><a href="#boot-features-external-config-random-values">2.2.1. 配置随机值</a></li>
<li><a href="#boot-features-external-config-command-line-args">2.2.2. 访问命令行Properties</a></li>
<li><a href="#boot-features-external-config-application-property-files">2.2.3. 应用程序属性文件</a></li>
<li><a href="#boot-features-external-config-profile-specific-properties">2.2.4. 特定于Profile的Properties</a></li>
<li><a href="#boot-features-external-config-placeholders-in-properties">2.2.5. Properties中的占位符</a></li>
<li><a href="#boot-features-encrypting-properties">2.2.6. 加密Properties</a></li>
<li><a href="#boot-features-external-config-yaml">2.2.7. 使用YAML代替Properties</a>
<ul class="sectlevel4">
<li><a href="#boot-features-external-config-loading-yaml">加载YAML</a></li>
<li><a href="#boot-features-external-config-exposing-yaml-to-spring">在Spring环境中将YAML公开为Properties</a></li>
<li><a href="#boot-features-external-config-multi-profile-yaml">Multi-profile的YAML文档</a></li>
<li><a href="#boot-features-external-config-yaml-shortcomings">YAML的缺点</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config-typesafe-configuration-properties">2.2.8. 类型安全的配置Properties</a>
<ul class="sectlevel4">
<li><a href="#boot-features-external-config-java-bean-binding">JavaBean properties绑定</a></li>
<li><a href="#boot-features-external-config-constructor-binding">构造函数绑定</a></li>
<li><a href="#boot-features-external-config-enabling">启用被 <code>@ConfigurationProperties</code> 注解的类型</a></li>
<li><a href="#boot-features-external-config-using">使用被 <code>@ConfigurationProperties</code> 注解的类型</a></li>
<li><a href="#boot-features-external-config-3rd-party-configuration">第三方配置</a></li>
<li><a href="#boot-features-external-config-relaxed-binding">宽松绑定</a></li>
<li><a href="#boot-features-external-config-complex-type-merge">合并复杂类型</a></li>
<li><a href="#boot-features-external-config-conversion">属性转换</a></li>
<li><a href="#boot-features-external-config-validation">@ConfigurationProperties验证</a></li>
<li><a href="#boot-features-external-config-vs-value">@ConfigurationProperties vs @Value</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-profiles">2.3. Profiles</a>
<ul class="sectlevel3">
<li><a href="#boot-features-adding-active-profiles">2.3.1. 添加活动Profiles</a></li>
<li><a href="#boot-features-programmatically-setting-profiles">2.3.2. 以编程方式设置Profiles</a></li>
<li><a href="#boot-features-profile-specific-configuration">2.3.3. 特定于Profile的配置文件</a></li>
</ul>
</li>
<li><a href="#boot-features-logging">2.4. 日志</a>
<ul class="sectlevel3">
<li><a href="#boot-features-logging-format">2.4.1. 日志格式</a></li>
<li><a href="#boot-features-logging-console-output">2.4.2. 控制台输出</a>
<ul class="sectlevel4">
<li><a href="#boot-features-logging-color-coded-output">颜色编码输出</a></li>
</ul>
</li>
<li><a href="#boot-features-logging-file-output">2.4.3. 文件输出</a></li>
<li><a href="#boot-features-custom-log-levels">2.4.4. 日志级别</a></li>
<li><a href="#boot-features-custom-log-groups">2.4.5. 日志组</a></li>
<li><a href="#boot-features-custom-log-configuration">2.4.6. 自定义日志配置</a></li>
<li><a href="#boot-features-logback-extensions">2.4.7. Logback扩展</a>
<ul class="sectlevel4">
<li><a href="#特定于profile的配置">特定于Profile的配置</a></li>
<li><a href="#环境属性">环境属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-internationalization">2.5. 国际化</a></li>
<li><a href="#boot-features-json">2.6. JSON</a>
<ul class="sectlevel3">
<li><a href="#boot-features-json-jackson">2.6.1. Jackson</a></li>
<li><a href="#boot-features-json-gson">2.6.2. Gson</a></li>
<li><a href="#boot-features-json-json-b">2.6.3. JSON-B</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-web-applications">2.7. 开发Web应用程序</a>
<ul class="sectlevel3">
<li><a href="#boot-features-spring-mvc">2.7.1. Spring Web MVC框架</a>
<ul class="sectlevel4">
<li><a href="#boot-features-spring-mvc-auto-configuration">Spring MVC自动配置</a></li>
<li><a href="#boot-features-spring-mvc-message-converters">HttpMessageConverters</a></li>
<li><a href="#boot-features-json-components">自定义JSON序列化器和反序列化器</a></li>
<li><a href="#boot-features-spring-message-codes">MessageCodesResolver</a></li>
<li><a href="#boot-features-spring-mvc-static-content">静态内容</a></li>
<li><a href="#boot-features-spring-mvc-welcome-page">欢迎页面</a></li>
<li><a href="#boot-features-spring-mvc-favicon">自定义图标</a></li>
<li><a href="#boot-features-spring-mvc-pathmatch">路径匹配和内容协商</a></li>
<li><a href="#boot-features-spring-mvc-web-binding-initializer">ConfigurableWebBindingInitializer</a></li>
<li><a href="#boot-features-spring-mvc-template-engines">模板引擎</a></li>
<li><a href="#boot-features-error-handling">错误处理</a></li>
<li><a href="#boot-features-spring-hateoas">Spring HATEOAS</a></li>
<li><a href="#boot-features-cors">CORS支持</a></li>
</ul>
</li>
<li><a href="#boot-features-webflux">2.7.2. Spring WebFlux框架</a>
<ul class="sectlevel4">
<li><a href="#boot-features-webflux-auto-configuration">Spring WebFlux自动配置</a></li>
<li><a href="#boot-features-webflux-httpcodecs">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</a></li>
<li><a href="#boot-features-webflux-static-content">静态内容</a></li>
<li><a href="#boot-features-webflux-template-engines">模板引擎</a></li>
<li><a href="#boot-features-webflux-error-handling">错误处理</a></li>
<li><a href="#boot-features-webflux-web-filters">Web过滤器</a></li>
</ul>
</li>
<li><a href="#boot-features-jersey">2.7.3. JAX-RS和Jersey</a></li>
<li><a href="#boot-features-embedded-container">2.7.4. 嵌入式Servlet容器支持</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-container-servlets-filters-listeners">Servlets, Filters和listeners</a></li>
<li><a href="#boot-features-embedded-container-context-initializer">Servlet上下文初始化</a></li>
<li><a href="#boot-features-embedded-container-application-context">ServletWebServerApplicationContext</a></li>
<li><a href="#boot-features-customizing-embedded-containers">自定义嵌入式Servlet容器</a></li>
<li><a href="#boot-features-jsp-limitations">JSP局限性</a></li>
</ul>
</li>
<li><a href="#boot-features-reactive-server">2.7.5. 响应式嵌入服务器支持</a></li>
<li><a href="#boot-features-reactive-server-resources">2.7.6. 响应式服务器资源配置</a></li>
</ul>
</li>
<li><a href="#boot-features-rsocket">2.8. RSocket</a>
<ul class="sectlevel3">
<li><a href="#boot-features-rsocket-strategies-auto-configuration">2.8.1. RSocket Strategies Auto-configuration</a></li>
<li><a href="#boot-features-rsocket-server-auto-configuration">2.8.2. RSocket server Auto-configuration</a></li>
<li><a href="#boot-features-rsocket-messaging">2.8.3. Spring Messaging RSocket support</a></li>
<li><a href="#boot-features-rsocket-requester">2.8.4. Calling RSocket Services with <code>RSocketRequester</code></a></li>
</ul>
</li>
<li><a href="#boot-features-security">2.9. Security</a>
<ul class="sectlevel3">
<li><a href="#boot-features-security-mvc">2.9.1. MVC Security</a></li>
<li><a href="#boot-features-security-webflux">2.9.2. WebFlux Security</a></li>
<li><a href="#boot-features-security-oauth2">2.9.3. OAuth2</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-oauth2-client">Client</a></li>
<li><a href="#boot-features-security-oauth2-server">Resource Server</a></li>
<li><a href="#authorization-server">Authorization Server</a></li>
</ul>
</li>
<li><a href="#boot-features-security-saml">2.9.4. SAML 2.0</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-saml2-relying-party">Relying Party</a></li>
</ul>
</li>
<li><a href="#boot-features-security-actuator">2.9.5. Actuator Security</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-csrf">Cross Site Request Forgery Protection</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-sql">2.10. Working with SQL Databases</a>
<ul class="sectlevel3">
<li><a href="#boot-features-configure-datasource">2.10.1. Configure a DataSource</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-database-support">Embedded Database Support</a></li>
<li><a href="#boot-features-connect-to-production-database">Connection to a Production Database</a></li>
<li><a href="#boot-features-connecting-to-a-jndi-datasource">Connection to a JNDI DataSource</a></li>
</ul>
</li>
<li><a href="#boot-features-using-jdbc-template">2.10.2. Using JdbcTemplate</a></li>
<li><a href="#boot-features-jpa-and-spring-data">2.10.3. JPA and Spring Data JPA</a>
<ul class="sectlevel4">
<li><a href="#boot-features-entity-classes">Entity Classes</a></li>
<li><a href="#boot-features-spring-data-jpa-repositories">Spring Data JPA Repositories</a></li>
<li><a href="#boot-features-creating-and-dropping-jpa-databases">Creating and Dropping JPA Databases</a></li>
<li><a href="#boot-features-jpa-in-web-environment">Open EntityManager in View</a></li>
</ul>
</li>
<li><a href="#boot-features-data-jdbc">2.10.4. Spring Data JDBC</a></li>
<li><a href="#boot-features-sql-h2-console">2.10.5. Using H2&#8217;s Web Console</a>
<ul class="sectlevel4">
<li><a href="#boot-features-sql-h2-console-custom-path">Changing the H2 Console&#8217;s Path</a></li>
</ul>
</li>
<li><a href="#boot-features-jooq">2.10.6. Using jOOQ</a>
<ul class="sectlevel4">
<li><a href="#code-generation">Code Generation</a></li>
<li><a href="#using-dslcontext">Using DSLContext</a></li>
<li><a href="#jooq-sql-dialect">jOOQ SQL Dialect</a></li>
<li><a href="#customizing-jooq">Customizing jOOQ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-nosql">2.11. Working with NoSQL Technologies</a>
<ul class="sectlevel3">
<li><a href="#boot-features-redis">2.11.1. Redis</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-redis">Connecting to Redis</a></li>
</ul>
</li>
<li><a href="#boot-features-mongodb">2.11.2. MongoDB</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-mongodb">Connecting to a MongoDB Database</a></li>
<li><a href="#boot-features-mongo-template">MongoTemplate</a></li>
<li><a href="#boot-features-spring-data-mongodb-repositories">Spring Data MongoDB Repositories</a></li>
<li><a href="#boot-features-mongo-embedded">Embedded Mongo</a></li>
</ul>
</li>
<li><a href="#boot-features-neo4j">2.11.3. Neo4j</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-neo4j">Connecting to a Neo4j Database</a></li>
<li><a href="#boot-features-connecting-to-neo4j-embedded">Using the Embedded Mode</a></li>
<li><a href="#boot-features-neo4j-ogm-native-types">Using Native Types</a></li>
<li><a href="#boot-features-neo4j-ogm-session">Neo4jSession</a></li>
<li><a href="#boot-features-spring-data-neo4j-repositories">Spring Data Neo4j Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-solr">2.11.4. Solr</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-solr">Connecting to Solr</a></li>
<li><a href="#boot-features-spring-data-solr-repositories">Spring Data Solr Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-elasticsearch">2.11.5. Elasticsearch</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-elasticsearch-rest">Connecting to Elasticsearch using REST clients</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-reactive-rest">Connecting to Elasticsearch using Reactive REST clients</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-jest">Connecting to Elasticsearch using Jest</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-spring-data">Connecting to Elasticsearch by Using Spring Data</a></li>
<li><a href="#boot-features-spring-data-elasticsearch-repositories">Spring Data Elasticsearch Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-cassandra">2.11.6. Cassandra</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-cassandra">Connecting to Cassandra</a></li>
<li><a href="#boot-features-spring-data-cassandra-repositories">Spring Data Cassandra Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-couchbase">2.11.7. Couchbase</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-couchbase">Connecting to Couchbase</a></li>
<li><a href="#boot-features-spring-data-couchbase-repositories">Spring Data Couchbase Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-ldap">2.11.8. LDAP</a>
<ul class="sectlevel4">
<li><a href="#boot-features-ldap-connecting">Connecting to an LDAP Server</a></li>
<li><a href="#boot-features-ldap-spring-data-repositories">Spring Data LDAP Repositories</a></li>
<li><a href="#boot-features-ldap-embedded">Embedded In-memory LDAP Server</a></li>
</ul>
</li>
<li><a href="#boot-features-influxdb">2.11.9. InfluxDB</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-influxdb">Connecting to InfluxDB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-caching">2.12. Caching</a>
<ul class="sectlevel3">
<li><a href="#boot-features-caching-provider">2.12.1. Supported Cache Providers</a>
<ul class="sectlevel4">
<li><a href="#boot-features-caching-provider-generic">Generic</a></li>
<li><a href="#boot-features-caching-provider-jcache">JCache (JSR-107)</a></li>
<li><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></li>
<li><a href="#boot-features-caching-provider-hazelcast">Hazelcast</a></li>
<li><a href="#boot-features-caching-provider-infinispan">Infinispan</a></li>
<li><a href="#boot-features-caching-provider-couchbase">Couchbase</a></li>
<li><a href="#boot-features-caching-provider-redis">Redis</a></li>
<li><a href="#boot-features-caching-provider-caffeine">Caffeine</a></li>
<li><a href="#boot-features-caching-provider-simple">Simple</a></li>
<li><a href="#boot-features-caching-provider-none">None</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-messaging">2.13. Messaging</a>
<ul class="sectlevel3">
<li><a href="#boot-features-jms">2.13.1. JMS</a>
<ul class="sectlevel4">
<li><a href="#boot-features-activemq">ActiveMQ Support</a></li>
<li><a href="#boot-features-artemis">Artemis Support</a></li>
<li><a href="#boot-features-jms-jndi">Using a JNDI ConnectionFactory</a></li>
<li><a href="#boot-features-using-jms-sending">Sending a Message</a></li>
<li><a href="#boot-features-using-jms-receiving">Receiving a Message</a></li>
</ul>
</li>
<li><a href="#boot-features-amqp">2.13.2. AMQP</a>
<ul class="sectlevel4">
<li><a href="#boot-features-rabbitmq">RabbitMQ support</a></li>
<li><a href="#boot-features-using-amqp-sending">Sending a Message</a></li>
<li><a href="#boot-features-using-amqp-receiving">Receiving a Message</a></li>
</ul>
</li>
<li><a href="#boot-features-kafka">2.13.3. Apache Kafka Support</a>
<ul class="sectlevel4">
<li><a href="#boot-features-kafka-sending-a-message">Sending a Message</a></li>
<li><a href="#boot-features-kafka-receiving-a-message">Receiving a Message</a></li>
<li><a href="#boot-features-kafka-streams">Kafka Streams</a></li>
<li><a href="#boot-features-kafka-extra-props">Additional Kafka Properties</a></li>
<li><a href="#boot-features-embedded-kafka">Testing with Embedded Kafka</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-resttemplate">2.14. 使用 <code>RestTemplate</code> 调用REST服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-resttemplate-customization">2.14.1. RestTemplate自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-webclient">2.15. 使用 <code>WebClient</code> 调用REST服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-webclient-runtime">2.15.1. WebClient运行时</a></li>
<li><a href="#boot-features-webclient-customization">2.15.2. WebClient自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-validation">2.16. 验证</a></li>
<li><a href="#boot-features-email">2.17. 发送邮件</a></li>
<li><a href="#boot-features-jta">2.18. JTA的分布式事务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-jta-atomikos">2.18.1. 使用Atomikos事务管理器</a></li>
<li><a href="#boot-features-jta-bitronix">2.18.2. 使用Bitronix事务管理器</a></li>
<li><a href="#boot-features-jta-javaee">2.18.3. 使用Java EE托管事务管理器</a></li>
<li><a href="#boot-features-jta-mixed-jms">2.18.4. 混合XA和非XA JMS连接</a></li>
<li><a href="#boot-features-jta-supporting-alternative-embedded">2.18.5. 支持替代嵌入式事务管理器</a></li>
</ul>
</li>
<li><a href="#boot-features-hazelcast">2.19. Hazelcast</a></li>
<li><a href="#boot-features-quartz">2.20. Quartz调度器</a></li>
<li><a href="#boot-features-task-execution-scheduling">2.21. 任务执行和调度</a></li>
<li><a href="#boot-features-integration">2.22. Spring Integration</a></li>
<li><a href="#boot-features-session">2.23. Spring Session</a></li>
<li><a href="#boot-features-jmx">2.24. 通过JMX进行监视和管理</a></li>
<li><a href="#boot-features-testing">2.25. 测试</a></li>
<li><a href="#boot-features-websockets">2.26. WebSockets</a></li>
<li><a href="#boot-features-webservices">2.27. Web服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-webservices-template">2.27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-auto-configuration">2.28. 创建自己的自动配置</a>
<ul class="sectlevel3">
<li><a href="#boot-features-understanding-auto-configured-beans">2.28.1. 了解自动配置的Bean</a></li>
<li><a href="#boot-features-locating-auto-configuration-candidates">2.28.2. 查找自动配置候选人</a></li>
<li><a href="#boot-features-condition-annotations">2.28.3. 条件注解</a>
<ul class="sectlevel4">
<li><a href="#boot-features-class-conditions">Class条件</a></li>
<li><a href="#boot-features-bean-conditions">Bean条件</a></li>
<li><a href="#boot-features-property-conditions">Property条件</a></li>
<li><a href="#boot-features-resource-conditions">Resource条件</a></li>
<li><a href="#boot-features-web-application-conditions">Web应用条件</a></li>
<li><a href="#boot-features-spel-conditions">SpEL表达式条件</a></li>
</ul>
</li>
<li><a href="#boot-features-test-autoconfig">2.28.4. 测试你的自动配置</a>
<ul class="sectlevel4">
<li><a href="#模拟一个web上下文">模拟一个Web上下文</a></li>
<li><a href="#覆盖类路径">覆盖类路径</a></li>
</ul>
</li>
<li><a href="#boot-features-custom-starter">2.28.5. 创建自己的Starter</a>
<ul class="sectlevel4">
<li><a href="#boot-features-custom-starter-naming">命名</a></li>
<li><a href="#boot-features-custom-starter-configuration-keys">配置键</a></li>
<li><a href="#boot-features-custom-starter-module-autoconfigure"><code>autoconfigure</code> 模块</a></li>
<li><a href="#boot-features-custom-starter-module-starter">starter模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-whats-next">2.29. 接下来要读什么</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="using-boot">1. Spring Boot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节将详细介绍如何使用Spring Boot。它涵盖了诸如构建系统，自动配置以及如何运行应用程序之类的主题。
我们还将介绍一些Spring Boot最佳实践。尽管Spring Boot并没有什么特别的地方（它只是另一个可以使用的库），
但是有一些建议可以使你的开发过程更轻松一些。</p>
</div>
<div class="sect2">
<h3 id="using-boot-build-systems">1.1. 构建系统</h3>
<div class="paragraph">
<p>强烈建议你选择一个支持<a href="#using-boot-dependency-management"><em>依赖关系管理</em></a>并且可以使用发布到“ Maven Central”存储库的工件的构建系统。
我们建议你选择Maven或Gradle。可以使Spring Boot与其他构建系统（例如，Ant）一起使用，但是它们并没有得到很好的支持。</p>
</div>
<div class="sect3">
<h4 id="using-boot-dependency-management">1.1.1. 依赖管理</h4>
<div class="paragraph">
<p>每个Spring Boot版本都提供了它所支持的依赖关系的精选列表。实际上，你不需要为构建配置中的所有这些依赖项提供版本，
因为Spring Boot会为你管理该版本。当你升级Spring Boot本身时，这些依赖项也会以一致的方式升级。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你仍然可以指定版本，并在需要时覆盖Spring Boot的建议版本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>精选列表包含可与Spring Boot一起使用的所有spring模块以及完善的第三方库列表。
该列表作为可与<a href="#using-boot-maven-parent-pom">Maven</a>和<a href="#using-boot-gradle">Gradle</a>
一起使用的<a href="#using-boot-maven-without-a-parent">标准物料清单(<code>spring-boot-dependencies</code>)</a>提供。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Spring Boot的每个发行版都与Spring Framework的基本版本相关联。<strong>强烈</strong> 建议你不要更改其版本。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-maven">1.1.2. Maven</h4>
<div class="paragraph">
<p>Maven用户可以从 <code>spring-boot-starter-parent</code> 项目继承来获得合理的默认值。父项目提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 1.8是默认的编译器级别。</p>
</li>
<li>
<p>UTF-8源编码。</p>
</li>
<li>
<p>从spring-boot-dependencies pom继承的<a href="#using-boot-dependency-management">依赖管理部分</a>，
它管理公共依赖项的版本。当在自己的pom中使用这些依赖关系时，可以为这些依赖关系省略 <code>&lt;version&gt;</code> 标记。</p>
</li>
<li>
<p>使用 <code>repackage</code> 执行id执行 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/maven-plugin//repackage-mojo.html"><code>repackage</code> 目标</a>。</p>
</li>
<li>
<p>明智的 <a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">资源过滤</a>.</p>
</li>
<li>
<p>明智的插件配置 (<a href="https://www.mojohaus.org/exec-maven-plugin/">exec plugin</a>,
<a href="https://github.com/ktoso/maven-git-commit-id-plugin">Git commit ID</a> 和
<a href="https://maven.apache.org/plugins/maven-shade-plugin/">shade</a>).</p>
</li>
<li>
<p>对 <code>application.properties</code> 和 <code>application.yml</code> 进行明智的资源过滤，包括特定于环境的文件
（例如：<code>application-dev.properties</code> 和 <code>application-dev.yml</code>）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，由于 <code>application.properties</code> 和 <code>application.yml</code> 文件接受Spring样式的占位符（<code>${&#8230;&#8203;}</code>），
因此Maven过滤已更改为使用 <code>@..@</code> 占位符。（你可以通过设置一个名为 <code>resource.delimiter</code> 的Maven属性来覆盖它。）</p>
</div>
<div class="sect4">
<h5 id="using-boot-maven-parent-pom">继承Starter Parent</h5>
<div class="paragraph">
<p>要将项目配置为从 <code>spring-boot-starter-parent</code> 继承，请设置 <code>parent</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- Inherit defaults from Spring Boot --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
&lt;/parent&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你只需要为此依赖项指定Spring Boot版本号。如果导入其他starter，则可以安全地省略版本号。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用该设置，你还可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，要升级到另一个Spring Data发布系列，
可以将以下内容添加到 <code>pom.xml</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;properties&gt;
    &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;
&lt;/properties&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
检查 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code> pom</a>以获取受支持属性的列表。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-maven-without-a-parent">在没有父POM的情况下使用Spring Boot</h5>
<div class="paragraph">
<p>并非每个人都喜欢从 <code>spring-boot-starter-parent</code> 父POM继承。你可能需要使用自己公司的标准父POM，或者可能希望显式声明所有Maven配置。</p>
</div>
<div class="paragraph">
<p>如果你不想使用 <code>spring-boot-starter-parent</code>，仍然可以通过使用 <code>scope=import</code> 依赖项来保留依赖项管理（而不是插件管理）的好处，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;!-- Import dependency management from Spring Boot --&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所述，前面的示例设置不允许你使用属性来覆盖各个依赖项。为了获得相同的结果，
需要在项目的 <code>dependencyManagement</code> 中 <code>spring-boot-dependencies</code> 条目 <strong>之前</strong> 添加一个条目。
例如，要升级到另一个Spring Data发布系列，可以将以下元素添加到 <code>pom.xml</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;!-- Override Spring Data release train provided by Spring Boot --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
            &lt;version&gt;Fowler-SR2&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在前面的示例中，我们指定了 <em>BOM</em>，但是可以以相同方式覆盖任何依赖项类型。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-maven-plugin">使用Spring Boot Maven插件</h5>
<div class="paragraph">
<p>Spring Boot包含一个 <a href="build-tool-plugins.html#build-tool-plugins-maven-plugin">Maven插件</a>，
可以将项目打包为可执行jar。如果要使用插件，请将其添加到你的 <code>&lt;plugins&gt;</code> 部分，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用Spring Boot starter parent pom，则只需添加插件。除非你要更改父级中定义的设置，否则无需对其进行配置。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-gradle">1.1.3. Gradle</h4>
<div class="paragraph">
<p>要了解有关将Spring Boot与Gradle结合使用的信息，请参阅Spring Boot的Gradle插件的文档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>参考（ <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/html/">HTML</a> 和 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf">PDF</a>）</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/api/">API</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-ant">1.1.4. Ant</h4>
<div class="paragraph">
<p>可以使用Apache Ant+Ivy构建Spring Boot项目。<code>spring-boot-antlib</code> “<code>AntLib</code>”模块也可用于帮助Ant创建可执行jar。</p>
</div>
<div class="paragraph">
<p>为了声明依赖关系，典型的 <code>ivy.xml</code> 文件看起来类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ivy-module version="2.0"&gt;
    &lt;info organisation="org.springframework.boot" module="spring-boot-sample-ant" /&gt;
    &lt;configurations&gt;
        &lt;conf name="compile" description="everything needed to compile this module" /&gt;
        &lt;conf name="runtime" extends="compile" description="everything needed to run this module" /&gt;
    &lt;/configurations&gt;
    &lt;dependencies&gt;
        &lt;dependency org="org.springframework.boot" name="spring-boot-starter"
            rev="${spring-boot.version}" conf="compile" /&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>典型的 <code>build.xml</code> 类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;project
    xmlns:ivy="antlib:org.apache.ivy.ant"
    xmlns:spring-boot="antlib:org.springframework.boot.ant"
    name="myapp" default="build"&gt;

    &lt;property name="spring-boot.version" value="2.2.2.RELEASE" /&gt;

    &lt;target name="resolve" description="--&gt; retrieve dependencies with ivy"&gt;
        &lt;ivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" /&gt;
    &lt;/target&gt;

    &lt;target name="classpaths" depends="resolve"&gt;
        &lt;path id="compile.classpath"&gt;
            &lt;fileset dir="lib/compile" includes="*.jar" /&gt;
        &lt;/path&gt;
    &lt;/target&gt;

    &lt;target name="init" depends="classpaths"&gt;
        &lt;mkdir dir="build/classes" /&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="init" description="compile"&gt;
        &lt;javac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" /&gt;
    &lt;/target&gt;

    &lt;target name="build" depends="compile"&gt;
        &lt;spring-boot:exejar destfile="build/myapp.jar" classes="build/classes"&gt;
            &lt;spring-boot:lib&gt;
                &lt;fileset dir="lib/runtime" /&gt;
            &lt;/spring-boot:lib&gt;
        &lt;/spring-boot:exejar&gt;
    &lt;/target&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想使用 <code>spring-boot-antlib</code> 模块，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-build-an-executable-archive-with-ant">不使用spring-boot-antlib “<code>How-to</code>”从Ant构建可执行存档</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-starter">1.1.5. Starters</h4>
<div class="paragraph">
<p>启动器是一组便捷的依赖项描述符，你可以在应用程序中包括它们。你可以一站式安装所需的所有Spring和相关技术，
而不必遍历示例代码和依赖描述符复制粘贴它。例如，如果要开始使用Spring和JPA进行数据库访问，请在项目中包括 <code>spring-boot-starter-data-jpa</code> 依赖项。</p>
</div>
<div class="paragraph">
<p>启动器包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的被管理的传递性依赖项。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">名字叫什么</div>
<div class="paragraph">
<p>所有 <strong>official</strong> 启动器都遵循类似的命名方式。<code>spring-boot-starter-*</code>，其中 <code>*</code> 是特定类型的应用程序。
这种命名结构旨在在你需要寻找启动器时提供帮助。许多IDE中的Maven集成使你可以按名称搜索依赖项。
例如，在安装了适当的Eclipse或STS插件的情况下，你可以在POM编辑器中按 <code>ctrl-space</code> 并键入“<code>spring-boot-starter</code>”以获取完整启动器列表。</p>
</div>
<div class="paragraph">
<p>如“<a href="spring-boot-features.html#boot-features-custom-starter">创建自己的启动器</a>”部分中所述，
第三方starters不应以 <code>spring-boot</code> 开始，因为它是为Spring Boot官方工件保留的。
而是，第三方启动程序通常以项目名称开头。例如，一个名为 <code>thirdpartyproject</code> 的第三方启动程序项目通常会被命名为
<code>thirdpartyproject-spring-boot-starter</code>。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Boot在 <code>org.springframework.boot</code> 组下提供了以下应用程序启动器：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Spring Boot application starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">核心启动器，包括自动配置支持，日志记录和YAML</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-activemq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache ActiveMQ的JMS消息传递启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-activemq/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-amqp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring AMQP和Rabbit MQ的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-amqp/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-aop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring AOP和AspectJ进行面向方面编程的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-aop/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-artemis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache Artemis的JMS消息传递启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-artemis/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-batch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Batch的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-batch/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-cache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework缓存支持的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cache/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-cloud-connectors</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Cloud Connectors的启动器，可简化与Cloud Foundry和Heroku等云平台中服务的连接。不赞成使用Java CFEnv</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cloud-connectors/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-cassandra</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Cassandra分布式数据库和Spring Data Cassandra的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-cassandra-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Cassandra分布式数据库和Spring Data Cassandra Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-couchbase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Couchbase面向文档的数据库和Spring Data Couchbase的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-couchbase-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Couchbase面向文档的数据库和Spring Data Couchbase Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-elasticsearch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Elasticsearch搜索和分析引擎以及Spring Data Elasticsearch的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-elasticsearch/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-jdbc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data JDBC的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jdbc/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-data-jpa"></a> <code>spring-boot-starter-data-jpa</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Spring Data JPA与Hibernate结合使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jpa/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-ldap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data LDAP的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-ldap/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-mongodb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用MongoDB面向文档的数据库和Spring Data MongoDB的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-mongodb-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用MongoDB面向文档的数据库和Spring Data MongoDB Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-neo4j</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Neo4j图数据库和Spring Data Neo4j的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-neo4j/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-redis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Redis键值对数据库与Spring Data Redis和Lettuce客户端一起使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-redis-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Redis键值对数据库与Spring Data Redis Reacting和Lettuce客户端一起使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-rest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data REST在REST上公开Spring Data存储库的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-rest/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-solr</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache Solr搜索平台和Spring Data Solr的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-solr/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-freemarker</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用FreeMarker视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-freemarker/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-groovy-templates</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Groovy模板视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-groovy-templates/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-hateoas</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-hateoas/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-integration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Integration的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-integration/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-jdbc"></a> <code>spring-boot-starter-jdbc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过HikariCP连接池使用JDBC的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jdbc/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jersey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用JAX-RS和Jersey构建RESTful Web应用程序的启动器。
  <a href="#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jersey/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jooq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用jOOQ访问SQL数据库的启动器。
  <a href="#spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></a>或
  <a href="#spring-boot-starter-jdbc"><code>spring-boot-starter-jdbc</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jooq/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-json</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写JSON的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-json/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jta-atomikos</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Atomikos的JTA事务启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-atomikos/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jta-bitronix</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Bitronix的JTA事务启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-bitronix/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-mail</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Java Mail和Spring Framework的电子邮件发送支持的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mail/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-mustache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Mustache视图构建Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mustache/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-oauth2-client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的OAuth2/OpenID Connect客户端功能的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-client/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-oauth2-resource-server</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的OAuth2资源服务器功能的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-resource-server/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-quartz</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Quartz Scheduler的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-quartz/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-rsocket</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于构建RSocket客户端和服务器的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-rsocket/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-security</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-security/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-test</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用包括JUnit，Hamcrest和Mockito在内的库测试Spring Boot应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-test/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-thymeleaf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Thymeleaf视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-thymeleaf/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-validation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过Hibernate Validator使用Java Bean验证的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-validation/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-web"></a> <code>spring-boot-starter-web</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring MVC构建Web（包括RESTful）应用程序的启动器。使用Tomcat作为默认的嵌入式容器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-web-services</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Web Services的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web-services/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-webflux</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework的响应式Web支持构建WebFlux应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-webflux/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-websocket</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework的WebSocket支持构建WebSocket应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-websocket/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了应用程序启动程序，以下启动程序可用于添加 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em> 功能：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Spring Boot production starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-actuator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Boot的Actuator的启动器，它提供了生产就绪功能，可帮助您监视和管理应用程序</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>最后，Spring Boot还包括以下启动程序，如果你想排除或替换特定的技术方面，可以使用这些启动程序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Spring Boot technical starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jetty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Jetty作为嵌入式servlet容器的启动器。<a href="#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-log4j2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Log4j2进行日志记录的启动器。<a href="#spring-boot-starter-logging"><code>spring-boot-starter-logging</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-logging"></a> <code>spring-boot-starter-logging</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Logback进行日志记录的启动器。默认日志记录启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-reactor-netty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Reactor Netty作为嵌入式响应式HTTP服务器的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-tomcat"></a> <code>spring-boot-starter-tomcat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于将Tomcat用作嵌入式servlet容器的启动器。<a href="#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>使用的默认servlet容器启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-undertow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Undertow作为嵌入式servlet容器的启动器。<a href="#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关社区贡献的其他启动程序的列表，请参阅GitHub上 <code>spring-boot-starters</code> 模块中的
<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/README.adoc">README文件</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-structuring-your-code">1.2. 结构化你的代码</h3>
<div class="paragraph">
<p>Spring Boot不需要任何特定的代码布局即可工作。但是，有一些最佳做法对你会有所帮助。</p>
</div>
<div class="sect3">
<h4 id="using-boot-using-the-default-package">1.2.1. 使用“<code>default</code>”包</h4>
<div class="paragraph">
<p>当类不包含 <code>package</code> 声明时，将其视为在“<code>default package</code>”中。通常不建议使用“<code>default package</code>”，应避免使用。
对于使用 <code>@ComponentScan</code>，<code>@ConfigurationPropertiesScan</code>，<code>@EntityScan</code> 或 <code>@SpringBootApplication</code>
注解的Spring Boot应用程序，这可能会引起特定的问题，因为每个jar中的每个类都会被读取。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议你遵循Java建议的程序包命名约定，并使用反向域名（例如：<code>com.example.project</code>）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-locating-the-main-class">1.2.2. 找到应用程序主类</h4>
<div class="paragraph">
<p>我们通常建议你将应用程序主类放在其他类之上的根包中。<a href="#using-boot-using-springbootapplication-annotation"><code>@SpringBootApplication</code> 注解</a>通常放在你的主类上，它隐式定义某些条目的基本“<code>search package</code>”。
例如，如果你正在编写JPA应用程序，则使用带 <code>@SpringBootApplication</code> 注解的类的包来搜索 <code>@Entity</code> 条目。
使用根软件包还允许组件扫描仅应用于你的项目。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你不想使用 <code>@SpringBootApplication</code>，则可以通过导入的
<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 注解来定义该行为，因此也可以使用它们。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下清单显示了典型的布局：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>com
 +- example
     +- myapplication
         +- Application.java
         |
         +- customer
         |   +- Customer.java
         |   +- CustomerController.java
         |   +- CustomerService.java
         |   +- CustomerRepository.java
         |
         +- order
             +- Order.java
             +- OrderController.java
             +- OrderService.java
             +- OrderRepository.java</pre>
</div>
</div>
<div class="paragraph">
<p><code>Application.java</code> 文件将声明 <code>main</code> 方法以及基本的 <code>@SpringBootApplication</code> 注解，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-configuration-classes">1.3. 配置类</h3>
<div class="paragraph">
<p>Spring Boot支持基于Java的配置。尽管可以将 <code>SpringApplication</code> 与XML源一起使用，但是我们通常建议你的主要源为单个
<code>@Configuration</code> 类。通常，定义 <code>main</code> 方法的类是首选的 <code>@Configuration</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在互联网上已经发布了许多使用XML配置的Spring配置示例。如果可能，请始终尝试使用等效的基于Java的配置。
搜索 <code>Enable*</code> 注解可能是一个不错的起点。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-importing-configuration">1.3.1. 导入其他配置类</h4>
<div class="paragraph">
<p>你无需将所有 <code>@Configuration</code> 放在单个类中。<code>@Import</code> 注解可用于导入其他配置类。
另外，你可以使用 <code>@ComponentScan</code> 自动拾取所有Spring组件，包括 <code>@Configuration</code> 类。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-importing-xml-configuration">1.3.2. 导入XML配置</h4>
<div class="paragraph">
<p>如果绝对必须使用基于XML的配置，我们建议你仍然从 <code>@Configuration</code> 类开始。然后使用 <code>@ImportResource</code> 注解来加载XML配置文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-auto-configuration">1.4. 自动配置</h3>
<div class="paragraph">
<p>Spring Boot自动配置会尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果 <code>HSQLDB</code> 在类路径上，
并且你尚未手动配置任何数据库连接bean，则Spring Boot会自动配置内存数据库。</p>
</div>
<div class="paragraph">
<p>你需要通过将 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解添加到你的 <code>@Configuration</code>
类之一来启用自动配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你应该只添加一个 <code>@SpringBootApplication</code> 或 <code>@EnableAutoConfiguration</code> 注解。
我们通常建议你仅将它们中的一个添加到你的主要 <code>@Configuration</code> 类中。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-replacing-auto-configuration">1.4.1. 逐渐取代自动配置</h4>
<div class="paragraph">
<p>自动配置是非侵入性的。在任何时候，你都可以开始定义自己的配置，以替换自动配置的特定部分。
例如，如果你添加自己的 <code>DataSource</code> bean，则默认的嵌入式数据库支持将回退。</p>
</div>
<div class="paragraph">
<p>如果你需要了解当前正在应用哪些自动配置以及原因，请使用 <code>--debug</code> 开关启动你的应用程序。
这样做可以启用调试日志以供选择核心记录器，并将条件报告记录到控制台。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-disabling-specific-auto-configuration">1.4.2. 禁用特定的自动配置类</h4>
<div class="paragraph">
<p>如果发现正在应用某个不需要的特定自动配置类，则可以使用 <code>@EnableAutoConfiguration</code> 的 <code>exclude</code> 属性禁用它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果该类不在类路径中，则可以使用注解的 <code>excludeName</code> 属性，并指定完全限定的名称。最后，你还可以使用
<code>spring.autoconfigure.exclude</code> 属性控制要排除的自动配置类的列表。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以在注解级别和使用属性来定义排除项。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
即使自动配置类是 <code>public</code>，类中唯一被认为是公共API的是类的名称，它可以用来禁用自动配置。
这些类的实际内容（例如：嵌套配置类或Bean方法）仅供内部使用，我们不建议直接使用它们。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-spring-beans-and-dependency-injection">1.5. Spring Beans和依赖注入</h3>
<div class="paragraph">
<p>你可以自由使用任何标准的Spring Framework技术来定义bean及其注入依赖关系。为简单起见，我们经常发现使用
<code>@ComponentScan</code>（查找你的bean）和使用 <code>@Autowired</code>（进行构造函数注入）效果很好。</p>
</div>
<div class="paragraph">
<p>如果按照上面的建议构造代码（将应用程序类放在根包中），则可以添加 <code>@ComponentScan</code>，而无需添加任何参数。
你的所有应用程序组件（<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等）都将自动注册为Spring Bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个 <code>@Service</code> Bean，它使用构造函数注入来获取所需的 <code>RiskAssessor</code> Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果bean具有一个构造函数，则可以省略 <code>@Autowired</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
请注意如何使用构造函数注入将 <code>riskAssessor</code> 字段标记为 <code>final</code>，以表示它随后不能更改。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-using-springbootapplication-annotation">1.6. 使用@SpringBootApplication注解</h3>
<div class="paragraph">
<p>许多Spring Boot开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。
单个 <code>@SpringBootApplication</code> 注解可用于同时启用这三个功能，即：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@EnableAutoConfiguration</code>: 启用<a href="#using-boot-auto-configuration">Spring Boot的自动配置机制</a></p>
</li>
<li>
<p>在应用程序所在的软件包上启用 <code>@Component</code> 扫描（请参阅<a href="#using-boot-structuring-your-code">最佳实践</a>）</p>
</li>
<li>
<p><code>@Configuration</code>: 允许在上下文中注册额外的bean或导入其他配置类</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@SpringBootApplication</code> 还提供别名以自定义 <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 的属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些功能都不是强制性的，你可以选择用它启用的任何功能替换这个单个注解。例如，你可能不想在应用程序中使用组件扫描或配置属性扫描：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@Import({ MyConfig.class, MyAnotherConfig.class })
public class Application {

    public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，除了没有自动检测到 <code>@Component</code> 和 <code>@ConfigurationProperties</code> 注解的类并且显式导入了用户定义的Bean外，
<code>Application</code> 就像其他任何Spring Boot应用程序一样（请参阅 <code>@Import</code>）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-running-your-application">1.7. 运行你的应用程序</h3>
<div class="paragraph">
<p>将应用程序打包为jar并使用嵌入式HTTP服务器的最大优势之一是，你可以像运行其他应用程序一样运行应用程序。
调试Spring Boot应用程序也很容易。你不需要任何特殊的IDE插件或扩展。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本节仅介绍基于jar的包装。如果选择将应用程序打包为war文件，则应参考服务器和IDE文档。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-running-from-an-ide">1.7.1. 从IDE运行</h4>
<div class="paragraph">
<p>你可以将IDE中的Spring Boot应用程序作为简单的Java应用程序运行。但是，你首先需要导入你的项目。
导入步骤因你的IDE和构建系统而异。大多数IDE可以直接导入Maven项目。例如：Eclipse用户可以从 <code>File</code> 中选择 <code>Import&#8230;&#8203;</code> &#8594; <code>Existing Maven Projects</code>。</p>
</div>
<div class="paragraph">
<p>如果你不能直接将项目导入IDE，则可以使用构建插件生成IDE元数据。Maven包括用于
<a href="https://maven.apache.org/plugins/maven-eclipse-plugin/">Eclipse</a> 和 <a href="https://maven.apache.org/plugins/maven-idea-plugin/">IDEA</a>的插件。
Gradle提供了用于 <a href="https://docs.gradle.org/current/userguide/userguide.html">各种IDE</a>的插件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不小心两次运行Web应用程序，则会看到“<code>Port already in use</code>”错误。
STS用户可以使用 <code>Relaunch</code> 按钮而不是 <code>Run</code> 按钮来确保关闭任何现有实例。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-as-a-packaged-application">1.7.2. 作为打包的应用程序运行</h4>
<div class="paragraph">
<p>如果使用Spring Boot Maven或Gradle插件创建可执行jar，则可以使用 <code>java -jar</code> 运行应用程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
<div class="paragraph">
<p>也可以在启用了远程调试支持的情况下运行打包的应用程序。这样做使你可以将调试器附加到打包的应用程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myapplication-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-with-the-maven-plugin">1.7.3. 使用Maven插件</h4>
<div class="paragraph">
<p>Spring Boot Maven插件包含一个 <code>run</code> 目标，可用于快速编译和运行你的应用程序。应用程序以爆炸形式运行，就像在IDE中一样。
以下示例显示了运行Spring Boot应用程序的典型Maven命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ mvn spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>你可能还想使用 <code>MAVEN_OPTS</code> 操作系统环境变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ export MAVEN_OPTS=-Xmx1024m</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-with-the-gradle-plugin">1.7.4. 使用Gradle插件</h4>
<div class="paragraph">
<p>Spring Boot Gradle插件包含一个 <code>bootRun</code> 任务，该任务可用于以爆炸形式运行你的应用程序。每当你应用
<code>org.springframework.boot</code> 和 <code>java</code> 插件时，都会添加 <code>bootRun</code> 任务，在以下示例中显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle bootRun</pre>
</div>
</div>
<div class="paragraph">
<p>你可能还想使用 <code>JAVA_OPTS</code> 操作系统环境变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ export JAVA_OPTS=-Xmx1024m</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-hot-swapping">1.7.5. 热交换</h4>
<div class="paragraph">
<p>由于Spring Boot应用程序只是普通的Java应用程序，因此JVM热交换应该可以立即使用。
JVM热交换在一定程度上受到它可以替换的字节码的限制。对于更完整的解决方案，可以使用 <a href="https://jrebel.com/software/jrebel/">JRebel</a>。</p>
</div>
<div class="paragraph">
<p><code>spring-boot-devtools</code> 模块还包括对应用程序快速重启的支持。有关详细信息，请参见本章后面的<a href="#using-boot-devtools">开发者工具</a>部分和
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle#howto-hotswapping">&#8220;How-to&#8221; 热交换</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-devtools">1.8. 开发者工具</h3>
<div class="paragraph">
<p>Spring Boot包含一组额外的工具，这些工具可以使应用程序开发体验更加愉快。
<code>spring-boot-devtools</code> 模块可以包含在任何项目中，以提供其他开发时功能。要包括devtools支持，
请将模块依赖项添加到你的构建中，如以下Maven和Gradle清单所示：</p>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">configurations {
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
}
dependencies {
    developmentOnly("org.springframework.boot:spring-boot-devtools")
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
运行完全打包的应用程序时，将自动禁用开发者工具。如果你的应用程序是以 <code>java -jar</code> 启动的，
或者是从特殊的类加载器启动的，则将其视为“<code>生产应用程序</code>”。如果这不适用于你（即如果你从容器中运行应用程序），
请考虑排除devtools或设置 <code>-Dspring.devtools.restart.enabled=false</code> 系统属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在Maven中将依赖项标记为optional或在Gradle中使用自定义 <code>developmentOnly</code> 配置（如上所示）是一种最佳实践，
它可以防止将devtools过渡地应用到使用你项目的其他模块。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
重新打包的存档默认情况下不包含devtools。如果要使用<a href="#using-boot-devtools-remote">某个远程devtools功能</a>，
则需要禁用 <code>excludeDevtools</code> 构建属性以包括它。Maven和Gradle插件均支持该属性。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-property-defaults">1.8.1. 属性默认值</h4>
<div class="paragraph">
<p>Spring Boot支持的一些库使用缓存来提高性能。例如：<a href="spring-boot-features.html#boot-features-spring-mvc-template-engines">模板引擎</a>缓存已编译的模板，以避免重复解析模板文件。
另外，Spring MVC可以在提供静态资源时向响应添加HTTP缓存头。</p>
</div>
<div class="paragraph">
<p>尽管缓存在生产中非常有益，但在开发过程中可能适得其反，从而使你无法看到刚刚在应用程序中所做的更改。因此，默认情况下，<code>spring-boot-devtools</code> 禁用缓存选项。</p>
</div>
<div class="paragraph">
<p>缓存选项通常由 <code>application.properties</code> 文件中的设置配置。例如，Thymeleaf提供 <code>spring.thymeleaf.cache</code> 属性。
<code>spring-boot-devtools</code> 模块不需要手动设置这些属性，而是自动应用合理的开发时配置。</p>
</div>
<div class="paragraph">
<p>由于在开发Spring MVC和Spring WebFlux应用程序时需要有关Web请求的更多信息，因此开发者工具将为 <code>web</code> 日志记录组启用 <code>DEBUG</code> 日志记录。
这将为你提供有关传入请求，正在处理的处理程序，响应结果等的信息。如果你希望记录所有请求详细信息（包括潜在的敏感信息），
则可以打开 <code>spring.http.log-request-details</code> 配置属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你不希望应用默认属性，则可以在 <code>application.properties</code> 中将 <code>spring.devtools.add-properties</code> 设置为 <code>false</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关devtools应用的属性完整列表，请参见
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java">DevToolsPropertyDefaultsPostProcessor</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-restart">1.8.2. 自动重启</h4>
<div class="paragraph">
<p>每当classpath上的文件更改时，使用 <code>spring-boot-devtools</code> 的应用程序都会自动重新启动。在IDE中工作时，
这可能是一个有用的功能，因为它为代码更改提供了非常快速的反馈循环。默认情况下，
将监视类路径上指向文件夹的任何条目的更改。请注意，某些资源（例如静态资产和视图模板）
<a href="#using-boot-devtools-restart-exclude">不需要重新启动应用程序</a>。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">触发重启</div>
<div class="paragraph">
<p>当DevTools监视类路径资源时，触发重启的唯一方法是更新类路径。导致类路径更新的方式取决于所使用的IDE。
在Eclipse中，保存修改后的文件将导致类路径被更新并触发重新启动。
在IntelliJ IDEA中，构建项目（<code>Build -&gt; Build Project</code>）具有相同的效果。</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只要启用了forking，你还可以使用受支持的构建插件（Maven和Gradle）启动应用程序，
因为DevTools需要一个隔离的应用程序类加载器才能正常运行。默认情况下，Gradle和Maven插件会fork应用程序进程。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
与LiveReload一起使用时，自动重启非常有效。有关详细信息，请参见<a href="#using-boot-devtools-livereload">LiveReload部分</a>。
如果使用JRebel，则禁用自动重新启动，而支持动态类重新加载。其他devtools功能（例如LiveReload和属性覆盖）仍可以使用。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DevTools依赖于应用程序上下文的关闭钩子在重新启动期间将其关闭。如果你禁用了关闭钩子
（<code>SpringApplication.setRegisterShutdownHook(false)</code>），它将无法正常工作。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在确定类路径上的条目是否应在更改后触发重新启动时，DevTools会自动忽略名为 <code>spring-boot</code>，
<code>spring-boot-devtools</code>，<code>spring-boot-autoconfigure</code>，<code>spring-boot-actuator</code> 和 <code>spring-boot-starter</code> 的项目。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DevTools需要自定义 <code>ApplicationContext</code> 使用的 <code>ResourceLoader</code>。如果你的应用程序已经提供了，它将被包装。
不支持在 <code>ApplicationContext</code> 上直接重写 <code>getResource</code> 方法。
</td>
</tr>
</table>
</div>
<div id="using-spring-boot-restart-vs-reload" class="sidebarblock">
<div class="content">
<div class="title">重新启动 vs 重新加载</div>
<div class="paragraph">
<p>Spring Boot提供的重启技术通过使用两个类加载器来工作。不变的类（例如：来自第三方jar的类）将被加载到 <em>基本</em> 类加载器中。
你正在积极开发的类将加载到 <em>重启</em> 类加载器中。重新启动应用程序时，将丢弃 <em>重启</em> 类加载器，并创建一个新的类加载器。
这种方法意味着应用程序的重启通常比“<code>冷启动</code>”要快得多，因为 <em>基本</em> 类加载器已经可用并已填充完毕。</p>
</div>
<div class="paragraph">
<p>如果发现重新启动对于你的应用程序来说不够快，或者遇到类加载问题，则可以考虑使用ZeroTurnaround重新加载技术，例如：
<a href="https://jrebel.com/software/jrebel/">JRebel</a>。这些方法通过在加载类时重写类来使其更易于重新加载。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-logging-condition-delta">记录条件评估中的更改</h5>
<div class="paragraph">
<p>默认情况下，每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量变化。
该报告显示了你进行代码更改（例如：添加或删除Bean以及设置配置属性）时所造成的对应用程序自动配置的更改。</p>
</div>
<div class="paragraph">
<p>要禁用报告的日志记录，请设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.devtools.restart.log-condition-evaluation-delta=false</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-exclude">排除资源</h5>
<div class="paragraph">
<p>某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf模板可以就地编辑。默认情况下，
更改 <code>/META-INF/maven</code>，<code>/META-INF/resources</code>，<code>/resources</code>，<code>/static</code>，<code>/public</code> 或 <code>/templates</code>
中的资源不会触发重新启动，但会触发<a href="#using-boot-devtools-livereload">实时重新加载</a>。如果要自定义这些排除项，则可以使用
<code>spring.devtools.restart.exclude</code> 属性。例如：仅排除 <code>/static</code> 和 <code>/public</code>，可以设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.devtools.restart.exclude=static/**,public/**</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要保留这些默认值并 <em>添加</em> 其他排除项，请改用 <code>spring.devtools.restart.additional-exclude</code> 属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-additional-paths">监视其他路径</h5>
<div class="paragraph">
<p>当你对不在类路径上的文件进行更改时，你可能希望重新启动或重新加载应用程序。为此，
请使用 <code>spring.devtools.restart.additional-paths</code> 属性配置其他路径以监视更改。
你可以使用<a href="#using-boot-devtools-restart-exclude">前面所述</a>的 <code>spring.devtools.restart.exclude</code>
属性来控制其他路径下的更改是触发完全重启还是<a href="#using-boot-devtools-livereload">实时重新加载</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-disable">禁用重启</h5>
<div class="paragraph">
<p>如果你不想使用重新启动功能，则可以使用 <code>spring.devtools.restart.enabled</code> 属性将其禁用。在大多数情况下，你可以在
<code>application.properties</code> 中设置此属性（这样做仍会初始化重启类加载器，但它不会监视文件更改）。</p>
</div>
<div class="paragraph">
<p>如果你需要 <em>完全</em> 禁用重启支持（例如：因为它不适用于特定的库），则需要在调用 <code>SpringApplication.run(&#8230;&#8203;)</code> 之前将
<code>spring.devtools.restart.enabled</code> 系统属性设置为 <code>false</code>。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    System.setProperty("spring.devtools.restart.enabled", "false");
    SpringApplication.run(MyApp.class, args);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-triggerfile">使用触发文件</h5>
<div class="paragraph">
<p>如果使用持续编译更改文件的IDE，则可能更喜欢仅在特定时间触发重新启动。为此，你可以使用“<code>触发文件</code>”，
这是一个特殊文件，当你要实际触发重新启动检查时必须对其进行修改。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对文件的任何更新都将触发检查，但是只有在Devtools检测到有事情要做的情况下，重启才真正发生。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用触发文件，请将 <code>spring.devtools.restart.trigger-file</code> 属性设置为触发文件的名称（不包括任何路径）。
触发文件必须出现在类路径上的某个位置。</p>
</div>
<div class="paragraph">
<p>例如，如果你的项目具有以下结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>src
+- main
   +- resources
      +- .reloadtrigger</pre>
</div>
</div>
<div class="paragraph">
<p>然后，你的 <code>trigger-file</code> 属性将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.trigger-file=.reloadtrigger</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在仅在更新 <code>src/main/resources/.reloadtrigger</code> 时才可能发生重启。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可能需要将 <code>spring.devtools.restart.trigger-file</code> 设置为<a href="#using-boot-devtools-globalsettings">全局设置</a>，以便所有项目的行为均相同。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>某些IDE具有使你不必手动更新触发器文件的功能。 <a href="https://spring.io/tools">Spring Tools for Eclipse</a>和
<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA (最终版)</a>都具有这种支持。
使用Spring Tools，你可以从控制台视图使用“<code>reload</code>”按钮（只要你的 <code>trigger-file</code> 为 <code>.reloadtrigger</code>）。
对于IntelliJ，你可以按照
<a href="https://www.jetbrains.com/help/idea/spring-boot.html#configure-application-update-policies-with-devtools">其文档中的说明</a>进行操作。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-customizing-classload">自定义重启类加载器</h5>
<div class="paragraph">
<p>如前面的<a href="#using-spring-boot-restart-vs-reload">重新启动 vs 重新加载</a>部分所述，重新启动功能是通过使用两个类加载器实现的。
对于大多数应用程序，此方法效果很好。但是，有时可能会导致类加载问题。</p>
</div>
<div class="paragraph">
<p>默认情况下，IDE中的任何打开的项目都使用“<code>重启</code>”类加载器加载，而任何常规的 <code>.jar</code> 文件都使用“<code>基本</code>”类加载器加载。
如果你在多模块项目上工作，并且并非每个模块都导入到IDE中，则可能需要自定义内容。为此，你可以创建一个
<code>META-INF/spring-devtools.properties</code> 文件。</p>
</div>
<div class="paragraph">
<p><code>spring-devtools.properties</code> 文件可以包含带有 <code>restart.exclude</code> 和 <code>restart.include</code> 前缀的属性。
<code>include</code> 元素是应上拉到“<code>重启</code>”类加载器中的项目，而 <code>exclude</code> 元素是应下推到“<code>基本</code>”类加载器中的项目。
该属性的值是应用于类路径的正则表达式模式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">restart.exclude.companycommonlibs=/mycorp-common-[\\w\\d-\.]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w\\d-\.]+\.jar</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
所有属性键都必须是唯一的。只要属性以 <code>restart.include</code> 或 <code>restart.exclude</code> 开头，它就会被考虑。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将加载类路径中的所有 <code>META-INF/spring-devtools.properties</code>。你可以将文件打包到项目内部，也可以打包到项目使用的库中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-known-restart-limitations">已知局限性</h5>
<div class="paragraph">
<p>重新启动功能不适用于使用标准 <code>ObjectInputStream</code> 反序列化的对象。如果你需要反序列化数据，
则可能需要将Spring的 <code>ConfigurableObjectInputStream</code> 与 <code>Thread.currentThread().getContextClassLoader()</code> 结合使用。</p>
</div>
<div class="paragraph">
<p>不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，则需要向库的原始作者请求修复。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-livereload">1.8.3. LiveReload</h4>
<div class="paragraph">
<p><code>spring-boot-devtools</code> 模块包括一个嵌入式LiveReload服务器，该服务器可用于在更改资源时触发浏览器刷新。
可从 <a href="http://livereload.com/extensions/">livereload.com</a>免费获得适用于Chrome，Firefox和Safari的LiveReload浏览器扩展。</p>
</div>
<div class="paragraph">
<p>如果你不想在应用程序运行时启动LiveReload服务器，则可以将 <code>spring.devtools.livereload.enabled</code> 属性设置为 <code>false</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
一次只能运行一台LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。
如果从IDE启动多个应用程序，则只有第一个具有LiveReload支持。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-globalsettings">1.8.4. 全局设置</h4>
<div class="paragraph">
<p>你可以通过将以下任何文件添加到 <code>$HOME/.config/spring-boot</code> 文件夹来配置全局devtools设置：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>spring-boot-devtools.properties</code></p>
</li>
<li>
<p><code>spring-boot-devtools.yaml</code></p>
</li>
<li>
<p><code>spring-boot-devtools.yml</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>添加到这些文件的任何属性都将应用于使用devtools的 <em>所有</em> Spring Boot应用程序。例如：要将重新启动配置为始终使用
<a href="#using-boot-devtools-restart-triggerfile">触发文件</a>，应添加以下属性：</p>
</div>
<div class="listingblock">
<div class="title">~/.config/spring-boot/spring-boot-devtools.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.trigger-file=.reloadtrigger</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果在 <code>$HOME/.config/spring-boot</code> 中找不到devtools配置文件，则在 <code>$HOME</code> 文件夹的根目录中搜索是否存在
<code>.spring-boot-devtools.properties</code> 文件。这使你可以与不支持 <code>$HOME/.config/spring-boot</code>
位置的较旧版本的Spring Boot上的应用程序共享devtools全局配置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上述文件中激活的Profiles不会影响
<a href="spring-boot-features.html#boot-features-external-config-profile-specific-properties">特定于环境的配置文件</a>的加载。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-remote">1.8.5. 远程应用</h4>
<div class="paragraph">
<p>Spring Boot开发者工具不仅限于本地开发。远程运行应用程序时，你还可以使用多种功能。
选择启用远程支持，因为启用它可能会带来安全风险。仅当在受信任的网络上运行或使用SSL保护时，才应启用它。
如果这两个选项都不可用，则不应使用DevTools的远程支持。你永远不要在生产部署上启用支持。</p>
</div>
<div class="paragraph">
<p>要启用它，你需要确保在重新打包的档案中包含 <code>devtools</code>，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你需要设置 <code>spring.devtools.remote.secret</code> 属性。像任何重要的密码或机密一样，该值应唯一且强壮，以免被猜测或强行使用。</p>
</div>
<div class="paragraph">
<p>远程devtools支持分为两部分：接受连接的服务器端端点和在IDE中运行的客户端应用程序。设置
 <code>spring.devtools.remote.secret</code> 属性后，将自动启用服务器组件，客户端组件必须手动启动。</p>
</div>
<div class="sect4">
<h5 id="运行远程客户端应用程序">运行远程客户端应用程序</h5>
<div class="paragraph">
<p>远程客户端应用程序旨在在你的IDE中运行。你需要使用与你连接到的远程项目相同的类路径来运行
<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。该应用程序的唯一必需参数是它连接到的远程URL。</p>
</div>
<div class="paragraph">
<p>例如，如果你使用的是Eclipse或STS，并且有一个名为 <code>my-app</code> 的项目已部署到Cloud Foundry，则可以执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 <code>Run</code> 菜单中选择 <code>Run Configurations&#8230;&#8203;</code>。</p>
</li>
<li>
<p>创建一个新的 <code>Java Application</code> “启动配置”。</p>
</li>
<li>
<p>浏览 <code>my-app</code> 项目。</p>
</li>
<li>
<p>使用 <code>org.springframework.boot.devtools.RemoteSpringApplication</code> 作为主类。</p>
</li>
<li>
<p>将 <code>https://myapp.cfapps.io</code> 添加到 <code>Program arguments</code>（或任何远程URL）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正在运行的远程客户端可能类似于以下清单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.2.2.RELEASE

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
因为远程客户端使用与真实应用程序相同的类路径，所以它可以直接读取应用程序属性。这就是读取 <code>spring.devtools.remote.secret</code> 属性并将其传递给服务器进行身份验证的方式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
始终建议使用 <code>https://</code> 作为连接协议，以便对通信进行加密并且不能截获密码。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要使用代理来访问远程应用程序，请配置 <code>spring.devtools.remote.proxy.host</code> 和 <code>spring.devtools.remote.proxy.port</code> 属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-remote-update">远程更新</h5>
<div class="paragraph">
<p>远程客户端以与<a href="#using-boot-devtools-restart">本地重新启动</a>相同的方式监视应用程序类路径中的更改。
任何更新的资源都会推送到远程应用程序，并且（<em>如果需要</em>）会触发重新启动。
如果你迭代使用本地没有的云服务的功能，这将很有帮助。通常，远程更新和重新启动比完整的重新构建和部署周期快得多。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅在远程客户端正在运行时监视文件。如果在启动远程客户端之前更改文件，则不会将其推送到远程服务器。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="configuring-file-system-watcher">配置文件系统观察器</h5>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.java">FileSystemWatcher</a>
的工作方式是按一定的时间间隔轮询类更改，然后等待预定义的静默期以确保没有更多更改。
然后将更改上传到远程应用程序。在较慢的开发环境中，可能会发生静默期不够的情况，并且类中的更改可能会分为几批。
第一批类更改上传后，服务器将重新启动。由于服务器正在重新启动，因此下一批不能发送到应用程序。</p>
</div>
<div class="paragraph">
<p>这通常通过 <code>RemoteSpringApplication</code> 日志中的警告来证明，即有关上载某些类失败的消息，然后进行重试。
但是，这也可能导致应用程序代码不一致，并且在上传第一批更改后无法重新启动。</p>
</div>
<div class="paragraph">
<p>如果你经常观察到此类问题，请尝试将 <code>spring.devtools.restart.poll-interval</code> 和
<code>spring.devtools.restart.quiet-period</code> 参数增加到适合你的开发环境的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.poll-interval=2s
spring.devtools.restart.quiet-period=1s</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在每2秒轮询一次受监视的classpath文件夹以进行更改，并保持1秒钟的静默时间以确保没有其他类更改。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-packaging-for-production">1.9. 打包你的应用程序用于生产</h3>
<div class="paragraph">
<p>可执行jar可以用于生产部署。由于它们是独立的，因此它们也非常适合云部署。</p>
</div>
<div class="paragraph">
<p>对于其他“生产就绪”功能，例如运行状况，审核和度量REST或JMX端点，请考虑添加 <code>spring-boot-actuator</code>。
有关详细信息，请参见 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em>。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-whats-next">1.10. 接下来要读什么</h3>
<div class="paragraph">
<p>现在，你应该了解了如何使用Spring Boot以及应遵循的一些最佳实践。现在，你可以继续深入了解特定的
<em><a href="spring-boot-features.html#boot-features">Spring Boot功能</a></em>，或者可以跳过并阅读有关
Spring Boot的 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em> 方面的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features">2. Spring Boot特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节将深入介绍Spring Boot。在这里，你可以了解可能要使用和自定义的关键功能。开始之前，建议你先阅读<a href="#using-boot">Spring Boot</a>部分，
以便你有足够的基础知识。</p>
</div>
<div class="sect2">
<h3 id="boot-features-spring-application">2.1. SpringApplication</h3>
<div class="paragraph">
<p><code>SpringApplication</code> 类提供了一种便捷的方式来引导从 <code>main()</code> 方法启动的Spring应用程序。在大多数情况下，
你可以委托给静态 <code>SpringApplication.run</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication.run(MySpringConfiguration.class, args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你的应用程序启动时，你应该看到类似于以下输出的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v2.2.2.RELEASE

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，显示 <code>INFO</code> 日志消息，包括一些相关的启动详细信息，例如：启动应用程序的用户。如果你需要除 <code>INFO</code> 级别以外的其他日志，
则可以按照<a href="#boot-features-custom-log-levels">日志级别</a>中的说明进行设置。使用主应用程序类包中的实现版本来确定应用程序版本。
可以通过将 <code>spring.main.log-startup-info</code> 设置为 <code>false</code> 来关闭启动信息记录。这还将关闭对应用程序激活的环境配置文件的日志记录。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在启动期间添加其他日志记录，可以在 <code>SpringApplication</code> 的子类中重写 <code>logStartupInfo(boolean)</code>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-startup-failure">2.1.1. 启动失败</h4>
<div class="paragraph">
<p>如果你的应用程序无法启动，则已注册的 <code>FailureAnalyzers</code> 将有机会提供专门的错误消息和解决该问题的具体措施。
例如：如果你在端口8080上启动Web应用程序并且该端口已在使用中，则应该看到类似于以下消息的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>***************************
APPLICATION FAILED TO START
***************************

Description:

Embedded servlet container failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot提供了大量的 <code>FailureAnalyzer</code> 实现，你可以添加<a href="howto.html#howto-failure-analyzer">自己的实现</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果没有故障分析器能够处理该异常，你仍然可以显示完整条件报告以更好地了解出了什么问题。
为此，你需要为 <code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code>
<a href="#boot-features-external-config">启用 <code>debug</code> 属性</a>或
<a href="#boot-features-custom-log-levels">启用 <code>DEBUG</code> 日志记录</a>。</p>
</div>
<div class="paragraph">
<p>例如，如果使用 <code>java -jar</code> 运行应用程序，则可以按以下方式启用 <code>debug</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-lazy-initialization">2.1.2. 延迟初始化</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 允许延迟初始化应用程序。启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。
因此，启用延迟初始化可以减少应用程序启动所需的时间。在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。</p>
</div>
<div class="paragraph">
<p>延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。如果错误配置的Bean被延迟初始化，则启动期间将不再发生故障，
并且只有在初始化Bean时问题才会发现。还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，
而不仅仅是启动期间初始化的bean。由于这些原因，默认情况下不会启用延迟初始化，
因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>SpringApplicationBuilder</code> 上的 <code>lazyInitialization</code> 方法或 <code>SpringApplication</code> 上的
<code>setLazyInitialization</code> 方法以编程方式启用延迟初始化。另外，可以使用 <code>spring.main.lazy-initialization</code>
属性启用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.main.lazy-initialization=true</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 <code>@Lazy(false)</code>
注解将它们的延迟属性显式设置为 <code>false</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-banner">2.1.3. 自定义横幅</h4>
<div class="paragraph">
<p>可以通过将 <code>banner.txt</code> 文件添加到类路径或将 <code>spring.banner.location</code> 属性设置为此类文件的位置来更改启动时打印的横幅。
如果文件的编码不是UTF-8，则可以设置 <code>spring.banner.charset</code>。除了文本文件之外，你还可以将
<code>banner.gif</code>，<code>banner.jpg</code> 或 <code>banner.png</code> 图像文件添加到类路径中，或设置 <code>spring.banner.image.location</code> 属性。
图像将转换为ASCII艺术品并打印在任何文字横幅上方。</p>
</div>
<div class="paragraph">
<p>在 <code>banner.txt</code> 文件中，你可以使用以下任意占位符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. 横幅变量</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Variable</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你的应用程序的版本号，在 <code>MANIFEST.MF</code> 中声明。例如：<code>Implementation-Version: 1.0</code> 被打印为 <code>1.0</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序版本号的格式化显示（用小括号括起来并以v开头）。例如：<code>(v1.0)</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本。例如 <code>2.2.2.RELEASE</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本的格式化显示（用小括号括起来并以v开头）。例如：<code>(v2.2.2.RELEASE)</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${Ansi.NAME}</code> (or <code>${AnsiColor.NAME}</code>, <code>${AnsiBackground.NAME}</code>, <code>${AnsiStyle.NAME}</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其中 <code>NAME</code> 是ANSI转义代码的名称。有关详细信息，请参见
  <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.title}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序标题。例如：<code>Implementation-Title: MyApp</code> 被打印为 <code>MyApp</code>。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要以编程方式生成横幅，则可以使用 <code>SpringApplication.setBanner(&#8230;&#8203;)</code> 方法。
使用 <code>org.springframework.boot.Banner</code> 接口并实现自己的 <code>printBanner()</code> 方法。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.main.banner-mode</code> 属性来确定横幅是否必须在 <code>System.out</code>（<code>控制台</code>）上打印，
是否必须发送到配置的日志记录器（<code>log</code>）或根本不打印（<code>关闭</code>）。</p>
</div>
<div class="paragraph">
<p>打印的横幅用 <code>springBootBanner</code> 名称注册为单例bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-customizing-spring-application">2.1.4. 自定义SpringApplication</h4>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 的默认设置不符合你的喜好，你可以创建一个本地实例并对其进行自定义。例如：要关闭横幅，你可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
传递给 <code>SpringApplication</code> 的构造函数参数是Spring bean的配置源。在大多数情况下，
它们是对 <code>@Configuration</code> 类的引用，但也可以是对XML配置或应扫描的程序包的引用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也可以通过使用 <code>application.properties</code> 文件配置 <code>SpringApplication</code>。有关详细信息，请参见 <em><a href="#boot-features-external-config">外部化配置</a></em>。</p>
</div>
<div class="paragraph">
<p>有关配置选项的完整列表，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-fluent-builder-api">2.1.5. 流式构建器API</h4>
<div class="paragraph">
<p>如果你需要构建 <code>ApplicationContext</code> 层次结构（具有父/子关系的多个上下文），或者如果你更喜欢使用“流式”构建器API，
则可以使用 <code>SpringApplicationBuilder</code>。</p>
</div>
<div class="paragraph">
<p><code>SpringApplicationBuilder</code> 使你可以将多个方法调用链接在一起，并包括允许你创建层次结构的 <code>parent</code> 和 <code>child</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
创建 <code>ApplicationContext</code> 层次结构时有一些限制。例如，Web组件必须包含在子上下文中，
并且父上下文和子上下文都使用相同的 <code>Environment</code>。有关完整的详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-events-and-listeners">2.1.6. 应用程序事件和监听器</h4>
<div class="paragraph">
<p>除了通常的Spring Framework事件（例如：
<a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a>）之外，
<code>SpringApplication</code> 还发送一些其他应用程序事件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实际上在创建 <code>ApplicationContext</code> 之前会触发一些事件，因此你不能将监听器注册为 <code>@Bean</code>。
你可以使用 <code>SpringApplication.addListeners(&#8230;&#8203;)</code> 方法或 <code>SpringApplicationBuilder.listeners(&#8230;&#8203;)</code> 方法注册它们。</p>
</div>
<div class="paragraph">
<p>如果希望这些侦听器自动注册，而不管以何种方式创建应用程序，都可以将
<code>META-INF/spring.factories</code> 文件添加到你的项目中，并使用 <code>org.springframework.context.ApplicationListener</code>
键引用你的侦听器。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.context.ApplicationListener=com.example.project.MyListener</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件在你的应用程序运行时按以下顺序发送：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在运行开始时但在任何处理之前（侦听器和初始化器的注册除外）发送 <code>ApplicationStartingEvent</code>。</p>
</li>
<li>
<p>已知晓要在上下文中使用的环境但在创建上下文之前，将发送 <code>ApplicationEnvironmentPreparedEvent</code>。</p>
</li>
<li>
<p>准备 <code>ApplicationContext</code> 并调用ApplicationContextInitializers之后但在加载任何bean
定义之前发送 <code>ApplicationContextInitializedEvent</code>。</p>
</li>
<li>
<p>在刷新开始之前但在加载bean定义之后发送 <code>ApplicationPreparedEvent</code>。</p>
</li>
<li>
<p>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前，将发送 <code>ApplicationStartedEvent</code>。</p>
</li>
<li>
<p>在调用任何应用程序和命令行运行程序之后，将发送 <code>ApplicationReadyEvent</code>。它指示该应用程序已准备就绪，可以处理请求。</p>
</li>
<li>
<p>如果启动时发生异常，则发送 <code>ApplicationFailedEvent</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面的列表仅包含绑定到 <code>SpringApplication</code> 的 <code>SpringApplicationEvents</code>。除这些以外，以下事件也在
<code>ApplicationPreparedEvent</code> 之后和 <code>ApplicationStartedEvent</code> 之前发布：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>刷新 <code>ApplicationContext</code> 后发送 <code>ContextRefreshedEvent</code>。</p>
</li>
<li>
<p>WebServer准备就绪后，将发送 <code>WebServerInitializedEvent</code>。<code>ServletWebServerInitializedEvent</code>
和 <code>ReactiveWebServerInitializedEvent</code> 分别是servlet和reactive的变体。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你通常不需要使用应用程序事件，但是知道它们的存在可能很方便。在Spring Boot内部使用事件来处理各种任务。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件是通过使用Spring Framework的事件发布机制发送的。
此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。
结果，如果你的应用程序使用 <code>SpringApplication</code> 实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。</p>
</div>
<div class="paragraph">
<p>为了使你的侦听器能够区分其上下文的事件和后代上下文的事件，则应请求注入其应用程序上下文，
然后将注入的上下文与事件的上下文进行比较。可以通过实现 <code>ApplicationContextAware</code> 来注入上下文，
或者如果侦听器是bean，则可以使用 <code>@Autowired</code> 注入上下文。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-web-environment">2.1.7. Web环境</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 尝试代表你创建正确的 <code>ApplicationContext</code> 类型。用于确定是 <code>WebApplicationType</code> 的算法非常简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果存在Spring MVC，则使用 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
</li>
<li>
<p>如果不存在Spring MVC但存在Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></p>
</li>
<li>
<p>否则，将使用 <code>AnnotationConfigApplicationContext</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着，如果你在同一应用程序中使用Spring MVC和Spring WebFlux中的新 <code>WebClient</code>，则默认情况下将使用Spring
MVC。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻松覆盖它。</p>
</div>
<div class="paragraph">
<p>也可以通过调用 <code>setApplicationContextClass(&#8230;&#8203;)</code> 完全控制要使用的 <code>ApplicationContext</code> 类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在JUnit测试中使用 <code>SpringApplication</code> 时，通常希望调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-arguments">2.1.8. 访问应用程序参数</h4>
<div class="paragraph">
<p>如果你需要访问传递给 <code>SpringApplication.run(&#8230;&#8203;)</code> 的应用程序参数，
则可以注入 <code>org.springframework.boot.ApplicationArguments</code> bean。<code>ApplicationArguments</code> 接口提供对原始
<code>String[]</code> 参数以及已解析的 <code>option</code> 和 <code>non-option</code> 参数的访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;

@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List&lt;String&gt; files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot还向Spring <code>Environment</code> 注册了 <code>CommandLinePropertySource</code>。
这样，你还可以使用 <code>@Value</code> 注解注入单个应用程序参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-command-line-runner">2.1.9. 使用ApplicationRunner或CommandLineRunner</h4>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 启动后需要运行一些特定的代码，则可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口。
这两个接口以相同的方式工作并提供一个 <code>run</code> 方法，该方法在 <code>SpringApplication.run(&#8230;&#8203;)</code> 完成之前被调用。</p>
</div>
<div class="paragraph">
<p><code>CommandLineRunner</code> 接口以简单的字符串数组提供对应用程序参数的访问，而 <code>ApplicationRunner</code> 使用前面讨论的
<code>ApplicationArguments</code> 接口。以下示例显示了带有 <code>run</code> 方法的 <code>CommandLineRunner</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了必须按特定顺序调用的几个 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> Beans，则可以另外实现
<code>org.springframework.core.Ordered</code> 接口或使用 <code>org.springframework.core.annotation.Order</code> 注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-exit">2.1.10. 应用程序退出</h4>
<div class="paragraph">
<p>每个 <code>SpringApplication</code> 向JVM注册一个关闭钩子，以确保 <code>ApplicationContext</code> 在退出时正常关闭。
可以使用所有标准的Spring生命周期回调（例如：<code>DisposableBean</code> 接口或 <code>@PreDestroy</code> 注解）。</p>
</div>
<div class="paragraph">
<p>另外，如果bean希望在调用 <code>SpringApplication.exit()</code> 时返回特定的退出码，
则可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口。然后可以将此退出码传递给 <code>System.exit()</code>，
以将其作为状态码返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ExitCodeApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -&gt; 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，<code>ExitCodeGenerator</code> 接口可以通过异常实现。遇到此类异常时，Spring Boot返回实现的 <code>getExitCode()</code> 方法提供的退出码。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-admin">2.1.11. 管理员功能</h4>
<div class="paragraph">
<p>通过指定 <code>spring.application.admin.enabled</code> 属性，可以为应用程序启用与管理员相关的功能。
这将在平台MBeanServer上公开 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>。
你可以使用此功能来远程管理Spring Boot应用程序。此功能对于任何服务包装器实现也可能很有用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你想知道应用程序在哪个HTTP端口上运行，请使用 <code>local.server.port</code> 键获取属性。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config">2.2. 外部化配置</h3>
<div class="paragraph">
<p>Spring Boot使你可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。你可以使用properties文件，YAML文件，
环境变量和命令行参数来外部化配置。可以使用 <code>@Value</code> 注解将属性值直接注入到你的bean中，
可以通过Spring的 <code>Environment</code> 抽象访问，也可以通过 <code>@ConfigurationProperties</code>
<a href="#boot-features-external-config-typesafe-configuration-properties">绑定到结构化对象</a>。</p>
</div>
<div class="paragraph">
<p>Spring Boot使用一个非常特殊的 <code>PropertySource</code> 顺序，该顺序旨在允许合理地覆盖值。按以下顺序考虑属性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当devtools处于活动状态时，<code>$HOME/.config/spring-boot</code> 文件夹中的
<a href="using-spring-boot.html#using-boot-devtools-globalsettings">Devtools全局设置属性</a>。</p>
</li>
<li>
<p>测试上的 <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a>注解。</p>
</li>
<li>
<p>测试中的properties属性。在 <code>@SpringBootTest</code> 和测试注解上可用，
用于<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试应用程序的特定部分</a>。</p>
</li>
<li>
<p>命令行参数。</p>
</li>
<li>
<p>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入在环境变量或系统属性中的嵌入式JSON）。</p>
</li>
<li>
<p><code>ServletConfig</code> 的初始化参数。</p>
</li>
<li>
<p><code>ServletContext</code> 的初始化参数。</p>
</li>
<li>
<p>来自 <code>java:comp/env</code> 的JNDI属性。</p>
</li>
<li>
<p>Java系统属性（<code>System.getProperties()</code>）。</p>
</li>
<li>
<p>操作系统环境变量。</p>
</li>
<li>
<p>一个 <code>RandomValuePropertySource</code> 仅具有 <code>random.*</code> 属性。</p>
</li>
<li>
<p>打包jar之外的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar之外的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p><code>@Configuration</code> 类上的 <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到 <code>Environment</code> 中。现在配置某些属性
（如 <code>logging.*</code> 和 <code>spring.main.*</code>）为时已晚，这些属性在刷新开始之前就已读取。</p>
</li>
<li>
<p>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了提供一个具体的示例，假设你开发了一个使用 <code>name</code> 属性的 <code>@Component</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在你的应用程序类路径上（例如：在jar中），你可以拥有一个 <code>application.properties</code> 文件，该文件为 <code>name</code>
提供合理的默认属性值。在新环境中运行时，可以在jar外部提供一个覆盖 <code>name</code> 的 <code>application.properties</code> 文件。
对于一次性测试，可以使用特定的命令行开关启动（例如：<code>java -jar app.jar --name="Spring"</code>）。</p>
</div>
<div id="boot-features-external-config-application-json" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以在命令行中使用环境变量来提供 <code>SPRING_APPLICATION_JSON</code> 属性。例如，你可以在UN*X shell中使用以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，你最终在Spring <code>Environment</code> 中获得了 <code>acme.name=test</code>。你还可以在System属性中将JSON作为
<code>spring.application.json</code> 提供，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用命令行参数来提供JSON，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --spring.application.json='{"name":"test"}'</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以将JSON作为JNDI变量提供，如下所示： <code>java:comp/env/spring.application.json</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-random-values">2.2.1. 配置随机值</h4>
<div class="paragraph">
<p><code>RandomValuePropertySource</code> 可用于注入随机值（例如：注入密钥或测试用例）。它可以产生整数，longs，uuid或字符串，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>random.int*</code> 语法是 <code>OPEN value (,max) CLOSE</code>，其中 <code>OPEN,CLOSE</code> 是任何字符，
而 <code>value,max</code> 是整数。如果提供了 <code>max</code>，则 <code>value</code> 是最小值，而 <code>max</code> 是最大值（不包括它）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-command-line-args">2.2.2. 访问命令行Properties</h4>
<div class="paragraph">
<p>默认情况下，<code>SpringApplication</code> 将所有命令行选项参数（即以 <code>--</code> 开头的参数，例如 <code>--server.port=9000</code>）转换为属性，
并将其添加到Spring <code>Environment</code> 中。如前所述，命令行属性始终优先于其他属性源。</p>
</div>
<div class="paragraph">
<p>如果你不希望将命令行属性添加到环境中，可以使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 禁用它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-application-property-files">2.2.3. 应用程序属性文件</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 在以下位置从 <code>application.properties</code> 文件加载属性，并将它们添加到Spring <code>Environment</code>：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当前目录的 <code>/config</code> 子目录</p>
</li>
<li>
<p>当前目录</p>
</li>
<li>
<p>类路径下的 <code>/config</code> 目录</p>
</li>
<li>
<p>类路径根目录</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该列表按优先级排序（列表前面定义的属性会覆盖后面的）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以<a href="#boot-features-external-config-yaml">使用YAML ('.yml')文件</a>来替代 '.properties'。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不喜欢 <code>application.properties</code> 作为配置文件名，则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名。
你还可以通过使用 <code>spring.config.location</code> 环境属性（这是目录位置或以逗号分隔的文件路径列表）来显式引用位置。
下面的示例演示如何指定其他文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.name=myproject</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to specify two locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>spring.config.name</code> 和 <code>spring.config.location</code> 很早就被用于确定必须加载的文件。
必须将它们定义为环境属性（通常是操作系统环境变量，系统属性或命令行参数）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>配置位置以相反的顺序搜索。默认情况下，配置的位置是 <code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>spring.config.location</code> 配置自定义配置位置后，它们将替换默认位置。例如：如果 <code>spring.config.location</code> 配置为值
<code>classpath:custom-config/,file:./custom-config/</code>，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>另外，当使用 <code>spring.config.additional-location</code> 配置自定义配置位置时，除默认位置外，还会考虑使用它们。
在默认位置之前搜索其他附加位置。例如：如果配置了 <code>classpath:/custom-config/,file:./custom-config/</code> 的附加位置，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过此搜索顺序，你可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。
你可以在默认位置之一的 <code>application.properties</code>（或使用 <code>spring.config.name</code> 选择的其他任何基本名称）中为应用程序提供默认值。
然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用环境变量而不是系统属性，则大多数操作系统都不允许使用句点分隔的键名，但是可以使用下划线
（例如：使用 <code>SPRING_CONFIG_NAME</code> 代替 <code>spring.config.name</code>）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你的应用程序在容器中运行，则可以使用JNDI属性（在 <code>java:comp/env</code> 中）或servlet上下文初始化参数代替环境变量或系统属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-profile-specific-properties">2.2.4. 特定于Profile的Properties</h4>
<div class="paragraph">
<p>除了 <code>application.properties</code> 文件之外，还可以使用以下命名约定来定义特定于profile的属性：
<code>application-{profile}.properties</code>。如果没有设置激活的profile，则 <code>Environment</code> 具有一组默认的profiles（默认为
<code>[default]</code>）。换句话说，如果未显式激活任何profiles，那么将从 <code>application-default.properties</code> 中加载属性。</p>
</div>
<div class="paragraph">
<p>特定于profile的属性是从与标准 <code>application.properties</code> 相同的位置加载的，特定于profile的文件始终会覆盖非特定文件，
而无论特定于profile的文件是位于打包jar的内部还是外部。</p>
</div>
<div class="paragraph">
<p>如果指定了多个profiles，则采用最后一个获胜策略。例如：将 <code>spring.profiles.active</code>
属性指定的profiles添加到通过SpringApplication API配置的profiles之后，因此具有优先权。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>spring.config.location</code> 中指定了任何文件，则不会考虑这些文件特定于profile的变体。
如果你还想使用特定于profile的属性，请使用 <code>spring.config.location</code> 中的目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-placeholders-in-properties">2.2.5. Properties中的占位符</h4>
<div class="paragraph">
<p><code>application.properties</code> 中的值在使用时会通过现有的 <code>Environment</code> 进行过滤，因此你可以参考在它之前定义的值（例如：从System属性中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">app.name=MyApp
app.description=${app.name} is a Spring Boot application</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以使用这种技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-use-short-command-line-arguments">使用“简短”命令行参数方法</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-encrypting-properties">2.2.6. 加密Properties</h4>
<div class="paragraph">
<p>Spring Boot不提供对加密属性值的任何内置支持，但是，它确实提供了修改Spring <code>Environment</code> 中包含的值所必需的钩子。
<code>EnvironmentPostProcessor</code> 界面允许你在应用程序启动之前操纵 <code>Environment</code>。
有关详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-customize-the-environment-or-application-context">在启动前自定义环境或ApplicationContext</a>。</p>
</div>
<div class="paragraph">
<p>如果你正在寻找一种安全的方式来存储凭据和密码， <a href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a>
项目提供了对在 <a href="https://www.vaultproject.io/">HashiCorp Vault</a>中存储外部配置的支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-yaml">2.2.7. 使用YAML代替Properties</h4>
<div class="paragraph">
<p><a href="https://yaml.org">YAML</a>是一个JSON超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在类路径上具有
<a href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库，
<code>SpringApplication</code> 类就会自动支持YAML作为Properties的替代方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用“启动器”，则 <code>spring-boot-starter</code> 会自动提供SnakeYAML。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-loading-yaml">加载YAML</h5>
<div class="paragraph">
<p>Spring Framework提供了两个方便的类，可用于加载YAML文档。<code>YamlPropertiesFactoryBean</code> 将YAML作为 <code>Properties</code> 加载，
而 <code>YamlMapFactoryBean</code> 将YAML作为 <code>Map</code> 加载。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下YAML文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">environments:
    dev:
        url: https://dev.example.com
        name: Developer Setup
    prod:
        url: https://another.example.com
        name: My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>YAML列表用 <code>[index]</code> 解引用器表示为属性键。例如：考虑以下YAML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">my:
   servers:
       - dev.example.com
       - another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.servers[0]=dev.example.com
my.servers[1]=another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过使用Spring Boot的 <code>Binder</code> 实用程序（<code>@ConfigurationProperties</code> 所做的）绑定到类似的属性，
你需要在目标bean中拥有一个类型为 <code>java.util.List</code>（或 <code>Set</code>）属性，或者你需要提供一个setter或使用可变值对其进行初始化。
例如，以下示例绑定到前面显示的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="my")
public class Config {

    private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();

    public List&lt;String&gt; getServers() {
        return this.servers;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-exposing-yaml-to-spring">在Spring环境中将YAML公开为Properties</h5>
<div class="paragraph">
<p><code>YamlPropertySourceLoader</code> 类可用于在Spring <code>Environment</code> 中将YAML公开为 <code>PropertySource</code>。
这样做可以让你使用 <code>@Value</code> 注解和占位符语法来访问YAML属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-multi-profile-yaml">Multi-profile的YAML文档</h5>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles</code> 键在一个文件中指定多个特定于profile的YAML文档，以指示何时应用该文档，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production &amp; eu-central
server:
    address: 192.168.1.120</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>development</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>127.0.0.1</code>。
同样，如果 <code>production</code> <strong>和</strong> <code>eu-central</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>192.168.1.120</code>。
如果 <strong>未</strong> 启用 <code>development</code>, <code>production</code> 和 <code>eu-central</code> profiles，则该属性的值为 <code>192.168.1.100</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因此 <code>spring.profiles</code> 可以包含一个简单的profile名称（例如：<code>production</code>）或profile表达式。
profile表达式允许表达更复杂的profile逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。有关更多详细信息，请参阅
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#beans-definition-profiles-java">参考指南</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果在启动应用程序上下文时未明确激活任何profiles，则会激活默认的profiles。因此，在以下YAML中，我们为
<code>spring.security.user.password</code> 设置了一个值，该值 <strong>仅</strong> 在 "default" profile中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>而在以下示例中，则会始终设置密码是因为该密码未附加到任何profile，并且必须根据需要在所有其他profiles中将其显式重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
spring:
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>spring.profiles</code> 元素指定的Spring profiles可以选择使用 <code>!</code> 字符来否定。如果为单个文档指定了否定的和非否定的profiles，
则至少一个非否定的profile必须匹配，并且否定的profiles不能匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-yaml-shortcomings">YAML的缺点</h5>
<div class="paragraph">
<p>无法使用 <code>@PropertySource</code> 注解加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用properties文件。</p>
</div>
<div class="paragraph">
<p>在特定于profile的YAML文件中使用多YAML文档语法可能会导致意外行为。例如：考虑文件中的以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: "!test"
  security:
    user:
      password: "secret"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用参数 <code>--spring.profiles.active=dev</code> 运行该应用程序，则可能希望将 <code>security.user.password</code> 设置为“<code>secret</code>”，但事实并非如此。</p>
</div>
<div class="paragraph">
<p>嵌套文档将被过滤，因为主文件名为 <code>application-dev.yml</code>。它已经被认为是特定于profile的，并且嵌套文档将被忽略。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议你不要混用特定于profile的YAML文件和多个YAML文档。坚持只使用其中之一。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-typesafe-configuration-properties">2.2.8. 类型安全的配置Properties</h4>
<div class="paragraph">
<p>使用 <code>@Value("${property}")</code> 注解来注入配置属性有时会很麻烦，尤其是当你使用多个properties或数据本质上是分层的时。
Spring Boot提供了一种使用属性的替代方法，使用强类型的properties bean来管理和验证应用程序的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
另请参见<a href="#boot-features-external-config-vs-value"><code>@Value</code> 和类型安全的配置properties之间的区别</a>。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-java-bean-binding">JavaBean properties绑定</h5>
<div class="paragraph">
<p>可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("acme")
public class AcmeProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    public boolean isEnabled() { ... }

    public void setEnabled(boolean enabled) { ... }

    public InetAddress getRemoteAddress() { ... }

    public void setRemoteAddress(InetAddress remoteAddress) { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private String username;

        private String password;

        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton("USER"));

        public String getUsername() { ... }

        public void setUsername(String username) { ... }

        public String getPassword() { ... }

        public void setPassword(String password) { ... }

        public List&lt;String&gt; getRoles() { ... }

        public void setRoles(List&lt;String&gt; roles) { ... }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的POJO定义了以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acme.enabled</code>，默认值为 <code>false</code>。</p>
</li>
<li>
<p><code>acme.remote-address</code>，其类型可以从 <code>String</code> 强制转换。</p>
</li>
<li>
<p><code>acme.security.username</code>，带有嵌套的“security”对象，其名称由属性名称确定。
特别是，返回类型根本没有使用，也可能是 <code>SecurityProperties</code>。</p>
</li>
<li>
<p><code>acme.security.password</code>。</p>
</li>
<li>
<p><code>acme.security.roles</code>，带有默认拥有单个 <code>USER</code> 的 <code>String</code> 集合。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot自动配置大量使用 <code>@ConfigurationProperties</code> 来轻松配置自动配置的bean。
与自动配置类相似，Spring Boot中可用的 <code>@ConfigurationProperties</code> 类仅供内部使用。
通过Properties文件、YAML文件、环境变量等配置映射到的类属性是公共API，但是该类本身的内容并不意味着可以直接使用。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种自动配置依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，
就像在Spring MVC中一样。在以下情况下，可以忽略setter：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maps，只要它们被初始化，需要一个getter但不一定是setter，因为绑定器可以对它们进行修改。</p>
</li>
<li>
<p>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（properties）来访问集合和数组。
在后一种情况下，必须使用setter。我们建议始终为此类类型添加setter。如果初始化集合，请确保它不是不可变的（如上例所示）。</p>
</li>
<li>
<p>如果初始化了嵌套的POJO属性（如前面示例中的 <code>Security</code> 字段），则不需要setter。
如果希望绑定器通过使用其默认构造函数动态创建实例，则需要一个setter。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有些人使用Lombok项目自动添加getters和setters。确保Lombok不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。</p>
</div>
<div class="paragraph">
<p>最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-constructor-binding">构造函数绑定</h5>
<div class="paragraph">
<p>上一节中的示例可以用不可变的方式重写，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.ConstructorBinding;
import org.springframework.boot.context.properties.DefaultValue;

@ConstructorBinding
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final boolean enabled;

    private final InetAddress remoteAddress;

    private final Security security;

    public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    public boolean isEnabled() { ... }

    public InetAddress getRemoteAddress() { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private final String username;

        private final String password;

        private final List&lt;String&gt; roles;

        public Security(String username, String password,
                @DefaultValue("USER") List&lt;String&gt; roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        public String getUsername() { ... }

        public String getPassword() { ... }

        public List&lt;String&gt; getRoles() { ... }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此设置中，<code>@ConstructorBinding</code> 注解用于指示应使用构造函数绑定。这意味着绑定器将期望找到带有你希望绑定的参数的构造函数。</p>
</div>
<div class="paragraph">
<p><code>@ConstructorBinding</code> 类的嵌套成员（例如上例中的 <code>Security</code>）也将通过其构造函数进行绑定。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>@DefaultValue</code> 指定默认值，并且将应用相应的转换服务将 <code>String</code> 值强制转换为缺失属性的目标类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用构造函数绑定，必须使用 <code>@EnableConfigurationProperties</code> 或配置属性扫描来启用该类。你不能对通过常规Spring机制创建的bean
使用构造函数绑定（例如：<code>@Component</code> bean，通过 <code>@Bean</code> 方法创建的bean或使用 <code>@Import</code> 加载的bean）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 <code>@ConstructorBinding</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-enabling">启用被 <code>@ConfigurationProperties</code> 注解的类型</h5>
<div class="paragraph">
<p>Spring Boot提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为Bean的基础设施。
你可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。</p>
</div>
<div class="paragraph">
<p>有时，用 <code>@ConfigurationProperties</code> 注解的类可能不适用于扫描，例如：如果你正在开发自己的自动配置，
或者想要有条件地启用它们。在这些情况下，请使用 <code>@EnableConfigurationProperties</code> 注解指定要处理的类型列表。
可以在任何 <code>@Configuration</code> 类上完成此操作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用配置属性扫描，请将 <code>@ConfigurationPropertiesScan</code> 注解添加到你的应用程序。
通常，它被添加到使用 <code>@SpringBootApplication</code> 注解的主应用程序类中，但可以将其添加到任何 <code>@Configuration</code> 类中。
默认情况下，将从声明注解的类的包中进行扫描。如果要定义待扫描的特定程序包，可以按照以下示例所示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
public class MyApplication {
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>@ConfigurationProperties</code> bean is registered using configuration property scanning or via <code>@EnableConfigurationProperties</code>, the bean has a conventional name: <code>&lt;prefix&gt;-&lt;fqn&gt;</code>, where <code>&lt;prefix&gt;</code> is the environment key prefix specified in the <code>@ConfigurationProperties</code> annotation and <code>&lt;fqn&gt;</code> is the fully qualified name of the bean.
If the annotation does not provide any prefix, only the fully qualified name of the bean is used.</p>
</div>
<div class="paragraph">
<p>使用配置属性扫描或通过 <code>@EnableConfigurationProperties</code> 注册 <code>@ConfigurationProperties</code> Bean时，
该Bean具有常规名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，其中 <code>&lt;prefix&gt;</code> 是 <code>@ConfigurationProperties</code> 注解中指定的环境键前缀。
<code>&lt;fqn&gt;</code> 是Bean的完全限定名称。如果注解不提供任何前缀，则仅使用Bean的完全限定名称。</p>
</div>
<div class="paragraph">
<p>上例中的bean名称是 <code>acme-com.example.AcmeProperties</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们建议 <code>@ConfigurationProperties</code> 仅处理环境，尤其不要从上下文中注入其他bean。
对于极端情况，可以使用setter注入或框架提供的任何 <code>*Aware</code> 接口（例如：需要访问 <code>Environment</code> 的 <code>EnvironmentAware</code>）。
如果仍然想使用构造函数注入其他bean，则必须使用 <code>@Component</code> 注解配置properties bean，并使用基于JavaBean的属性绑定。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-using">使用被 <code>@ConfigurationProperties</code> 注解的类型</h5>
<div class="paragraph">
<p>这种配置方式在 <code>SpringApplication</code> 外部的YAML配置中特别好用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml"># application.yml

acme:
    remote-address: 192.168.1.1
    security:
        username: admin
        roles:
          - USER
          - ADMIN

# additional configuration as required</code></pre>
</div>
</div>
<div class="paragraph">
<p>要与 <code>@ConfigurationProperties</code> Bean一起使用，可以像其他任何Bean一样注入它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final AcmeProperties properties;

    @Autowired
    public MyService(AcmeProperties properties) {
        this.properties = properties;
    }

     //...

    @PostConstruct
    public void openConnection() {
        Server server = new Server(this.properties.getRemoteAddress());
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>@ConfigurationProperties</code> 还可让你生成元数据文件，IDE可以使用这些元数据文件为你自己的键提供自动完成功能。
有关详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#configuration-metadata">附录</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-3rd-party-configuration">第三方配置</h5>
<div class="paragraph">
<p>除了使用 <code>@ConfigurationProperties</code> 注解类外，还可以在public <code>@Bean</code> 方法上使用它。当你要将属性绑定到控件之外的第三方组件时，这样做特别有用。</p>
</div>
<div class="paragraph">
<p>要从 <code>Environment</code> 属性配置Bean，请将 <code>@ConfigurationProperties</code> 添加到其Bean注册中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix = "another")
@Bean
public AnotherComponent anotherComponent() {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code>another</code> 前缀定义的任何JavaBean属性都以类似于前面的 <code>AcmeProperties</code> 示例的方式映射到该 <code>AnotherComponent</code> bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-relaxed-binding">宽松绑定</h5>
<div class="paragraph">
<p>Spring Boot使用一些宽松的规则将 <code>Environment</code> 属性绑定到 <code>@ConfigurationProperties</code> bean，
因此 <code>Environment</code> 属性名称和bean属性名称之间不需要完全匹配。有用的常见示例包括：以破折号分隔的环境属性
（例如：<code>context-path</code> 绑定到 <code>contextPath</code>）和大写的环境属性（例如：<code>PORT</code> 绑定到 <code>port</code>）。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下 <code>@ConfigurationProperties</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme.my-project.person")
public class OwnerProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用前面的代码，以下属性名称均可以使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. 宽松绑定</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my-project.person.first-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kebab格式，建议在 <code>.properties</code> 和 <code>.yml</code> 文件中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.myProject.person.firstName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准小驼峰式语法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my_project.person.first_name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线表示法，是 <code>.properties</code> 和 <code>.yml</code> 文件中使用的另一种格式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写格式，使用系统环境变量时建议使用。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
注解的前缀值 <em>必须</em> 为kebab格式（小写，并用 <code>-</code> 分隔，例如：<code>acme.my-project.person</code>）。
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. 每个属性源的宽松绑定规则</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性源</th>
<th class="tableblock halign-left valign-top">支持</th>
<th class="tableblock halign-left valign-top">列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Properties文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YAML文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard YAML list syntax or comma-separated values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以下划线作为定界符的大写格式。<code>_</code> 不应在属性名称中使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线包围的数值，例如：<code>MY_ACME_1_OTHER = my.acme[1].other</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议，如果可能，属性以小写kebab格式存储，例如：<code>my.property-name=acme</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>绑定到 <code>Map</code> 属性时，如果 <code>key</code> 包含小写字母数字字符或 <code>-</code> 以外的任何其他字符，则需要使用方括号表示法，以便保留原始值。
如果键没有被 <code>[]</code> 包围，则所有非字母数字或 <code>-</code> 字符都将被删除。例如，考虑将以下属性绑定到 <code>Map</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    "[/key1]": value1
    "[/key2]": value2
    /key3: value3</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的属性将以 <code>/key1</code>，<code>/key2</code> 和 <code>key3</code> 作为映射中的键被绑定到 <code>Map</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于YAML文件，方括号需要用引号引起来，以便正确解析。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-complex-type-merge">合并复杂类型</h5>
<div class="paragraph">
<p>如果在多个地方配置了列表，则通过替换整个列表来进行覆盖。</p>
</div>
<div class="paragraph">
<p>例如：假设 <code>MyPojo</code> 对象的 <code>name</code> 和 <code>description</code> 属性默认为 <code>null</code>。
下面的示例从 <code>AcmeProperties</code> 公开 <code>MyPojo</code> 对象的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;();

    public List&lt;MyPojo&gt; getList() {
        return this.list;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目，如先前所定义。
但是，如果启用了 <code>dev</code> profile，则该列表仍然仅包含一个条目（名称为 <code>my another name</code>，并且描述为 <code>null</code>）。
此配置 <em>不会</em> 将第二个 <code>MyPojo</code> 实例添加到列表中，并且不会合并条目。</p>
</div>
<div class="paragraph">
<p>在多个profiles中指定 <code>List</code> 时，将使用优先级最高的列表（并且仅使用那个列表）。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
    - name: another name
      description: another description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>dev</code> profile处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目
（其名称为 <code>my another name</code>，并且描述为 <code>null</code>）。对于YAML，可以使用逗号分隔的列表和YAML列表来完全覆盖列表的内容。</p>
</div>
<div class="paragraph">
<p>对于 <code>Map</code> 属性，可以绑定从多个来源绘制的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。
下面的示例从 <code>AcmeProperties</code> 公开 <code>Map&lt;String, MyPojo&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final Map&lt;String, MyPojo&gt; map = new HashMap&lt;&gt;();

    public Map&lt;String, MyPojo&gt; getMap() {
        return this.map;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.map</code> 包含一个键为key1的条目（名称为 <code>my name 1</code>，描述为 <code>my description 1</code>）。
但是，如果启用了 <code>dev</code> profile，则map包含两个条目，其中键为key1的条目（名称为 <code>dev name 1</code>，描述为 <code>my description 1</code>）
和key2（名称为 <code>dev name 2</code>，描述为 <code>dev description 2</code>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前述合并规则不仅适用于YAML文件，而且适用于所有属性源中的属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion">属性转换</h5>
<div class="paragraph">
<p>当Spring Boot绑定到 <code>@ConfigurationProperties</code> bean时，它尝试将外部应用程序属性强制为正确的类型。
如果需要自定义类型转换，则可以提供一个 <code>ConversionService</code> bean（具有一个名为 <code>conversionService</code> 的bean）
或自定义属性编辑器（通过 <code>CustomEditorConfigurer</code> bean）或自定义 <code>Converters</code>（具有定义为 <code>@ConfigurationPropertiesBinding</code> 的bean定义）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于在应用程序生命周期中非常早就请求了此bean，因此请确保限制你的 <code>ConversionService</code> 使用的依赖项。
通常，你需要的任何依赖项可能在创建时未完全初始化。如果配置键强制转换不需要自定义的转换服务，则可能要重命名自定义的
<code>ConversionService</code> 且它仅依赖于具有 <code>@ConfigurationPropertiesBinding</code> 限定的自定义转换器。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="boot-features-external-config-conversion-duration">转换持续时间</h6>
<div class="paragraph">
<p>Spring Boot为表达持续时间提供了专门的支持。如果公开 <code>java.time.Duration</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（使用毫秒作为默认单位，除非已指定 <code>@DurationUnit</code>）</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-">`java.time.Duration`使用的</a>标准ISO-8601格式</p>
</li>
<li>
<p>值和单位相结合的更易读的格式（例如：10s表示10秒）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.system")
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定30秒的会话超时，则 <code>30</code>，<code>PT30S</code> 和 <code>30s</code> 都是等效的。可以使用以下任意形式指定500ms的读取超时：
<code>500</code>，<code>PT0.5S</code> 和 <code>500ms</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns</code> 纳秒</p>
</li>
<li>
<p><code>us</code> 微秒</p>
</li>
<li>
<p><code>ms</code> 毫秒</p>
</li>
<li>
<p><code>s</code> 秒</p>
</li>
<li>
<p><code>m</code> 分钟</p>
</li>
<li>
<p><code>h</code> 小时</p>
</li>
<li>
<p><code>d</code> 天</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是毫秒，可以使用 <code>@DurationUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要从仅使用 <code>Long</code> 表示持续时间的先前版本进行升级，原单位若不是毫秒那么请确保在切换到 <code>Duration</code>
时指定单位（使用 <code>@DurationUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-external-config-conversion-datasize">转换数据大小</h6>
<div class="paragraph">
<p>Spring Framework具有 <code>DataSize</code> 值类型，以字节为单位表示大小。如果公开 <code>DataSize</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（除非已指定 <code>@DataSizeUnit</code>，否则使用字节作为默认单位）</p>
</li>
<li>
<p>值和单位耦合在一起的更易读的格式（例如：10MB表示10兆字节）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.io")
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>若要指定10 MB的缓冲区大小，则 <code>10</code> 和 <code>10MB</code> 是等效的。256个字节大小的阈值可以指定为 <code>256</code> 或 <code>256B</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>B</code> 字节</p>
</li>
<li>
<p><code>KB</code> 千字节</p>
</li>
<li>
<p><code>MB</code> 兆字节</p>
</li>
<li>
<p><code>GB</code> 千兆字节</p>
</li>
<li>
<p><code>TB</code> 兆兆字节</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是字节，可以使用 <code>@DataSizeUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要从仅使用 <code>Long</code> 表示大小的先前版本进行升级，原单位若不是字节那么请确保在切换到 <code>DataSize</code>
时指定单位（使用 <code>@DataSizeUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-validation">@ConfigurationProperties验证</h5>
<div class="paragraph">
<p>每当使用Spring的 <code>@Validated</code> 注解对 <code>@ConfigurationProperties</code> 类进行批注时，
Spring Boot就会尝试对其进行验证。你可以在配置类上直接使用JSR-303 <code>javax.validation</code> 约束注解。
为此，请确保在类路径上有兼容的JSR-303实现，然后将约束注解添加到字段中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    // ... getters and setters

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以通过使用 <code>@Validated</code> 注解创建配置属性的 <code>@Bean</code> 方法来触发验证。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了确保始终为嵌套属性触发验证，即使未找到任何属性，也必须使用 <code>@Valid</code> 注解关联的字段。下面的示例基于前面的 <code>AcmeProperties</code> 示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以通过创建一个名为 <code>configurationPropertiesValidator</code> 的bean定义来添加自定义Spring <code>Validator</code>。
<code>@Bean</code> 方法应声明为 <code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，
并且将 <code>@Bean</code> 方法声明为 <code>static</code> 可以使创建该bean而不必实例化 <code>@Configuration</code> 类。这样做避免了由早期实例化引起的任何问题。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring-boot-actuator</code> 模块包括一个公开所有 <code>@ConfigurationProperties</code> beans的端点。
将你的Web浏览器指向 <code>/actuator/configprops</code> 或使用等效的JMX端点访问。有关详细信息，请参见“
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready-endpoints">生产就绪功能</a>”部分。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-vs-value">@ConfigurationProperties vs @Value</h5>
<div class="paragraph">
<p><code>@Value</code> 注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。
下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 支持的功能：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">功能</th>
<th class="tableblock halign-left valign-top"><code>@ConfigurationProperties</code></th>
<th class="tableblock halign-left valign-top"><code>@Value</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#boot-features-external-config-relaxed-binding">宽松绑定</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#configuration-metadata">元数据支持</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SpEL</code> 评估</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果你为自己的组件定义了一组配置键，我们建议你将它们组合在以 <code>@ConfigurationProperties</code> 注解的POJO中。
你还应该意识到，由于 <code>@Value</code> 不支持宽松的绑定，因此如果你需要使用环境变量来提供值，则它不是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>最后，尽管你可以在 <code>@Value</code> 中编写SpEL表达式，但不会从<a href="#boot-features-external-config-application-property-files">应用程序属性文件</a>中处理此类表达式。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-profiles">2.3. Profiles</h3>
<div class="paragraph">
<p>Spring Profiles提供了一种隔离应用程序配置部分并使之仅在某些环境中可用的方法。
任何 <code>@Component</code>，<code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 标记以限制其加载时间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果 <code>@ConfigurationProperties</code> Bean是通过 <code>@EnableConfigurationProperties</code> 而非自动扫描注册的，
则需要在具有 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解。
在自动扫描 <code>@ConfigurationProperties</code> 的情况下，可以在 <code>@ConfigurationProperties</code> 类本身上指定 <code>@Profile</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles.active</code> 环境属性来指定哪些配置文件处于激活状态。你可以通过本章前面介绍的任何方式指定属性。
例如，你可以将其包含在 <code>application.properties</code> 中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.profiles.active=dev,hsqldb</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。</p>
</div>
<div class="sect3">
<h4 id="boot-features-adding-active-profiles">2.3.1. 添加活动Profiles</h4>
<div class="paragraph">
<p><code>spring.profiles.active</code> 属性遵循与其他属性相同的排序规则：最高的 <code>PropertySource</code> 获胜。这意味着你可以在
<code>application.properties</code> 中指定要激活配置文件，然后使用命令行开关 <strong>替换</strong> 它们。</p>
</div>
<div class="paragraph">
<p>有时，将特定于profile的属性 <strong>添加</strong> 到活动profiles而不是替换它们很有用。
<code>spring.profiles.include</code> 属性可用于无条件添加活动Profiles。<code>SpringApplication</code> 入口点还具有Java API，
用于设置其他附加的profiles（即在由 <code>spring.profiles.active</code> 属性激活的profiles之上）。
参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/SpringApplication.html">SpringApplication</a>中的 <code>setAdditionalProfiles()</code> 方法。</p>
</div>
<div class="paragraph">
<p>例如，当使用开关 <code>--spring.profiles.active=prod</code> 运行具有以下属性的应用程序时，<code>proddb</code> 和 <code>prodmq</code> 配置文件也会被激活：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.include:
  - proddb
  - prodmq</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请记住，可以在YAML文档中定义 <code>spring.profiles</code> 属性，以确定该特定文档何时包含在配置中。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-change-configuration-depending-on-the-environment">根据环境更改配置</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-programmatically-setting-profiles">2.3.2. 以编程方式设置Profiles</h4>
<div class="paragraph">
<p>你可以在应用程序运行之前通过调用 <code>SpringApplication.setAdditionalProfiles(&#8230;&#8203;)</code> 以编程方式设置活动配置文件。
也可以使用Spring的 <code>ConfigurableEnvironment</code> 接口来激活profiles。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-profile-specific-configuration">2.3.3. 特定于Profile的配置文件</h4>
<div class="paragraph">
<p><code>application.properties</code>（或 <code>application.yml</code>）和通过
<code>@ConfigurationProperties</code> 所引用文件的特定于profile的变体都会被视为配置文件并加载。
有关详细信息，请参见“<a href="#boot-features-external-config-profile-specific-properties">特定于Profile的Properties</a>”。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging">2.4. 日志</h3>
<div class="paragraph">
<p>Spring Boot使用 <a href="https://commons.apache.org/logging">Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。
提供了 <a href="https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html">Java Util Logging</a>，
<a href="https://logging.apache.org/log4j/2.x/">Log4J2</a>和 <a href="https://logback.qos.ch/">Logback</a>的默认配置。
在每种情况下，日志记录器都已预先配置为使用控制台输出，同时还提供可选的文件输出。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果使用“<code>Starters</code>”，则使用Logback进行日志记录。还包括适当的Logback路由，以确保使用
Java Util Logging，Commons Logging，Log4J或SLF4J的从属库都可以正常工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Java有许多可用的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。
通常，你不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。
这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-logging-format">2.4.1. 日志格式</h4>
<div class="paragraph">
<p>Spring Boot的默认日志输出类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</pre>
</div>
</div>
<div class="paragraph">
<p>默认输出以下条目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日期和时间：毫秒精度，易于分类。</p>
</li>
<li>
<p>日志级别：<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code> 和 <code>TRACE</code>。</p>
</li>
<li>
<p>进程ID。</p>
</li>
<li>
<p><code>---</code> 分隔符用于区分实际日志消息的开始。</p>
</li>
<li>
<p>线程名：用方括号括起来（对于控制台输出，可能会被截断）。</p>
</li>
<li>
<p>记录器名称：这通常是源类名称（通常是缩写格式）。</p>
</li>
<li>
<p>日志消息。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Logback没有 <code>FATAL</code> 日志级别。它被映射到 <code>ERROR</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logging-console-output">2.4.2. 控制台输出</h4>
<div class="paragraph">
<p>默认日志配置在消息写入时将消息回显到控制台。默认情况下，将记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
你还可以通过使用 <code>--debug</code> 标志启动应用程序来启用“<code>debug</code>”模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --debug</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以在 <code>application.properties</code> 中指定 <code>debug=true</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启用调试模式后，将配置一些核心日志记录器（嵌入式容器，Hibernate和Spring Boot）以输出更多信息。
启用调试模式 <em>不会</em> 将你的应用程序配置为记录所有具有 <code>DEBUG</code> 级别的消息。</p>
</div>
<div class="paragraph">
<p>或者，你可以通过使用 <code>--trace</code> 标志（或 <code>application.properties</code> 中的 <code>trace=true</code>）启动应用程序来启用“<code>trace</code>”模式。
这样做可以为某些核心记录器（嵌入式容器，Hibernate schema生成以及整个Spring产品组合）启用跟踪记录。</p>
</div>
<div class="sect4">
<h5 id="boot-features-logging-color-coded-output">颜色编码输出</h5>
<div class="paragraph">
<p>如果你的终端支持ANSI，则使用彩色输出来提高可读性。你可以将 <code>spring.output.ansi.enabled</code> 设置为
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/ansi/AnsiOutput.Enabled.html">支持的值</a>，以覆盖自动检测。</p>
</div>
<div class="paragraph">
<p>使用 <code>%clr</code> 转换字配置颜色编码。转换器以最简单的形式根据日志级别为输出着色，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%5p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了日志级别到颜色的映射：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Level</th>
<th class="tableblock halign-left valign-top">Color</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FATAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ERROR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WARN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">黄色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INFO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEBUG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另外，你可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如：要使文本变黄，请使用以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持以下颜色和样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>blue</code></p>
</li>
<li>
<p><code>cyan</code></p>
</li>
<li>
<p><code>faint</code></p>
</li>
<li>
<p><code>green</code></p>
</li>
<li>
<p><code>magenta</code></p>
</li>
<li>
<p><code>red</code></p>
</li>
<li>
<p><code>yellow</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logging-file-output">2.4.3. 文件输出</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，
则需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性（例如：在 <code>application.properties</code> 中）。</p>
</div>
<div class="paragraph">
<p>下表显示了如何结合使用 <code>logging.*</code> 属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. 日志属性</caption>
<colgroup>
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 57%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>logging.file.name</code></th>
<th class="tableblock halign-left valign-top"><code>logging.file.path</code></th>
<th class="tableblock halign-left valign-top">示例</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅控制台记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>my.log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写入指定的日志文件。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定目录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将 <code>spring.log</code> 写入指定目录。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>日志文件达到10 MB时会旋转，并且与控制台输出一样，默认情况下会记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
可以使用 <code>logging.file.max-size</code> 属性更改大小限制。除非已设置 <code>logging.file.max-history</code> 属性，
否则以前旋转的文件将无限期存档。可以使用 <code>logging.file.total-size-cap</code> 限制日志归档文件的总大小。
当日志归档的总大小超过该阈值时，将删除备份。要在应用程序启动时强制清除日志归档文件，
请使用 <code>logging.file.clean-history-on-start</code> 属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
日志记录属性独立于实际的日志记录基础设施。因此，特定的配置键（例如：Logback的 <code>logback.configurationFile</code>）不是由Spring Boot管理的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-levels">2.4.4. 日志级别</h4>
<div class="paragraph">
<p>通过使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 可以在Spring <code>Environment</code> 中（例如：在 <code>application.properties</code> 中）
设置所有受支持的日志记录器级别。其中 <code>level</code> 是TRACE, DEBUG, INFO, WARN, ERROR, FATAL 或 OFF。
可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器。</p>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>application.properties</code> 中的潜在日志记录设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.root=warn
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用环境变量设置日志记录级别。例如：<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 会将
<code>org.springframework.web</code> 设置为 <code>DEBUG</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
以上方法仅适用于程序包级别的日志记录。由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。
如果需要为类配置日志记录，则可以使用<a href="#boot-features-external-config-application-json"><code>SPRING_APPLICATION_JSON</code></a>变量。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-groups">2.4.5. 日志组</h4>
<div class="paragraph">
<p>能够将相关记录器分组在一起通常是很有用的，以便可以同时配置它们。例如：你可能通常会更改 <em>所有</em> 与Tomcat相关的记录器的日志级别，但是你不容易记住顶层软件包。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，Spring Boot允许你在Spring <code>Environment</code> 中定义日志记录组。例如：以下是通过将“<code>tomcat</code>”组添加到
<code>application.properties</code> 来定义它的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义后，你可以仅使用一行就更改该组中所有记录器的日志级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.tomcat=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot包含以下预定义的日志记录组，它们可以直接使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">记录器</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">web</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.codec</code>, <code>org.springframework.http</code>, <code>org.springframework.web</code>, <code>org.springframework.boot.actuate.endpoint.web</code>, <code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sql</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.jdbc.core</code>, <code>org.hibernate.SQL</code>, <code>org.jooq.tools.LoggerListener</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-configuration">2.4.6. 自定义日志配置</h4>
<div class="paragraph">
<p>可以通过在类路径中包括适当的库来激活各种日志记录系统，并可以通过在类路径的根目录中或在以下Spring
<code>Environment</code> 属性指定的位置中提供适当的配置文件来进一步自定义日志文件：<code>logging.config</code>。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性来强制Spring Boot使用特定的日志记录系统。
该值应该是 <code>LoggingSystem</code> 实现的完全限定类名。你也可以使用 <code>none</code> 值完全禁用Spring Boot的日志记录配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于日志记录是在创建 <code>ApplicationContext</code> <strong>之前</strong> 初始化的，因此无法从Spring
<code>@Configuration</code> 文件中的 <code>@PropertySources</code> 控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>根据你的日志记录系统，将加载以下文件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">志记录系统</th>
<th class="tableblock halign-left valign-top">自定义配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> 或 <code>logback.groovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Log4j2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log4j2-spring.xml</code> 或 <code>log4j2.xml</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDK (Java Util Logging)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.properties</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果可能，我们建议你在日志配置中使用 <code>-spring</code> 变体（例如：使用 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>）。
如果使用标准配置位置，Spring将无法完全控制日志初始化。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这会引起问题。我们建议你尽可能在“可执行jar”运行时避免使用它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了帮助定制，将一些其他属性从Spring <code>Environment</code> 转移到系统属性，如下表所述：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Environment</th>
<th class="tableblock halign-left valign-top">System Property</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.exception-conversion-word</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_EXCEPTION_CONVERSION_WORD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录异常时使用的转换字。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.clean-history-on-start</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_CLEAN_HISTORY_ON_START</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在启动时清除存档日志文件（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_SIZE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大日志文件大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-history</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_HISTORY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的最大归档日志文件数（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_PATH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.total-size-cap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_TOTAL_SIZE_CAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的备份日志的总大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.console</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONSOLE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制台上使用的日志模式（stdout）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.dateformat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_DATEFORMAT_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录日期格式的附加模式。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FILE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件中使用的日志模式（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_LEVEL_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现日志级别时使用的格式（默认为 <code>%5p</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.rolling-file-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROLLING_FILE_NAME_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过渡日志文件名的模式（默认为 <code>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前进程ID（如果可能，并且尚未将其定义为操作系统环境变量时将被发现）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见 <code>spring-boot.jar</code> 中的默认配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要在日志记录属性中使用占位符，则应使用<a href="#boot-features-external-config-placeholders-in-properties">Spring Boot的语法</a>而不是基础框架的语法。
值得注意的是，如果使用Logback，则应使用 <code>:</code> 作为属性名称与其默认值之间的分隔符，而不应使用 <code>:-</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以通过仅覆盖 <code>LOG_LEVEL_PATTERN</code>（或Logback的 <code>logging.pattern.level</code>）来将MDC和其他临时内容添加到日志行。
例如，如果你使用 <code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含一个名为“user”的MDC条目（如果存在），如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
Handling authenticated request</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logback-extensions">2.4.7. Logback扩展</h4>
<div class="paragraph">
<p>Spring Boot包含许多Logback扩展，可以帮助进行高级配置。你可以在 <code>logback-spring.xml</code> 配置文件中使用这些扩展名。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于标准 <code>logback.xml</code> 配置文件加载得太早，因此无法在其中使用扩展名。你需要使用 <code>logback-spring.xml</code> 或定义 <code>logging.config</code> 属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
这些扩展不能与Logback的 <a href="https://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a>一起使用。
如果尝试这样做，则对配置文件进行更改将导致类似于以下日志之一的错误：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</pre>
</div>
</div>
<div class="sect4">
<h5 id="特定于profile的配置">特定于Profile的配置</h5>
<div class="paragraph">
<p>通过 <code>&lt;springProfile&gt;</code> 标记，你可以根据活动的Spring profiles有选择地包括或排除配置部分。
在 <code>&lt;configuration&gt;</code> 元素内的任何位置都支持profile部分。使用 <code>name</code> 属性指定哪个profile接受配置。
<code>&lt;springProfile&gt;</code> 标记可以包含简单的profile名称（例如：<code>staging</code>）或profile表达式。
profile表达式允许表达更复杂的配置文件逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。
有关更多详细信息，请参阅 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#beans-definition-profiles-java">参考指南</a>。
以下清单显示了三个样本profiles：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProfile name="staging"&gt;
    &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="dev | staging"&gt;
    &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="!production"&gt;
    &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;
&lt;/springProfile&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="环境属性">环境属性</h5>
<div class="paragraph">
<p><code>&lt;springProperty&gt;</code> 标签使你可以从Spring <code>Environment</code> 中公开属性，以在Logback中使用。
如果要在Logback配置中访问 <code>application.properties</code> 文件中的值，则这样做很有用。
该标签的工作方式类似于Logback的标准 <code>&lt;property&gt;</code> 标签。但是，不是指定直接 <code>value</code>，而是指定属性的 <code>source</code>（来自 <code>Environment</code>）。
如果需要将属性存储在 <code>local</code> 作用域以外的其他位置，则可以使用 <code>scope</code> 属性。如果需要后备值（如果未在环境中设置该属性），
则可以使用 <code>defaultValue</code> 属性。以下示例显示如何公开在Logback中使用的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
        defaultValue="localhost"/&gt;
&lt;appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"&gt;
    &lt;remoteHost&gt;${fluentHost}&lt;/remoteHost&gt;
    ...
&lt;/appender&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>source</code> 必须以kebab格式指定（例如：<code>my.property-name</code>）。但是，可以使用宽松的规则将属性添加到 <code>Environment</code> 中。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-internationalization">2.5. 国际化</h3>
<div class="paragraph">
<p>Spring Boot支持本地化消息，因此你的应用程序可以迎合不同语言首选项的用户。
默认情况下，Spring Boot在类路径的根目录下查找存在的 <code>messages</code> 资源包。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当已配置资源束的默认属性文件可用时（即默认情况下为 <code>messages.properties</code>），将应用自动配置。
如果你的资源包仅包含特定于语言的属性文件，则需要添加默认文件。如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 <code>MessageSource</code> 可用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.messages</code> 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring.messages.basename</code> 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json">2.6. JSON</h3>
<div class="paragraph">
<p>Spring Boot提供了与三个JSON映射库的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gson</p>
</li>
<li>
<p>Jackson</p>
</li>
<li>
<p>JSON-B</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jackson是首选的默认库。</p>
</div>
<div class="sect3">
<h4 id="boot-features-json-jackson">2.6.1. Jackson</h4>
<div class="paragraph">
<p>提供了Jackson的自动配置，并且Jackson是 <code>spring-boot-starter-json</code> 的一部分。当Jackson放在类路径上时，
将自动配置 <code>ObjectMapper</code> Bean。提供了几个配置属性，用于
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-customize-the-jackson-objectmapper">自定义 <code>ObjectMapper</code> 的配置</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-gson">2.6.2. Gson</h4>
<div class="paragraph">
<p>提供了Gson的自动配置。当Gson在类路径上时，将自动配置 <code>Gson</code> bean。提供了几个 <code>spring.gson.*</code>
配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个 <code>GsonBuilderCustomizer</code> bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-json-b">2.6.3. JSON-B</h4>
<div class="paragraph">
<p>提供了JSON-B的自动配置。当JSON-B API和实现位于类路径上时，将自动配置 <code>Jsonb</code> bean。首选的JSON-B实现是提供了依赖管理的
<a href="http://johnzon.apache.org/">Apache Johnzon</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-developing-web-applications">2.7. 开发Web应用程序</h3>
<div class="paragraph">
<p>Spring Boot非常适合于Web应用程序开发。你可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建独立的HTTP服务器。
大多数Web应用程序都使用 <code>spring-boot-starter-web</code> 模块来快速启动和运行。
你还可以选择使用 <code>spring-boot-starter-webflux</code> 模块构建响应式Web应用程序。</p>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc">2.7.1. Spring Web MVC框架</h4>
<div class="paragraph">
<p><a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">Spring Web MVC框架</a>
（通常简称为“Spring MVC”）是一个丰富的“<code>model view controller</code>”Web框架。
Spring MVC使你可以创建特殊的 <code>@Controller</code> 或 <code>@RestController</code> Bean来处理传入的HTTP请求。
使用 <code>@RequestMapping</code> 注解将控制器中的方法映射到HTTP。</p>
</div>
<div class="paragraph">
<p>以下代码显示了提供JSON数据返回的典型 <code>@RestController</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping(value="/users")
public class MyRestController {

    @RequestMapping(value="/{user}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
    List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
    public User deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC是核心Spring Framework的一部分，有关详细信息，请参阅 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">参考文档</a>。
在 spring.io/guides 上还有一些涵盖Spring MVC的指南。</p>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-auto-configuration">Spring MVC自动配置</h5>
<div class="paragraph">
<p>Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含 <code>ContentNegotiatingViewResolver</code> 和 <code>BeanNameViewResolver</code> Bean。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>Converter</code>，<code>GenericConverter</code> 和 <code>Formatter</code> Bean。</p>
</li>
<li>
<p>对 <code>HttpMessageConverters</code> 的支持（<a href="#boot-features-spring-mvc-message-converters">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>MessageCodesResolver</code>（<a href="#boot-features-spring-message-codes">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>静态 <code>index.html</code> 支持。</p>
</li>
<li>
<p>自定义 <code>Favicon</code> 支持（<a href="#boot-features-spring-mvc-favicon">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动使用 <code>ConfigurableWebBindingInitializer</code> Bean（<a href="#boot-features-spring-mvc-web-binding-initializer">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot MVC功能并想要添加其他 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），
则可以添加自己的类型为 <code>WebMvcConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不添加</strong> <code>@EnableWebMvc</code>。
如果希望提供 <code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code> 或
<code>ExceptionHandlerExceptionResolver</code> 的自定义实例，则可以声明一个 <code>WebMvcRegistrationsAdapter</code> 实例以提供此类组件。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring MVC，则可以添加自己的带有 <code>@EnableWebMvc</code> 注解的 <code>@Configuration</code> 类。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-message-converters">HttpMessageConverters</h5>
<div class="paragraph">
<p>Spring MVC使用 <code>HttpMessageConverter</code> 接口转换HTTP请求和响应。开箱即用中包含明智的默认设置。
例如：可以将对象自动转换为JSON（通过使用Jackson库）或XML（如果可用通过使用Jackson XML扩展或如果Jackson
XML扩展不可用通过使用JAXB）。默认情况下，字符串以 <code>UTF-8</code> 编码。</p>
</div>
<div class="paragraph">
<p>如果你需要添加或自定义转换器，则可以使用Spring Boot的 <code>HttpMessageConverters</code> 类，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上下文中存在的所有 <code>HttpMessageConverter</code> bean都将添加到转换器列表中。你也可以用相同的方法覆盖默认转换器。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-json-components">自定义JSON序列化器和反序列化器</h5>
<div class="paragraph">
<p>如果使用Jackson序列化和反序列化JSON数据，则可能要编写自己的 <code>JsonSerializer</code> 和 <code>JsonDeserializer</code> 类。
自定义序列化程序通常是 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块向Jackson进行注册的</a>，
但是Spring Boot提供了替代的 <code>@JsonComponent</code> 注解，这使得直接注册Spring Bean更加容易。</p>
</div>
<div class="paragraph">
<p>你可以直接在 <code>JsonSerializer</code>，<code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。
你还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

    public static class Serializer extends JsonSerializer&lt;SomeObject&gt; {
        // ...
    }

    public static class Deserializer extends JsonDeserializer&lt;SomeObject&gt; {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> bean都会自动向Jackson注册。
因为 <code>@JsonComponent</code> 用 <code>@Component</code> 进行元注解，所以适用常规的组件扫描规则。</p>
</div>
<div class="paragraph">
<p>Spring Boot还提供了 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a>
和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a>基类，
这些基类在序列化对象时为标准Jackson版本提供了有用的替代方法。有关详细信息，请参见Javadoc中的
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jackson/JsonObjectSerializer.html"><code>JsonObjectSerializer</code></a>和
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jackson/JsonObjectDeserializer.html"><code>JsonObjectDeserializer</code></a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-message-codes">MessageCodesResolver</h5>
<div class="paragraph">
<p>Spring MVC有一种生成错误码以从绑定错误中呈现错误消息的策略：<code>MessageCodesResolver</code>。
如果你设置 <code>spring.mvc.message-codes-resolver-format</code> 属性为 <code>PREFIX_ERROR_CODE</code> 或 <code>POSTFIX_ERROR_CODE</code>，
Spring Boot会为你创建一个（请参见 <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html"><code>DefaultMessageCodesResolver.Format</code></a>中的枚举）。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-static-content">静态内容</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中的 <code>/static</code> 目录（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/ resources</code>）
或ServletContext的根目录中提供静态内容。它使用Spring MVC中的 <code>ResourceHttpRequestHandler</code>，
以便你可以通过添加自己的 <code>WebMvcConfigurer</code> 并重写 <code>addResourceHandlers</code> 方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>在独立的Web应用程序中，还启用了容器中的默认Servlet，并将其用作降级方案，如果Spring决定不处理，
则从 <code>ServletContext</code> 的根目录提供内容。在大多数情况下，这不会发生（除非你修改默认的MVC配置），
因为Spring始终可以通过 <code>DispatcherServlet</code> 处理请求。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以使用 <code>spring.mvc.static-path-pattern</code> 属性进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以按如下方式实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 属性来自定义静态资源位置（用目录位置列表替换默认值）。
根Servlet上下文路径 <code>"/"</code> 也会作为位置自动添加。</p>
</div>
<div class="paragraph">
<p>除了前面提到的“标准”静态资源位置，https://www.webjars.org/[Webjars 内容]还有一个特殊情况。
如果jar文件以Webjars格式打包，则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的应用程序打包为jar，则不要使用 <code>src/main/webapp</code> 目录。尽管此目录是一个通用标准，
但它仅与war打包一起使用，并且如果生成jar，大多数构建工具都将其忽略。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用案例如：缓存清除静态资源或对Webjars使用版本无关的URL。</p>
</div>
<div class="paragraph">
<p>要对Webjars使用版本无关的URL，请添加 <code>webjars-locator-core</code> 依赖项，然后声明你的Webjar。
以jQuery为例，添加 <code>"/webjars/jquery/jquery.min.js"</code> 将得到 <code>"/webjars/jquery/x.y.z/jquery.min.js"</code>，
其中 <code>x.y.z</code> 是Webjar版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用JBoss，则需要声明 <code>webjars-locator-jboss-vfs</code> 依赖项，而不是 <code>webjars-locator-core</code>。
否则，所有Webjar都解析为 <code>404</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，并在URL中有效地添加了内容哈希，例如：
<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过为Thymeleaf和FreeMarker自动配置 <code>ResourceUrlEncodingFilter</code>，可以在运行时在模板中重写到资源的链接。
使用JSP时，你应该手动声明此过滤器。当前尚不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，以及使用
<a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如：当使用JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以相互组合的原因。
“固定”策略在URL中添加静态版本字符串，而不更改文件名，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这种配置，位于 <code>"/js/lib/"</code> 下的JavaScript模块使用固定的版本控制策略（<code>"/v12/js/lib/mymodule.js"</code>），
而其他资源仍使用内容版本（<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code>）。</p>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java"><code>ResourceProperties</code></a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该功能已在专门的 <a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客文章</a>
和Spring Framework的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-config-static-resources">参考文档</a>中进行了详细说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-welcome-page">欢迎页面</h5>
<div class="paragraph">
<p>Spring Boot支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找 <code>index.html</code> 文件。如果未找到，则寻找 <code>index</code>
模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-favicon">自定义图标</h5>
<div class="paragraph">
<p>与其他静态资源一样，Spring Boot在已配置的静态内容位置中查找 <code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-pathmatch">路径匹配和内容协商</h5>
<div class="paragraph">
<p>Spring MVC可以通过查看请求路径并将其匹配到应用程序中定义的映射（例如：Controller方法上的 <code>@GetMapping</code> 注解）来将传入的HTTP请求映射到处理程序。</p>
</div>
<div class="paragraph">
<p>Spring Boot选择默认情况下禁用后缀模式匹配，这意味着 <code>"GET /projects/spring-boot.json"</code> 之类的请求将不会与
<code>@GetMapping("/projects/spring-boot")</code> 映射进行匹配。这被认为是
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC应用程序的最佳实践</a>。
过去，此功能主要用于未发送正确的“Accept”请求头的HTTP客户端，我们需要确保将正确的内容类型发送给客户端。
如今，内容协商已变得更加可靠。</p>
</div>
<div class="paragraph">
<p>还有其他处理HTTP客户端的方法，这些客户端不能始终发送正确的“Accept”请求头。
除了使用后缀匹配，我们还可以使用查询参数来确保将诸如 <code>"GET /projects/spring-boot?format=json"</code> 之类的请求映射到
<code>@GetMapping("/projects/spring-boot")</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你了解了注意事项，但仍希望你的应用程序使用后缀模式匹配，则需要以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-suffix-pattern=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，与其打开所有后缀模式，不如只支持已注册的后缀模式，这更安全：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-web-binding-initializer">ConfigurableWebBindingInitializer</h5>
<div class="paragraph">
<p>Spring MVC使用 <code>WebBindingInitializer</code> 来为特定请求初始化 <code>WebDataBinder</code>。
如果创建自己的 <code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC以使用它。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-template-engines">模板引擎</h5>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，
包括Thymeleaf，FreeMarker和JSP。同样，许多其他模板引擎也提供包括他们自己的Spring MVC集成。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果可能，应避免使用JSP。将它们与嵌入式servlet容器一起使用时，存在几个<a href="#boot-features-jsp-limitations">已知的限制</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
根据你运行应用程序的方式，IntelliJ IDEA对类路径的排序不同。与使用Maven或Gradle或从其打包的jar运行应用程序时相比，
从IDE的main方法运行应用程序的顺序会有所不同。这可能导致Spring Boot无法在类路径上找到模板。
如果遇到此问题，可以在IDE中重新排序类路径，以首先放置模块的类和资源。
或者，你可以配置模板前缀以搜索类路径上的每个 <code>templates</code> 目录，例如：<code>classpath*:/templates/</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling">错误处理</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot提供一个 <code>/error</code> 映射，以一种明智的方式处理所有错误，并且在servlet容器中注册为“<code>global</code>”错误页面。
对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“<code>whitelabel</code>”错误视图以HTML格式呈现相同的数据（要对其进行自定义，请添加一个可解决 <code>error</code> 的 <code>View</code>）。
要完全替换默认行为，可以实现 <code>ErrorController</code> 并注册该类型的bean定义，或者添加类型为 <code>ErrorAttributes</code> 的bean以使用现有机制，但替换其内容。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>BasicErrorController</code> 可用作自定义 <code>ErrorController</code> 的基类。如果要为新的内容类型添加处理程序（默认是专门处理
<code>text/html</code> 并为其他所有内容提供降级功能），则此功能特别有用。为此，请继承 <code>BasicErrorController</code>，添加具有 <code>@RequestMapping</code>
的公共方法，该方法具有 <code>produces</code> 属性，并创建新类型的Bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以定义一个用 <code>@ControllerAdvice</code> 注解的类，以自定义JSON文档以针对特定的控制器和/或异常类型返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(YourException.class)
    @ResponseBody
    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new CustomErrorType(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果与 <code>AcmeController</code> 在同一包中定义的控制器抛出 <code>YourException</code>，则使用 <code>CustomErrorType</code>
POJO的JSON表示形式而不是 <code>ErrorAttributes</code> 表示形式。</p>
</div>
<div class="sect5">
<h6 id="boot-features-error-handling-custom-error-pages">自定义错误页面</h6>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板来构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用FreeMarker模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的映射，还可以添加实现 <code>ErrorViewResolver</code> 接口的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request,
            HttpStatus status, Map&lt;String, Object&gt; model) {
        // Use the request or status to optionally return a ModelAndView
        return ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用常规的Spring MVC功能，例如： <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-exceptionhandlers"><code>@ExceptionHandler</code> 方法</a>和
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a>。然后，<code>ErrorController</code> 拾取所有未处理的异常。</p>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-error-handling-mapping-error-pages-without-mvc">在Spring MVC之外映射错误页面</h6>
<div class="paragraph">
<p>对于不使用Spring MVC的应用程序，可以使用 <code>ErrorPageRegistrar</code> 接口直接注册 <code>ErrorPages</code>。
此抽象直接与基础嵌入式servlet容器一起使用，即使你没有Spring MVC <code>DispatcherServlet</code> 它也可以使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ErrorPageRegistrar errorPageRegistrar(){
    return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>ErrorPage</code> 上注册了一个最终由 <code>Filter</code> 处理的路径（这在某些非Spring Web框架中很常见，如Jersey和Wicket），
则必须将 <code>Filter</code> 显式注册为 <code>ERROR</code> 调度程序，如下面的例子所示：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new MyFilter());
    ...
    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
    return registration;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，默认的 <code>FilterRegistrationBean</code> 不包含 <code>ERROR</code> 调度程序类型。</p>
</div>
<div id="boot-features-error-handling-websphere" class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
当部署到Servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到适当的错误页面。
如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0
及更高版本在成功完成servlet的服务方法后提交响应。
你应该通过将 <code>com.ibm.ws.webcontainer.invokeFlushAfterService</code> 设置为 <code>false</code> 来禁用此行为。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-hateoas">Spring HATEOAS</h5>
<div class="paragraph">
<p>如果你开发使用超媒体的RESTful API，Spring Boot将为Spring HATEOAS提供自动配置，
该配置可与大多数应用程序很好地兼容。自动配置取代了手动使用 <code>@EnableHypermediaSupport</code> 的需要，
并注册了许多bean来简化基于超媒体的应用程序的构建，其中包括 <code>LinkDiscoverers</code>（用于客户端支持）和 <code>ObjectMapper</code>
其配置为将响应正确地组装为所需的表示形式。通过设置各种 <code>spring.jackson.*</code> 属性，
或通过 <code>Jackson2ObjectMapperBuilder</code> bean（如果存在）来定制 <code>ObjectMapper</code>。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@EnableHypermediaSupport</code> 来控制Spring HATEOAS的配置。请注意，这样做会禁用前面所述的 <code>ObjectMapper</code> 定制。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-cors">CORS支持</h5>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>（CORS）是由 <a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实施的
<a href="https://www.w3.org/TR/cors/">W3C 规范</a>，可让你灵活地指定授权哪种类型的跨域请求，而不是使用诸如IFRAME或JSONP之类的安全性较低，功能较弱的方法。</p>
</div>
<div class="paragraph">
<p>从4.2版本开始，Spring MVC <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors">支持CORS</a>。在Spring Boot应用程序中使用带有
<a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>
注解的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors-controller">控制器方法CORS配置</a>不需要任何特定的配置。
可以通过使用自定义的 <code>addCorsMappings(CorsRegistry)</code> 方法注册 <code>WebMvcConfigurer</code> Bean来定义
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors-global">全局CORS配置</a>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux">2.7.2. Spring WebFlux框架</h4>
<div class="paragraph">
<p>Spring WebFlux是Spring Framework 5.0中引入的新响应式Web框架。
与Spring MVC不同，它不需要Servlet API，是完全异步和非阻塞的，并且通过 <a href="https://projectreactor.io/">Reactor项目</a>
实现 <a href="https://www.reactive-streams.org/">Reactive Streams</a>规范。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux有两种形式：函数式的和基于注解的。基于注解的模型非常类似于Spring MVC模型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/users")
public class MyRestController {

    @GetMapping("/{user}")
    public Mono&lt;User&gt; getUser(@PathVariable Long user) {
        // ...
    }

    @GetMapping("/{user}/customers")
    public Flux&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @DeleteMapping("/{user}")
    public Mono&lt;User&gt; deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数式变体“<code>WebFlux.fn</code>”将路由配置与请求的实际处理分开，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class RoutingConfiguration {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler) {
        return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
                .andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
                .andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
    }

}

@Component
public class UserHandler {

    public Mono&lt;ServerResponse&gt; getUser(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; deleteUser(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux是Spring Framework的一部分，其 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-fn">参考文档</a>中提供了详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以根据需要定义任意数量的 <code>RouterFunction</code> beans，以对路由器的定义进行模块化。如果需要应用优先级，可以排序Beans。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先将 <code>spring-boot-starter-webflux</code> 模块添加到你的应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在应用程序中同时添加 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-webflux</code> 模块会导致Spring
Boot自动配置Spring MVC，而不是WebFlux。之所以选择这种行为，是因为许多Spring开发人员将 <code>spring-boot-starter-webflux</code>
添加到其Spring MVC应用程序中以使用响应式 <code>WebClient</code>。你仍然可以通过将选定的应用程序类型设置为
<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code> 来强制执行选择。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-auto-configuration">Spring WebFlux自动配置</h5>
<div class="paragraph">
<p>Spring Boot为Spring WebFlux提供了自动配置，可与大多数应用程序很好地配合使用。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 实例配置编解码器（<a href="#boot-features-webflux-httpcodecs">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot WebFlux功能并想要添加其他WebFlux配置，则可以添加自己的类型为
<code>WebFluxConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不</strong> 添加 <code>@EnableWebFlux</code>。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring WebFlux，则可以添加带有 <code>@EnableWebFlux</code> 注解的自己的 <code>@Configuration</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-httpcodecs">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h5>
<div class="paragraph">
<p>Spring WebFlux使用 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 接口转换HTTP请求和响应。
通过查看类路径中可用的库，使用 <code>CodecConfigurer</code> 将它们配置为具有合理的默认值。</p>
</div>
<div class="paragraph">
<p>Spring Boot为编解码器 <code>spring.codec.*</code> 提供了专用的配置属性。它还通过使用 <code>CodecCustomizer</code> 实例应用进一步的自定义。
例如，将 <code>spring.jackson.*</code> 配置keys应用于Jackson编解码器。</p>
</div>
<div class="paragraph">
<p>如果需要添加或自定义编解码器，则可以创建一个自定义 <code>CodecCustomizer</code> 组件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.codec.CodecCustomizer;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return codecConfigurer -&gt; {
            // ...
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以利用<a href="#boot-features-json-components">Boot&#8217;s自定义JSON序列化器和反序列化器</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-static-content">静态内容</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中名为 <code>/static</code>（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code>）的目录中提供静态内容。
它使用Spring WebFlux中的 <code>ResourceWebHandler</code>，以便你可以通过添加自己的 <code>WebFluxConfigurer</code> 并覆盖 <code>addResourceHandlers</code>
方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以通过设置 <code>spring.webflux.static-path-pattern</code> 属性来对其进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以实现如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webflux.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 自定义静态资源位置。这样做会将默认值替换为目录位置列表。
如果这样做，默认的欢迎页面检测将切换到你的自定义位置。因此，如果启动时你指定的任何位置有 <code>index.html</code>，则它是应用程序的主页。</p>
</div>
<div class="paragraph">
<p>除了前面列出的“标准”静态资源位置外，https://www.webjars.org/[Webjar内容]有个特殊情况。如果jar文件以Webjars格式打包，
则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring WebFlux应用程序不严格依赖Servlet API，因此不能将它们部署为war文件，也不使用 <code>src/main/webapp</code> 目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-template-engines">模板引擎</h5>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring WebFlux来提供动态HTML内容。
Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-error-handling">错误处理</h5>
<div class="paragraph">
<p>Spring Boot提供了一个 <code>WebExceptionHandler</code>，以一种明智的方式处理所有错误。它在处理顺序中的位置紧靠WebFlux提供的处理程序之前，
后者被认为是最后一个处理程序。对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“whitelabel”错误处理程序，以HTML格式呈现相同的数据。你还可以提供自己的HTML模板来显示错误（请参阅
<a href="#boot-features-webflux-error-handling-custom-error-pages">下一节</a>）。</p>
</div>
<div class="paragraph">
<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，你可以添加类型为 <code>ErrorAttributes</code> 的bean。</p>
</div>
<div class="paragraph">
<p>要更改错误处理行为，可以实现 <code>ErrorWebExceptionHandler</code> 并注册该类型的bean定义。由于 <code>WebExceptionHandler</code> 的级别很低，
因此Spring Boot还提供了一个方便的 <code>AbstractErrorWebExceptionHandler</code>，可让你以WebFlux函数式方式处理错误，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    // Define constructor here

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) {

        return RouterFunctions
                .route(aPredicate, aHandler)
                .andRoute(anotherPredicate, anotherHandler);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了获得更完整的图像，你还可以直接将 <code>DefaultErrorWebExceptionHandler</code> 子类化并重写特定方法。</p>
</div>
<div class="sect5">
<h6 id="boot-features-webflux-error-handling-custom-error-pages">自定义错误页面</h6>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用Mustache模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-web-filters">Web过滤器</h5>
<div class="paragraph">
<p>Spring WebFlux提供了一个 <code>WebFilter</code> 接口，可以实现该接口来过滤HTTP请求-响应交换。
在应用程序上下文中找到的 <code>WebFilter</code> bean将自动用于过滤每个交换。</p>
</div>
<div class="paragraph">
<p>如果过滤器的顺序很重要，则可以实现 <code>Ordered</code> 或使用 <code>@Order</code> 进行注解。
Spring Boot自动配置会为你配置Web过滤器。这样做时，将使用下表中显示的顺序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Web过滤器</th>
<th class="tableblock halign-left valign-top">顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MetricsWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilterChainProxy</code> (Spring Security)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-100</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpTraceWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE - 10</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jersey">2.7.3. JAX-RS和Jersey</h4>
<div class="paragraph">
<p>如果你更喜欢REST端点的JAX-RS编程模型，则可以使用可用的实现之一来代替Spring MVC。
<a href="https://jersey.github.io/">Jersey</a> 和 <a href="https://cxf.apache.org/">Apache CXF</a>开箱即用。
CXF要求你在应用程序上下文中将其 <code>Servlet</code> 或 <code>Filter</code> 注册为 <code>@Bean</code>。
Jersey提供了一些native Spring支持，因此我们还在Spring Boot中提供了对它的自动配置支持，以及一个启动器。</p>
</div>
<div class="paragraph">
<p>要开始使用Jersey，请将 <code>spring-boot-starter-jersey</code> 作为依赖项包括在内，然后需要一个
<code>ResourceConfig</code> 类型的 <code>@Bean</code>，在其中注册所有端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Jersey&#8217;s对扫描可执行档案的支持非常有限。例如：在运行可执行的war文件时，
它无法扫描在<a href="deployment.html#deployment-install">完全可执行的jar文件</a>或
<code>WEB-INF/classes</code> 中找到的包中的端点。为了避免这种限制，不应该使用 <code>packages</code> 方法，
而应该使用 <code>register</code> 方法分别注册端点，如前面的示例所示。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于更高级的定制，你还可以注册任意数量的 <code>ResourceConfigCustomizer</code> 实现beans。</p>
</div>
<div class="paragraph">
<p>所有注册的端点应为具有HTTP资源注解的 <code>@Components</code>（<code>@GET</code> 和其他注解），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Path("/hello")
public class Endpoint {

    @GET
    public String message() {
        return "Hello";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于端点是Spring <code>@Component</code>，因此其生命周期由Spring管理，你可以使用 <code>@Autowired</code> 注解注入依赖项，
并使用 <code>@Value</code> 注解注入外部配置。默认情况下，Jersey servlet被注册并映射到 <code>/*</code>。
你可以通过将 <code>@ApplicationPath</code> 添加到 <code>ResourceConfig</code> 来更改映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jersey在名为 <code>jerseyServletRegistration</code> 的 <code>ServletRegistrationBean</code> 类型的 <code>@Bean</code> 中设置为Servlet。
默认情况下，该Servlet延迟初始化，但是你可以通过设置 <code>spring.jersey.servlet.load-on-startup</code> 来自定义该行为。
你可以通过创建自己的同名bean之一来禁用或覆盖该bean。你还可以通过设置 <code>spring.jersey.type=filter</code>
（在这种情况下，要替换或覆盖的 <code>@Bean</code> 是 <code>jerseyFilterRegistration</code>）来使用过滤器而不是servlet。
过滤器具有 <code>@Order</code>，你可以使用 <code>spring.jersey.filter.order</code> 进行设置。可以通过使用 <code>spring.jersey.init.*</code> 来指定属性映射，
从而为servlet和过滤器注册都赋予init参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container">2.7.4. 嵌入式Servlet容器支持</h4>
<div class="paragraph">
<p>Spring Boot包括对嵌入式 <a href="https://tomcat.apache.org/">Tomcat</a>， <a href="https://www.eclipse.org/jetty/">Jetty</a>和
默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners">Servlets, Filters和listeners</h5>
<div class="paragraph">
<p>使用嵌入式Servlet容器时，可以通过使用Spring beans或扫描Servlet组件来注册Servlet规范中的servlets，过滤器和所有监听器（例如：<code>HttpSessionListener</code>）。</p>
</div>
<div class="sect5">
<h6 id="boot-features-embedded-container-servlets-filters-listeners-beans">将Servlets, Filters和Listeners注册为Spring Beans</h6>
<div class="paragraph">
<p>任何作为Spring Bean的 <code>Servlet</code>，<code>Filter</code> 或 <code>*Listener</code> 实例都向嵌入式容器注册。如果要在配置过程中引用
<code>application.properties</code> 中的值，这可能特别方便。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果上下文仅包含单个Servlet，则将其映射到 <code>/</code>。对于多个servlet bean，bean名称被用作路径前缀。
过滤器映射到 <code>/*</code>。</p>
</div>
<div class="paragraph">
<p>如果基于约定的映射不够灵活，则可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>
和 <code>ServletListenerRegistrationBean</code> 类进行完全控制。</p>
</div>
<div class="paragraph">
<p>通常可以使无序的过滤器beans处于安全状态。如果需要特定的顺序，则应使用 <code>@Order</code> 注解 <code>Filter</code> 或使其实现 <code>Ordered</code>。
你不能通过使用 <code>@Order</code> 注解 <code>Filter</code> 的bean方法来配置 <code>Filter</code> 的顺序。如果你不能更改 <code>Filter</code> 类以添加 <code>@Order</code> 或实现 <code>Ordered</code>，
则必须为 <code>Filter</code> 定义一个 <code>FilterRegistrationBean</code> 并使用 <code>setOrder(int)</code> 方法设置注册bean的顺序。
避免配置一个在 <code>Ordered.HIGHEST_PRECEDENCE</code> 上读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。
如果Servlet过滤器包装了请求，则应使用小于或等于 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 的顺序来配置它。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要查看应用程序中每个 <code>Filter</code> 的顺序，请为 <code>web</code> <a href="#boot-features-custom-log-groups">日志记录组</a>
（<code>logging.level.web=debug</code>）启用调试级别的日志记录。然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
注册 <code>Filter</code> beans时要小心，因为它们是在应用程序生命周期中很早就初始化的。如果需要注册与其他bean交互的 <code>Filter</code>
，请考虑改用 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/web/servlet/DelegatingFilterProxyRegistrationBean.html"><code>DelegatingFilterProxyRegistrationBean</code></a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-context-initializer">Servlet上下文初始化</h5>
<div class="paragraph">
<p>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code> 接口或Spring的
<code>org.springframework.web.WebApplicationInitializer</code> 接口。这是一个有意的设计决定，
旨在降低在war中运行的第三方库可能破坏Spring Boot应用程序的风险。</p>
</div>
<div class="paragraph">
<p>如果你需要在Spring Boot应用程序中执行Servlet上下文初始化，则应该注册一个实现
<code>org.springframework.boot.web.servlet.ServletContextInitializer</code> 接口的bean。
单个 <code>onStartup</code> 方法提供对 <code>ServletContext</code> 的访问，并且在必要时可以轻松地用作现有 <code>WebApplicationInitializer</code> 的适配器。</p>
</div>
<div class="sect5">
<h6 id="boot-features-embedded-container-servlets-filters-listeners-scanning">扫描Servlets, Filters和Listeners</h6>
<div class="paragraph">
<p>使用嵌入式容器时，可以使用 <code>@ServletComponentScan</code> 启用自动注册带有 <code>@WebServlet</code>，<code>@WebFilter</code> 和 <code>@WebListener</code> 的类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@ServletComponentScan</code> 在独立容器中无效，而是使用容器的内置发现机制。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-application-context">ServletWebServerApplicationContext</h5>
<div class="paragraph">
<p>在后台，Spring Boot使用另一种类型的 <code>ApplicationContext</code> 来支持嵌入式Servlet容器。
<code>ServletWebServerApplicationContext</code> 是 <code>WebApplicationContext</code> 的一种特殊类型，
它通过搜索单个 <code>ServletWebServerFactory</code> bean来自我引导。通常，已经自动配置了
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 或 <code>UndertowServletWebServerFactory</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通常，你不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表你创建了相应的 <code>ApplicationContext</code>
和 <code>ServletWebServerFactory</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-customizing-embedded-containers">自定义嵌入式Servlet容器</h5>
<div class="paragraph">
<p>可以使用Spring <code>Environment</code> 属性来配置常见的servlet容器设置。通常，你将在 <code>application.properties</code>
文件中定义属性。</p>
</div>
<div class="paragraph">
<p>常用服务器设置包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络设置：监听传入HTTP请求的端口（<code>server.port</code>），绑定到 <code>server.address</code> 的接口地址，等等。</p>
</li>
<li>
<p>会话设置：会话是否持久（<code>server.servlet.session.persistent</code>），会话超时（<code>server.servlet.session.timeout</code>），
会话数据的位置（<code>server.servlet.session.store-dir</code>）和会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</p>
</li>
<li>
<p>错误管理：错误页面的位置（<code>server.error.path</code>）等。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-configure-ssl">SSL</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression">HTTP压缩</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot尝试尽可能多地公开通用设置，但这并不总是可能的。对于这些情况，
专用名称空间提供特定服务器的自定义项（请参阅 <code>server.tomcat</code> 和 <code>server.undertow</code>）。
例如：可以使用嵌入式servlet容器的特定功能配置 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-configure-accesslogs">访问日志</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关完整列表，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="boot-features-programmatic-embedded-container-customization">编程定制</h6>
<div class="paragraph">
<p>如果需要以编程方式配置嵌入式Servlet容器，则可以注册一个实现 <code>WebServerFactoryCustomizer</code> 接口的Spring
Bean。<code>WebServerFactoryCustomizer</code> 提供对 <code>ConfigurableServletWebServerFactory</code>
的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 和 <code>UndertowServletWebServerFactory</code> 是
<code>ConfigurableServletWebServerFactory</code> 的专用变体，分别具有针对Tomcat，Jetty和Undertow的其他自定义设置方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-customizing-configurableservletwebserverfactory-directly">直接自定义ConfigurableServletWebServerFactory</h6>
<div class="paragraph">
<p>如果上述定制技术太有限，则可以自己注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>
或 <code>UndertowServletWebServerFactory</code> bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
    return factory;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供了许多配置选项的设置器。如果你需要做一些更奇特的操作，还提供了几种受保护的方法“<code>hooks</code>”。有关详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">源代码文档</a>。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jsp-limitations">JSP局限性</h5>
<div class="paragraph">
<p>运行使用嵌入式servlet容器（并打包为可执行档案）的Spring Boot应用程序时，JSP支持存在一些限制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Jetty和Tomcat，如果使用war包装，它应该可以工作。
一个可执行的war在使用 <code>java -jar</code> 启动时可以工作，并且可以部署到任何标准容器中。使用可执行jar时不支持JSPs。</p>
</li>
<li>
<p>Undertow不支持JSPs。</p>
</li>
<li>
<p>创建定制的 <code>error.jsp</code> 页面不会覆盖默认视图以进行<a href="#boot-features-error-handling">错误处理</a>。应改用
<a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a>。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-reactive-server">2.7.5. 响应式嵌入服务器支持</h4>
<div class="paragraph">
<p>Spring Boot包含对以下响应式Web嵌入服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。
大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-reactive-server-resources">2.7.6. 响应式服务器资源配置</h4>
<div class="paragraph">
<p>当自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，这些bean将向服务器实例提供HTTP资源：
<code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，这些资源还将与Reactor Netty和Jetty客户端共享，以实现最佳性能，前提是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器和客户端使用相同的技术</p>
</li>
<li>
<p>客户端实例是使用Spring Boot自动配置的 <code>WebClient.Builder</code> bean构建的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="#boot-features-webclient-runtime">WebClient Runtime部分</a>中了解有关客户端资源配置的更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket">2.8. RSocket</h3>
<div class="paragraph">
<p><a href="https://rsocket.io">RSocket</a> is a binary protocol for use on byte stream transports.
It enables symmetric interaction models via async message passing over a single connection.</p>
</div>
<div class="paragraph">
<p>The <code>spring-messaging</code> module of the Spring Framework provides support for RSocket requesters and responders, both on the client and on the server side.
See the <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#rsocket-spring">RSocket section</a> of the Spring Framework reference for more details, including an overview of the RSocket protocol.</p>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-strategies-auto-configuration">2.8.1. RSocket Strategies Auto-configuration</h4>
<div class="paragraph">
<p>Spring Boot auto-configures an <code>RSocketStrategies</code> bean that provides all the required infrastructure for encoding and decoding RSocket payloads.
By default, the auto-configuration will try to configure the following (in order):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://cbor.io/">CBOR</a> codecs with Jackson</p>
</li>
<li>
<p>JSON codecs with Jackson</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>spring-boot-starter-rsocket</code> starter provides both dependencies.
Check out the <a href="#boot-features-json-jackson">Jackson support section</a> to know more about customization possibilities.</p>
</div>
<div class="paragraph">
<p>Developers can customize the <code>RSocketStrategies</code> component by creating beans that implement the <code>RSocketStrategiesCustomizer</code> interface.
Note that their <code>@Order</code> is important, as it determines the order of codecs.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-server-auto-configuration">2.8.2. RSocket server Auto-configuration</h4>
<div class="paragraph">
<p>Spring Boot provides RSocket server auto-configuration.
The required dependencies are provided by the <code>spring-boot-starter-rsocket</code>.</p>
</div>
<div class="paragraph">
<p>Spring Boot allows exposing RSocket over WebSocket from a WebFlux server, or standing up an independent RSocket server.
This depends on the type of application and its configuration.</p>
</div>
<div class="paragraph">
<p>For WebFlux application (i.e. of type <code>WebApplicationType.REACTIVE</code>), the RSocket server will be plugged into the Web Server only if the following properties match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
spring.rsocket.server.transport=websocket # websocket is chosen as a transport
#spring.rsocket.server.port= # no port is defined</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Plugging RSocket into a web server is only supported with Reactor Netty, as RSocket itself is built with that library.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, an RSocket TCP or websocket server is started as an independent, embedded server.
Besides the dependency requirements, the only required configuration is to define a port for that server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.port=9898 # the only required configuration
spring.rsocket.server.transport=tcp # you're free to configure other properties</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-messaging">2.8.3. Spring Messaging RSocket support</h4>
<div class="paragraph">
<p>Spring Boot will auto-configure the Spring Messaging infrastructure for RSocket.</p>
</div>
<div class="paragraph">
<p>This means that Spring Boot will create a <code>RSocketMessageHandler</code> bean that will handle RSocket requests to your application.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-requester">2.8.4. Calling RSocket Services with <code>RSocketRequester</code></h4>
<div class="paragraph">
<p>Once the <code>RSocket</code> channel is established between server and client, any party can send or receive requests to the other.</p>
</div>
<div class="paragraph">
<p>As a server, you can get injected with an <code>RSocketRequester</code> instance on any handler method of an RSocket <code>@Controller</code>.
As a client, you need to configure and establish an RSocket connection first.
Spring Boot auto-configures an <code>RSocketRequester.Builder</code> for such cases with the expected codecs.</p>
</div>
<div class="paragraph">
<p>The <code>RSocketRequester.Builder</code> instance is a prototype bean, meaning each injection point will provide you with a new instance .
This is done on purpose since this builder is stateful and you shouldn&#8217;t create requesters with different setups using the same instance.</p>
</div>
<div class="paragraph">
<p>The following code shows a typical example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RSocketRequester rsocketRequester;

    public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
        this.rsocketRequester = rsocketRequesterBuilder
                .connectTcp("example.org", 9898).block();
    }

    public Mono&lt;User&gt; someRSocketCall(String name) {
        return this.requester.route("user").data(name)
                .retrieveMono(User.class);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security">2.9. Security</h3>
<div class="paragraph">
<p>If <a href="https://spring.io/projects/spring-security">Spring Security</a> is on the classpath, then web applications are secured by default.
Spring Boot relies on Spring Security’s content-negotiation strategy to determine whether to use <code>httpBasic</code> or <code>formLogin</code>.
To add method-level security to a web application, you can also add <code>@EnableGlobalMethodSecurity</code> with your desired settings.
Additional information can be found in the <a href="https://docs.spring.io/spring-security/site/docs/{spring-security-version}/reference/htmlsingle/#jc-method">Spring Security Reference Guide</a>.</p>
</div>
<div class="paragraph">
<p>The default <code>UserDetailsService</code> has a single user.
The user name is <code>user</code>, and the password is random and is printed at INFO level when the application starts, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you fine-tune your logging configuration, ensure that the <code>org.springframework.boot.autoconfigure.security</code> category is set to log <code>INFO</code>-level messages.
Otherwise, the default password is not printed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can change the username and password by providing a <code>spring.security.user.name</code> and <code>spring.security.user.password</code>.</p>
</div>
<div class="paragraph">
<p>The basic features you get by default in a web application are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>UserDetailsService</code> (or <code>ReactiveUserDetailsService</code> in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a> for the properties of the user).</p>
</li>
<li>
<p>Form-based login or HTTP Basic security (depending on the <code>Accept</code> header in the request) for the entire application (including actuator endpoints if actuator is on the classpath).</p>
</li>
<li>
<p>A <code>DefaultAuthenticationEventPublisher</code> for publishing authentication events.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can provide a different <code>AuthenticationEventPublisher</code> by adding a bean for it.</p>
</div>
<div class="sect3">
<h4 id="boot-features-security-mvc">2.9.1. MVC Security</h4>
<div class="paragraph">
<p>The default security configuration is implemented in <code>SecurityAutoConfiguration</code> and <code>UserDetailsServiceAutoConfiguration</code>.
<code>SecurityAutoConfiguration</code> imports <code>SpringBootWebSecurityConfiguration</code> for web security and <code>UserDetailsServiceAutoConfiguration</code> configures authentication, which is also relevant in non-web applications.
To switch off the default web application security configuration completely or to combine multiple Spring Security components such as OAuth 2 Client and Resource Server, add a bean of type <code>WebSecurityConfigurerAdapter</code> (doing so does not disable the <code>UserDetailsService</code> configuration or Actuator&#8217;s security).</p>
</div>
<div class="paragraph">
<p>To also switch off the <code>UserDetailsService</code> configuration, you can add a bean of type <code>UserDetailsService</code>, <code>AuthenticationProvider</code>, or <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>Access rules can be overridden by adding a custom <code>WebSecurityConfigurerAdapter</code>.
Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources.
<code>EndpointRequest</code> can be used to create a <code>RequestMatcher</code> that is based on the configprop:management.endpoints.web.base-path[] property.
<code>PathRequest</code> can be used to create a <code>RequestMatcher</code> for resources in commonly used locations.</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-webflux">2.9.2. WebFlux Security</h4>
<div class="paragraph">
<p>Similar to Spring MVC applications, you can secure your WebFlux applications by adding the <code>spring-boot-starter-security</code> dependency.
The default security configuration is implemented in <code>ReactiveSecurityAutoConfiguration</code> and <code>UserDetailsServiceAutoConfiguration</code>.
<code>ReactiveSecurityAutoConfiguration</code> imports <code>WebFluxSecurityConfiguration</code> for web security and <code>UserDetailsServiceAutoConfiguration</code> configures authentication, which is also relevant in non-web applications.
To switch off the default web application security configuration completely, you can add a bean of type <code>WebFilterChainProxy</code> (doing so does not disable the <code>UserDetailsService</code> configuration or Actuator&#8217;s security).</p>
</div>
<div class="paragraph">
<p>To also switch off the <code>UserDetailsService</code> configuration, you can add a bean of type <code>ReactiveUserDetailsService</code> or <code>ReactiveAuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>Access rules and the use of multiple Spring Security components such as OAuth 2 Client and Resource Server can be configured by adding a custom <code>SecurityWebFilterChain</code> bean.
Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources.
<code>EndpointRequest</code> can be used to create a <code>ServerWebExchangeMatcher</code> that is based on the configprop:management.endpoints.web.base-path[] property.</p>
</div>
<div class="paragraph">
<p><code>PathRequest</code> can be used to create a <code>ServerWebExchangeMatcher</code> for resources in commonly used locations.</p>
</div>
<div class="paragraph">
<p>For example, you can customize your security configuration by adding something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange()
            .matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
            .pathMatchers("/foo", "/bar")
                .authenticated().and()
            .formLogin().and()
        .build();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2">2.9.3. OAuth2</h4>
<div class="paragraph">
<p><a href="https://oauth.net/2/">OAuth2</a> is a widely used authorization framework that is supported by Spring.</p>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-client">Client</h5>
<div class="paragraph">
<p>If you have <code>spring-security-oauth2-client</code> on your classpath, you can take advantage of some auto-configuration to make it easy to set up an OAuth2/Open ID Connect clients.
This configuration makes use of the properties under <code>OAuth2ClientProperties</code>.
The same properties are applicable to both servlet and reactive applications.</p>
</div>
<div class="paragraph">
<p>You can register multiple OAuth2 clients and providers under the <code>spring.security.oauth2.client</code> prefix, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client-1.client-id=abcd
spring.security.oauth2.client.registration.my-client-1.client-secret=password
spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-1.scope=user
spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-2.client-id=abcd
spring.security.oauth2.client.registration.my-client-2.client-secret=password
spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-2.scope=email
spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>For OpenID Connect providers that support <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect discovery</a>, the configuration can be further simplified.
The provider needs to be configured with an <code>issuer-uri</code> which is the URI that the it asserts as its Issuer Identifier.
For example, if the <code>issuer-uri</code> provided is "https://example.com", then an <code>OpenID Provider Configuration Request</code> will be made to "https://example.com/.well-known/openid-configuration".
The result is expected to be an <code>OpenID Provider Configuration Response</code>.
The following example shows how an OpenID Connect Provider can be configured with the <code>issuer-uri</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, Spring Security&#8217;s <code>OAuth2LoginAuthenticationFilter</code> only processes URLs matching <code>/login/oauth2/code/*</code>.
If you want to customize the <code>redirect-uri</code> to use a different pattern, you need to provide configuration to process that custom pattern.
For example, for servlet applications, you can add your own <code>WebSecurityConfigurerAdapter</code> that resembles the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .redirectionEndpoint()
                    .baseUri("/custom-callback");
    }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-security-oauth2-common-providers">OAuth2 client registration for common providers</h6>
<div class="paragraph">
<p>For common OAuth2 and OpenID providers, including Google, Github, Facebook, and Okta, we provide a set of provider defaults (<code>google</code>, <code>github</code>, <code>facebook</code>, and <code>okta</code>, respectively).</p>
</div>
<div class="paragraph">
<p>If you do not need to customize these providers, you can set the <code>provider</code> attribute to the one for which you need to infer defaults.
Also, if the key for the client registration matches a default supported provider, Spring Boot infers that as well.</p>
</div>
<div class="paragraph">
<p>In other words, the two configurations in the following example use the Google provider:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client.client-id=abcd
spring.security.oauth2.client.registration.my-client.client-secret=password
spring.security.oauth2.client.registration.my-client.provider=google

spring.security.oauth2.client.registration.google.client-id=abcd
spring.security.oauth2.client.registration.google.client-secret=password</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-server">Resource Server</h5>
<div class="paragraph">
<p>If you have <code>spring-security-oauth2-resource-server</code> on your classpath, Spring Boot can set up an OAuth2 Resource Server.
For JWT configuration, a JWK Set URI or OIDC Issuer URI needs to be specified, as shown in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the authorization server does not support a JWK Set URI, you can configure the resource server with the Public Key used for verifying the signature of the JWT.
This can be done using the configprop:spring.security.oauth2.resourceserver.jwt.public-key-location[] property, where the value needs to point to a file containing the public key in the PEM-encoded x509 format.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The same properties are applicable for both servlet and reactive applications.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can define your own <code>JwtDecoder</code> bean for servlet applications or a <code>ReactiveJwtDecoder</code> for reactive applications.</p>
</div>
<div class="paragraph">
<p>In cases where opaque tokens are used instead of JWTs, you can configure the following properties to validate tokens via introspection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the same properties are applicable for both servlet and reactive applications.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can define your own <code>OpaqueTokenIntrospector</code> bean for servlet applications or a <code>ReactiveOpaqueTokenIntrospector</code> for reactive applications.</p>
</div>
</div>
<div class="sect4">
<h5 id="authorization-server">Authorization Server</h5>
<div class="paragraph">
<p>Currently, Spring Security does not provide support for implementing an OAuth 2.0 Authorization Server.
However, this functionality is available from the <a href="https://spring.io/projects/spring-security-oauth">Spring Security OAuth</a> project, which will eventually be superseded by Spring Security completely.
Until then, you can use the <code>spring-security-oauth2-autoconfigure</code> module to easily set up an OAuth 2.0 authorization server; see its <a href="https://docs.spring.io/spring-security-oauth2-boot">documentation</a> for instructions.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-saml">2.9.4. SAML 2.0</h4>
<div class="sect4">
<h5 id="boot-features-security-saml2-relying-party">Relying Party</h5>
<div class="paragraph">
<p>If you have <code>spring-security-saml2-service-provider</code> on your classpath, you can take advantage of some auto-configuration to make it easy to set up a SAML 2.0 Relying Party.
This configuration makes use of the properties under <code>Saml2RelyingPartyProperties</code>.</p>
</div>
<div class="paragraph">
<p>A relying party registration represents a paired configuration between an Identity Provider, IDP, and a Service Provider, SP.
You can register multiple relying parties under the <code>spring.security.saml2.relyingparty</code> prefix, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-actuator">2.9.5. Actuator Security</h4>
<div class="paragraph">
<p>For security purposes, all actuators other than <code>/health</code> and <code>/info</code> are disabled by default.
The configprop:management.endpoints.web.exposure.include[] property can be used to enable the actuators.</p>
</div>
<div class="paragraph">
<p>If Spring Security is on the classpath and no other WebSecurityConfigurerAdapter is present, all actuators other than <code>/health</code> and <code>/info</code> are secured by Spring Boot auto-configuration.
If you define a custom <code>WebSecurityConfigurerAdapter</code>, Spring Boot auto-configuration will back off and you will be in full control of actuator access rules.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before setting the <code>management.endpoints.web.exposure.include</code>, ensure that the exposed actuators do not contain sensitive information and/or are secured by placing them behind a firewall or by something like Spring Security.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-security-csrf">Cross Site Request Forgery Protection</h5>
<div class="paragraph">
<p>Since Spring Boot relies on Spring Security&#8217;s defaults, CSRF protection is turned on by default.
This means that the actuator endpoints that require a <code>POST</code> (shutdown and loggers endpoints), <code>PUT</code> or <code>DELETE</code> will get a 403 forbidden error when the default security configuration is in use.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We recommend disabling CSRF protection completely only if you are creating a service that is used by non-browser clients.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Additional information about CSRF protection can be found in the <a href="https://docs.spring.io/spring-security/site/docs/{spring-security-version}/reference/htmlsingle/#csrf">Spring Security Reference Guide</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-sql">2.10. Working with SQL Databases</h3>
<div class="paragraph">
<p>The <a href="https://spring.io/projects/spring-framework">Spring Framework</a> provides extensive support for working with SQL databases, from direct JDBC access using <code>JdbcTemplate</code> to complete &#8220;object relational mapping&#8221; technologies such as Hibernate.
<a href="https://spring.io/projects/spring-data">Spring Data</a> provides an additional level of functionality: creating <code>Repository</code> implementations directly from interfaces and using conventions to generate queries from your method names.</p>
</div>
<div class="sect3">
<h4 id="boot-features-configure-datasource">2.10.1. Configure a DataSource</h4>
<div class="paragraph">
<p>Java&#8217;s <code>javax.sql.DataSource</code> interface provides a standard method of working with database connections.
Traditionally, a 'DataSource' uses a <code>URL</code> along with some credentials to establish a database connection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="howto.html#howto-configure-a-datasource">the &#8220;How-to&#8221; section</a> for more advanced examples, typically to take full control over the configuration of the DataSource.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-database-support">Embedded Database Support</h5>
<div class="paragraph">
<p>It is often convenient to develop applications by using an in-memory embedded database.
Obviously, in-memory databases do not provide persistent storage.
You need to populate your database when your application starts and be prepared to throw away data when your application ends.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The &#8220;How-to&#8221; section includes a <a href="howto.html#howto-database-initialization">section on how to initialize a database</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot can auto-configure embedded <a href="https://www.h2database.com">H2</a>, <a href="http://hsqldb.org/">HSQL</a>, and <a href="https://db.apache.org/derby/">Derby</a> databases.
You need not provide any connection URLs.
You need only include a build dependency to the embedded database that you want to use.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are using this feature in your tests, you may notice that the same database is reused by your whole test suite regardless of the number of application contexts that you use.
If you want to make sure that each context has a separate embedded database, you should set <code>spring.datasource.generate-unique-name</code> to <code>true</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, the typical POM dependencies would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You need a dependency on <code>spring-jdbc</code> for an embedded database to be auto-configured.
In this example, it is pulled in transitively through <code>spring-boot-starter-data-jpa</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If, for whatever reason, you do configure the connection URL for an embedded database, take care to ensure that the database&#8217;s automatic shutdown is disabled.
If you use H2, you should use <code>DB_CLOSE_ON_EXIT=FALSE</code> to do so.
If you use HSQLDB, you should ensure that <code>shutdown=true</code> is not used.
Disabling the database&#8217;s automatic shutdown lets Spring Boot control when the database is closed, thereby ensuring that it happens once access to the database is no longer needed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connect-to-production-database">Connection to a Production Database</h5>
<div class="paragraph">
<p>Production database connections can also be auto-configured by using a pooling <code>DataSource</code>.
Spring Boot uses the following algorithm for choosing a specific implementation:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We prefer <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> for its performance and concurrency.
If HikariCP is available, we always choose it.</p>
</li>
<li>
<p>Otherwise, if the Tomcat pooling <code>DataSource</code> is available, we use it.</p>
</li>
<li>
<p>If neither HikariCP nor the Tomcat pooling datasource are available and if <a href="https://commons.apache.org/proper/commons-dbcp/">Commons DBCP2</a> is available, we use it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you use the <code>spring-boot-starter-jdbc</code> or <code>spring-boot-starter-data-jpa</code> &#8220;starters&#8221;, you automatically get a dependency to <code>HikariCP</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can bypass that algorithm completely and specify the connection pool to use by setting the configprop:spring.datasource.type[] property.
This is especially important if you run your application in a Tomcat container, as <code>tomcat-jdbc</code> is provided by default.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Additional connection pools can always be configured manually.
If you define your own <code>DataSource</code> bean, auto-configuration does not occur.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>DataSource configuration is controlled by external configuration properties in <code>spring.datasource.*</code>.
For example, you might declare the following section in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You should at least specify the URL by setting the configprop:spring.datasource.url[] property.
Otherwise, Spring Boot tries to auto-configure an embedded database.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You often do not need to specify the <code>driver-class-name</code>, since Spring Boot can deduce it for most databases from the <code>url</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For a pooling <code>DataSource</code> to be created, we need to be able to verify that a valid <code>Driver</code> class is available, so we check for that before doing anything.
In other words, if you set <code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>, then that class has to be loadable.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a> for more of the supported options.
These are the standard options that work regardless of the actual implementation.
It is also possible to fine-tune implementation-specific settings by using their respective prefix (<code>spring.datasource.hikari.*</code>, <code>spring.datasource.tomcat.*</code>, and <code>spring.datasource.dbcp2.*</code>).
Refer to the documentation of the connection pool implementation you are using for more details.</p>
</div>
<div class="paragraph">
<p>For instance, if you use the <a href="https://tomcat.apache.org/tomcat-9.0-doc/jdbc-pool.html#Common_Attributes">Tomcat connection pool</a>, you could customize many additional settings, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-a-jndi-datasource">Connection to a JNDI DataSource</h5>
<div class="paragraph">
<p>If you deploy your Spring Boot application to an Application Server, you might want to configure and manage your DataSource by using your Application Server&#8217;s built-in features and access it by using JNDI.</p>
</div>
<div class="paragraph">
<p>The configprop:spring.datasource.jndi-name[] property can be used as an alternative to the configprop:spring.datasource.url[], configprop:spring.datasource.username[], and configprop:spring.datasource.password[] properties to access the <code>DataSource</code> from a specific JNDI location.
For example, the following section in <code>application.properties</code> shows how you can access a JBoss AS defined <code>DataSource</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.jndi-name=java:jboss/datasources/customers</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jdbc-template">2.10.2. Using JdbcTemplate</h4>
<div class="paragraph">
<p>Spring&#8217;s <code>JdbcTemplate</code> and <code>NamedParameterJdbcTemplate</code> classes are auto-configured, and you can <code>@Autowire</code> them directly into your own beans, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public MyBean(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can customize some properties of the template by using the <code>spring.jdbc.template.*</code> properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jdbc.template.max-rows=500</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>NamedParameterJdbcTemplate</code> reuses the same <code>JdbcTemplate</code> instance behind the scenes.
If more than one <code>JdbcTemplate</code> is defined and no primary candidate exists, the <code>NamedParameterJdbcTemplate</code> is not auto-configured.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jpa-and-spring-data">2.10.3. JPA and Spring Data JPA</h4>
<div class="paragraph">
<p>The Java Persistence API is a standard technology that lets you &#8220;map&#8221; objects to relational databases.
The <code>spring-boot-starter-data-jpa</code> POM provides a quick way to get started.
It provides the following key dependencies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hibernate: One of the most popular JPA implementations.</p>
</li>
<li>
<p>Spring Data JPA: Makes it easy to implement JPA-based repositories.</p>
</li>
<li>
<p>Spring ORMs: Core ORM support from the Spring Framework.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We do not go into too many details of JPA or <a href="https://spring.io/projects/spring-data">Spring Data</a> here.
You can follow the <a href="https://spring.io/guides/gs/accessing-data-jpa/">&#8220;Accessing Data with JPA&#8221;</a> guide from <a href="https://spring.io" class="bare">https://spring.io</a> and read the <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> and <a href="https://hibernate.org/orm/documentation/">Hibernate</a> reference documentation.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-entity-classes">Entity Classes</h5>
<div class="paragraph">
<p>Traditionally, JPA &#8220;Entity&#8221; classes are specified in a <code>persistence.xml</code> file.
With Spring Boot, this file is not necessary and &#8220;Entity Scanning&#8221; is used instead.
By default, all packages below your main configuration class (the one annotated with <code>@EnableAutoConfiguration</code> or <code>@SpringBootApplication</code>) are searched.</p>
</div>
<div class="paragraph">
<p>Any classes annotated with <code>@Entity</code>, <code>@Embeddable</code>, or <code>@MappedSuperclass</code> are considered.
A typical entity class resembles the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.io.Serializable;
import javax.persistence.*;

@Entity
public class City implements Serializable {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String state;

    // ... additional members, often include @OneToMany mappings

    protected City() {
        // no-args constructor required by JPA spec
        // this one is protected since it shouldn't be used directly
    }

    public City(String name, String state) {
        this.name = name;
        this.state = state;
    }

    public String getName() {
        return this.name;
    }

    public String getState() {
        return this.state;
    }

    // ... etc

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can customize entity scanning locations by using the <code>@EntityScan</code> annotation.
See the &#8220;<a href="howto.html#howto-separate-entity-definitions-from-spring-configuration">[howto#howto-separate-entity-definitions-from-spring-configuration]</a>&#8221; how-to.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-jpa-repositories">Spring Data JPA Repositories</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> repositories are interfaces that you can define to access data.
JPA queries are created automatically from your method names.
For example, a <code>CityRepository</code> interface might declare a <code>findAllByState(String state)</code> method to find all the cities in a given state.</p>
</div>
<div class="paragraph">
<p>For more complex queries, you can annotate your method with Spring Data&#8217;s <a href="https://docs.spring.io/spring-data/jpa/docs/{spring-data-jpa-version}/api/org/springframework/data/jpa/repository/Query.html"><code>Query</code></a> annotation.</p>
</div>
<div class="paragraph">
<p>Spring Data repositories usually extend from the <a href="https://docs.spring.io/spring-data/commons/docs/{spring-data-commons-version}/api/org/springframework/data/repository/Repository.html"><code>Repository</code></a> or <a href="https://docs.spring.io/spring-data/commons/docs/{spring-data-commons-version}/api/org/springframework/data/repository/CrudRepository.html"><code>CrudRepository</code></a> interfaces.
If you use auto-configuration, repositories are searched from the package containing your main configuration class (the one annotated with <code>@EnableAutoConfiguration</code> or <code>@SpringBootApplication</code>) down.</p>
</div>
<div class="paragraph">
<p>The following example shows a typical Spring Data repository interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Data JPA repositories support three different modes of bootstrapping: default, deferred, and lazy.
To enable deferred or lazy bootstrapping, set the configprop:spring.data.jpa.repositories.bootstrap-mode[] property to <code>deferred</code> or <code>lazy</code> respectively.
When using deferred or lazy bootstrapping, the auto-configured <code>EntityManagerFactoryBuilder</code> will use the context&#8217;s <code>AsyncTaskExecutor</code>, if any, as the bootstrap executor.
If more than one exists, the one named <code>applicationTaskExecutor</code> will be used.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
We have barely scratched the surface of Spring Data JPA.
For complete details, see the <a href="https://docs.spring.io/spring-data/jdbc/docs/{spring-data-jdbc-version}/reference/html/">Spring Data JPA reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-creating-and-dropping-jpa-databases">Creating and Dropping JPA Databases</h5>
<div class="paragraph">
<p>By default, JPA databases are automatically created <strong>only</strong> if you use an embedded database (H2, HSQL, or Derby).
You can explicitly configure JPA settings by using <code>spring.jpa.*</code> properties.
For example, to create and drop tables you can add the following line to your <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.ddl-auto=create-drop</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Hibernate&#8217;s own internal property name for this (if you happen to remember it better) is <code>hibernate.hbm2ddl.auto</code>.
You can set it, along with other Hibernate native properties, by using <code>spring.jpa.properties.*</code> (the prefix is stripped before adding them to the entity manager).
The following line shows an example of setting JPA properties for Hibernate:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.properties.hibernate.globally_quoted_identifiers=true</pre>
</div>
</div>
<div class="paragraph">
<p>The line in the preceding example passes a value of <code>true</code> for the <code>hibernate.globally_quoted_identifiers</code> property to the Hibernate entity manager.</p>
</div>
<div class="paragraph">
<p>By default, the DDL execution (or validation) is deferred until the <code>ApplicationContext</code> has started.
There is also a <code>spring.jpa.generate-ddl</code> flag, but it is not used if Hibernate auto-configuration is active, because the <code>ddl-auto</code> settings are more fine-grained.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jpa-in-web-environment">Open EntityManager in View</h5>
<div class="paragraph">
<p>If you are running a web application, Spring Boot by default registers <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html"><code>OpenEntityManagerInViewInterceptor</code></a> to apply the &#8220;Open EntityManager in View&#8221; pattern, to allow for lazy loading in web views.
If you do not want this behavior, you should set <code>spring.jpa.open-in-view</code> to <code>false</code> in your <code>application.properties</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-data-jdbc">2.10.4. Spring Data JDBC</h4>
<div class="paragraph">
<p>Spring Data includes repository support for JDBC and will automatically generate SQL for the methods on <code>CrudRepository</code>.
For more advanced queries, a <code>@Query</code> annotation is provided.</p>
</div>
<div class="paragraph">
<p>Spring Boot will auto-configure Spring Data&#8217;s JDBC repositories when the necessary dependencies are on the classpath.
They can be added to your project with a single dependency on <code>spring-boot-starter-data-jdbc</code>.
If necessary, you can take control of Spring Data JDBC&#8217;s configuration by adding the <code>@EnableJdbcRepositories</code> annotation or a <code>JdbcConfiguration</code> subclass to your application.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data JDBC, please refer to the <a href="https://docs.spring.io/spring-data/jdbc/docs/{spring-data-jdbc-version}/reference/html/">reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-sql-h2-console">2.10.5. Using H2&#8217;s Web Console</h4>
<div class="paragraph">
<p>The <a href="https://www.h2database.com">H2 database</a> provides a <a href="https://www.h2database.com/html/quickstart.html#h2_console">browser-based console</a> that Spring Boot can auto-configure for you.
The console is auto-configured when the following conditions are met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are developing a servlet-based web application.</p>
</li>
<li>
<p><code>com.h2database:h2</code> is on the classpath.</p>
</li>
<li>
<p>You are using <a href="using-spring-boot.html#using-boot-devtools">Spring Boot&#8217;s developer tools</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are not using Spring Boot&#8217;s developer tools but would still like to make use of H2&#8217;s console, you can configure the configprop:spring.h2.console.enabled[] property with a value of <code>true</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The H2 console is only intended for use during development, so you should take care to ensure that <code>spring.h2.console.enabled</code> is not set to <code>true</code> in production.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-sql-h2-console-custom-path">Changing the H2 Console&#8217;s Path</h5>
<div class="paragraph">
<p>By default, the console is available at <code>/h2-console</code>.
You can customize the console&#8217;s path by using the configprop:spring.h2.console.path[] property.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jooq">2.10.6. Using jOOQ</h4>
<div class="paragraph">
<p>jOOQ Object Oriented Querying (<a href="https://www.jooq.org/">jOOQ</a>) is a popular product from <a href="https://www.datageekery.com/">Data Geekery</a> which generates Java code from your database and lets you build type-safe SQL queries through its fluent API.
Both the commercial and open source editions can be used with Spring Boot.</p>
</div>
<div class="sect4">
<h5 id="code-generation">Code Generation</h5>
<div class="paragraph">
<p>In order to use jOOQ type-safe queries, you need to generate Java classes from your database schema.
You can follow the instructions in the <a href="https://www.jooq.org/doc/{jooq-version}/manual-single-page/#jooq-in-7-steps-step3">jOOQ user manual</a>.
If you use the <code>jooq-codegen-maven</code> plugin and you also use the <code>spring-boot-starter-parent</code> &#8220;parent POM&#8221;, you can safely omit the plugin&#8217;s <code>&lt;version&gt;</code> tag.
You can also use Spring Boot-defined version variables (such as <code>h2.version</code>) to declare the plugin&#8217;s database dependency.
The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.jooq&lt;/groupId&gt;
    &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;
    &lt;executions&gt;
        ...
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;${h2.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;configuration&gt;
        &lt;jdbc&gt;
            &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
            &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;
        &lt;/jdbc&gt;
        &lt;generator&gt;
            ...
        &lt;/generator&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-dslcontext">Using DSLContext</h5>
<div class="paragraph">
<p>The fluent API offered by jOOQ is initiated through the <code>org.jooq.DSLContext</code> interface.
Spring Boot auto-configures a <code>DSLContext</code> as a Spring Bean and connects it to your application <code>DataSource</code>.
To use the <code>DSLContext</code>, you can <code>@Autowire</code> it, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JooqExample implements CommandLineRunner {

    private final DSLContext create;

    @Autowired
    public JooqExample(DSLContext dslContext) {
        this.create = dslContext;
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The jOOQ manual tends to use a variable named <code>create</code> to hold the <code>DSLContext</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can then use the <code>DSLContext</code> to construct your queries, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public List&lt;GregorianCalendar&gt; authorsBornAfter1980() {
    return this.create.selectFrom(AUTHOR)
        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
        .fetch(AUTHOR.DATE_OF_BIRTH);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jooq-sql-dialect">jOOQ SQL Dialect</h5>
<div class="paragraph">
<p>Unless the configprop:spring.jooq.sql-dialect[] property has been configured, Spring Boot determines the SQL dialect to use for your datasource.
If Spring Boot could not detect the dialect, it uses <code>DEFAULT</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot can only auto-configure dialects supported by the open source version of jOOQ.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="customizing-jooq">Customizing jOOQ</h5>
<div class="paragraph">
<p>More advanced customizations can be achieved by defining your own <code>@Bean</code> definitions, which is used when the jOOQ <code>Configuration</code> is created.
You can define beans for the following jOOQ Types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConnectionProvider</code></p>
</li>
<li>
<p><code>ExecutorProvider</code></p>
</li>
<li>
<p><code>TransactionProvider</code></p>
</li>
<li>
<p><code>RecordMapperProvider</code></p>
</li>
<li>
<p><code>RecordUnmapperProvider</code></p>
</li>
<li>
<p><code>Settings</code></p>
</li>
<li>
<p><code>RecordListenerProvider</code></p>
</li>
<li>
<p><code>ExecuteListenerProvider</code></p>
</li>
<li>
<p><code>VisitListenerProvider</code></p>
</li>
<li>
<p><code>TransactionListenerProvider</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also create your own <code>org.jooq.Configuration</code> <code>@Bean</code> if you want to take complete control of the jOOQ configuration.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-nosql">2.11. Working with NoSQL Technologies</h3>
<div class="paragraph">
<p>Spring Data provides additional projects that help you access a variety of NoSQL technologies, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/projects/spring-data-mongodb">MongoDB</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-neo4j">Neo4J</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-elasticsearch">Elasticsearch</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-solr">Solr</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-redis">Redis</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-gemfire">GemFire</a> or <a href="https://spring.io/projects/spring-data-geode">Geode</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-cassandra">Cassandra</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-ldap">LDAP</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot provides auto-configuration for Redis, MongoDB, Neo4j, Elasticsearch, Solr Cassandra, Couchbase, and LDAP.
You can make use of the other projects, but you must configure them yourself.
Refer to the appropriate reference documentation at <a href="https://spring.io/projects/spring-data" class="bare">https://spring.io/projects/spring-data</a>.</p>
</div>
<div class="sect3">
<h4 id="boot-features-redis">2.11.1. Redis</h4>
<div class="paragraph">
<p><a href="https://redis.io/">Redis</a> is a cache, message broker, and richly-featured key-value store.
Spring Boot offers basic auto-configuration for the <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a> and <a href="https://github.com/xetorthio/jedis/">Jedis</a> client libraries and the abstractions on top of them provided by <a href="https://github.com/spring-projects/spring-data-redis">Spring Data Redis</a>.</p>
</div>
<div class="paragraph">
<p>There is a <code>spring-boot-starter-data-redis</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.
By default, it uses <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>.
That starter handles both traditional and reactive applications.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
we also provide a <code>spring-boot-starter-data-redis-reactive</code> &#8220;Starter&#8221; for consistency with the other stores with reactive support.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-redis">Connecting to Redis</h5>
<div class="paragraph">
<p>You can inject an auto-configured <code>RedisConnectionFactory</code>, <code>StringRedisTemplate</code>, or vanilla <code>RedisTemplate</code> instance as you would any other Spring Bean.
By default, the instance tries to connect to a Redis server at <code>localhost:6379</code>.
The following listing shows an example of such a bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private StringRedisTemplate template;

    @Autowired
    public MyBean(StringRedisTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can also register an arbitrary number of beans that implement <code>LettuceClientConfigurationBuilderCustomizer</code> for more advanced customizations.
If you use Jedis, <code>JedisClientConfigurationBuilderCustomizer</code> is also available.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you add your own <code>@Bean</code> of any of the auto-configured types, it replaces the default (except in the case of <code>RedisTemplate</code>, when the exclusion is based on the bean name, <code>redisTemplate</code>, not its type).
By default, if <code>commons-pool2</code> is on the classpath, you get a pooled connection factory.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongodb">2.11.2. MongoDB</h4>
<div class="paragraph">
<p><a href="https://www.mongodb.com/">MongoDB</a> is an open-source NoSQL document database that uses a JSON-like schema instead of traditional table-based relational data.
Spring Boot offers several conveniences for working with MongoDB, including the <code>spring-boot-starter-data-mongodb</code> and <code>spring-boot-starter-data-mongodb-reactive</code> &#8220;Starters&#8221;.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-mongodb">Connecting to a MongoDB Database</h5>
<div class="paragraph">
<p>To access Mongo databases, you can inject an auto-configured <code>org.springframework.data.mongodb.MongoDbFactory</code>.
By default, the instance tries to connect to a MongoDB server at <code>mongodb://localhost/test</code>.
The following example shows how to connect to a MongoDB database:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.data.mongodb.MongoDbFactory;
import com.mongodb.DB;

@Component
public class MyBean {

    private final MongoDbFactory mongo;

    @Autowired
    public MyBean(MongoDbFactory mongo) {
        this.mongo = mongo;
    }

    // ...

    public void example() {
        DB db = mongo.getDb();
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can set the configprop:spring.data.mongodb.uri[] property to change the URL and configure additional settings such as the <em>replica set</em>, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, as long as you use Mongo 2.x, you can specify a <code>host</code>/<code>port</code>.
For example, you might declare the following settings in your <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you have defined your own <code>MongoClient</code>, it will be used to auto-configure a suitable <code>MongoDbFactory</code>.
Both <code>com.mongodb.MongoClient</code> and <code>com.mongodb.client.MongoClient</code> are supported.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use the Mongo 3.0 Java driver, <code>spring.data.mongodb.host</code> and <code>spring.data.mongodb.port</code> are not supported.
In such cases, <code>spring.data.mongodb.uri</code> should be used to provide all of the configuration.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If <code>spring.data.mongodb.port</code> is not specified, the default of <code>27017</code> is used.
You could delete this line from the example shown earlier.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you do not use Spring Data Mongo, you can inject <code>com.mongodb.MongoClient</code> beans instead of using <code>MongoDbFactory</code>.
If you want to take complete control of establishing the MongoDB connection, you can also declare your own <code>MongoDbFactory</code> or <code>MongoClient</code> bean.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using the reactive driver, Netty is required for SSL.
The auto-configuration configures this factory automatically if Netty is available and the factory to use hasn&#8217;t been customized already.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-mongo-template">MongoTemplate</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-mongodb">Spring Data MongoDB</a> provides a <a href="https://docs.spring.io/spring-data/mongodb/docs/{spring-data-mongodb-version}/api/org/springframework/data/mongodb/core/MongoTemplate.html"><code>MongoTemplate</code></a> class that is very similar in its design to Spring&#8217;s <code>JdbcTemplate</code>.
As with <code>JdbcTemplate</code>, Spring Boot auto-configures a bean for you to inject the template, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final MongoTemplate mongoTemplate;

    @Autowired
    public MyBean(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-data/mongodb/docs/{spring-data-mongodb-version}/api/org/springframework/data/mongodb/core/MongoOperations.html"><code>MongoOperations</code> Javadoc</a> for complete details.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-mongodb-repositories">Spring Data MongoDB Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for MongoDB.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed automatically, based on method names.</p>
</div>
<div class="paragraph">
<p>In fact, both Spring Data JPA and Spring Data MongoDB share the same common infrastructure.
You could take the JPA example from earlier and, assuming that <code>City</code> is now a Mongo data class rather than a JPA <code>@Entity</code>, it works in the same way, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can customize document scanning locations by using the <code>@EntityScan</code> annotation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data MongoDB, including its rich object mapping technologies, refer to its <a href="https://spring.io/projects/spring-data-mongodb">reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-mongo-embedded">Embedded Mongo</h5>
<div class="paragraph">
<p>Spring Boot offers auto-configuration for <a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo">Embedded Mongo</a>.
To use it in your Spring Boot application, add a dependency on <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>.</p>
</div>
<div class="paragraph">
<p>The port that Mongo listens on can be configured by setting the configprop:spring.data.mongodb.port[] property.
To use a randomly allocated free port, use a value of 0.
The <code>MongoClient</code> created by <code>MongoAutoConfiguration</code> is automatically configured to use the randomly allocated port.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not configure a custom port, the embedded support uses a random port (rather than 27017) by default.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you have SLF4J on the classpath, the output produced by Mongo is automatically routed to a logger named <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>.</p>
</div>
<div class="paragraph">
<p>You can declare your own <code>IMongodConfig</code> and <code>IRuntimeConfig</code> beans to take control of the Mongo instance&#8217;s configuration and logging routing.
The download configuration can be customized by declaring a <code>DownloadConfigBuilderCustomizer</code> bean.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j">2.11.3. Neo4j</h4>
<div class="paragraph">
<p><a href="https://neo4j.com/">Neo4j</a> is an open-source NoSQL graph database that uses a rich data model of nodes connected by first class relationships, which is better suited for connected big data than traditional RDBMS approaches.
Spring Boot offers several conveniences for working with Neo4j, including the <code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221;.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-neo4j">Connecting to a Neo4j Database</h5>
<div class="paragraph">
<p>To access a Neo4j server, you can inject an auto-configured <code>org.neo4j.ogm.session.Session</code>.
By default, the instance tries to connect to a Neo4j server at <code>localhost:7687</code> using the Bolt protocol.
The following example shows how to inject a Neo4j <code>Session</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final Session session;

    @Autowired
    public MyBean(Session session) {
        this.session = session;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can configure the uri and credentials to use by setting the <code>spring.data.neo4j.*</code> properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.uri=bolt://my-server:7687
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can take full control over the session creation by adding either an <code>org.neo4j.ogm.config.Configuration</code> bean or an <code>org.neo4j.ogm.session.SessionFactory</code> bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-neo4j-embedded">Using the Embedded Mode</h5>
<div class="paragraph">
<p>If you add <code>org.neo4j:neo4j-ogm-embedded-driver</code> to the dependencies of your application, Spring Boot automatically configures an in-process embedded instance of Neo4j that does not persist any data when your application shuts down.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As the embedded Neo4j OGM  driver  does not provide the Neo4j kernel itself, you have to declare <code>org.neo4j:neo4j</code> as dependency yourself.
Refer to <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started">the Neo4j OGM documentation</a> for a list of compatible versions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The embedded driver takes precedence over the other drivers when there are multiple drivers on the classpath.
You can explicitly disable the embedded mode by setting <code>spring.data.neo4j.embedded.enabled=false</code>.</p>
</div>
<div class="paragraph">
<p><a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test">Data Neo4j Tests</a> automatically make use of an embedded Neo4j instance if the embedded driver and Neo4j kernel are on the classpath as described above.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can enable persistence for the embedded mode by providing a path to a database file in your configuration, e.g. <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-neo4j-ogm-native-types">Using Native Types</h5>
<div class="paragraph">
<p>Neo4j-OGM can map some types, like those in <code>java.time.*</code>, to <code>String</code>-based properties or to one of the native types that Neo4j provides.
For backwards compatibility reasons the default for Neo4j-OGM is to use a <code>String</code>-based representation.
To use native types, add a dependency on either <code>org.neo4j:neo4j-ogm-bolt-native-types</code> or <code>org.neo4j:neo4j-ogm-embedded-native-types</code>, and configure the configprop:spring.data.neo4j.use-native-types[] property as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.use-native-types=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-neo4j-ogm-session">Neo4jSession</h5>
<div class="paragraph">
<p>By default, if you are running a web application, the session is bound to the thread for the entire processing of the request (that is, it uses the "Open Session in View" pattern).
If you do not want this behavior, add the following line to your <code>application.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.open-in-view=false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-neo4j-repositories">Spring Data Neo4j Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for Neo4j.</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j shares the common infrastructure with Spring Data JPA as many other Spring Data modules do.
You could take the JPA example from earlier and define <code>City</code> as Neo4j OGM <code>@NodeEntity</code> rather than JPA <code>@Entity</code> and the repository abstraction works in the same way, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.util.Optional;

import org.springframework.data.neo4j.repository.*;

public interface CityRepository extends Neo4jRepository&lt;City, Long&gt; {

    Optional&lt;City&gt; findOneByNameAndState(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221; enables the repository support as well as transaction management.
You can customize the locations to look for repositories and entities by using <code>@EnableNeo4jRepositories</code> and <code>@EntityScan</code> respectively on a <code>@Configuration</code>-bean.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Neo4j, including its object mapping technologies, refer to the <a href="https://docs.spring.io/spring-data/neo4j/docs/{spring-data-neo4j-version}/reference/html/">reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-solr">2.11.4. Solr</h4>
<div class="paragraph">
<p><a href="https://lucene.apache.org/solr/">Apache Solr</a> is a search engine.
Spring Boot offers basic auto-configuration for the Solr 5 client library and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-solr">Spring Data Solr</a>.
There is a <code>spring-boot-starter-data-solr</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-solr">Connecting to Solr</h5>
<div class="paragraph">
<p>You can inject an auto-configured <code>SolrClient</code> instance as you would any other Spring bean.
By default, the instance tries to connect to a server at <code><a href="http://localhost:8983/solr" class="bare">http://localhost:8983/solr</a></code>.
The following example shows how to inject a Solr bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private SolrClient solr;

    @Autowired
    public MyBean(SolrClient solr) {
        this.solr = solr;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you add your own <code>@Bean</code> of type <code>SolrClient</code>, it replaces the default.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-solr-repositories">Spring Data Solr Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for Apache Solr.
As with the JPA repositories discussed earlier, the basic principle is that queries are automatically constructed for you based on method names.</p>
</div>
<div class="paragraph">
<p>In fact, both Spring Data JPA and Spring Data Solr share the same common infrastructure.
You could take the JPA example from earlier and, assuming that <code>City</code> is now a <code>@SolrDocument</code> class rather than a JPA <code>@Entity</code>, it works in the same way.</p>
</div>
<div class="paragraph">
<p>IP: For complete details of Spring Data Solr, refer to the <a href="https://docs.spring.io/spring-data/solr/docs/{spring-data-solr-version}/reference/html/">reference documentation</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-elasticsearch">2.11.5. Elasticsearch</h4>
<div class="paragraph">
<p><a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a> is an open source, distributed, RESTful search and analytics engine.
Spring Boot offers basic auto-configuration for Elasticsearch.</p>
</div>
<div class="paragraph">
<p>Spring Boot supports several clients:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The official Java "Low Level" and "High Level" REST clients</p>
</li>
<li>
<p>The <code>ReactiveElasticsearchClient</code> provided by Spring Data Elasticsearch</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The transport client is still available but its support has been deprecated in <a href="https://github.com/spring-projects/spring-data-elasticsearch">Spring Data Elasticsearch</a> and Elasticsearch itself.
It will be removed in a future release.
Spring Boot provides a dedicated &#8220;Starter&#8221;, <code>spring-boot-starter-data-elasticsearch</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="https://github.com/searchbox-io/Jest">Jest</a> client has been deprecated as well, since both Elasticsearch and Spring Data Elasticsearch provide official support for REST clients.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-rest">Connecting to Elasticsearch using REST clients</h5>
<div class="paragraph">
<p>Elasticsearch ships <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">two different REST clients</a> that you can use to query a cluster: the "Low Level" client and the "High Level" client.</p>
</div>
<div class="paragraph">
<p>If you have the <code>org.elasticsearch.client:elasticsearch-rest-client</code> dependency on the classpath, Spring Boot will auto-configure and register a <code>RestClient</code> bean that by default targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how <code>RestClient</code> is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.rest.uris=https://search.example.com:9200
spring.elasticsearch.rest.read-timeout=10s
spring.elasticsearch.rest.username=user
spring.elasticsearch.rest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>RestClientBuilderCustomizer</code> for more advanced customizations.
To take full control over the registration, define a <code>RestClient</code> bean.</p>
</div>
<div class="paragraph">
<p>If you have the <code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code> dependency on the classpath, Spring Boot will auto-configure a <code>RestHighLevelClient</code>, which wraps any existing <code>RestClient</code> bean, reusing its HTTP configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-reactive-rest">Connecting to Elasticsearch using Reactive REST clients</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-elasticsearch">Spring Data Elasticsearch</a> ships <code>ReactiveElasticsearchClient</code> for querying Elasticsearch instances in a reactive fashion.
It is built on top of WebFlux&#8217;s <code>WebClient</code>, so both <code>spring-boot-starter-elasticsearch</code> and <code>spring-boot-starter-webflux</code> dependencies are useful to enable this support.</p>
</div>
<div class="paragraph">
<p>By default, Spring Boot will auto-configure and register a <code>ReactiveElasticsearchClient</code>
bean that targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how it is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
spring.data.elasticsearch.client.reactive.use-ssl=true
spring.data.elasticsearch.client.reactive.socket-timeout=10s
spring.data.elasticsearch.client.reactive.username=user
spring.data.elasticsearch.client.reactive.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the configuration properties are not enough and you&#8217;d like to fully control the client
configuration, you can register a custom <code>ClientConfiguration</code> bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-jest">Connecting to Elasticsearch using Jest</h5>
<div class="paragraph">
<p>Now that Spring Boot supports the official <code>RestHighLevelClient</code>, Jest support is deprecated.</p>
</div>
<div class="paragraph">
<p>If you have <code>Jest</code> on the classpath, you can inject an auto-configured <code>JestClient</code> that by default targets <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>.
You can further tune how the client is configured, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.jest.uris=https://search.example.com:9200
spring.elasticsearch.jest.read-timeout=10000
spring.elasticsearch.jest.username=user
spring.elasticsearch.jest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>HttpClientConfigBuilderCustomizer</code> for more advanced customizations.
The following example tunes additional HTTP settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {

    @Override
    public void customize(HttpClientConfig.Builder builder) {
        builder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To take full control over the registration, define a <code>JestClient</code> bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-spring-data">Connecting to Elasticsearch by Using Spring Data</h5>
<div class="paragraph">
<p>To connect to Elasticsearch, a <code>RestHighLevelClient</code> bean must be defined,
auto-configured by Spring Boot or manually provided by the application (see previous sections).
With this configuration in place, an
<code>ElasticsearchRestTemplate</code> can be injected like any other Spring bean,
as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final ElasticsearchRestTemplate template;

    public MyBean(ElasticsearchRestTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the presence of <code>spring-data-elasticsearch</code> and the required dependencies for using a <code>WebClient</code> (typically <code>spring-boot-starter-webflux</code>), Spring Boot can also auto-configure a <a href="#boot-features-connecting-to-elasticsearch-reactive-rest">ReactiveElasticsearchClient</a> and a <code>ReactiveElasticsearchTemplate</code> as beans.
They are the reactive equivalent of the other REST clients.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-elasticsearch-repositories">Spring Data Elasticsearch Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for Elasticsearch.
As with the JPA repositories discussed earlier, the basic principle is that queries are constructed for you automatically based on method names.</p>
</div>
<div class="paragraph">
<p>In fact, both Spring Data JPA and Spring Data Elasticsearch share the same common infrastructure.
You could take the JPA example from earlier and, assuming that <code>City</code> is now an Elasticsearch <code>@Document</code> class rather than a JPA <code>@Entity</code>, it works in the same way.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Elasticsearch, refer to the <a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">reference documentation</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot supports both classic and reactive Elasticsearch repositories, using the <code>ElasticsearchRestTemplate</code> or <code>ReactiveElasticsearchTemplate</code> beans.
Most likely those beans are auto-configured by Spring Boot given the required dependencies are present.</p>
</div>
<div class="paragraph">
<p>If you wish to use your own template for backing the Elasticsearch repositories, you can add your own <code>ElasticsearchRestTemplate</code> or <code>ElasticsearchOperations</code> <code>@Bean</code>, as long as it is named <code>"elasticsearchTemplate"</code>.
Same applies to <code>ReactiveElasticsearchTemplate</code> and <code>ReactiveElasticsearchOperations</code>, with the bean name <code>"reactiveElasticsearchTemplate"</code>.</p>
</div>
<div class="paragraph">
<p>You can choose to disable the repositories support with the following property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.repositories.enabled=false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-cassandra">2.11.6. Cassandra</h4>
<div class="paragraph">
<p><a href="https://cassandra.apache.org/">Cassandra</a> is an open source, distributed database management system designed to handle large amounts of data across many commodity servers.
Spring Boot offers auto-configuration for Cassandra and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-cassandra">Spring Data Cassandra</a>.
There is a <code>spring-boot-starter-data-cassandra</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-cassandra">Connecting to Cassandra</h5>
<div class="paragraph">
<p>You can inject an auto-configured <code>CassandraTemplate</code> or a Cassandra <code>Session</code> instance as you would with any other Spring Bean.
The <code>spring.data.cassandra.*</code> properties can be used to customize the connection.
Generally, you provide <code>keyspace-name</code> and <code>contact-points</code> properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.cassandra.keyspace-name=mykeyspace
spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register an arbitrary number of beans that implement <code>ClusterBuilderCustomizer</code> for more advanced customizations.</p>
</div>
<div class="paragraph">
<p>The following code listing shows how to inject a Cassandra bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private CassandraTemplate template;

    @Autowired
    public MyBean(CassandraTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you add your own <code>@Bean</code> of type <code>CassandraTemplate</code>, it replaces the default.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-cassandra-repositories">Spring Data Cassandra Repositories</h5>
<div class="paragraph">
<p>Spring Data includes basic repository support for Cassandra.
Currently, this is more limited than the JPA repositories discussed earlier and needs to annotate finder methods with <code>@Query</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For complete details of Spring Data Cassandra, refer to the <a href="https://docs.spring.io/spring-data/cassandra/docs/">reference documentation</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-couchbase">2.11.7. Couchbase</h4>
<div class="paragraph">
<p><a href="https://www.couchbase.com/">Couchbase</a> is an open-source, distributed, multi-model NoSQL document-oriented database that is optimized for interactive applications.
Spring Boot offers auto-configuration for Couchbase and the abstractions on top of it provided by <a href="https://github.com/spring-projects/spring-data-couchbase">Spring Data Couchbase</a>.
There are <code>spring-boot-starter-data-couchbase</code> and <code>spring-boot-starter-data-couchbase-reactive</code> &#8220;Starters&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-couchbase">Connecting to Couchbase</h5>
<div class="paragraph">
<p>You can get a <code>Bucket</code> and <code>Cluster</code> by adding the Couchbase SDK and some configuration.
The <code>spring.couchbase.*</code> properties can be used to customize the connection.
Generally, you provide the bootstrap hosts, bucket name, and password, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
spring.couchbase.bucket.name=my-bucket
spring.couchbase.bucket.password=secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You need to provide <em>at least</em> the bootstrap host(s), in which case the bucket name is <code>default</code> and the password is an empty String.
Alternatively, you can define your own <code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code> to take control over the whole configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is also possible to customize some of the <code>CouchbaseEnvironment</code> settings.
For instance, the following configuration changes the timeout to use to open a new <code>Bucket</code> and enables SSL support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.env.timeouts.connect=3000
spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
spring.couchbase.env.ssl.key-store-password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check the <code>spring.couchbase.env.*</code> properties for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-couchbase-repositories">Spring Data Couchbase Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for Couchbase.
For complete details of Spring Data Couchbase, refer to the <a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/">reference documentation</a>.</p>
</div>
<div class="paragraph">
<p>You can inject an auto-configured <code>CouchbaseTemplate</code> instance as you would with any other Spring Bean, provided a <em>default</em> <code>CouchbaseConfigurer</code> is available (which happens when you enable Couchbase support, as explained earlier).</p>
</div>
<div class="paragraph">
<p>The following examples shows how to inject a Couchbase bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final CouchbaseTemplate template;

    @Autowired
    public MyBean(CouchbaseTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>CouchbaseTemplate</code> <code>@Bean</code> with a name of <code>couchbaseTemplate</code>.</p>
</li>
<li>
<p>An <code>IndexManager</code> <code>@Bean</code> with a name of <code>couchbaseIndexManager</code>.</p>
</li>
<li>
<p>A <code>CustomConversions</code> <code>@Bean</code> with a name of <code>couchbaseCustomConversions</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To avoid hard-coding those names in your own config, you can reuse <code>BeanNames</code> provided by Spring Data Couchbase.
For instance, you can customize the converters to use, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class SomeConfiguration {

    @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
    public CustomConversions myCustomConversions() {
        return new CustomConversions(...);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you want to fully bypass the auto-configuration for Spring Data Couchbase, provide your own implementation of <code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap">2.11.8. LDAP</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> (Lightweight Directory Access Protocol) is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network.
Spring Boot offers auto-configuration for any compliant LDAP server as well as support for the embedded in-memory LDAP server from <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>.</p>
</div>
<div class="paragraph">
<p>LDAP abstractions are provided by <a href="https://github.com/spring-projects/spring-data-ldap">Spring Data LDAP</a>.
There is a <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221; for collecting the dependencies in a convenient way.</p>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-connecting">Connecting to an LDAP Server</h5>
<div class="paragraph">
<p>To connect to an LDAP server, make sure you declare a dependency on the <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221; or <code>spring-ldap-core</code> and then declare the URLs of your server in your application.properties, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.urls=ldap://myserver:1235
spring.ldap.username=admin
spring.ldap.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to customize connection settings, you can use the <code>spring.ldap.base</code> and <code>spring.ldap.base-environment</code> properties.</p>
</div>
<div class="paragraph">
<p>An <code>LdapContextSource</code> is auto-configured based on these settings.
If a <code>DirContextAuthenticationStrategy</code> bean is available, it is associated to the auto-configured <code>LdapContextSource</code>.
If you need to customize it, for instance to use a <code>PooledContextSource</code>, you can still inject the auto-configured <code>LdapContextSource</code>.
Make sure to flag your customized <code>ContextSource</code> as <code>@Primary</code> so that the auto-configured <code>LdapTemplate</code> uses it.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-spring-data-repositories">Spring Data LDAP Repositories</h5>
<div class="paragraph">
<p>Spring Data includes repository support for LDAP.
For complete details of Spring Data LDAP, refer to the <a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">reference documentation</a>.</p>
</div>
<div class="paragraph">
<p>You can also inject an auto-configured <code>LdapTemplate</code> instance as you would with any other Spring Bean, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final LdapTemplate template;

    @Autowired
    public MyBean(LdapTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-embedded">Embedded In-memory LDAP Server</h5>
<div class="paragraph">
<p>For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>.
To configure the server, add a dependency to <code>com.unboundid:unboundid-ldapsdk</code> and declare a configprop:spring.ldap.embedded.base-dn[] property, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn=dc=spring,dc=io</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible to define multiple base-dn values, however, since distinguished names usually contain commas, they must be defined using the correct notation.</p>
</div>
<div class="paragraph">
<p>In yaml files, you can use the yaml list notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">spring.ldap.embedded.base-dn:
  - dc=spring,dc=io
  - dc=pivotal,dc=io</code></pre>
</div>
</div>
<div class="paragraph">
<p>In properties files, you must include the index as part of the property name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, the server starts on a random port and triggers the regular LDAP support.
There is no need to specify a configprop:spring.ldap.urls[] property.</p>
</div>
<div class="paragraph">
<p>If there is a <code>schema.ldif</code> file on your classpath, it is used to initialize the server.
If you want to load the initialization script from a different resource, you can also use the configprop:spring.ldap.embedded.ldif[] property.</p>
</div>
<div class="paragraph">
<p>By default, a standard schema is used to validate <code>LDIF</code> files.
You can turn off validation altogether by setting the configprop:spring.ldap.embedded.validation.enabled[] property.
If you have custom attributes, you can use configprop:spring.ldap.embedded.validation.schema[] to define your custom attribute types or object classes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-influxdb">2.11.9. InfluxDB</h4>
<div class="paragraph">
<p><a href="https://www.influxdata.com/">InfluxDB</a> is an open-source time series database optimized for fast, high-availability storage and retrieval of time series data in fields such as operations monitoring, application metrics, Internet-of-Things sensor data, and real-time analytics.</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-influxdb">Connecting to InfluxDB</h5>
<div class="paragraph">
<p>Spring Boot auto-configures an <code>InfluxDB</code> instance, provided the <code>influxdb-java</code> client is on the classpath and the URL of the database is set, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.influx.url=https://172.0.0.1:8086</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the connection to InfluxDB requires a user and password, you can set the <code>spring.influx.user</code> and <code>spring.influx.password</code> properties accordingly.</p>
</div>
<div class="paragraph">
<p>InfluxDB relies on OkHttp.
If you need to tune the http client <code>InfluxDB</code> uses behind the scenes, you can register an <code>InfluxDbOkHttpClientBuilderProvider</code> bean.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-caching">2.12. Caching</h3>
<div class="paragraph">
<p>The Spring Framework provides support for transparently adding caching to an application.
At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache.
The caching logic is applied transparently, without any interference to the invoker.
Spring Boot auto-configures the cache infrastructure as long as caching support is enabled via the <code>@EnableCaching</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Check the <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache">relevant section</a> of the Spring Framework reference for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In a nutshell, adding caching to an operation of your service is as easy as adding the relevant annotation to its method, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MathService {

    @Cacheable("piDecimals")
    public int computePiDecimal(int i) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example demonstrates the use of caching on a potentially costly operation.
Before invoking <code>computePiDecimal</code>, the abstraction looks for an entry in the <code>piDecimals</code> cache that matches the <code>i</code> argument.
If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked.
Otherwise, the method is invoked, and the cache is updated before returning the value.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
You can also use the standard JSR-107 (JCache) annotations (such as <code>@CacheResult</code>) transparently.
However, we strongly advise you to not mix and match the Spring Cache and JCache annotations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you do not add any specific cache library, Spring Boot auto-configures a <a href="#boot-features-caching-provider-simple">simple provider</a> that uses concurrent maps in memory.
When a cache is required (such as <code>piDecimals</code> in the preceding example), this provider creates it for you.
The simple provider is not really recommended for production usage, but it is great for getting started and making sure that you understand the features.
When you have made up your mind about the cache provider to use, please make sure to read its documentation to figure out how to configure the caches that your application uses.
Nearly all providers require you to explicitly configure every cache that you use in the application.
Some offer a way to customize the default caches defined by the configprop:spring.cache.cache-names[] property.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is also possible to transparently <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache-annotations-put">update</a> or <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache-annotations-evict">evict</a> data from the cache.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider">2.12.1. Supported Cache Providers</h4>
<div class="paragraph">
<p>The cache abstraction does not provide an actual store and relies on abstraction materialized by the <code>org.springframework.cache.Cache</code> and <code>org.springframework.cache.CacheManager</code> interfaces.</p>
</div>
<div class="paragraph">
<p>If you have not defined a bean of type <code>CacheManager</code> or a <code>CacheResolver</code> named <code>cacheResolver</code> (see <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a>), Spring Boot tries to detect the following providers (in the indicated order):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#boot-features-caching-provider-generic">Generic</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, and others)</p>
</li>
<li>
<p><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-hazelcast">Hazelcast</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-infinispan">Infinispan</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-redis">Redis</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-caffeine">Caffeine</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-simple">Simple</a></p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is also possible to <em>force</em> a particular cache provider by setting the configprop:spring.cache.type[] property.
Use this property if you need to <a href="#boot-features-caching-provider-none">disable caching altogether</a> in certain environment (such as tests).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use the <code>spring-boot-starter-cache</code> &#8220;Starter&#8221; to quickly add basic caching dependencies.
The starter brings in <code>spring-context-support</code>.
If you add dependencies manually, you must include <code>spring-context-support</code> in order to use the JCache, EhCache 2.x, or Caffeine support.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the <code>CacheManager</code> is auto-configured by Spring Boot, you can further tune its configuration before it is fully initialized by exposing a bean that implements the <code>CacheManagerCustomizer</code> interface.
The following example sets a flag to say that <code>null</code> values should be passed down to the underlying map:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; cacheManagerCustomizer() {
    return new CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() {
        @Override
        public void customize(ConcurrentMapCacheManager cacheManager) {
            cacheManager.setAllowNullValues(false);
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the preceding example, an auto-configured <code>ConcurrentMapCacheManager</code> is expected.
If that is not the case (either you provided your own config or a different cache provider was auto-configured), the customizer is not invoked at all.
You can have as many customizers as you want, and you can also order them by using <code>@Order</code> or <code>Ordered</code>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-generic">Generic</h5>
<div class="paragraph">
<p>Generic caching is used if the context defines <em>at least</em> one <code>org.springframework.cache.Cache</code> bean.
A <code>CacheManager</code> wrapping all beans of that type is created.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-jcache">JCache (JSR-107)</h5>
<div class="paragraph">
<p><a href="https://jcp.org/en/jsr/detail?id=107">JCache</a> is bootstrapped through the presence of a <code>javax.cache.spi.CachingProvider</code> on the classpath (that is, a JSR-107 compliant caching library exists on the classpath), and the <code>JCacheCacheManager</code> is provided by the <code>spring-boot-starter-cache</code> &#8220;Starter&#8221;.
Various compliant libraries are available, and Spring Boot provides dependency management for Ehcache 3, Hazelcast, and Infinispan.
Any other compliant library can be added as well.</p>
</div>
<div class="paragraph">
<p>It might happen that more than one provider is present, in which case the provider must be explicitly specified.
Even if the JSR-107 standard does not enforce a standardized way to define the location of the configuration file, Spring Boot does its best to accommodate setting a cache with implementation details, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Only necessary if more than one provider is present
spring.cache.jcache.provider=com.acme.MyCachingProvider
spring.cache.jcache.config=classpath:acme.xml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot has <a href="#boot-features-hazelcast">general support for Hazelcast</a>.
If a single <code>HazelcastInstance</code> is available, it is automatically reused for the <code>CacheManager</code> as well, unless the configprop:spring.cache.jcache.config[] property is specified.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two ways to customize the underlying <code>javax.cache.cacheManager</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
If a custom <code>javax.cache.configuration.Configuration</code> bean is defined, it is used to customize them.</p>
</li>
<li>
<p><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> beans are invoked with the reference of the <code>CacheManager</code> for full customization.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If a standard <code>javax.cache.CacheManager</code> bean is defined, it is wrapped automatically in an <code>org.springframework.cache.CacheManager</code> implementation that the abstraction expects.
No further customization is applied to it.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-ehcache2">EhCache 2.x</h5>
<div class="paragraph">
<p><a href="https://www.ehcache.org/">EhCache</a> 2.x is used if a file named <code>ehcache.xml</code> can be found at the root of the classpath.
If EhCache 2.x is found, the <code>EhCacheCacheManager</code> provided by the <code>spring-boot-starter-cache</code> &#8220;Starter&#8221; is used to bootstrap the cache manager.
An alternate configuration file can be provided as well, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.ehcache.config=classpath:config/another-config.xml</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-hazelcast">Hazelcast</h5>
<div class="paragraph">
<p>Spring Boot has <a href="#boot-features-hazelcast">general support for Hazelcast</a>.
If a <code>HazelcastInstance</code> has been auto-configured, it is automatically wrapped in a <code>CacheManager</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-infinispan">Infinispan</h5>
<div class="paragraph">
<p><a href="https://infinispan.org/">Infinispan</a> has no default configuration file location, so it must be specified explicitly.
Otherwise, the default bootstrap is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.infinispan.config=infinispan.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property.
If a custom <code>ConfigurationBuilder</code> bean is defined, it is used to customize the caches.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The support of Infinispan in Spring Boot is restricted to the embedded mode and is quite basic.
If you want more options, you should use the official Infinispan Spring Boot starter instead.
See <a href="https://github.com/infinispan/infinispan-spring-boot">Infinispan&#8217;s documentation</a> for more details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-couchbase">Couchbase</h5>
<div class="paragraph">
<p>If the <a href="https://www.couchbase.com/">Couchbase</a> Java client and the <code>couchbase-spring-cache</code> implementation are available and Couchbase is <a href="#boot-features-couchbase">configured</a>, a <code>CouchbaseCacheManager</code> is auto-configured.
It is also possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property.
These caches operate on the <code>Bucket</code> that was auto-configured.
You can <em>also</em> create additional caches on another <code>Bucket</code> by using the customizer.
Assume you need two caches (<code>cache1</code> and <code>cache2</code>) on the "main" <code>Bucket</code> and one (<code>cache3</code>) cache with a custom time to live of 2 seconds on the &#8220;another&#8221; <code>Bucket</code>.
You can create the first two caches through configuration, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can define a <code>@Configuration</code> class to configure the extra <code>Bucket</code> and the <code>cache3</code> cache, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class CouchbaseCacheConfiguration {

    private final Cluster cluster;

    public CouchbaseCacheConfiguration(Cluster cluster) {
        this.cluster = cluster;
    }

    @Bean
    public Bucket anotherBucket() {
        return this.cluster.openBucket("another", "secret");
    }

    @Bean
    public CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; cacheManagerCustomizer() {
        return c -&gt; {
            c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
                    .withExpiration(2));
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sample configuration reuses the <code>Cluster</code> that was created through auto-configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-redis">Redis</h5>
<div class="paragraph">
<p>If <a href="https://redis.io/">Redis</a> is available and configured, a <code>RedisCacheManager</code> is auto-configured.
It is possible to create additional caches on startup by setting the configprop:spring.cache.cache-names[] property and cache defaults can be configured by using <code>spring.cache.redis.*</code> properties.
For instance, the following configuration creates <code>cache1</code> and <code>cache2</code> caches with a <em>time to live</em> of 10 minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=600000</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values.
We strongly recommend keeping this setting enabled if you create your own <code>RedisCacheManager</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can take full control of the configuration by adding a <code>RedisCacheConfiguration</code> <code>@Bean</code> of your own.
This can be useful if you&#8217;re looking for customizing the serialization strategy.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-caffeine">Caffeine</h5>
<div class="paragraph">
<p><a href="https://github.com/ben-manes/caffeine">Caffeine</a> is a Java 8 rewrite of Guava&#8217;s cache that supersedes support for Guava.
If Caffeine is present, a <code>CaffeineCacheManager</code> (provided by the <code>spring-boot-starter-cache</code> &#8220;Starter&#8221;) is auto-configured.
Caches can be created on startup by setting the configprop:spring.cache.cache-names[] property and can be customized by one of the following (in the indicated order):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A cache spec defined by <code>spring.cache.caffeine.spec</code></p>
</li>
<li>
<p>A <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean is defined</p>
</li>
<li>
<p>A <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean is defined</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For instance, the following configuration creates <code>cache1</code> and <code>cache2</code> caches with a maximum size of 500 and a <em>time to live</em> of 10 minutes</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a <code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean is defined, it is automatically associated to the <code>CaffeineCacheManager</code>.
Since the <code>CacheLoader</code> is going to be associated with <em>all</em> caches managed by the cache manager, it must be defined as <code>CacheLoader&lt;Object, Object&gt;</code>.
The auto-configuration ignores any other generic type.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-simple">Simple</h5>
<div class="paragraph">
<p>If none of the other providers can be found, a simple implementation using a <code>ConcurrentHashMap</code> as the cache store is configured.
This is the default if no caching library is present in your application.
By default, caches are created as needed, but you can restrict the list of available caches by setting the <code>cache-names</code> property.
For instance, if you want only <code>cache1</code> and <code>cache2</code> caches, set the <code>cache-names</code> property as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do so and your application uses a cache not listed, then it fails at runtime when the cache is needed, but not on startup.
This is similar to the way the "real" cache providers behave if you use an undeclared cache.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-none">None</h5>
<div class="paragraph">
<p>When <code>@EnableCaching</code> is present in your configuration, a suitable cache configuration is expected as well.
If you need to disable caching altogether in certain environments, force the cache type to <code>none</code> to use a no-op implementation, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.type=none</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-messaging">2.13. Messaging</h3>
<div class="paragraph">
<p>The Spring Framework provides extensive support for integrating with messaging systems, from simplified use of the JMS API using <code>JmsTemplate</code> to a complete infrastructure to receive messages asynchronously.
Spring AMQP provides a similar feature set for the Advanced Message Queuing Protocol.
Spring Boot also provides auto-configuration options for <code>RabbitTemplate</code> and RabbitMQ.
Spring WebSocket natively includes support for STOMP messaging, and Spring Boot has support for that through starters and a small amount of auto-configuration.
Spring Boot also has support for Apache Kafka.</p>
</div>
<div class="sect3">
<h4 id="boot-features-jms">2.13.1. JMS</h4>
<div class="paragraph">
<p>The <code>javax.jms.ConnectionFactory</code> interface provides a standard method of creating a <code>javax.jms.Connection</code> for interacting with a JMS broker.
Although Spring needs a <code>ConnectionFactory</code> to work with JMS, you generally need not use it directly yourself and can instead rely on higher level messaging abstractions.
(See the <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#jms">relevant section</a> of the Spring Framework reference documentation for details.)
Spring Boot also auto-configures the necessary infrastructure to send and receive messages.</p>
</div>
<div class="sect4">
<h5 id="boot-features-activemq">ActiveMQ Support</h5>
<div class="paragraph">
<p>When <a href="https://activemq.apache.org/">ActiveMQ</a> is available on the classpath, Spring Boot can also configure a <code>ConnectionFactory</code>.
If the broker is present, an embedded broker is automatically started and configured (provided no broker URL is specified through configuration).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use <code>spring-boot-starter-activemq</code>, the necessary dependencies to connect or embed an ActiveMQ instance are provided, as is the Spring infrastructure to integrate with JMS.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ActiveMQ configuration is controlled by external configuration properties in <code>spring.activemq.*</code>.
For example, you might declare the following section in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, a <code>CachingConnectionFactory</code> wraps the native <code>ConnectionFactory</code> with sensible settings that you can control by external configuration properties in <code>spring.jms.*</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;d rather use native pooling, you can do so by adding a dependency to <code>org.messaginghub:pooled-jms</code> and configuring the <code>JmsPoolConnectionFactory</code> accordingly, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a> for more of the supported options.
You can also register an arbitrary number of beans that implement <code>ActiveMQConnectionFactoryCustomizer</code> for more advanced customizations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, ActiveMQ creates a destination if it does not yet exist so that destinations are resolved against their provided names.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-artemis">Artemis Support</h5>
<div class="paragraph">
<p>Spring Boot can auto-configure a <code>ConnectionFactory</code> when it detects that <a href="https://activemq.apache.org/artemis/">Artemis</a> is available on the classpath.
If the broker is present, an embedded broker is automatically started and configured (unless the mode property has been explicitly set).
The supported modes are <code>embedded</code> (to make explicit that an embedded broker is required and that an error should occur if the broker is not available on the classpath) and <code>native</code> (to connect to a broker using the <code>netty</code> transport protocol).
When the latter is configured, Spring Boot configures a <code>ConnectionFactory</code> that connects to a broker running on the local machine with the default settings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use <code>spring-boot-starter-artemis</code>, the necessary dependencies to connect to an existing Artemis instance are provided, as well as the Spring infrastructure to integrate with JMS.
Adding <code>org.apache.activemq:artemis-jms-server</code> to your application lets you use embedded mode.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Artemis configuration is controlled by external configuration properties in <code>spring.artemis.*</code>.
For example, you might declare the following section in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.mode=native
spring.artemis.host=192.168.1.210
spring.artemis.port=9876
spring.artemis.user=admin
spring.artemis.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available.
These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> or <code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>, for advanced queue and topic configurations, respectively.</p>
</div>
<div class="paragraph">
<p>By default, a <code>CachingConnectionFactory</code> wraps the native <code>ConnectionFactory</code> with sensible settings that you can control by external configuration properties in <code>spring.jms.*</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;d rather use native pooling, you can do so by adding a dependency to <code>org.messaginghub:pooled-jms</code> and configuring the <code>JmsPoolConnectionFactory</code> accordingly, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a> for more supported options.</p>
</div>
<div class="paragraph">
<p>No JNDI lookup is involved, and destinations are resolved against their names, using either the <code>name</code> attribute in the Artemis configuration or the names provided through configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jms-jndi">Using a JNDI ConnectionFactory</h5>
<div class="paragraph">
<p>If you are running your application in an application server, Spring Boot tries to locate a JMS <code>ConnectionFactory</code> by using JNDI.
By default, the <code>java:/JmsXA</code> and <code>java:/XAConnectionFactory</code> location are checked.
You can use the configprop:spring.jms.jndi-name[] property if you need to specify an alternative location, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.jndi-name=java:/MyConnectionFactory</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-jms-sending">Sending a Message</h5>
<div class="paragraph">
<p>Spring&#8217;s <code>JmsTemplate</code> is auto-configured, and you can autowire it directly into your own beans, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    @Autowired
    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html"><code>JmsMessagingTemplate</code></a> can be injected in a similar manner.
If a <code>DestinationResolver</code> or a <code>MessageConverter</code> bean is defined, it is associated automatically to the auto-configured <code>JmsTemplate</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-jms-receiving">Receiving a Message</h5>
<div class="paragraph">
<p>When the JMS infrastructure is present, any bean can be annotated with <code>@JmsListener</code> to create a listener endpoint.
If no <code>JmsListenerContainerFactory</code> has been defined, a default one is configured automatically.
If a <code>DestinationResolver</code> or a <code>MessageConverter</code> beans is defined, it is associated automatically to the default factory.</p>
</div>
<div class="paragraph">
<p>By default, the default factory is transactional.
If you run in an infrastructure where a <code>JtaTransactionManager</code> is present, it is associated to the listener container by default.
If not, the <code>sessionTransacted</code> flag is enabled.
In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding <code>@Transactional</code> on your listener method (or a delegate thereof).
This ensures that the incoming message is acknowledged, once the local transaction has completed.
This also includes sending response messages that have been performed on the same JMS session.</p>
</div>
<div class="paragraph">
<p>The following component creates a listener endpoint on the <code>someQueue</code> destination:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/jms/annotation/EnableJms.html">the Javadoc of <code>@EnableJms</code></a> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to create more <code>JmsListenerContainerFactory</code> instances or if you want to override the default, Spring Boot provides a <code>DefaultJmsListenerContainerFactoryConfigurer</code> that you can use to initialize a <code>DefaultJmsListenerContainerFactory</code> with the same settings as the one that is auto-configured.</p>
</div>
<div class="paragraph">
<p>For instance, the following example exposes another factory that uses a specific <code>MessageConverter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class JmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory());
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can use the factory in any <code>@JmsListener</code>-annotated method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-amqp">2.13.2. AMQP</h4>
<div class="paragraph">
<p>The Advanced Message Queuing Protocol (AMQP) is a platform-neutral, wire-level protocol for message-oriented middleware.
The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.
Spring Boot offers several conveniences for working with AMQP through RabbitMQ, including the <code>spring-boot-starter-amqp</code> &#8220;Starter&#8221;.</p>
</div>
<div class="sect4">
<h5 id="boot-features-rabbitmq">RabbitMQ support</h5>
<div class="paragraph">
<p><a href="https://www.rabbitmq.com/">RabbitMQ</a> is a lightweight, reliable, scalable, and portable message broker based on the AMQP protocol.
Spring uses <code>RabbitMQ</code> to communicate through the AMQP protocol.</p>
</div>
<div class="paragraph">
<p>RabbitMQ configuration is controlled by external configuration properties in <code>spring.rabbitmq.*</code>.
For example, you might declare the following section in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you could configure the same connection using the <code>addresses</code> attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.addresses=amqp://admin:secret@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a <code>ConnectionNameStrategy</code> bean exists in the context, it will be automatically used to name connections created by the auto-configured <code>ConnectionFactory</code>.
See <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a> for more of the supported options.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">Understanding AMQP, the protocol used by RabbitMQ</a> for more details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-amqp-sending">Sending a Message</h5>
<div class="paragraph">
<p>Spring&#8217;s <code>AmqpTemplate</code> and <code>AmqpAdmin</code> are auto-configured, and you can autowire them directly into your own beans, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;
    private final AmqpTemplate amqpTemplate;

    @Autowired
    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring-amqp/docs/{spring-amqp-version}/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html"><code>RabbitMessagingTemplate</code></a> can be injected in a similar manner.
If a <code>MessageConverter</code> bean is defined, it is associated automatically to the auto-configured <code>AmqpTemplate</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If necessary, any <code>org.springframework.amqp.core.Queue</code> that is defined as a bean is automatically used to declare a corresponding queue on the RabbitMQ instance.</p>
</div>
<div class="paragraph">
<p>To retry operations, you can enable retries on the <code>AmqpTemplate</code> (for example, in the event that the broker connection is lost):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Retries are disabled by default.
You can also customize the <code>RetryTemplate</code> programmatically by declaring a <code>RabbitRetryTemplateCustomizer</code> bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-amqp-receiving">Receiving a Message</h5>
<div class="paragraph">
<p>When the Rabbit infrastructure is present, any bean can be annotated with <code>@RabbitListener</code> to create a listener endpoint.
If no <code>RabbitListenerContainerFactory</code> has been defined, a default <code>SimpleRabbitListenerContainerFactory</code> is automatically configured and you can switch to a direct container using the configprop:spring.rabbitmq.listener.type[] property.
If a <code>MessageConverter</code> or a <code>MessageRecoverer</code> bean is defined, it is automatically associated with the default factory.</p>
</div>
<div class="paragraph">
<p>The following sample component creates a listener endpoint on the <code>someQueue</code> queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
See <a href="https://docs.spring.io/spring-amqp/docs/{spring-amqp-version}/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">the Javadoc of <code>@EnableRabbit</code></a> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you need to create more <code>RabbitListenerContainerFactory</code> instances or if you want to override the default, Spring Boot provides a <code>SimpleRabbitListenerContainerFactoryConfigurer</code> and a <code>DirectRabbitListenerContainerFactoryConfigurer</code> that you can use to initialize a <code>SimpleRabbitListenerContainerFactory</code> and a <code>DirectRabbitListenerContainerFactory</code> with the same settings as the factories used by the auto-configuration.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It does not matter which container type you chose.
Those two beans are exposed by the auto-configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For instance, the following configuration class exposes another factory that uses a specific <code>MessageConverter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class RabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can use the factory in any <code>@RabbitListener</code>-annotated method, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can enable retries to handle situations where your listener throws an exception.
By default, <code>RejectAndDontRequeueRecoverer</code> is used, but you can define a <code>MessageRecoverer</code> of your own.
When retries are exhausted, the message is rejected and either dropped or routed to a dead-letter exchange if the broker is configured to do so.
By default, retries are disabled.
You can also customize the <code>RetryTemplate</code> programmatically by declaring a <code>RabbitRetryTemplateCustomizer</code> bean.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely.
You can modify this behavior in two ways: Set the <code>defaultRequeueRejected</code> property to <code>false</code> so that zero re-deliveries are attempted or throw an <code>AmqpRejectAndDontRequeueException</code> to signal the message should be rejected.
The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka">2.13.3. Apache Kafka Support</h4>
<div class="paragraph">
<p><a href="https://kafka.apache.org/">Apache Kafka</a> is supported by providing auto-configuration of the <code>spring-kafka</code> project.</p>
</div>
<div class="paragraph">
<p>Kafka configuration is controlled by external configuration properties in <code>spring.kafka.*</code>.
For example, you might declare the following section in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=myGroup</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To create a topic on startup, add a bean of type <code>NewTopic</code>.
If the topic already exists, the bean is ignored.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a> for more supported options.</p>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-sending-a-message">Sending a Message</h5>
<div class="paragraph">
<p>Spring&#8217;s <code>KafkaTemplate</code> is auto-configured, and you can autowire it directly in your own beans, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final KafkaTemplate kafkaTemplate;

    @Autowired
    public MyBean(KafkaTemplate kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the property configprop:spring.kafka.producer.transaction-id-prefix[] is defined, a <code>KafkaTransactionManager</code> is automatically configured.
Also, if a <code>RecordMessageConverter</code> bean is defined, it is automatically associated to the auto-configured <code>KafkaTemplate</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-receiving-a-message">Receiving a Message</h5>
<div class="paragraph">
<p>When the Apache Kafka infrastructure is present, any bean can be annotated with <code>@KafkaListener</code> to create a listener endpoint.
If no <code>KafkaListenerContainerFactory</code> has been defined, a default one is automatically configured with keys defined in <code>spring.kafka.listener.*</code>.</p>
</div>
<div class="paragraph">
<p>The following component creates a listener endpoint on the <code>someTopic</code> topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @KafkaListener(topics = "someTopic")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a <code>KafkaTransactionManager</code> bean is defined, it is automatically associated to the container factory.
Similarly, if a <code>ErrorHandler</code>, <code>AfterRollbackProcessor</code> or <code>ConsumerAwareRebalanceListener</code> bean is defined, it is automatically associated to the default factory.</p>
</div>
<div class="paragraph">
<p>Depending on the listener type, a <code>RecordMessageConverter</code> or <code>BatchMessageConverter</code> bean is associated to the default factory.
If only a <code>RecordMessageConverter</code> bean is present for a batch listener, it is wrapped in a <code>BatchMessageConverter</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
A custom <code>ChainedKafkaTransactionManager</code> must be marked <code>@Primary</code> as it usually references the auto-configured <code>KafkaTransactionManager</code> bean.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-streams">Kafka Streams</h5>
<div class="paragraph">
<p>Spring for Apache Kafka provides a factory bean to create a <code>StreamsBuilder</code> object and manage the lifecycle of its streams.
Spring Boot auto-configures the required <code>KafkaStreamsConfiguration</code> bean as long as <code>kafka-streams</code> is on the classpath and Kafka Streams is enabled via the <code>@EnableKafkaStreams</code> annotation.</p>
</div>
<div class="paragraph">
<p>Enabling Kafka Streams means that the application id and bootstrap servers must be set.
The former can be configured using <code>spring.kafka.streams.application-id</code>, defaulting to <code>spring.application.name</code> if not set.
The latter can be set globally or specifically overridden just for streams.</p>
</div>
<div class="paragraph">
<p>Several additional properties are available using dedicated properties; other arbitrary Kafka properties can be set using the <code>spring.kafka.streams.properties</code> namespace.
See also <a href="#boot-features-kafka-extra-props">Additional Kafka Properties</a> for more information.</p>
</div>
<div class="paragraph">
<p>To use the factory bean, simply wire <code>StreamsBuilder</code> into your <code>@Bean</code> as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public static class KafkaStreamsExampleConfiguration {

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder streamsBuilder) {
        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream("ks1In");
        stream.map((k, v) -&gt; new KeyValue&lt;&gt;(k, v.toUpperCase())).to("ks1Out",
                Produced.with(Serdes.Integer(), new JsonSerde&lt;&gt;()));
        return stream;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the streams managed by the <code>StreamBuilder</code> object it creates are started automatically.
You can customize this behaviour using the configprop:spring.kafka.streams.auto-startup[] property.</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-extra-props">Additional Kafka Properties</h5>
<div class="paragraph">
<p>The properties supported by auto configuration are shown in <a href="appendix-application-properties.html#common-application-properties">[appendix-application-properties#common-application-properties]</a>.
Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties.
Refer to the Apache Kafka documentation for details.</p>
</div>
<div class="paragraph">
<p>The first few of these properties apply to all components (producers, consumers, admins, and streams) but can be specified at the component level if you wish to use different values.
Apache Kafka designates properties with an importance of HIGH, MEDIUM, or LOW.
Spring Boot auto-configuration supports all HIGH importance properties, some selected MEDIUM and LOW properties, and any properties that do not have a default value.</p>
</div>
<div class="paragraph">
<p>Only a subset of the properties supported by Kafka are available directly through the <code>KafkaProperties</code> class.
If you wish to configure the producer or consumer with additional properties that are not directly supported, use the following properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.properties.prop.one=first
spring.kafka.admin.properties.prop.two=second
spring.kafka.consumer.properties.prop.three=third
spring.kafka.producer.properties.prop.four=fourth
spring.kafka.streams.properties.prop.five=fifth</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sets the common <code>prop.one</code> Kafka property to <code>first</code> (applies to producers, consumers and admins), the <code>prop.two</code> admin property to <code>second</code>, the <code>prop.three</code> consumer property to <code>third</code>, the <code>prop.four</code> producer property to <code>fourth</code> and the <code>prop.five</code> streams property to <code>fifth</code>.</p>
</div>
<div class="paragraph">
<p>You can also configure the Spring Kafka <code>JsonDeserializer</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can disable the <code>JsonSerializer</code> default behavior of sending type information in headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.add.type.headers=false</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Properties set in this way override any configuration item that Spring Boot explicitly supports.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-kafka">Testing with Embedded Kafka</h5>
<div class="paragraph">
<p>Spring for Apache Kafka provides a convenient way to test projects with an embedded Apache Kafka broker.
To use this feature, annotate a test class with <code>@EmbeddedKafka</code> from the <code>spring-kafka-test</code> module.
For more information, please see the Spring for Apache Kafka <a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation">reference manual</a>.</p>
</div>
<div class="paragraph">
<p>To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the <code>EmbeddedKafkaBroker</code>) into the Spring Boot configuration property for Apache Kafka.
There are several ways to do that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide a system property to map embedded broker addresses into configprop:spring.kafka.bootstrap-servers[] in the test class:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Configure a property name on the <code>@EmbeddedKafka</code> annotation:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a placeholder in configuration properties:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-resttemplate">2.14. 使用 <code>RestTemplate</code> 调用REST服务</h3>
<div class="paragraph">
<p>如果你需要从应用程序中调用远程REST服务，则可以使用Spring Framework的 <a href="https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api/org/springframework/web/client/RestTemplate.html"><code>RestTemplate</code></a>类。
由于 <code>RestTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>RestTemplate</code> bean。
但是，它确实会自动配置 <code>RestTemplateBuilder</code>，可在需要时将其用于创建 <code>RestTemplate</code> 实例。
自动配置的 <code>RestTemplateBuilder</code> 确保将明智的 <code>HttpMessageConverters</code> 应用于 <code>RestTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>RestTemplateBuilder</code> 包含许多有用的方法，可用于快速配置 <code>RestTemplate</code>。例如：要添加BASIC身份验证支持，
可以使用 <code>builder.basicAuthentication("user", "password").build()</code>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-resttemplate-customization">2.14.1. RestTemplate自定义</h4>
<div class="paragraph">
<p><code>RestTemplate</code> 自定义有三种主要方法，具体取决于你要应用自定义的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。
每个方法调用都返回一个新的 <code>RestTemplateBuilder</code> 实例，因此自定义项仅影响此builder的使用。</p>
</div>
<div class="paragraph">
<p>要进行应用程序作用域的附加自定义，请使用 <code>RestTemplateCustomizer</code> bean。
所有此类bean都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 中，并应用于使用它构建的任何模板。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个定制程序，该定制程序为除 <code>192.168.0.5</code> 之外的所有主机配置使用代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code> bean。
这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置，并阻止使用任何 <code>RestTemplateCustomizer</code> Bean。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient">2.15. 使用 <code>WebClient</code> 调用REST服务</h3>
<div class="paragraph">
<p>如果你的类路径中包含Spring WebFlux，则还可以选择使用 <code>WebClient</code> 调用远程REST服务。
与 <code>RestTemplate</code> 相比，此客户端具有更强的功能性，并且是完全响应性的。
你可以在 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-client">Spring Framework文档的专用部分</a>中了解有关 <code>WebClient</code> 的更多信息。</p>
</div>
<div class="paragraph">
<p>Spring Boot为你创建并预配置了 <code>WebClient.Builder</code>。强烈建议将其注入你的组件中，并使用它来创建 <code>WebClient</code> 实例。
Spring Boot将该builder配置为共享HTTP资源，以与服务器相同的方式反映编解码器的设置
（请参阅<a href="#boot-features-webflux-httpcodecs">WebFlux HTTP codecs自动配置</a>），等等。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name)
                        .retrieve().bodyToMono(Details.class);
    }

}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webclient-runtime">2.15.1. WebClient运行时</h4>
<div class="paragraph">
<p>Spring Boot将根据应用程序类路径上可用的库自动检测要使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>。
目前支持Reactor Netty和Jetty RS客户端。</p>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-webflux</code> 启动器默认情况下依赖于 <code>io.projectreactor.netty:reactor-netty</code>，
这带来了服务器和客户端的实现。如果选择使用Jetty作为响应式服务器，则应该添加对Jetty响应式HTTP客户端库
<code>org.eclipse.jetty:jetty-reactive-httpclient</code> 的依赖。
对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>JettyResourceFactory</code> 或 <code>ReactorResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>如果你希望为客户端覆盖该选项，则可以定义自己的 <code>ClientHttpConnector</code> bean，并完全控制客户端配置。</p>
</div>
<div class="paragraph">
<p>你可以 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-client-builder">在Spring Framework参考文档中了解有关 <code>WebClient</code> 配置选项</a>的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webclient-customization">2.15.2. WebClient自定义</h4>
<div class="paragraph">
<p><code>WebClient</code> 自定义有三种主要方法，具体取决于你希望自定义应用的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>WebClient.Builder</code>，然后根据需要调用其方法。
<code>WebClient.Builder</code> 实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。
如果要使用同一构建器创建多个客户端，则还可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆该构建器。</p>
</div>
<div class="paragraph">
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用程序作用域的附加自定义，可以声明 <code>WebClientCustomizer</code> bean
并在注入点本地更改 <code>WebClient.Builder</code>。</p>
</div>
<div class="paragraph">
<p>最后，你可以回退到原始API并使用 <code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或 <code>WebClientCustomizer</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-validation">2.16. 验证</h3>
<div class="paragraph">
<p>只要JSR-303实现（例如：Hibernate验证器）位于类路径上，就会自动启用Bean验证1.1支持的方法验证功能。
这使bean方法的参数和/或返回值可以使用 <code>javax.validation</code> 约束进行注解。
具有此类注解方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行注释，以便在其方法中搜索内联约束注解。</p>
</div>
<div class="paragraph">
<p>例如：以下服务触发第一个参数的验证，确保其大小在8到10之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
@Validated
public class MyBean {

    public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
            Author author) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-email">2.17. 发送邮件</h3>
<div class="paragraph">
<p>Spring Framework通过使用 <code>JavaMailSender</code> 接口提供了用于发送电子邮件的简单抽象，Spring Boot为它提供了自动配置以及starter模块。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关如何使用 <code>JavaMailSender</code> 的详细说明，请参见 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#mail">参考文档</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>spring.mail.host</code> 和相关库（由 <code>spring-boot-starter-mail</code> 定义）可用，且不存在默认 <code>JavaMailSender</code>，
则创建一个。可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender。
有关更多详细信息，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>。</p>
</div>
<div class="paragraph">
<p>特别是，某些默认超时值是无限的，你可能需要更改此值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=3000
spring.mail.properties.mail.smtp.writetimeout=5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用来自JNDI的现有 <code>Session</code> 配置 <code>JavaMailSender</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.jndi-name=mail/Session</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置 <code>jndi-name</code> 时，它优先于所有其他与Session相关的其他设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta">2.18. JTA的分布式事务</h3>
<div class="paragraph">
<p>通过使用 <a href="https://www.atomikos.com/">Atomikos</a>或 <a href="https://github.com/bitronix/btm">Bitronix</a>嵌入式事务管理器，
Spring Boot支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE应用程序服务器时，还支持JTA事务。</p>
</div>
<div class="paragraph">
<p>当检测到JTA环境时，将使用Spring的 <code>JtaTransactionManager</code> 来管理事务。
自动配置的JMS，DataSource和JPA Bean已升级为支持XA事务。
你可以使用标准的Spring习惯用法（例如：<code>@Transactional</code>）来参与分布式事务。
如果你在JTA环境中，并且仍要使用本地事务，则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用JTA自动配置。</p>
</div>
<div class="sect3">
<h4 id="boot-features-jta-atomikos">2.18.1. 使用Atomikos事务管理器</h4>
<div class="paragraph">
<p><a href="https://www.atomikos.com/">Atomikos</a>是一种流行的开源事务管理器，可以嵌入到你的Spring Boot应用程序中。
你可以使用 <code>spring-boot-starter-jta-atomikos</code> 启动器引入相应的Atomikos库。
Spring Boot自动配置Atomikos，并确保将适当的 <code>depends-on</code> 设置应用于Spring Bean，以实现正确的启动和关闭顺序。</p>
</div>
<div class="paragraph">
<p>默认情况下，Atomikos事务日志将写入应用程序主目录（应用程序jar文件所在的目录）中的 <code>transaction-logs</code> 目录。
你可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。
以 <code>spring.jta.atomikos.properties</code> 开头的属性也可以用于自定义Atomikos <code>UserTransactionServiceImp</code>。
有关完整的详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Atomikos实例配置一个唯一的ID。
默认情况下，此ID是运行Atomikos的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-bitronix">2.18.2. 使用Bitronix事务管理器</h4>
<div class="paragraph">
<p><a href="https://github.com/bitronix/btm">Bitronix</a>是流行的开源JTA事务管理器实现。
你可以使用 <code>spring-boot-starter-jta-bitronix</code> 启动器将适当的Bitronix依赖项添加到项目中。
与Atomikos一样，Spring Boot自动配置Bitronix并对你的bean进行后处理，以确保启动和关闭顺序正确。</p>
</div>
<div class="paragraph">
<p>默认情况下，Bitronix事务日志文件（<code>part1.btm</code> 和 <code>part2.btm</code>）被写入应用程序主目录中的 <code>transaction-logs</code> 目录。
你可以通过设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。以 <code>spring.jta.bitronix.properties</code>
开头的属性也绑定到 <code>bitronix.tm.Configuration</code> Bean，从而可以进行完全自定义。
有关详细信息，请参见 <a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix文档</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Bitronix实例配置唯一的ID。
默认情况下，此ID是运行Bitronix的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-javaee">2.18.3. 使用Java EE托管事务管理器</h4>
<div class="paragraph">
<p>如果将Spring Boot应用程序打包为 <code>war</code> 或 <code>ear</code> 文件，并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。
Spring Boot通过查看常见的JNDI位置（<code>java:comp/UserTransaction</code>, <code>java:comp/TransactionManager</code> 等）来尝试自动配置事务管理器。
如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。
Spring Boot尝试通过在JNDI路径（<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>）中查找 <code>ConnectionFactory</code> 来自动配置JMS，
并且你可以使用 <a href="#boot-features-connecting-to-a-jndi-datasource"><code>spring.datasource.jndi-name</code> 属性</a>配置你的 <code>DataSource</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-mixed-jms">2.18.4. 混合XA和非XA JMS连接</h4>
<div class="paragraph">
<p>使用JTA时，主要的JMS <code>ConnectionFactory</code> bean是XA-aware，并参与分布式事务。
在某些情况下，你可能想通过使用非XA <code>ConnectionFactory</code> 处理某些JMS消息。
例如：你的JMS处理逻辑可能需要比XA超时更长的时间。</p>
</div>
<div class="paragraph">
<p>如果要使用非XA <code>ConnectionFactory</code>，则可以注入 <code>nonXaJmsConnectionFactory</code> bean，
而不是 <code>@Primary</code> <code>jmsConnectionFactory</code> bean。
为了保持一致性，还可使用bean别名 <code>xaJmsConnectionFactory 提供了 `jmsConnectionFactory</code> bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何注入 <code>ConnectionFactory</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Inject the primary (XA aware) ConnectionFactory
@Autowired
private ConnectionFactory defaultConnectionFactory;

// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
@Autowired
@Qualifier("xaJmsConnectionFactory")
private ConnectionFactory xaConnectionFactory;

// Inject the non-XA aware ConnectionFactory
@Autowired
@Qualifier("nonXaJmsConnectionFactory")
private ConnectionFactory nonXaConnectionFactory;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-supporting-alternative-embedded">2.18.5. 支持替代嵌入式事务管理器</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java"><code>XAConnectionFactoryWrapper</code></a>和
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java"><code>XADataSourceWrapper</code></a>接口可用于支持其他嵌入式事务管理器。
这些接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> Bean，并将它们作为常规的 <code>ConnectionFactory</code> 和
<code>DataSource</code> Bean公开，以透明方式注册分布式事务。如果你在 <code>ApplicationContext</code> 中注册了
<code>JtaTransactionManager</code> bean和适当的XA包装bean，则 <code>DataSource</code> 和JMS自动配置使用JTA变体。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java">BitronixXAConnectionFactoryWrapper</a>和
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java">BitronixXADataSourceWrapper</a>
提供了有关如何编写XA包装器的良好示例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-hazelcast">2.19. Hazelcast</h3>
<div class="paragraph">
<p>如果 <a href="https://hazelcast.com/">Hazelcast</a>位于类路径上，并且找到了合适的配置，
则Spring Boot会自动配置一个 <code>HazelcastInstance</code>，你可以将其注入应用程序中。</p>
</div>
<div class="paragraph">
<p>如果定义 <code>com.hazelcast.config.Config</code> bean，Spring Boot会使用它。
如果你的配置定义了一个实例名称，Spring Boot会尝试查找现有实例，而不是创建一个新实例。</p>
</div>
<div class="paragraph">
<p>你还可以通过配置指定使用的Hazelcast配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.hazelcast.config=classpath:config/my-hazelcast.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>否则，Spring Boot会尝试从默认位置查找Hazelcast配置：
工作目录中或类路径根目录中的 <code>hazelcast.xml</code>，或相同位置中的 <code>.yaml</code> 副本。
我们还检查是否设置了 <code>hazelcast.config</code> 系统属性。有关更多详细信息，请参见
<a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast文档</a>。</p>
</div>
<div class="paragraph">
<p>如果在类路径中存在 <code>hazelcast-client</code>，Spring Boot首先尝试通过检查以下配置选项来创建客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.client.config.ClientConfig</code> bean的存在。</p>
</li>
<li>
<p>由 <code>spring.hazelcast.config</code> 属性定义的配置文件。</p>
</li>
<li>
<p><code>hazelcast.client.config</code> 系统属性的存在。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.xml</code>。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.yaml</code>。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot还具有<a href="#boot-features-caching-provider-hazelcast">对Hazelcast的显式缓存支持</a>。
如果启用了缓存，则 <code>HazelcastInstance</code> 将自动包装在 <code>CacheManager</code> 实现中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-quartz">2.20. Quartz调度器</h3>
<div class="paragraph">
<p>Spring Boot为使用 <a href="https://www.quartz-scheduler.org/">Quartz scheduler</a>提供了许多便利，包括
<code>spring-boot-starter-quartz</code> &#8220;Starter&#8221;。如果Quartz可用，则自动配置 <code>Scheduler</code>（通过 <code>SchedulerFactoryBean</code> 抽象）。</p>
</div>
<div class="paragraph">
<p>以下类型的Bean将自动被拾取并与 <code>Scheduler</code> 关联：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JobDetail</code>: 定义一个特定的Job。
<code>JobDetail</code> 实例可以使用JobBuilder API构建。</p>
</li>
<li>
<p><code>Calendar</code>.</p>
</li>
<li>
<p><code>Trigger</code>: 定义何时触发特定job。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，使用内存中的 <code>JobStore</code>。但是，如果应用程序中有可用的 <code>DataSource</code> bean，并且相应地配置了
<code>spring.quartz.job-store-type</code> 属性，则可以配置基于JDBC的存储，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.job-store-type=jdbc</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JDBC存储时，可以在启动时初始化schema，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
默认情况下，使用Quartz库随附的标准脚本检测并初始化数据库。这些脚本将删除现有表，并在每次重新启动时删除所有触发器。
还可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使Quartz使用应用程序的主 <code>DataSource</code> 以外的 <code>DataSource</code>，
请声明一个 <code>DataSource</code> bean，并用 <code>@QuartzDataSource</code> 注解其 <code>@Bean</code> 方法。
这样可以确保 <code>SchedulerFactoryBean</code> 和Schema初始化都使用特定于Quartz的 <code>DataSource</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过配置创建的jobs将不会覆盖从持久性job存储中读取的已注册jobs。要启用覆盖现有作业定义的功能，
请设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean来定制Quartz Scheduler配置，
这允许以编程方式进行 <code>SchedulerFactoryBean</code> 定制。可以使用 <code>spring.quartz.properties.*</code> 自定义高级Quartz配置属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
特别是，<code>Executor</code> bean没有与调度程序关联，因为Quartz提供了一种通过 <code>spring.quartz.properties</code>
配置调度程序的方法。如果需要自定义任务执行程序，请考虑实现 <code>SchedulerFactoryBeanCustomizer</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jobs可以定义设置器以注入数据映射属性。常规beans也可以用类似的方式注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleJob extends QuartzJobBean {

    private MyService myService;

    private String name;

    // Inject "MyService" bean
    public void setMyService(MyService myService) { ... }

    // Inject the "name" job data property
    public void setName(String name) { ... }

    @Override
    protected void executeInternal(JobExecutionContext context)
            throws JobExecutionException {
        ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-task-execution-scheduling">2.21. 任务执行和调度</h3>
<div class="paragraph">
<p>在上下文中没有 <code>Executor</code> bean的情况下，Spring Boot会使用合理的默认值自动配置 <code>ThreadPoolTaskExecutor</code>，
这些默认值可以自动与异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理相关联。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你在上下文中定义一个自定义 <code>Executor</code>，则常规任务执行（即 <code>@EnableAsync</code>）将透明地使用它，
但是Spring MVC支持将不会被配置，因为它需要一个 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>)。
根据你的目标安排，你可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code>，
或者定义一个 <code>ThreadPoolTaskExecutor</code> 和包装自定义 <code>Executor</code> 的 <code>AsyncConfigurer</code>。</p>
</div>
<div class="paragraph">
<p>自动配置的 <code>TaskExecutorBuilder</code> 可让你轻松创建实例，以重用默认情况下自动配置的功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>线程池使用8个核心线程，这些线程可以根据负载增长和收缩。可以使用 <code>spring.task.execution</code> 命名空间微调这些默认设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.task.execution.pool.max-size=16
spring.task.execution.pool.queue-capacity=100
spring.task.execution.pool.keep-alive=10s</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将线程池更改为使用有界队列，以便在队列已满（100个任务）时，线程池最多增加到16个线程。
池的收缩更加激进，因为当线程空闲10秒（而不是默认情况下的60秒）时，它们将被回收。</p>
</div>
<div class="paragraph">
<p>如果需要将 <code>ThreadPoolTaskScheduler</code> 与计划的任务执行（<code>@EnableScheduling</code>）关联，也可以对其进行自动配置。
线程池默认使用一个线程，可以使用 <code>spring.task.scheduling</code> 命名空间对这些设置进行微调。</p>
</div>
<div class="paragraph">
<p>如果需要创建自定义执行器或调度器，则可以在上下文中使用 <code>TaskExecutorBuilder</code> bean和 <code>TaskSchedulerBuilder</code> bean。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-integration">2.22. Spring Integration</h3>
<div class="paragraph">
<p>Spring Boot为使用 <a href="https://spring.io/projects/spring-integration">Spring Integration</a>提供了许多便利，包括
<code>spring-boot-starter-integration</code> “<code>Starter</code>”。
Spring Integration提供消息传递以及其他传输（例如：HTTP，TCP等）的抽象。
如果Spring Integration在你的类路径中可用，则通过 <code>@EnableIntegration</code> 注解对其进行初始化。</p>
</div>
<div class="paragraph">
<p>Spring Boot还配置了一些功能，这些功能由其他Spring Integration模块的存在触发。
如果 <code>spring-integration-jmx</code> 也位于类路径上，则消息处理统计信息将通过JMX发布。
如果 <code>spring-integration-jdbc</code> 可用，则可以在启动时创建默认的数据库schema，如以下行所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.integration.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a>
和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a>类。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果存在Micrometer <code>meterRegistry</code> bean，那么Spring Integration指标将由Micrometer管理。
如果你希望使用旧版Spring Integration指标，请将 <code>DefaultMetricsFactory</code> bean添加到应用程序上下文中。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-session">2.23. Spring Session</h3>
<div class="paragraph">
<p>Spring Boot为各种数据存储提供了 <a href="https://spring.io/projects/spring-session">Spring Session</a>自动配置。在构建Servlet Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDBC</p>
</li>
<li>
<p>Redis</p>
</li>
<li>
<p>Hazelcast</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>构建响应式Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redis</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。
如果你有多个实现，则必须选择要用于存储会话的 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java"><code>StoreType</code></a>。
例如：要将JDBC用作后端存储，可以按以下方式配置应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.store-type=jdbc</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过将 <code>store-type</code> 设置为 <code>none</code> 来禁用Spring Session。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个存储都有特定的附加设置。例如：可以为JDBC存储定制表的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.jdbc.table-name=SESSIONS</code></pre>
</div>
</div>
<div class="paragraph">
<p>要设置会话的超时时间，可以使用 <code>spring.session.timeout</code> 属性。如果未设置该属性，则自动配置将降级到 <code>server.servlet.session.timeout</code> 的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jmx">2.24. 通过JMX进行监视和管理</h3>
<div class="paragraph">
<p>Java Management Extensions (JMX) 提供了监视和管理应用程序的标准机制。
Spring Boot将最合适的 <code>MBeanServer</code> 公开为ID为 <code>mbeanServer</code> 的bean。
带有Spring JMX注解（<code>@ManagedResource</code>，<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>）的任何bean都可以使用它。</p>
</div>
<div class="paragraph">
<p>如果你的平台提供了标准的 <code>MBeanServer</code>，则Spring Boot将使用该标准，并在必要时默认使用VM <code>MBeanServer</code>。
如果所有操作失败，将创建一个新的 <code>MBeanServer</code>。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a>类。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-testing">2.25. 测试</h3>
<div class="paragraph">
<p>请移步 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-boot-test.html">这里</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-websockets">2.26. WebSockets</h3>
<div class="paragraph">
<p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供了WebSockets自动配置。
如果将war文件部署到独立容器，Spring Boot会假定该容器负责其WebSocket支持的配置。</p>
</div>
<div class="paragraph">
<p>Spring Framework为MVC Web应用程序提供了 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb.html#websocket">丰富的WebSocket支持</a>，
可以通过 <code>spring-boot-starter-websocket</code> 模块轻松访问。</p>
</div>
<div class="paragraph">
<p>WebSocket支持也可用于 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-websocket">响应式Web应用程序</a>，
需要在 <code>spring-boot-starter-webflux</code> 旁包含WebSocket API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webservices">2.27. Web服务</h3>
<div class="paragraph">
<p>Spring Boot提供了Web服务自动配置，因此你所要做的就是定义 <code>Endpoints</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>spring-boot-starter-webservices</code> 模块可以轻松访问 <a href="https://docs.spring.io/spring-ws/docs/{spring-webservices-version}/reference/">Spring Web Services功能</a>。</p>
</div>
<div class="paragraph">
<p>可以分别为你的WSDL和XSD自动创建 <code>SimpleWsdl11Definition</code> 和 <code>SimpleXsdSchema</code> Bean。为此请配置其位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webservices.wsdl-locations=classpath:/wsdl</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webservices-template">2.27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</h4>
<div class="paragraph">
<p>如果需要从应用程序中调用远程Web服务，则可以使用 <a href="https://docs.spring.io/spring-ws/docs/{spring-webservices-version}/reference/#client-web-service-template"><code>WebServiceTemplate</code></a>类。
由于 <code>WebServiceTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>WebServiceTemplate</code> bean。
但是，它会自动配置 <code>WebServiceTemplateBuilder</code>，可在需要时将其用于创建 <code>WebServiceTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebServiceTemplate webServiceTemplate;

    public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
        this.webServiceTemplate = webServiceTemplateBuilder.build();
    }

    public DetailsResp someWsCall(DetailsReq detailsReq) {
         return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>WebServiceTemplateBuilder</code> 使用类路径上的可用HTTP客户端库来检测合适的基于HTTP的 <code>WebServiceMessageSender</code>。
你还可以像下面那样自定义读取和连接超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
    return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(5000).setReadTimeout(2000).build()).build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-developing-auto-configuration">2.28. 创建自己的自动配置</h3>
<div class="paragraph">
<p>如果你在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，并且仍由Spring Boot拾取。</p>
</div>
<div class="paragraph">
<p>自动配置可以与“<code>starter</code>”相关联，该“<code>starter</code>”提供自动配置代码以及你将使用的典型库。
我们首先介绍构建自己的自动配置所需的知识，然后继续介绍<a href="#boot-features-custom-starter">创建自定义启动器所需的典型步骤</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有一个 <a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">demo项目</a>可以展示如何逐步创建starter。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-understanding-auto-configured-beans">2.28.1. 了解自动配置的Bean</h4>
<div class="paragraph">
<p>在后台，自动配置是通过标准 <code>@Configuration</code> 类实现的。其他 <code>@Conditional</code> 注解用于约束何时应应用自动配置。
通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。
这样可以确保仅当找到相关的类并且没有声明自己的 <code>@Configuration</code> 时，才应用自动配置。</p>
</div>
<div class="paragraph">
<p>你可以浏览 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a>的源代码以查看Spring提供的
<code>@Configuration</code> 类（请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a>文件）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-locating-auto-configuration-candidates">2.28.2. 查找自动配置候选人</h4>
<div class="paragraph">
<p>Spring Boot检查发布的jar中是否存在 <code>META-INF/spring.factories</code> 文件。
该文件应在 <code>EnableAutoConfiguration</code> 键下列出你的配置类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
自动配置 <em>只能</em> 以这种方式加载。
确保在特定的程序包空间中定义它们，并且决不要将它们作为组件扫描的目标。
此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的 <code>@Imports</code> 代替。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果需要按特定顺序应用配置，则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a>或
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a>注解。
例如：如果你提供特定于Web的配置，则可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用你的类。</p>
</div>
<div class="paragraph">
<p>如果要排序某些彼此之间不具有任何直接了解的自动配置，则也可以使用 <code>@AutoConfigureOrder</code>。
该注解与常规 <code>@Order</code> 注解具有相同的语义，但为自动配置类提供了专用的顺序。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-condition-annotations">2.28.3. 条件注解</h4>
<div class="paragraph">
<p>你几乎总是希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解。
<code>@ConditionalOnMissingBean</code> 注解是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含许多 <code>@Conditional</code> 注解，你可以通过标注 <code>@Configuration</code> 类或单个 <code>@Bean</code> 方法在自己的代码中重用它。
这些注解包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#boot-features-class-conditions">Class条件</a></p>
</li>
<li>
<p><a href="#boot-features-bean-conditions">Bean条件</a></p>
</li>
<li>
<p><a href="#boot-features-property-conditions">Property条件</a></p>
</li>
<li>
<p><a href="#boot-features-resource-conditions">Resource条件</a></p>
</li>
<li>
<p><a href="#boot-features-web-application-conditions">Web应用条件</a></p>
</li>
<li>
<p><a href="#boot-features-spel-conditions">SpEL表达式条件</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="boot-features-class-conditions">Class条件</h5>
<div class="paragraph">
<p>通过 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解，可以根据是否存在特定类来包含 <code>@Configuration</code> 类。
由于注解元数据是通过使用 <a href="https://asm.ow2.org/">ASM</a>进行解析的，因此即使该类可能实际上未出现在正在运行的应用程序类路径上，
你也可以使用 <code>value</code> 属性来引用真实的类。如果你更喜欢通过使用 <code>String</code> 值来指定类名称，则也可以使用 <code>name</code> 属性。</p>
</div>
<div class="paragraph">
<p>这种机制不适用于通常将返回类型作为该条件目标的 <code>@Bean</code> 方法：在方法上的条件应用之前，JVM将加载该类和可能处理的方法引用，如果类不存在，这些引用将失败。</p>
</div>
<div class="paragraph">
<p>为了处理这种情况，可以使用单独的 <code>@Configuration</code> 类隔离条件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
// Some conditions
public class MyAutoConfiguration {

    // Auto-configured beans

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(EmbeddedAcmeService.class)
    static class EmbeddedConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public EmbeddedAcmeService embeddedAcmeService() { ... }

    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果在元注解中使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 来组成自己的组合注解，
则在不处理这种情况下，必须使用 <code>name</code> 来引用该类。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-bean-conditions">Bean条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据是否存在特定bean来包含bean。
你可以使用 <code>value</code> 属性按类型指定bean或使用 <code>name</code> 属性按名称指定bean。
<code>search</code> 属性使你可以限制在搜索bean时应考虑的 <code>ApplicationContext</code> 层次结构。</p>
</div>
<div class="paragraph">
<p>当放置在 <code>@Bean</code> 方法上时，目标类型默认为该方法的返回类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public MyService myService() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>ApplicationContext</code> 中没有包含 <code>MyService</code> 类型的bean，将创建 <code>myService</code> bean。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你要特别注意添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容来评估的。
出于这个原因，我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解
（因为可以保证在添加任何用户定义的bean定义后加载它们）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类。
在类级别使用这些条件与使用注解标记每个包含的 <code>@Bean</code> 方法之间的唯一区别是，如果条件不匹配，则前者会阻止将 <code>@Configuration</code> 类注册为bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-property-conditions">Property条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnProperty</code> 注解允许基于Spring <code>Environment</code> 属性包含的配置，使用 <code>prefix</code> 和 <code>name</code> 属性指定应检查的属性。
默认情况下，将匹配存在且不等于 <code>false</code> 的任何属性。你也可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性来创建更高级的检查。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-resource-conditions">Resource条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnResource</code> 注解仅在存在特定资源时才包含配置。可以使用常规的Spring约定来指定资源，
如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-web-application-conditions">Web应用条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为“Web应用程序”来包含配置。
基于Servlet的Web应用程序是使用Spring <code>WebApplicationContext</code>，定义 <code>session</code> 作用域或具有 <code>ConfigurableWebEnvironment</code> 的任何应用程序。
响应式Web应用程序是使用 <code>ReactiveWebApplicationContext</code> 或具有 <code>ConfigurableReactiveWebEnvironment</code> 的任何应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spel-conditions">SpEL表达式条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnExpression</code> 注解允许基于 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#expressions">SpEL表达式</a>的结果来包含配置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-test-autoconfig">2.28.4. 测试你的自动配置</h4>
<div class="paragraph">
<p>自动配置可能受许多因素影响：用户配置（<code>@Bean</code> 定义和 <code>Environment</code> 自定义），条件评估（存在特定库）以及其他因素。
具体而言，每个测试都应创建定义良好的 <code>ApplicationContext</code>，以表示这些自定义项的组合。
<code>ApplicationContextRunner</code> 提供了一种实现此目标的好方法。</p>
</div>
<div class="paragraph">
<p>通常将 <code>ApplicationContextRunner</code> 定义为测试类的字段，以收集基本的通用配置。
下面的示例确保始终调用 <code>UserServiceAutoConfiguration</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个测试都可以使用运行器来表示特定的用例。例如：下面的示例调用一个用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退出。
调用 <code>run</code> 提供了可与 <code>Assert4J</code> 一起使用的回调上下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void defaultServiceBacksOff() {
    this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context).getBean("myUserService").isSameAs(context.getBean(UserService.class));
    });
}

@Configuration(proxyBeanMethods = false)
static class UserConfiguration {

    @Bean
    UserService myUserService() {
        return new UserService("mine");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以轻松自定义 <code>Environment</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceNameCanBeConfigured() {
    this.contextRunner.withPropertyValues("user.name=test123").run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context.getBean(UserService.class).getName()).isEqualTo("test123");
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行器还可以用于显示 <code>ConditionEvaluationReport</code>。
可以以 <code>INFO</code> 或 <code>DEBUG</code> 级别打印报告。以下示例显示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
public void autoConfigTest {
    ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
            LogLevel.INFO);
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withInitializer(initializer).run((context) -&gt; {
                    // Do something...
            });
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="模拟一个web上下文">模拟一个Web上下文</h5>
<div class="paragraph">
<p>如果你需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用
<code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="覆盖类路径">覆盖类路径</h5>
<div class="paragraph">
<p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。
Spring Boot附带有 <code>FilteredClassLoader</code>，运行器可以轻松使用。
在以下示例中，我们断言，如果不存在 <code>UserService</code>，则会自动禁用自动配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceIsIgnoredIfLibraryIsNotPresent() {
    this.contextRunner.withClassLoader(new FilteredClassLoader(UserService.class))
            .run((context) -&gt; assertThat(context).doesNotHaveBean("userService"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter">2.28.5. 创建自己的Starter</h4>
<div class="paragraph">
<p>一个库的完整Spring Boot starter可能包含以下组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>autoconfigure</code> 模块：包含自动配置代码。</p>
</li>
<li>
<p><code>starter</code> 模块：提供对 <code>autoconfigure</code> 模块以及其库的依赖，和通常有用的任何其他依赖项。
简而言之，添加starter应提供开始使用该库所需的一切。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不需要将这两个问题分开，则可以将自动配置代码和依赖管理组合在一起。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-naming">命名</h5>
<div class="paragraph">
<p>你应该确保为启动器提供适当的命名空间。即使你使用其他Maven <code>groupId</code>，也不要以 <code>spring-boot</code> 开头模块名称。
将来，我们可能会为你自动配置的内容提供官方支持。</p>
</div>
<div class="paragraph">
<p>根据经验，你应该在启动器后命名一个组合模块。例如：假设你要为“acme”创建starter，
并命名自动配置模块 <code>acme-spring-boot-autoconfigure</code> 和启动器 <code>acme-spring-boot-starter</code>。
如果只有一个模块将两者结合在一起，则将其命名为 <code>acme-spring-boot-starter</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-configuration-keys">配置键</h5>
<div class="paragraph">
<p>如果你的starter提供了配置键，请为其使用唯一的命名空间。
特别是，不要将键包含在Spring Boot使用的名称空间中（例如：<code>server</code>, <code>management</code>, <code>spring`等）。
如果使用相同的命名空间，将来我们可能会以破坏模块的方式修改这些命名空间。
根据经验，所有键都必须拥有自己的命名空间（例如：`acme</code>）。</p>
</div>
<div class="paragraph">
<p>通过为每个属性添加字段javadoc来确保文档化配置键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    /**
     * Whether to check the location of acme resources.
     */
    private boolean checkLocation = true;

    /**
     * Timeout for establishing a connection to the acme server.
     */
    private Duration loginTimeout = Duration.ofSeconds(3);

    // getters &amp; setters

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你仅应将简单文本与 <code>@ConfigurationProperties</code> 字段Javadoc一起使用，因为在将它们添加到JSON之前不会对其进行处理。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这是我们内部遵循的一些规则，以确保描述一致：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请勿以“The”或“A”开头描述。</p>
</li>
<li>
<p>对于 <code>boolean</code> 类型，请以“Whether”或“Enable”开始描述。</p>
</li>
<li>
<p>对于基于集合的类型，请以“Comma-separated list”开始描述。</p>
</li>
<li>
<p>使用 <code>java.time.Duration</code> 而不是 <code>long</code>，如果它不为毫秒，请描述默认单位，例如：“If a duration suffix is not specified, seconds will be used”。</p>
</li>
<li>
<p>除非必须在运行时确定默认值，否则请不要在描述中提供默认值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保<a href="appendix-configuration-metadata.html#configuration-metadata-annotation-processor">触发元数据生成</a>，
以便IDE助手也可用于你的键。你可能需要查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>），
以确保正确记录了你的键。在兼容的IDE中使用自己的starter也是验证元数据质量的好主意。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-module-autoconfigure"><code>autoconfigure</code> 模块</h5>
<div class="paragraph">
<p><code>autoconfigure</code> 模块包含开始使用该库所需的所有内容。它还可能包含配置键定义（例如：<code>@ConfigurationProperties</code>）
和可用于进一步自定义组件初始化方式的任何回调接口。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你应该将对库的依赖项标记为optional，以便可以更轻松地在项目中包括 <code>autoconfigure</code> 模块。
如果这样做，则不提供该库，并且默认情况下，Spring Boot会回退。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot使用注解处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。
如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.5及更早版本，应在配置中使用 <code>compileOnly</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.6和更高版本，应在配置中使用 <code>annotationProcessor</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-module-starter">starter模块</h5>
<div class="paragraph">
<p>Starter确实是一个空jar。其唯一目的是提供必要的依赖关系以使用库。你可以将其视为对入门所需。</p>
</div>
<div class="paragraph">
<p>不要对添加了启动器的项目做任何假设。如果你要自动配置的库通常需要其他启动器，请同时提及它们。
如果可选依赖项的数量很高，则提供一组适当的 <em>默认</em> 依赖项可能会很困难，因此你应该避免包括对于库的典型用法不必要的依赖项。
换句话说，你不应包括可选的依赖项。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无论哪种方式，你的starter都必须直接或间接引用（即如果你的starter依赖于另一个starter，则无需添加它）
核心Spring Boot starter（<code>spring-boot-starter</code>）。如果仅使用你的自定义starter创建项目，
则会通过使用该核心starter来支持Spring Boot的核心功能。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-whats-next">2.29. 接下来要读什么</h3>
<div class="paragraph">
<p>如果你想了解有关本节中讨论的任何类的更多信息，可以查看 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api/">Spring Boot API文档</a>或
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE">直接浏览源代码</a>。</p>
</div>
<div class="paragraph">
<p>如果你有特定问题，请查看 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto">how-to</a>部分。</p>
</div>
<div class="paragraph">
<p>如果你对Spring Boot的核心功能感到满意，则可以继续阅读有关
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready-endpoints">生产就绪功能</a>的信息。</p>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>