<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.3">
<meta name="author" content="Version 2.2.2.RELEASE">
<title>Spring Boot</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>

</head>
<body id="boot-documentation" class="book toc2 toc-left">
<div id="header">
<h1>Spring Boot</h1>
<div class="details">
<span id="author" class="author">Version 2.2.2.RELEASE</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#using-boot">1. Spring Boot</a>
<ul class="sectlevel2">
<li><a href="#using-boot-build-systems">1.1. 构建系统</a>
<ul class="sectlevel3">
<li><a href="#using-boot-dependency-management">1.1.1. 依赖管理</a></li>
<li><a href="#using-boot-maven">1.1.2. Maven</a>
<ul class="sectlevel4">
<li><a href="#using-boot-maven-parent-pom">继承Starter Parent</a></li>
<li><a href="#using-boot-maven-without-a-parent">在没有父POM的情况下使用Spring Boot</a></li>
<li><a href="#using-boot-maven-plugin">使用Spring Boot Maven插件</a></li>
</ul>
</li>
<li><a href="#using-boot-gradle">1.1.3. Gradle</a></li>
<li><a href="#using-boot-ant">1.1.4. Ant</a></li>
<li><a href="#using-boot-starter">1.1.5. Starters</a></li>
</ul>
</li>
<li><a href="#using-boot-structuring-your-code">1.2. 结构化你的代码</a>
<ul class="sectlevel3">
<li><a href="#using-boot-using-the-default-package">1.2.1. 使用“<code>default</code>”包</a></li>
<li><a href="#using-boot-locating-the-main-class">1.2.2. 找到应用程序主类</a></li>
</ul>
</li>
<li><a href="#using-boot-configuration-classes">1.3. 配置类</a>
<ul class="sectlevel3">
<li><a href="#using-boot-importing-configuration">1.3.1. 导入其他配置类</a></li>
<li><a href="#using-boot-importing-xml-configuration">1.3.2. 导入XML配置</a></li>
</ul>
</li>
<li><a href="#using-boot-auto-configuration">1.4. 自动配置</a>
<ul class="sectlevel3">
<li><a href="#using-boot-replacing-auto-configuration">1.4.1. 逐渐取代自动配置</a></li>
<li><a href="#using-boot-disabling-specific-auto-configuration">1.4.2. 禁用特定的自动配置类</a></li>
</ul>
</li>
<li><a href="#using-boot-spring-beans-and-dependency-injection">1.5. Spring Beans和依赖注入</a></li>
<li><a href="#using-boot-using-springbootapplication-annotation">1.6. 使用@SpringBootApplication注解</a></li>
<li><a href="#using-boot-running-your-application">1.7. 运行你的应用程序</a>
<ul class="sectlevel3">
<li><a href="#using-boot-running-from-an-ide">1.7.1. 从IDE运行</a></li>
<li><a href="#using-boot-running-as-a-packaged-application">1.7.2. 作为打包的应用程序运行</a></li>
<li><a href="#using-boot-running-with-the-maven-plugin">1.7.3. 使用Maven插件</a></li>
<li><a href="#using-boot-running-with-the-gradle-plugin">1.7.4. 使用Gradle插件</a></li>
<li><a href="#using-boot-hot-swapping">1.7.5. 热交换</a></li>
</ul>
</li>
<li><a href="#using-boot-devtools">1.8. 开发者工具</a>
<ul class="sectlevel3">
<li><a href="#using-boot-devtools-property-defaults">1.8.1. 属性默认值</a></li>
<li><a href="#using-boot-devtools-restart">1.8.2. 自动重启</a>
<ul class="sectlevel4">
<li><a href="#using-boot-devtools-restart-logging-condition-delta">记录条件评估中的更改</a></li>
<li><a href="#using-boot-devtools-restart-exclude">排除资源</a></li>
<li><a href="#using-boot-devtools-restart-additional-paths">监视其他路径</a></li>
<li><a href="#using-boot-devtools-restart-disable">禁用重启</a></li>
<li><a href="#using-boot-devtools-restart-triggerfile">使用触发文件</a></li>
<li><a href="#using-boot-devtools-customizing-classload">自定义重启类加载器</a></li>
<li><a href="#using-boot-devtools-known-restart-limitations">已知局限性</a></li>
</ul>
</li>
<li><a href="#using-boot-devtools-livereload">1.8.3. LiveReload</a></li>
<li><a href="#using-boot-devtools-globalsettings">1.8.4. 全局设置</a></li>
<li><a href="#using-boot-devtools-remote">1.8.5. 远程应用</a>
<ul class="sectlevel4">
<li><a href="#运行远程客户端应用程序">运行远程客户端应用程序</a></li>
<li><a href="#using-boot-devtools-remote-update">远程更新</a></li>
<li><a href="#configuring-file-system-watcher">配置文件系统观察器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#using-boot-packaging-for-production">1.9. 打包你的应用程序用于生产</a></li>
<li><a href="#using-boot-whats-next">1.10. 接下来要读什么</a></li>
</ul>
</li>
<li><a href="#boot-features">2. Spring Boot特性</a>
<ul class="sectlevel2">
<li><a href="#boot-features-spring-application">2.1. SpringApplication</a>
<ul class="sectlevel3">
<li><a href="#boot-features-startup-failure">2.1.1. 启动失败</a></li>
<li><a href="#boot-features-lazy-initialization">2.1.2. 延迟初始化</a></li>
<li><a href="#boot-features-banner">2.1.3. 自定义横幅</a></li>
<li><a href="#boot-features-customizing-spring-application">2.1.4. 自定义SpringApplication</a></li>
<li><a href="#boot-features-fluent-builder-api">2.1.5. 流式构建器API</a></li>
<li><a href="#boot-features-application-events-and-listeners">2.1.6. 应用程序事件和监听器</a></li>
<li><a href="#boot-features-web-environment">2.1.7. Web环境</a></li>
<li><a href="#boot-features-application-arguments">2.1.8. 访问应用程序参数</a></li>
<li><a href="#boot-features-command-line-runner">2.1.9. 使用ApplicationRunner或CommandLineRunner</a></li>
<li><a href="#boot-features-application-exit">2.1.10. 应用程序退出</a></li>
<li><a href="#boot-features-application-admin">2.1.11. 管理员功能</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config">2.2. 外部化配置</a>
<ul class="sectlevel3">
<li><a href="#boot-features-external-config-random-values">2.2.1. 配置随机值</a></li>
<li><a href="#boot-features-external-config-command-line-args">2.2.2. 访问命令行Properties</a></li>
<li><a href="#boot-features-external-config-application-property-files">2.2.3. 应用程序属性文件</a></li>
<li><a href="#boot-features-external-config-profile-specific-properties">2.2.4. 特定于Profile的Properties</a></li>
<li><a href="#boot-features-external-config-placeholders-in-properties">2.2.5. Properties中的占位符</a></li>
<li><a href="#boot-features-encrypting-properties">2.2.6. 加密Properties</a></li>
<li><a href="#boot-features-external-config-yaml">2.2.7. 使用YAML代替Properties</a>
<ul class="sectlevel4">
<li><a href="#boot-features-external-config-loading-yaml">加载YAML</a></li>
<li><a href="#boot-features-external-config-exposing-yaml-to-spring">在Spring环境中将YAML公开为Properties</a></li>
<li><a href="#boot-features-external-config-multi-profile-yaml">Multi-profile的YAML文档</a></li>
<li><a href="#boot-features-external-config-yaml-shortcomings">YAML的缺点</a></li>
</ul>
</li>
<li><a href="#boot-features-external-config-typesafe-configuration-properties">2.2.8. 类型安全的配置Properties</a>
<ul class="sectlevel4">
<li><a href="#boot-features-external-config-java-bean-binding">JavaBean properties绑定</a></li>
<li><a href="#boot-features-external-config-constructor-binding">构造函数绑定</a></li>
<li><a href="#boot-features-external-config-enabling">启用被 <code>@ConfigurationProperties</code> 注解的类型</a></li>
<li><a href="#boot-features-external-config-using">使用被 <code>@ConfigurationProperties</code> 注解的类型</a></li>
<li><a href="#boot-features-external-config-3rd-party-configuration">第三方配置</a></li>
<li><a href="#boot-features-external-config-relaxed-binding">宽松绑定</a></li>
<li><a href="#boot-features-external-config-complex-type-merge">合并复杂类型</a></li>
<li><a href="#boot-features-external-config-conversion">属性转换</a></li>
<li><a href="#boot-features-external-config-validation">@ConfigurationProperties验证</a></li>
<li><a href="#boot-features-external-config-vs-value">@ConfigurationProperties vs @Value</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-profiles">2.3. Profiles</a>
<ul class="sectlevel3">
<li><a href="#boot-features-adding-active-profiles">2.3.1. 添加活动Profiles</a></li>
<li><a href="#boot-features-programmatically-setting-profiles">2.3.2. 以编程方式设置Profiles</a></li>
<li><a href="#boot-features-profile-specific-configuration">2.3.3. 特定于Profile的配置文件</a></li>
</ul>
</li>
<li><a href="#boot-features-logging">2.4. 日志</a>
<ul class="sectlevel3">
<li><a href="#boot-features-logging-format">2.4.1. 日志格式</a></li>
<li><a href="#boot-features-logging-console-output">2.4.2. 控制台输出</a>
<ul class="sectlevel4">
<li><a href="#boot-features-logging-color-coded-output">颜色编码输出</a></li>
</ul>
</li>
<li><a href="#boot-features-logging-file-output">2.4.3. 文件输出</a></li>
<li><a href="#boot-features-custom-log-levels">2.4.4. 日志级别</a></li>
<li><a href="#boot-features-custom-log-groups">2.4.5. 日志组</a></li>
<li><a href="#boot-features-custom-log-configuration">2.4.6. 自定义日志配置</a></li>
<li><a href="#boot-features-logback-extensions">2.4.7. Logback扩展</a>
<ul class="sectlevel4">
<li><a href="#特定于profile的配置">特定于Profile的配置</a></li>
<li><a href="#环境属性">环境属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-internationalization">2.5. 国际化</a></li>
<li><a href="#boot-features-json">2.6. JSON</a>
<ul class="sectlevel3">
<li><a href="#boot-features-json-jackson">2.6.1. Jackson</a></li>
<li><a href="#boot-features-json-gson">2.6.2. Gson</a></li>
<li><a href="#boot-features-json-json-b">2.6.3. JSON-B</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-web-applications">2.7. 开发Web应用程序</a>
<ul class="sectlevel3">
<li><a href="#boot-features-spring-mvc">2.7.1. Spring Web MVC框架</a>
<ul class="sectlevel4">
<li><a href="#boot-features-spring-mvc-auto-configuration">Spring MVC自动配置</a></li>
<li><a href="#boot-features-spring-mvc-message-converters">HttpMessageConverters</a></li>
<li><a href="#boot-features-json-components">自定义JSON序列化器和反序列化器</a></li>
<li><a href="#boot-features-spring-message-codes">MessageCodesResolver</a></li>
<li><a href="#boot-features-spring-mvc-static-content">静态内容</a></li>
<li><a href="#boot-features-spring-mvc-welcome-page">欢迎页面</a></li>
<li><a href="#boot-features-spring-mvc-favicon">自定义图标</a></li>
<li><a href="#boot-features-spring-mvc-pathmatch">路径匹配和内容协商</a></li>
<li><a href="#boot-features-spring-mvc-web-binding-initializer">ConfigurableWebBindingInitializer</a></li>
<li><a href="#boot-features-spring-mvc-template-engines">模板引擎</a></li>
<li><a href="#boot-features-error-handling">错误处理</a></li>
<li><a href="#boot-features-spring-hateoas">Spring HATEOAS</a></li>
<li><a href="#boot-features-cors">CORS支持</a></li>
</ul>
</li>
<li><a href="#boot-features-webflux">2.7.2. Spring WebFlux框架</a>
<ul class="sectlevel4">
<li><a href="#boot-features-webflux-auto-configuration">Spring WebFlux自动配置</a></li>
<li><a href="#boot-features-webflux-httpcodecs">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</a></li>
<li><a href="#boot-features-webflux-static-content">静态内容</a></li>
<li><a href="#boot-features-webflux-template-engines">模板引擎</a></li>
<li><a href="#boot-features-webflux-error-handling">错误处理</a></li>
<li><a href="#boot-features-webflux-web-filters">Web过滤器</a></li>
</ul>
</li>
<li><a href="#boot-features-jersey">2.7.3. JAX-RS和Jersey</a></li>
<li><a href="#boot-features-embedded-container">2.7.4. 嵌入式Servlet容器支持</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-container-servlets-filters-listeners">Servlets, Filters和listeners</a></li>
<li><a href="#boot-features-embedded-container-context-initializer">Servlet上下文初始化</a></li>
<li><a href="#boot-features-embedded-container-application-context">ServletWebServerApplicationContext</a></li>
<li><a href="#boot-features-customizing-embedded-containers">自定义嵌入式Servlet容器</a></li>
<li><a href="#boot-features-jsp-limitations">JSP局限性</a></li>
</ul>
</li>
<li><a href="#boot-features-reactive-server">2.7.5. 响应式嵌入服务器支持</a></li>
<li><a href="#boot-features-reactive-server-resources">2.7.6. 响应式服务器资源配置</a></li>
</ul>
</li>
<li><a href="#boot-features-rsocket">2.8. RSocket</a>
<ul class="sectlevel3">
<li><a href="#boot-features-rsocket-strategies-auto-configuration">2.8.1. RSocket策略自动配置</a></li>
<li><a href="#boot-features-rsocket-server-auto-configuration">2.8.2. RSocket服务器自动配置</a></li>
<li><a href="#boot-features-rsocket-messaging">2.8.3. Spring Messaging RSocket支持</a></li>
<li><a href="#boot-features-rsocket-requester">2.8.4. 使用 <code>RSocketRequester</code> 调用RSocket服务</a></li>
</ul>
</li>
<li><a href="#boot-features-security">2.9. 安全</a>
<ul class="sectlevel3">
<li><a href="#boot-features-security-mvc">2.9.1. MVC安全</a></li>
<li><a href="#boot-features-security-webflux">2.9.2. WebFlux安全</a></li>
<li><a href="#boot-features-security-oauth2">2.9.3. OAuth2</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-oauth2-client">客户端</a></li>
<li><a href="#boot-features-security-oauth2-server">资源服务器</a></li>
<li><a href="#授权服务器">授权服务器</a></li>
</ul>
</li>
<li><a href="#boot-features-security-saml">2.9.4. SAML 2.0</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-saml2-relying-party">依赖方</a></li>
</ul>
</li>
<li><a href="#boot-features-security-actuator">2.9.5. Actuator安全</a>
<ul class="sectlevel4">
<li><a href="#boot-features-security-csrf">跨站请求伪造保护</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-sql">2.10. 使用SQL数据库</a>
<ul class="sectlevel3">
<li><a href="#boot-features-configure-datasource">2.10.1. 配置DataSource</a>
<ul class="sectlevel4">
<li><a href="#boot-features-embedded-database-support">嵌入式数据库支持</a></li>
<li><a href="#boot-features-connect-to-production-database">连接到生产数据库</a></li>
<li><a href="#boot-features-connecting-to-a-jndi-datasource">连接到JNDI数据源</a></li>
</ul>
</li>
<li><a href="#boot-features-using-jdbc-template">2.10.2. 使用JdbcTemplate</a></li>
<li><a href="#boot-features-jpa-and-spring-data">2.10.3. JPA和Spring Data JPA</a>
<ul class="sectlevel4">
<li><a href="#boot-features-entity-classes">实体类</a></li>
<li><a href="#boot-features-spring-data-jpa-repositories">Spring Data JPA存储库</a></li>
<li><a href="#boot-features-creating-and-dropping-jpa-databases">创建和删除JPA数据库</a></li>
<li><a href="#boot-features-jpa-in-web-environment">在视图中打开EntityManager</a></li>
</ul>
</li>
<li><a href="#boot-features-data-jdbc">2.10.4. Spring Data JDBC</a></li>
<li><a href="#boot-features-sql-h2-console">2.10.5. 使用H2的Web控制台</a>
<ul class="sectlevel4">
<li><a href="#boot-features-sql-h2-console-custom-path">更改H2控制台的路径</a></li>
</ul>
</li>
<li><a href="#boot-features-jooq">2.10.6. 使用jOOQ</a>
<ul class="sectlevel4">
<li><a href="#代码生成">代码生成</a></li>
<li><a href="#使用dslcontext">使用DSLContext</a></li>
<li><a href="#jooq-sql方言">jOOQ SQL方言</a></li>
<li><a href="#自定义jooq">自定义jOOQ</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-nosql">2.11. 使用NoSQL技术</a>
<ul class="sectlevel3">
<li><a href="#boot-features-redis">2.11.1. Redis</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-redis">连接到Redis</a></li>
</ul>
</li>
<li><a href="#boot-features-mongodb">2.11.2. MongoDB</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-mongodb">连接到MongoDB数据库</a></li>
<li><a href="#boot-features-mongo-template">MongoTemplate</a></li>
<li><a href="#boot-features-spring-data-mongodb-repositories">Spring Data MongoDB存储库</a></li>
<li><a href="#boot-features-mongo-embedded">嵌入式Mongo</a></li>
</ul>
</li>
<li><a href="#boot-features-neo4j">2.11.3. Neo4j</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-neo4j">连接到Neo4j数据库</a></li>
<li><a href="#boot-features-connecting-to-neo4j-embedded">使用嵌入式模式</a></li>
<li><a href="#boot-features-neo4j-ogm-native-types">使用Native类型</a></li>
<li><a href="#boot-features-neo4j-ogm-session">Neo4jSession</a></li>
<li><a href="#boot-features-spring-data-neo4j-repositories">Spring Data Neo4j存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-solr">2.11.4. Solr</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-solr">连接到Solr</a></li>
<li><a href="#boot-features-spring-data-solr-repositories">Spring Data Solr存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-elasticsearch">2.11.5. Elasticsearch</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-elasticsearch-rest">使用REST客户端连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-reactive-rest">使用响应式REST客户端连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-jest">使用Jest连接到Elasticsearch</a></li>
<li><a href="#boot-features-connecting-to-elasticsearch-spring-data">使用Spring Data连接到Elasticsearch</a></li>
<li><a href="#boot-features-spring-data-elasticsearch-repositories">Spring Data Elasticsearch存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-cassandra">2.11.6. Cassandra</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-cassandra">连接到Cassandra</a></li>
<li><a href="#boot-features-spring-data-cassandra-repositories">Spring Data Cassandra存储库</a></li>
</ul>
</li>
<li><a href="#boot-features-couchbase">2.11.7. Couchbase</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-couchbase">连接到Couchbase</a></li>
<li><a href="#boot-features-spring-data-couchbase-repositories">Spring Data Couchbase Repositories</a></li>
</ul>
</li>
<li><a href="#boot-features-ldap">2.11.8. LDAP</a>
<ul class="sectlevel4">
<li><a href="#boot-features-ldap-connecting">连接到LDAP服务器</a></li>
<li><a href="#boot-features-ldap-spring-data-repositories">Spring Data LDAP存储库</a></li>
<li><a href="#boot-features-ldap-embedded">嵌入式内存LDAP服务器</a></li>
</ul>
</li>
<li><a href="#boot-features-influxdb">2.11.9. InfluxDB</a>
<ul class="sectlevel4">
<li><a href="#boot-features-connecting-to-influxdb">连接到InfluxDB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-caching">2.12. 缓存</a>
<ul class="sectlevel3">
<li><a href="#boot-features-caching-provider">2.12.1. 支持的缓存供应商</a>
<ul class="sectlevel4">
<li><a href="#boot-features-caching-provider-generic">泛型</a></li>
<li><a href="#boot-features-caching-provider-jcache">JCache (JSR-107)</a></li>
<li><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></li>
<li><a href="#boot-features-caching-provider-hazelcast">Hazelcast</a></li>
<li><a href="#boot-features-caching-provider-infinispan">Infinispan</a></li>
<li><a href="#boot-features-caching-provider-couchbase">Couchbase</a></li>
<li><a href="#boot-features-caching-provider-redis">Redis</a></li>
<li><a href="#boot-features-caching-provider-caffeine">Caffeine</a></li>
<li><a href="#boot-features-caching-provider-simple">Simple</a></li>
<li><a href="#boot-features-caching-provider-none">None</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-messaging">2.13. 消息</a>
<ul class="sectlevel3">
<li><a href="#boot-features-jms">2.13.1. JMS</a>
<ul class="sectlevel4">
<li><a href="#boot-features-activemq">ActiveMQ支持</a></li>
<li><a href="#boot-features-artemis">Artemis支持</a></li>
<li><a href="#boot-features-jms-jndi">使用JNDI ConnectionFactory</a></li>
<li><a href="#boot-features-using-jms-sending">发送消息</a></li>
<li><a href="#boot-features-using-jms-receiving">接收消息</a></li>
</ul>
</li>
<li><a href="#boot-features-amqp">2.13.2. AMQP</a>
<ul class="sectlevel4">
<li><a href="#boot-features-rabbitmq">RabbitMQ支持</a></li>
<li><a href="#boot-features-using-amqp-sending">发送消息</a></li>
<li><a href="#boot-features-using-amqp-receiving">接收消息</a></li>
</ul>
</li>
<li><a href="#boot-features-kafka">2.13.3. Apache Kafka支持</a>
<ul class="sectlevel4">
<li><a href="#boot-features-kafka-sending-a-message">发送消息</a></li>
<li><a href="#boot-features-kafka-receiving-a-message">接收消息</a></li>
<li><a href="#boot-features-kafka-streams">Kafka流</a></li>
<li><a href="#boot-features-kafka-extra-props">Kafka的其他属性</a></li>
<li><a href="#boot-features-embedded-kafka">使用嵌入式Kafka进行测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-resttemplate">2.14. 使用 <code>RestTemplate</code> 调用REST服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-resttemplate-customization">2.14.1. RestTemplate自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-webclient">2.15. 使用 <code>WebClient</code> 调用REST服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-webclient-runtime">2.15.1. WebClient运行时</a></li>
<li><a href="#boot-features-webclient-customization">2.15.2. WebClient自定义</a></li>
</ul>
</li>
<li><a href="#boot-features-validation">2.16. 验证</a></li>
<li><a href="#boot-features-email">2.17. 发送邮件</a></li>
<li><a href="#boot-features-jta">2.18. JTA的分布式事务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-jta-atomikos">2.18.1. 使用Atomikos事务管理器</a></li>
<li><a href="#boot-features-jta-bitronix">2.18.2. 使用Bitronix事务管理器</a></li>
<li><a href="#boot-features-jta-javaee">2.18.3. 使用Java EE托管事务管理器</a></li>
<li><a href="#boot-features-jta-mixed-jms">2.18.4. 混合XA和非XA JMS连接</a></li>
<li><a href="#boot-features-jta-supporting-alternative-embedded">2.18.5. 支持替代嵌入式事务管理器</a></li>
</ul>
</li>
<li><a href="#boot-features-hazelcast">2.19. Hazelcast</a></li>
<li><a href="#boot-features-quartz">2.20. Quartz调度器</a></li>
<li><a href="#boot-features-task-execution-scheduling">2.21. 任务执行和调度</a></li>
<li><a href="#boot-features-integration">2.22. Spring Integration</a></li>
<li><a href="#boot-features-session">2.23. Spring Session</a></li>
<li><a href="#boot-features-jmx">2.24. 通过JMX进行监视和管理</a></li>
<li><a href="#boot-features-testing">2.25. 测试</a></li>
<li><a href="#boot-features-websockets">2.26. WebSockets</a></li>
<li><a href="#boot-features-webservices">2.27. Web服务</a>
<ul class="sectlevel3">
<li><a href="#boot-features-webservices-template">2.27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</a></li>
</ul>
</li>
<li><a href="#boot-features-developing-auto-configuration">2.28. 创建自己的自动配置</a>
<ul class="sectlevel3">
<li><a href="#boot-features-understanding-auto-configured-beans">2.28.1. 了解自动配置的Bean</a></li>
<li><a href="#boot-features-locating-auto-configuration-candidates">2.28.2. 查找自动配置候选人</a></li>
<li><a href="#boot-features-condition-annotations">2.28.3. 条件注解</a>
<ul class="sectlevel4">
<li><a href="#boot-features-class-conditions">Class条件</a></li>
<li><a href="#boot-features-bean-conditions">Bean条件</a></li>
<li><a href="#boot-features-property-conditions">Property条件</a></li>
<li><a href="#boot-features-resource-conditions">Resource条件</a></li>
<li><a href="#boot-features-web-application-conditions">Web应用条件</a></li>
<li><a href="#boot-features-spel-conditions">SpEL表达式条件</a></li>
</ul>
</li>
<li><a href="#boot-features-test-autoconfig">2.28.4. 测试你的自动配置</a>
<ul class="sectlevel4">
<li><a href="#模拟一个web上下文">模拟一个Web上下文</a></li>
<li><a href="#覆盖类路径">覆盖类路径</a></li>
</ul>
</li>
<li><a href="#boot-features-custom-starter">2.28.5. 创建自己的Starter</a>
<ul class="sectlevel4">
<li><a href="#boot-features-custom-starter-naming">命名</a></li>
<li><a href="#boot-features-custom-starter-configuration-keys">配置键</a></li>
<li><a href="#boot-features-custom-starter-module-autoconfigure"><code>autoconfigure</code> 模块</a></li>
<li><a href="#boot-features-custom-starter-module-starter">starter模块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#boot-features-whats-next">2.29. 接下来要读什么</a></li>
</ul>
</li>
<li><a href="#production-ready">3. Spring Boot Actuator: 生产就绪功能</a>
<ul class="sectlevel2">
<li><a href="#production-ready-enabling">3.1. 启用生产就绪功能</a></li>
<li><a href="#production-ready-endpoints">3.2. 端点</a>
<ul class="sectlevel3">
<li><a href="#production-ready-endpoints-enabling-endpoints">3.2.1. 启用端点</a></li>
<li><a href="#production-ready-endpoints-exposing-endpoints">3.2.2. 暴露端点</a></li>
<li><a href="#production-ready-endpoints-security">3.2.3. 保护HTTP端点</a></li>
<li><a href="#production-ready-endpoints-caching">3.2.4. 配置端点</a></li>
<li><a href="#production-ready-endpoints-hypermedia">3.2.5. 用于执行器Web端点的超媒体</a></li>
<li><a href="#production-ready-endpoints-cors">3.2.6. CORS支持</a></li>
<li><a href="#production-ready-endpoints-custom">3.2.7. 实现自定义端点</a>
<ul class="sectlevel4">
<li><a href="#production-ready-endpoints-custom-input">接收输入</a></li>
<li><a href="#production-ready-endpoints-custom-web">自定义Web端点</a></li>
<li><a href="#production-ready-endpoints-custom-servlet">Servlet端点</a></li>
<li><a href="#production-ready-endpoints-custom-controller">控制器端点</a></li>
</ul>
</li>
<li><a href="#production-ready-health">3.2.8. 健康信息</a>
<ul class="sectlevel4">
<li><a href="#自动配置的healthindicators">自动配置的HealthIndicators</a></li>
<li><a href="#编写自定义健康指标">编写自定义健康指标</a></li>
<li><a href="#reactive-health-indicators">Reactive健康指标</a></li>
<li><a href="#自动配置的reactivehealthindicators">自动配置的ReactiveHealthIndicators</a></li>
<li><a href="#健康组">健康组</a></li>
</ul>
</li>
<li><a href="#production-ready-application-info">3.2.9. 应用信息</a>
<ul class="sectlevel4">
<li><a href="#production-ready-application-info-autoconfigure">自动配置的InfoContributors</a></li>
<li><a href="#production-ready-application-info-env">自定义应用信息</a></li>
<li><a href="#production-ready-application-info-git">Git提交信息</a></li>
<li><a href="#production-ready-application-info-build">构建信息</a></li>
<li><a href="#production-ready-application-info-custom">编写自定义InfoContributors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#production-ready-monitoring">3.3. 通过HTTP进行监视和管理</a>
<ul class="sectlevel3">
<li><a href="#production-ready-customizing-management-server-context-path">3.3.1. 自定义管理端点路径</a></li>
<li><a href="#production-ready-customizing-management-server-port">3.3.2. 自定义管理服务器端口</a></li>
<li><a href="#production-ready-management-specific-ssl">3.3.3. 配置特定于管理的SSL</a></li>
<li><a href="#production-ready-customizing-management-server-address">3.3.4. 自定义管理服务器地址</a></li>
<li><a href="#production-ready-disabling-http-endpoints">3.3.5. 禁用HTTP端点</a></li>
</ul>
</li>
<li><a href="#production-ready-jmx">3.4. 通过JMX进行监视和管理</a>
<ul class="sectlevel3">
<li><a href="#production-ready-custom-mbean-names">3.4.1. 自定义MBean名称</a></li>
<li><a href="#production-ready-disable-jmx-endpoints">3.4.2. 禁用JMX端点</a></li>
<li><a href="#production-ready-jolokia">3.4.3. 通过HTTP将Jolokia用于JMX</a>
<ul class="sectlevel4">
<li><a href="#production-ready-customizing-jolokia">自定义Jolokia</a></li>
<li><a href="#production-ready-disabling-jolokia">禁用Jolokia</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#production-ready-loggers">3.5. 日志记录器</a>
<ul class="sectlevel3">
<li><a href="#production-ready-logger-configuration">3.5.1. 配置记录器</a></li>
</ul>
</li>
<li><a href="#production-ready-metrics">3.6. 指标</a>
<ul class="sectlevel3">
<li><a href="#production-ready-metrics-getting-started">3.6.1. 入门</a></li>
<li><a href="#production-ready-metrics-export">3.6.2. 支持的监控系统</a>
<ul class="sectlevel4">
<li><a href="#production-ready-metrics-export-appoptics">AppOptics</a></li>
<li><a href="#production-ready-metrics-export-atlas">Atlas</a></li>
<li><a href="#production-ready-metrics-export-datadog">Datadog</a></li>
<li><a href="#production-ready-metrics-export-dynatrace">Dynatrace</a></li>
<li><a href="#production-ready-metrics-export-elastic">Elastic</a></li>
<li><a href="#production-ready-metrics-export-ganglia">Ganglia</a></li>
<li><a href="#production-ready-metrics-export-graphite">Graphite</a></li>
<li><a href="#production-ready-metrics-export-humio">Humio</a></li>
<li><a href="#production-ready-metrics-export-influx">Influx</a></li>
<li><a href="#production-ready-metrics-export-jmx">JMX</a></li>
<li><a href="#production-ready-metrics-export-kairos">KairosDB</a></li>
<li><a href="#production-ready-metrics-export-newrelic">New Relic</a></li>
<li><a href="#production-ready-metrics-export-prometheus">Prometheus</a></li>
<li><a href="#production-ready-metrics-export-signalfx">SignalFx</a></li>
<li><a href="#production-ready-metrics-export-simple">Simple</a></li>
<li><a href="#production-ready-metrics-export-stackdriver">Stackdriver</a></li>
<li><a href="#production-ready-metrics-export-statsd">StatsD</a></li>
<li><a href="#production-ready-metrics-export-wavefront">Wavefront</a></li>
</ul>
</li>
<li><a href="#production-ready-metrics-meter">3.6.3. 支持的指标</a>
<ul class="sectlevel4">
<li><a href="#production-ready-metrics-spring-mvc">Spring MVC指标</a></li>
<li><a href="#production-ready-metrics-web-flux">Spring WebFlux指标</a></li>
<li><a href="#production-ready-metrics-jersey-server">Jersey服务器指标</a></li>
<li><a href="#production-ready-metrics-http-clients">HTTP客户端指标</a></li>
<li><a href="#production-ready-metrics-cache">缓存指标</a></li>
<li><a href="#production-ready-metrics-jdbc">数据源指标</a></li>
<li><a href="#production-ready-metrics-hibernate">Hibernate指标</a></li>
<li><a href="#production-ready-metrics-rabbitmq">RabbitMQ指标</a></li>
</ul>
</li>
<li><a href="#production-ready-metrics-custom">3.6.4. 注册自定义指标</a></li>
<li><a href="#production-ready-metrics-per-meter-properties">3.6.5. 自定义单个指标</a>
<ul class="sectlevel4">
<li><a href="#production-ready-metrics-common-tags">通用标签</a></li>
<li><a href="#per-meter属性">Per-meter属性</a></li>
</ul>
</li>
<li><a href="#production-ready-metrics-endpoint">3.6.6. 指标端点</a></li>
</ul>
</li>
<li><a href="#production-ready-auditing">3.7. 审计</a>
<ul class="sectlevel3">
<li><a href="#production-ready-auditing-custom">3.7.1. 自定义审计</a></li>
</ul>
</li>
<li><a href="#production-ready-http-tracing">3.8. HTTP追踪</a>
<ul class="sectlevel3">
<li><a href="#production-ready-http-tracing-custom">3.8.1. 自定义HTTP追踪</a></li>
</ul>
</li>
<li><a href="#production-ready-process-monitoring">3.9. 进程监控</a>
<ul class="sectlevel3">
<li><a href="#production-ready-process-monitoring-configuration">3.9.1. 扩展配置</a></li>
<li><a href="#production-ready-process-monitoring-programmatically">3.9.2. 以编程方式</a></li>
</ul>
</li>
<li><a href="#production-ready-whats-next">3.10. 接下来要读什么</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="using-boot">1. Spring Boot</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节将详细介绍如何使用Spring Boot。它涵盖了诸如构建系统，自动配置以及如何运行应用程序之类的主题。
我们还将介绍一些Spring Boot最佳实践。尽管Spring Boot并没有什么特别的地方（它只是另一个可以使用的库），
但是有一些建议可以使你的开发过程更轻松一些。</p>
</div>
<div class="sect2">
<h3 id="using-boot-build-systems">1.1. 构建系统</h3>
<div class="paragraph">
<p>强烈建议你选择一个支持<a href="#using-boot-dependency-management"><em>依赖关系管理</em></a>并且可以使用发布到“ Maven Central”存储库的工件的构建系统。
我们建议你选择Maven或Gradle。可以使Spring Boot与其他构建系统（例如，Ant）一起使用，但是它们并没有得到很好的支持。</p>
</div>
<div class="sect3">
<h4 id="using-boot-dependency-management">1.1.1. 依赖管理</h4>
<div class="paragraph">
<p>每个Spring Boot版本都提供了它所支持的依赖关系的精选列表。实际上，你不需要为构建配置中的所有这些依赖项提供版本，
因为Spring Boot会为你管理该版本。当你升级Spring Boot本身时，这些依赖项也会以一致的方式升级。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你仍然可以指定版本，并在需要时覆盖Spring Boot的建议版本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>精选列表包含可与Spring Boot一起使用的所有spring模块以及完善的第三方库列表。
该列表作为可与<a href="#using-boot-maven-parent-pom">Maven</a>和<a href="#using-boot-gradle">Gradle</a>
一起使用的<a href="#using-boot-maven-without-a-parent">标准物料清单(<code>spring-boot-dependencies</code>)</a>提供。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Spring Boot的每个发行版都与Spring Framework的基本版本相关联。<strong>强烈</strong> 建议你不要更改其版本。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-maven">1.1.2. Maven</h4>
<div class="paragraph">
<p>Maven用户可以从 <code>spring-boot-starter-parent</code> 项目继承来获得合理的默认值。父项目提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java 1.8是默认的编译器级别。</p>
</li>
<li>
<p>UTF-8源编码。</p>
</li>
<li>
<p>从spring-boot-dependencies pom继承的<a href="#using-boot-dependency-management">依赖管理部分</a>，
它管理公共依赖项的版本。当在自己的pom中使用这些依赖关系时，可以为这些依赖关系省略 <code>&lt;version&gt;</code> 标记。</p>
</li>
<li>
<p>使用 <code>repackage</code> 执行id执行 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/maven-plugin//repackage-mojo.html"><code>repackage</code> 目标</a>。</p>
</li>
<li>
<p>明智的 <a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html">资源过滤</a>.</p>
</li>
<li>
<p>明智的插件配置 (<a href="https://www.mojohaus.org/exec-maven-plugin/">exec plugin</a>,
<a href="https://github.com/ktoso/maven-git-commit-id-plugin">Git commit ID</a> 和
<a href="https://maven.apache.org/plugins/maven-shade-plugin/">shade</a>).</p>
</li>
<li>
<p>对 <code>application.properties</code> 和 <code>application.yml</code> 进行明智的资源过滤，包括特定于环境的文件
（例如：<code>application-dev.properties</code> 和 <code>application-dev.yml</code>）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，由于 <code>application.properties</code> 和 <code>application.yml</code> 文件接受Spring样式的占位符（<code>${&#8230;&#8203;}</code>），
因此Maven过滤已更改为使用 <code>@..@</code> 占位符。（你可以通过设置一个名为 <code>resource.delimiter</code> 的Maven属性来覆盖它。）</p>
</div>
<div class="sect4">
<h5 id="using-boot-maven-parent-pom">继承Starter Parent</h5>
<div class="paragraph">
<p>要将项目配置为从 <code>spring-boot-starter-parent</code> 继承，请设置 <code>parent</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- Inherit defaults from Spring Boot --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
&lt;/parent&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你只需要为此依赖项指定Spring Boot版本号。如果导入其他starter，则可以安全地省略版本号。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用该设置，你还可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，要升级到另一个Spring Data发布系列，
可以将以下内容添加到 <code>pom.xml</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;properties&gt;
    &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;
&lt;/properties&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
检查 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-dependencies/pom.xml"><code>spring-boot-dependencies</code> pom</a>以获取受支持属性的列表。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-maven-without-a-parent">在没有父POM的情况下使用Spring Boot</h5>
<div class="paragraph">
<p>并非每个人都喜欢从 <code>spring-boot-starter-parent</code> 父POM继承。你可能需要使用自己公司的标准父POM，或者可能希望显式声明所有Maven配置。</p>
</div>
<div class="paragraph">
<p>如果你不想使用 <code>spring-boot-starter-parent</code>，仍然可以通过使用 <code>scope=import</code> 依赖项来保留依赖项管理（而不是插件管理）的好处，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;!-- Import dependency management from Spring Boot --&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上所述，前面的示例设置不允许你使用属性来覆盖各个依赖项。为了获得相同的结果，
需要在项目的 <code>dependencyManagement</code> 中 <code>spring-boot-dependencies</code> 条目 <strong>之前</strong> 添加一个条目。
例如，要升级到另一个Spring Data发布系列，可以将以下元素添加到 <code>pom.xml</code> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;!-- Override Spring Data release train provided by Spring Boot --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
            &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
            &lt;version&gt;Fowler-SR2&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在前面的示例中，我们指定了 <em>BOM</em>，但是可以以相同方式覆盖任何依赖项类型。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-maven-plugin">使用Spring Boot Maven插件</h5>
<div class="paragraph">
<p>Spring Boot包含一个 <a href="build-tool-plugins.html#build-tool-plugins-maven-plugin">Maven插件</a>，
可以将项目打包为可执行jar。如果要使用插件，请将其添加到你的 <code>&lt;plugins&gt;</code> 部分，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用Spring Boot starter parent pom，则只需添加插件。除非你要更改父级中定义的设置，否则无需对其进行配置。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-gradle">1.1.3. Gradle</h4>
<div class="paragraph">
<p>要了解有关将Spring Boot与Gradle结合使用的信息，请参阅Spring Boot的Gradle插件的文档：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>参考（ <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/html/">HTML</a> 和 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf">PDF</a>）</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/gradle-plugin/reference/api/">API</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-ant">1.1.4. Ant</h4>
<div class="paragraph">
<p>可以使用Apache Ant+Ivy构建Spring Boot项目。<code>spring-boot-antlib</code> “<code>AntLib</code>”模块也可用于帮助Ant创建可执行jar。</p>
</div>
<div class="paragraph">
<p>为了声明依赖关系，典型的 <code>ivy.xml</code> 文件看起来类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ivy-module version="2.0"&gt;
    &lt;info organisation="org.springframework.boot" module="spring-boot-sample-ant" /&gt;
    &lt;configurations&gt;
        &lt;conf name="compile" description="everything needed to compile this module" /&gt;
        &lt;conf name="runtime" extends="compile" description="everything needed to run this module" /&gt;
    &lt;/configurations&gt;
    &lt;dependencies&gt;
        &lt;dependency org="org.springframework.boot" name="spring-boot-starter"
            rev="${spring-boot.version}" conf="compile" /&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>典型的 <code>build.xml</code> 类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;project
    xmlns:ivy="antlib:org.apache.ivy.ant"
    xmlns:spring-boot="antlib:org.springframework.boot.ant"
    name="myapp" default="build"&gt;

    &lt;property name="spring-boot.version" value="2.2.2.RELEASE" /&gt;

    &lt;target name="resolve" description="--&gt; retrieve dependencies with ivy"&gt;
        &lt;ivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" /&gt;
    &lt;/target&gt;

    &lt;target name="classpaths" depends="resolve"&gt;
        &lt;path id="compile.classpath"&gt;
            &lt;fileset dir="lib/compile" includes="*.jar" /&gt;
        &lt;/path&gt;
    &lt;/target&gt;

    &lt;target name="init" depends="classpaths"&gt;
        &lt;mkdir dir="build/classes" /&gt;
    &lt;/target&gt;

    &lt;target name="compile" depends="init" description="compile"&gt;
        &lt;javac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" /&gt;
    &lt;/target&gt;

    &lt;target name="build" depends="compile"&gt;
        &lt;spring-boot:exejar destfile="build/myapp.jar" classes="build/classes"&gt;
            &lt;spring-boot:lib&gt;
                &lt;fileset dir="lib/runtime" /&gt;
            &lt;/spring-boot:lib&gt;
        &lt;/spring-boot:exejar&gt;
    &lt;/target&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你不想使用 <code>spring-boot-antlib</code> 模块，请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-build-an-executable-archive-with-ant">不使用spring-boot-antlib “<code>How-to</code>”从Ant构建可执行存档</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-starter">1.1.5. Starters</h4>
<div class="paragraph">
<p>启动器是一组便捷的依赖项描述符，你可以在应用程序中包括它们。你可以一站式安装所需的所有Spring和相关技术，
而不必遍历示例代码和依赖描述符复制粘贴它。例如，如果要开始使用Spring和JPA进行数据库访问，请在项目中包括 <code>spring-boot-starter-data-jpa</code> 依赖项。</p>
</div>
<div class="paragraph">
<p>启动器包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的被管理的传递性依赖项。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">名字叫什么</div>
<div class="paragraph">
<p>所有 <strong>official</strong> 启动器都遵循类似的命名方式。<code>spring-boot-starter-*</code>，其中 <code>*</code> 是特定类型的应用程序。
这种命名结构旨在在你需要寻找启动器时提供帮助。许多IDE中的Maven集成使你可以按名称搜索依赖项。
例如，在安装了适当的Eclipse或STS插件的情况下，你可以在POM编辑器中按 <code>ctrl-space</code> 并键入“<code>spring-boot-starter</code>”以获取完整启动器列表。</p>
</div>
<div class="paragraph">
<p>如“<a href="spring-boot-features.html#boot-features-custom-starter">创建自己的启动器</a>”部分中所述，
第三方starters不应以 <code>spring-boot</code> 开始，因为它是为Spring Boot官方工件保留的。
而是，第三方启动程序通常以项目名称开头。例如，一个名为 <code>thirdpartyproject</code> 的第三方启动程序项目通常会被命名为
<code>thirdpartyproject-spring-boot-starter</code>。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Boot在 <code>org.springframework.boot</code> 组下提供了以下应用程序启动器：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Spring Boot application starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">核心启动器，包括自动配置支持，日志记录和YAML</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-activemq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache ActiveMQ的JMS消息传递启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-activemq/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-amqp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring AMQP和Rabbit MQ的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-amqp/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-aop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring AOP和AspectJ进行面向方面编程的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-aop/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-artemis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache Artemis的JMS消息传递启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-artemis/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-batch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Batch的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-batch/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-cache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework缓存支持的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cache/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-cloud-connectors</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Cloud Connectors的启动器，可简化与Cloud Foundry和Heroku等云平台中服务的连接。不赞成使用Java CFEnv</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cloud-connectors/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-cassandra</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Cassandra分布式数据库和Spring Data Cassandra的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-cassandra-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Cassandra分布式数据库和Spring Data Cassandra Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-couchbase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Couchbase面向文档的数据库和Spring Data Couchbase的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-couchbase-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Couchbase面向文档的数据库和Spring Data Couchbase Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-elasticsearch</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Elasticsearch搜索和分析引擎以及Spring Data Elasticsearch的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-elasticsearch/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-jdbc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data JDBC的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jdbc/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-data-jpa"></a> <code>spring-boot-starter-data-jpa</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Spring Data JPA与Hibernate结合使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jpa/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-ldap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data LDAP的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-ldap/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-mongodb</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用MongoDB面向文档的数据库和Spring Data MongoDB的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-mongodb-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用MongoDB面向文档的数据库和Spring Data MongoDB Reactive的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-neo4j</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Neo4j图数据库和Spring Data Neo4j的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-neo4j/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-redis</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Redis键值对数据库与Spring Data Redis和Lettuce客户端一起使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-redis-reactive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将Redis键值对数据库与Spring Data Redis Reacting和Lettuce客户端一起使用的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis-reactive/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-rest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Data REST在REST上公开Spring Data存储库的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-rest/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-data-solr</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Apache Solr搜索平台和Spring Data Solr的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-solr/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-freemarker</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用FreeMarker视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-freemarker/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-groovy-templates</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Groovy模板视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-groovy-templates/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-hateoas</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-hateoas/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-integration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Integration的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-integration/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-jdbc"></a> <code>spring-boot-starter-jdbc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过HikariCP连接池使用JDBC的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jdbc/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jersey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用JAX-RS和Jersey构建RESTful Web应用程序的启动器。
  <a href="#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jersey/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jooq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用jOOQ访问SQL数据库的启动器。
  <a href="#spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></a>或
  <a href="#spring-boot-starter-jdbc"><code>spring-boot-starter-jdbc</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jooq/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-json</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读写JSON的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-json/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jta-atomikos</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Atomikos的JTA事务启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-atomikos/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jta-bitronix</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Bitronix的JTA事务启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-bitronix/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-mail</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Java Mail和Spring Framework的电子邮件发送支持的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mail/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-mustache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Mustache视图构建Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mustache/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-oauth2-client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的OAuth2/OpenID Connect客户端功能的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-client/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-oauth2-resource-server</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的OAuth2资源服务器功能的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-resource-server/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-quartz</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Quartz Scheduler的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-quartz/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-rsocket</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于构建RSocket客户端和服务器的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-rsocket/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-security</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Security的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-security/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-test</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用包括JUnit，Hamcrest和Mockito在内的库测试Spring Boot应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-test/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-thymeleaf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Thymeleaf视图构建MVC Web应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-thymeleaf/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-validation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过Hibernate Validator使用Java Bean验证的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-validation/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-web"></a> <code>spring-boot-starter-web</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring MVC构建Web（包括RESTful）应用程序的启动器。使用Tomcat作为默认的嵌入式容器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-web-services</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Web Services的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web-services/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-webflux</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework的响应式Web支持构建WebFlux应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-webflux/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-websocket</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Framework的WebSocket支持构建WebSocket应用程序的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-websocket/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除了应用程序启动程序，以下启动程序可用于添加 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em> 功能：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Spring Boot production starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-actuator</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Spring Boot的Actuator的启动器，它提供了生产就绪功能，可帮助您监视和管理应用程序</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>最后，Spring Boot还包括以下启动程序，如果你想排除或替换特定的技术方面，可以使用这些启动程序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Spring Boot technical starters</caption>
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Pom</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-jetty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Jetty作为嵌入式servlet容器的启动器。<a href="#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-log4j2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Log4j2进行日志记录的启动器。<a href="#spring-boot-starter-logging"><code>spring-boot-starter-logging</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-logging"></a> <code>spring-boot-starter-logging</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Logback进行日志记录的启动器。默认日志记录启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-reactor-netty</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Reactor Netty作为嵌入式响应式HTTP服务器的启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="spring-boot-starter-tomcat"></a> <code>spring-boot-starter-tomcat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于将Tomcat用作嵌入式servlet容器的启动器。<a href="#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>使用的默认servlet容器启动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml">Pom</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-undertow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用Undertow作为嵌入式servlet容器的启动器。<a href="#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml">Pom</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关社区贡献的其他启动程序的列表，请参阅GitHub上 <code>spring-boot-starters</code> 模块中的
<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/README.adoc">README文件</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-structuring-your-code">1.2. 结构化你的代码</h3>
<div class="paragraph">
<p>Spring Boot不需要任何特定的代码布局即可工作。但是，有一些最佳做法对你会有所帮助。</p>
</div>
<div class="sect3">
<h4 id="using-boot-using-the-default-package">1.2.1. 使用“<code>default</code>”包</h4>
<div class="paragraph">
<p>当类不包含 <code>package</code> 声明时，将其视为在“<code>default package</code>”中。通常不建议使用“<code>default package</code>”，应避免使用。
对于使用 <code>@ComponentScan</code>，<code>@ConfigurationPropertiesScan</code>，<code>@EntityScan</code> 或 <code>@SpringBootApplication</code>
注解的Spring Boot应用程序，这可能会引起特定的问题，因为每个jar中的每个类都会被读取。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议你遵循Java建议的程序包命名约定，并使用反向域名（例如：<code>com.example.project</code>）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-locating-the-main-class">1.2.2. 找到应用程序主类</h4>
<div class="paragraph">
<p>我们通常建议你将应用程序主类放在其他类之上的根包中。<a href="#using-boot-using-springbootapplication-annotation"><code>@SpringBootApplication</code> 注解</a>通常放在你的主类上，它隐式定义某些条目的基本“<code>search package</code>”。
例如，如果你正在编写JPA应用程序，则使用带 <code>@SpringBootApplication</code> 注解的类的包来搜索 <code>@Entity</code> 条目。
使用根软件包还允许组件扫描仅应用于你的项目。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你不想使用 <code>@SpringBootApplication</code>，则可以通过导入的
<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 注解来定义该行为，因此也可以使用它们。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下清单显示了典型的布局：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>com
 +- example
     +- myapplication
         +- Application.java
         |
         +- customer
         |   +- Customer.java
         |   +- CustomerController.java
         |   +- CustomerService.java
         |   +- CustomerRepository.java
         |
         +- order
             +- Order.java
             +- OrderController.java
             +- OrderService.java
             +- OrderRepository.java</pre>
</div>
</div>
<div class="paragraph">
<p><code>Application.java</code> 文件将声明 <code>main</code> 方法以及基本的 <code>@SpringBootApplication</code> 注解，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-configuration-classes">1.3. 配置类</h3>
<div class="paragraph">
<p>Spring Boot支持基于Java的配置。尽管可以将 <code>SpringApplication</code> 与XML源一起使用，但是我们通常建议你的主要源为单个
<code>@Configuration</code> 类。通常，定义 <code>main</code> 方法的类是首选的 <code>@Configuration</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在互联网上已经发布了许多使用XML配置的Spring配置示例。如果可能，请始终尝试使用等效的基于Java的配置。
搜索 <code>Enable*</code> 注解可能是一个不错的起点。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-importing-configuration">1.3.1. 导入其他配置类</h4>
<div class="paragraph">
<p>你无需将所有 <code>@Configuration</code> 放在单个类中。<code>@Import</code> 注解可用于导入其他配置类。
另外，你可以使用 <code>@ComponentScan</code> 自动拾取所有Spring组件，包括 <code>@Configuration</code> 类。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-importing-xml-configuration">1.3.2. 导入XML配置</h4>
<div class="paragraph">
<p>如果绝对必须使用基于XML的配置，我们建议你仍然从 <code>@Configuration</code> 类开始。然后使用 <code>@ImportResource</code> 注解来加载XML配置文件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-auto-configuration">1.4. 自动配置</h3>
<div class="paragraph">
<p>Spring Boot自动配置会尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果 <code>HSQLDB</code> 在类路径上，
并且你尚未手动配置任何数据库连接bean，则Spring Boot会自动配置内存数据库。</p>
</div>
<div class="paragraph">
<p>你需要通过将 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解添加到你的 <code>@Configuration</code>
类之一来启用自动配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你应该只添加一个 <code>@SpringBootApplication</code> 或 <code>@EnableAutoConfiguration</code> 注解。
我们通常建议你仅将它们中的一个添加到你的主要 <code>@Configuration</code> 类中。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-replacing-auto-configuration">1.4.1. 逐渐取代自动配置</h4>
<div class="paragraph">
<p>自动配置是非侵入性的。在任何时候，你都可以开始定义自己的配置，以替换自动配置的特定部分。
例如，如果你添加自己的 <code>DataSource</code> bean，则默认的嵌入式数据库支持将回退。</p>
</div>
<div class="paragraph">
<p>如果你需要了解当前正在应用哪些自动配置以及原因，请使用 <code>--debug</code> 开关启动你的应用程序。
这样做可以启用调试日志以供选择核心记录器，并将条件报告记录到控制台。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-disabling-specific-auto-configuration">1.4.2. 禁用特定的自动配置类</h4>
<div class="paragraph">
<p>如果发现正在应用某个不需要的特定自动配置类，则可以使用 <code>@EnableAutoConfiguration</code> 的 <code>exclude</code> 属性禁用它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;
import org.springframework.context.annotation.*;

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果该类不在类路径中，则可以使用注解的 <code>excludeName</code> 属性，并指定完全限定的名称。最后，你还可以使用
<code>spring.autoconfigure.exclude</code> 属性控制要排除的自动配置类的列表。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以在注解级别和使用属性来定义排除项。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
即使自动配置类是 <code>public</code>，类中唯一被认为是公共API的是类的名称，它可以用来禁用自动配置。
这些类的实际内容（例如：嵌套配置类或Bean方法）仅供内部使用，我们不建议直接使用它们。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-spring-beans-and-dependency-injection">1.5. Spring Beans和依赖注入</h3>
<div class="paragraph">
<p>你可以自由使用任何标准的Spring Framework技术来定义bean及其注入依赖关系。为简单起见，我们经常发现使用
<code>@ComponentScan</code>（查找你的bean）和使用 <code>@Autowired</code>（进行构造函数注入）效果很好。</p>
</div>
<div class="paragraph">
<p>如果按照上面的建议构造代码（将应用程序类放在根包中），则可以添加 <code>@ComponentScan</code>，而无需添加任何参数。
你的所有应用程序组件（<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code> 等）都将自动注册为Spring Bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个 <code>@Service</code> Bean，它使用构造函数注入来获取所需的 <code>RiskAssessor</code> Bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果bean具有一个构造函数，则可以省略 <code>@Autowired</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
请注意如何使用构造函数注入将 <code>riskAssessor</code> 字段标记为 <code>final</code>，以表示它随后不能更改。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-using-springbootapplication-annotation">1.6. 使用@SpringBootApplication注解</h3>
<div class="paragraph">
<p>许多Spring Boot开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。
单个 <code>@SpringBootApplication</code> 注解可用于同时启用这三个功能，即：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@EnableAutoConfiguration</code>: 启用<a href="#using-boot-auto-configuration">Spring Boot的自动配置机制</a></p>
</li>
<li>
<p>在应用程序所在的软件包上启用 <code>@Component</code> 扫描（请参阅<a href="#using-boot-structuring-your-code">最佳实践</a>）</p>
</li>
<li>
<p><code>@Configuration</code>: 允许在上下文中注册额外的bean或导入其他配置类</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@SpringBootApplication</code> 还提供别名以自定义 <code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 的属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些功能都不是强制性的，你可以选择用它启用的任何功能替换这个单个注解。例如，你可能不想在应用程序中使用组件扫描或配置属性扫描：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@Import({ MyConfig.class, MyAnotherConfig.class })
public class Application {

    public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，除了没有自动检测到 <code>@Component</code> 和 <code>@ConfigurationProperties</code> 注解的类并且显式导入了用户定义的Bean外，
<code>Application</code> 就像其他任何Spring Boot应用程序一样（请参阅 <code>@Import</code>）。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-running-your-application">1.7. 运行你的应用程序</h3>
<div class="paragraph">
<p>将应用程序打包为jar并使用嵌入式HTTP服务器的最大优势之一是，你可以像运行其他应用程序一样运行应用程序。
调试Spring Boot应用程序也很容易。你不需要任何特殊的IDE插件或扩展。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本节仅介绍基于jar的包装。如果选择将应用程序打包为war文件，则应参考服务器和IDE文档。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-running-from-an-ide">1.7.1. 从IDE运行</h4>
<div class="paragraph">
<p>你可以将IDE中的Spring Boot应用程序作为简单的Java应用程序运行。但是，你首先需要导入你的项目。
导入步骤因你的IDE和构建系统而异。大多数IDE可以直接导入Maven项目。例如：Eclipse用户可以从 <code>File</code> 中选择 <code>Import&#8230;&#8203;</code> &#8594; <code>Existing Maven Projects</code>。</p>
</div>
<div class="paragraph">
<p>如果你不能直接将项目导入IDE，则可以使用构建插件生成IDE元数据。Maven包括用于
<a href="https://maven.apache.org/plugins/maven-eclipse-plugin/">Eclipse</a> 和 <a href="https://maven.apache.org/plugins/maven-idea-plugin/">IDEA</a>的插件。
Gradle提供了用于 <a href="https://docs.gradle.org/current/userguide/userguide.html">各种IDE</a>的插件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不小心两次运行Web应用程序，则会看到“<code>Port already in use</code>”错误。
STS用户可以使用 <code>Relaunch</code> 按钮而不是 <code>Run</code> 按钮来确保关闭任何现有实例。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-as-a-packaged-application">1.7.2. 作为打包的应用程序运行</h4>
<div class="paragraph">
<p>如果使用Spring Boot Maven或Gradle插件创建可执行jar，则可以使用 <code>java -jar</code> 运行应用程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
<div class="paragraph">
<p>也可以在启用了远程调试支持的情况下运行打包的应用程序。这样做使你可以将调试器附加到打包的应用程序，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myapplication-0.0.1-SNAPSHOT.jar</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-with-the-maven-plugin">1.7.3. 使用Maven插件</h4>
<div class="paragraph">
<p>Spring Boot Maven插件包含一个 <code>run</code> 目标，可用于快速编译和运行你的应用程序。应用程序以爆炸形式运行，就像在IDE中一样。
以下示例显示了运行Spring Boot应用程序的典型Maven命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ mvn spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>你可能还想使用 <code>MAVEN_OPTS</code> 操作系统环境变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ export MAVEN_OPTS=-Xmx1024m</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-running-with-the-gradle-plugin">1.7.4. 使用Gradle插件</h4>
<div class="paragraph">
<p>Spring Boot Gradle插件包含一个 <code>bootRun</code> 任务，该任务可用于以爆炸形式运行你的应用程序。每当你应用
<code>org.springframework.boot</code> 和 <code>java</code> 插件时，都会添加 <code>bootRun</code> 任务，在以下示例中显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle bootRun</pre>
</div>
</div>
<div class="paragraph">
<p>你可能还想使用 <code>JAVA_OPTS</code> 操作系统环境变量，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ export JAVA_OPTS=-Xmx1024m</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-hot-swapping">1.7.5. 热交换</h4>
<div class="paragraph">
<p>由于Spring Boot应用程序只是普通的Java应用程序，因此JVM热交换应该可以立即使用。
JVM热交换在一定程度上受到它可以替换的字节码的限制。对于更完整的解决方案，可以使用 <a href="https://jrebel.com/software/jrebel/">JRebel</a>。</p>
</div>
<div class="paragraph">
<p><code>spring-boot-devtools</code> 模块还包括对应用程序快速重启的支持。有关详细信息，请参见本章后面的<a href="#using-boot-devtools">开发者工具</a>部分和
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle#howto-hotswapping">&#8220;How-to&#8221; 热交换</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-devtools">1.8. 开发者工具</h3>
<div class="paragraph">
<p>Spring Boot包含一组额外的工具，这些工具可以使应用程序开发体验更加愉快。
<code>spring-boot-devtools</code> 模块可以包含在任何项目中，以提供其他开发时功能。要包括devtools支持，
请将模块依赖项添加到你的构建中，如以下Maven和Gradle清单所示：</p>
</div>
<div class="listingblock">
<div class="title">Maven</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">configurations {
    developmentOnly
    runtimeClasspath {
        extendsFrom developmentOnly
    }
}
dependencies {
    developmentOnly("org.springframework.boot:spring-boot-devtools")
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
运行完全打包的应用程序时，将自动禁用开发者工具。如果你的应用程序是以 <code>java -jar</code> 启动的，
或者是从特殊的类加载器启动的，则将其视为“<code>生产应用程序</code>”。如果这不适用于你（即如果你从容器中运行应用程序），
请考虑排除devtools或设置 <code>-Dspring.devtools.restart.enabled=false</code> 系统属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在Maven中将依赖项标记为optional或在Gradle中使用自定义 <code>developmentOnly</code> 配置（如上所示）是一种最佳实践，
它可以防止将devtools过渡地应用到使用你项目的其他模块。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
重新打包的存档默认情况下不包含devtools。如果要使用<a href="#using-boot-devtools-remote">某个远程devtools功能</a>，
则需要禁用 <code>excludeDevtools</code> 构建属性以包括它。Maven和Gradle插件均支持该属性。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-property-defaults">1.8.1. 属性默认值</h4>
<div class="paragraph">
<p>Spring Boot支持的一些库使用缓存来提高性能。例如：<a href="spring-boot-features.html#boot-features-spring-mvc-template-engines">模板引擎</a>缓存已编译的模板，以避免重复解析模板文件。
另外，Spring MVC可以在提供静态资源时向响应添加HTTP缓存头。</p>
</div>
<div class="paragraph">
<p>尽管缓存在生产中非常有益，但在开发过程中可能适得其反，从而使你无法看到刚刚在应用程序中所做的更改。因此，默认情况下，<code>spring-boot-devtools</code> 禁用缓存选项。</p>
</div>
<div class="paragraph">
<p>缓存选项通常由 <code>application.properties</code> 文件中的设置配置。例如，Thymeleaf提供 <code>spring.thymeleaf.cache</code> 属性。
<code>spring-boot-devtools</code> 模块不需要手动设置这些属性，而是自动应用合理的开发时配置。</p>
</div>
<div class="paragraph">
<p>由于在开发Spring MVC和Spring WebFlux应用程序时需要有关Web请求的更多信息，因此开发者工具将为 <code>web</code> 日志记录组启用 <code>DEBUG</code> 日志记录。
这将为你提供有关传入请求，正在处理的处理程序，响应结果等的信息。如果你希望记录所有请求详细信息（包括潜在的敏感信息），
则可以打开 <code>spring.http.log-request-details</code> 配置属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你不希望应用默认属性，则可以在 <code>application.properties</code> 中将 <code>spring.devtools.add-properties</code> 设置为 <code>false</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关devtools应用的属性完整列表，请参见
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java">DevToolsPropertyDefaultsPostProcessor</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-restart">1.8.2. 自动重启</h4>
<div class="paragraph">
<p>每当classpath上的文件更改时，使用 <code>spring-boot-devtools</code> 的应用程序都会自动重新启动。在IDE中工作时，
这可能是一个有用的功能，因为它为代码更改提供了非常快速的反馈循环。默认情况下，
将监视类路径上指向文件夹的任何条目的更改。请注意，某些资源（例如静态资产和视图模板）
<a href="#using-boot-devtools-restart-exclude">不需要重新启动应用程序</a>。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">触发重启</div>
<div class="paragraph">
<p>当DevTools监视类路径资源时，触发重启的唯一方法是更新类路径。导致类路径更新的方式取决于所使用的IDE。
在Eclipse中，保存修改后的文件将导致类路径被更新并触发重新启动。
在IntelliJ IDEA中，构建项目（<code>Build -&gt; Build Project</code>）具有相同的效果。</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只要启用了forking，你还可以使用受支持的构建插件（Maven和Gradle）启动应用程序，
因为DevTools需要一个隔离的应用程序类加载器才能正常运行。默认情况下，Gradle和Maven插件会fork应用程序进程。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
与LiveReload一起使用时，自动重启非常有效。有关详细信息，请参见<a href="#using-boot-devtools-livereload">LiveReload部分</a>。
如果使用JRebel，则禁用自动重新启动，而支持动态类重新加载。其他devtools功能（例如LiveReload和属性覆盖）仍可以使用。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DevTools依赖于应用程序上下文的关闭钩子在重新启动期间将其关闭。如果你禁用了关闭钩子
（<code>SpringApplication.setRegisterShutdownHook(false)</code>），它将无法正常工作。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在确定类路径上的条目是否应在更改后触发重新启动时，DevTools会自动忽略名为 <code>spring-boot</code>，
<code>spring-boot-devtools</code>，<code>spring-boot-autoconfigure</code>，<code>spring-boot-actuator</code> 和 <code>spring-boot-starter</code> 的项目。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
DevTools需要自定义 <code>ApplicationContext</code> 使用的 <code>ResourceLoader</code>。如果你的应用程序已经提供了，它将被包装。
不支持在 <code>ApplicationContext</code> 上直接重写 <code>getResource</code> 方法。
</td>
</tr>
</table>
</div>
<div id="using-spring-boot-restart-vs-reload" class="sidebarblock">
<div class="content">
<div class="title">重新启动 vs 重新加载</div>
<div class="paragraph">
<p>Spring Boot提供的重启技术通过使用两个类加载器来工作。不变的类（例如：来自第三方jar的类）将被加载到 <em>基本</em> 类加载器中。
你正在积极开发的类将加载到 <em>重启</em> 类加载器中。重新启动应用程序时，将丢弃 <em>重启</em> 类加载器，并创建一个新的类加载器。
这种方法意味着应用程序的重启通常比“<code>冷启动</code>”要快得多，因为 <em>基本</em> 类加载器已经可用并已填充完毕。</p>
</div>
<div class="paragraph">
<p>如果发现重新启动对于你的应用程序来说不够快，或者遇到类加载问题，则可以考虑使用ZeroTurnaround重新加载技术，例如：
<a href="https://jrebel.com/software/jrebel/">JRebel</a>。这些方法通过在加载类时重写类来使其更易于重新加载。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-logging-condition-delta">记录条件评估中的更改</h5>
<div class="paragraph">
<p>默认情况下，每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量变化。
该报告显示了你进行代码更改（例如：添加或删除Bean以及设置配置属性）时所造成的对应用程序自动配置的更改。</p>
</div>
<div class="paragraph">
<p>要禁用报告的日志记录，请设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.devtools.restart.log-condition-evaluation-delta=false</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-exclude">排除资源</h5>
<div class="paragraph">
<p>某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf模板可以就地编辑。默认情况下，
更改 <code>/META-INF/maven</code>，<code>/META-INF/resources</code>，<code>/resources</code>，<code>/static</code>，<code>/public</code> 或 <code>/templates</code>
中的资源不会触发重新启动，但会触发<a href="#using-boot-devtools-livereload">实时重新加载</a>。如果要自定义这些排除项，则可以使用
<code>spring.devtools.restart.exclude</code> 属性。例如：仅排除 <code>/static</code> 和 <code>/public</code>，可以设置以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.devtools.restart.exclude=static/**,public/**</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要保留这些默认值并 <em>添加</em> 其他排除项，请改用 <code>spring.devtools.restart.additional-exclude</code> 属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-additional-paths">监视其他路径</h5>
<div class="paragraph">
<p>当你对不在类路径上的文件进行更改时，你可能希望重新启动或重新加载应用程序。为此，
请使用 <code>spring.devtools.restart.additional-paths</code> 属性配置其他路径以监视更改。
你可以使用<a href="#using-boot-devtools-restart-exclude">前面所述</a>的 <code>spring.devtools.restart.exclude</code>
属性来控制其他路径下的更改是触发完全重启还是<a href="#using-boot-devtools-livereload">实时重新加载</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-disable">禁用重启</h5>
<div class="paragraph">
<p>如果你不想使用重新启动功能，则可以使用 <code>spring.devtools.restart.enabled</code> 属性将其禁用。在大多数情况下，你可以在
<code>application.properties</code> 中设置此属性（这样做仍会初始化重启类加载器，但它不会监视文件更改）。</p>
</div>
<div class="paragraph">
<p>如果你需要 <em>完全</em> 禁用重启支持（例如：因为它不适用于特定的库），则需要在调用 <code>SpringApplication.run(&#8230;&#8203;)</code> 之前将
<code>spring.devtools.restart.enabled</code> 系统属性设置为 <code>false</code>。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    System.setProperty("spring.devtools.restart.enabled", "false");
    SpringApplication.run(MyApp.class, args);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-restart-triggerfile">使用触发文件</h5>
<div class="paragraph">
<p>如果使用持续编译更改文件的IDE，则可能更喜欢仅在特定时间触发重新启动。为此，你可以使用“<code>触发文件</code>”，
这是一个特殊文件，当你要实际触发重新启动检查时必须对其进行修改。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对文件的任何更新都将触发检查，但是只有在Devtools检测到有事情要做的情况下，重启才真正发生。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用触发文件，请将 <code>spring.devtools.restart.trigger-file</code> 属性设置为触发文件的名称（不包括任何路径）。
触发文件必须出现在类路径上的某个位置。</p>
</div>
<div class="paragraph">
<p>例如，如果你的项目具有以下结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>src
+- main
   +- resources
      +- .reloadtrigger</pre>
</div>
</div>
<div class="paragraph">
<p>然后，你的 <code>trigger-file</code> 属性将是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.trigger-file=.reloadtrigger</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在仅在更新 <code>src/main/resources/.reloadtrigger</code> 时才可能发生重启。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可能需要将 <code>spring.devtools.restart.trigger-file</code> 设置为<a href="#using-boot-devtools-globalsettings">全局设置</a>，以便所有项目的行为均相同。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>某些IDE具有使你不必手动更新触发器文件的功能。 <a href="https://spring.io/tools">Spring Tools for Eclipse</a>和
<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA (最终版)</a>都具有这种支持。
使用Spring Tools，你可以从控制台视图使用“<code>reload</code>”按钮（只要你的 <code>trigger-file</code> 为 <code>.reloadtrigger</code>）。
对于IntelliJ，你可以按照
<a href="https://www.jetbrains.com/help/idea/spring-boot.html#configure-application-update-policies-with-devtools">其文档中的说明</a>进行操作。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-customizing-classload">自定义重启类加载器</h5>
<div class="paragraph">
<p>如前面的<a href="#using-spring-boot-restart-vs-reload">重新启动 vs 重新加载</a>部分所述，重新启动功能是通过使用两个类加载器实现的。
对于大多数应用程序，此方法效果很好。但是，有时可能会导致类加载问题。</p>
</div>
<div class="paragraph">
<p>默认情况下，IDE中的任何打开的项目都使用“<code>重启</code>”类加载器加载，而任何常规的 <code>.jar</code> 文件都使用“<code>基本</code>”类加载器加载。
如果你在多模块项目上工作，并且并非每个模块都导入到IDE中，则可能需要自定义内容。为此，你可以创建一个
<code>META-INF/spring-devtools.properties</code> 文件。</p>
</div>
<div class="paragraph">
<p><code>spring-devtools.properties</code> 文件可以包含带有 <code>restart.exclude</code> 和 <code>restart.include</code> 前缀的属性。
<code>include</code> 元素是应上拉到“<code>重启</code>”类加载器中的项目，而 <code>exclude</code> 元素是应下推到“<code>基本</code>”类加载器中的项目。
该属性的值是应用于类路径的正则表达式模式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">restart.exclude.companycommonlibs=/mycorp-common-[\\w\\d-\.]+\.jar
restart.include.projectcommon=/mycorp-myproj-[\\w\\d-\.]+\.jar</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
所有属性键都必须是唯一的。只要属性以 <code>restart.include</code> 或 <code>restart.exclude</code> 开头，它就会被考虑。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将加载类路径中的所有 <code>META-INF/spring-devtools.properties</code>。你可以将文件打包到项目内部，也可以打包到项目使用的库中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-known-restart-limitations">已知局限性</h5>
<div class="paragraph">
<p>重新启动功能不适用于使用标准 <code>ObjectInputStream</code> 反序列化的对象。如果你需要反序列化数据，
则可能需要将Spring的 <code>ConfigurableObjectInputStream</code> 与 <code>Thread.currentThread().getContextClassLoader()</code> 结合使用。</p>
</div>
<div class="paragraph">
<p>不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，则需要向库的原始作者请求修复。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-livereload">1.8.3. LiveReload</h4>
<div class="paragraph">
<p><code>spring-boot-devtools</code> 模块包括一个嵌入式LiveReload服务器，该服务器可用于在更改资源时触发浏览器刷新。
可从 <a href="http://livereload.com/extensions/">livereload.com</a>免费获得适用于Chrome，Firefox和Safari的LiveReload浏览器扩展。</p>
</div>
<div class="paragraph">
<p>如果你不想在应用程序运行时启动LiveReload服务器，则可以将 <code>spring.devtools.livereload.enabled</code> 属性设置为 <code>false</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
一次只能运行一台LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。
如果从IDE启动多个应用程序，则只有第一个具有LiveReload支持。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-globalsettings">1.8.4. 全局设置</h4>
<div class="paragraph">
<p>你可以通过将以下任何文件添加到 <code>$HOME/.config/spring-boot</code> 文件夹来配置全局devtools设置：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>spring-boot-devtools.properties</code></p>
</li>
<li>
<p><code>spring-boot-devtools.yaml</code></p>
</li>
<li>
<p><code>spring-boot-devtools.yml</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>添加到这些文件的任何属性都将应用于使用devtools的 <em>所有</em> Spring Boot应用程序。例如：要将重新启动配置为始终使用
<a href="#using-boot-devtools-restart-triggerfile">触发文件</a>，应添加以下属性：</p>
</div>
<div class="listingblock">
<div class="title">~/.config/spring-boot/spring-boot-devtools.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.trigger-file=.reloadtrigger</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果在 <code>$HOME/.config/spring-boot</code> 中找不到devtools配置文件，则在 <code>$HOME</code> 文件夹的根目录中搜索是否存在
<code>.spring-boot-devtools.properties</code> 文件。这使你可以与不支持 <code>$HOME/.config/spring-boot</code>
位置的较旧版本的Spring Boot上的应用程序共享devtools全局配置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上述文件中激活的Profiles不会影响
<a href="spring-boot-features.html#boot-features-external-config-profile-specific-properties">特定于环境的配置文件</a>的加载。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="using-boot-devtools-remote">1.8.5. 远程应用</h4>
<div class="paragraph">
<p>Spring Boot开发者工具不仅限于本地开发。远程运行应用程序时，你还可以使用多种功能。
选择启用远程支持，因为启用它可能会带来安全风险。仅当在受信任的网络上运行或使用SSL保护时，才应启用它。
如果这两个选项都不可用，则不应使用DevTools的远程支持。你永远不要在生产部署上启用支持。</p>
</div>
<div class="paragraph">
<p>要启用它，你需要确保在重新打包的档案中包含 <code>devtools</code>，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你需要设置 <code>spring.devtools.remote.secret</code> 属性。像任何重要的密码或机密一样，该值应唯一且强壮，以免被猜测或强行使用。</p>
</div>
<div class="paragraph">
<p>远程devtools支持分为两部分：接受连接的服务器端端点和在IDE中运行的客户端应用程序。设置
 <code>spring.devtools.remote.secret</code> 属性后，将自动启用服务器组件，客户端组件必须手动启动。</p>
</div>
<div class="sect4">
<h5 id="运行远程客户端应用程序">运行远程客户端应用程序</h5>
<div class="paragraph">
<p>远程客户端应用程序旨在在你的IDE中运行。你需要使用与你连接到的远程项目相同的类路径来运行
<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。该应用程序的唯一必需参数是它连接到的远程URL。</p>
</div>
<div class="paragraph">
<p>例如，如果你使用的是Eclipse或STS，并且有一个名为 <code>my-app</code> 的项目已部署到Cloud Foundry，则可以执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 <code>Run</code> 菜单中选择 <code>Run Configurations&#8230;&#8203;</code>。</p>
</li>
<li>
<p>创建一个新的 <code>Java Application</code> “启动配置”。</p>
</li>
<li>
<p>浏览 <code>my-app</code> 项目。</p>
</li>
<li>
<p>使用 <code>org.springframework.boot.devtools.RemoteSpringApplication</code> 作为主类。</p>
</li>
<li>
<p>将 <code>https://myapp.cfapps.io</code> 添加到 <code>Program arguments</code>（或任何远程URL）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正在运行的远程客户端可能类似于以下清单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.2.2.RELEASE

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
因为远程客户端使用与真实应用程序相同的类路径，所以它可以直接读取应用程序属性。这就是读取 <code>spring.devtools.remote.secret</code> 属性并将其传递给服务器进行身份验证的方式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
始终建议使用 <code>https://</code> 作为连接协议，以便对通信进行加密并且不能截获密码。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要使用代理来访问远程应用程序，请配置 <code>spring.devtools.remote.proxy.host</code> 和 <code>spring.devtools.remote.proxy.port</code> 属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="using-boot-devtools-remote-update">远程更新</h5>
<div class="paragraph">
<p>远程客户端以与<a href="#using-boot-devtools-restart">本地重新启动</a>相同的方式监视应用程序类路径中的更改。
任何更新的资源都会推送到远程应用程序，并且（<em>如果需要</em>）会触发重新启动。
如果你迭代使用本地没有的云服务的功能，这将很有帮助。通常，远程更新和重新启动比完整的重新构建和部署周期快得多。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅在远程客户端正在运行时监视文件。如果在启动远程客户端之前更改文件，则不会将其推送到远程服务器。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="configuring-file-system-watcher">配置文件系统观察器</h5>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.java">FileSystemWatcher</a>
的工作方式是按一定的时间间隔轮询类更改，然后等待预定义的静默期以确保没有更多更改。
然后将更改上传到远程应用程序。在较慢的开发环境中，可能会发生静默期不够的情况，并且类中的更改可能会分为几批。
第一批类更改上传后，服务器将重新启动。由于服务器正在重新启动，因此下一批不能发送到应用程序。</p>
</div>
<div class="paragraph">
<p>这通常通过 <code>RemoteSpringApplication</code> 日志中的警告来证明，即有关上载某些类失败的消息，然后进行重试。
但是，这也可能导致应用程序代码不一致，并且在上传第一批更改后无法重新启动。</p>
</div>
<div class="paragraph">
<p>如果你经常观察到此类问题，请尝试将 <code>spring.devtools.restart.poll-interval</code> 和
<code>spring.devtools.restart.quiet-period</code> 参数增加到适合你的开发环境的值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.devtools.restart.poll-interval=2s
spring.devtools.restart.quiet-period=1s</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在每2秒轮询一次受监视的classpath文件夹以进行更改，并保持1秒钟的静默时间以确保没有其他类更改。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-packaging-for-production">1.9. 打包你的应用程序用于生产</h3>
<div class="paragraph">
<p>可执行jar可以用于生产部署。由于它们是独立的，因此它们也非常适合云部署。</p>
</div>
<div class="paragraph">
<p>对于其他“生产就绪”功能，例如运行状况，审核和度量REST或JMX端点，请考虑添加 <code>spring-boot-actuator</code>。
有关详细信息，请参见 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em>。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-boot-whats-next">1.10. 接下来要读什么</h3>
<div class="paragraph">
<p>现在，你应该了解了如何使用Spring Boot以及应遵循的一些最佳实践。现在，你可以继续深入了解特定的
<em><a href="spring-boot-features.html#boot-features">Spring Boot功能</a></em>，或者可以跳过并阅读有关
Spring Boot的 <em><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready">生产就绪</a></em> 方面的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot-features">2. Spring Boot特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节将深入介绍Spring Boot。在这里，你可以了解可能要使用和自定义的关键功能。开始之前，建议你先阅读<a href="#using-boot">Spring Boot</a>部分，
以便你有足够的基础知识。</p>
</div>
<div class="sect2">
<h3 id="boot-features-spring-application">2.1. SpringApplication</h3>
<div class="paragraph">
<p><code>SpringApplication</code> 类提供了一种便捷的方式来引导从 <code>main()</code> 方法启动的Spring应用程序。在大多数情况下，
你可以委托给静态 <code>SpringApplication.run</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication.run(MySpringConfiguration.class, args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当你的应用程序启动时，你应该看到类似于以下输出的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::   v2.2.2.RELEASE

2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)
2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy
2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080
2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，显示 <code>INFO</code> 日志消息，包括一些相关的启动详细信息，例如：启动应用程序的用户。如果你需要除 <code>INFO</code> 级别以外的其他日志，
则可以按照<a href="#boot-features-custom-log-levels">日志级别</a>中的说明进行设置。使用主应用程序类包中的实现版本来确定应用程序版本。
可以通过将 <code>spring.main.log-startup-info</code> 设置为 <code>false</code> 来关闭启动信息记录。这还将关闭对应用程序激活的环境配置文件的日志记录。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在启动期间添加其他日志记录，可以在 <code>SpringApplication</code> 的子类中重写 <code>logStartupInfo(boolean)</code>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-startup-failure">2.1.1. 启动失败</h4>
<div class="paragraph">
<p>如果你的应用程序无法启动，则已注册的 <code>FailureAnalyzers</code> 将有机会提供专门的错误消息和解决该问题的具体措施。
例如：如果你在端口8080上启动Web应用程序并且该端口已在使用中，则应该看到类似于以下消息的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>***************************
APPLICATION FAILED TO START
***************************

Description:

Embedded servlet container failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot提供了大量的 <code>FailureAnalyzer</code> 实现，你可以添加<a href="howto.html#howto-failure-analyzer">自己的实现</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果没有故障分析器能够处理该异常，你仍然可以显示完整条件报告以更好地了解出了什么问题。
为此，你需要为 <code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code>
<a href="#boot-features-external-config">启用 <code>debug</code> 属性</a>或
<a href="#boot-features-custom-log-levels">启用 <code>DEBUG</code> 日志记录</a>。</p>
</div>
<div class="paragraph">
<p>例如，如果使用 <code>java -jar</code> 运行应用程序，则可以按以下方式启用 <code>debug</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-lazy-initialization">2.1.2. 延迟初始化</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 允许延迟初始化应用程序。启用延迟初始化后，将根据需要创建bean，而不是在应用程序启动期间创建bean。
因此，启用延迟初始化可以减少应用程序启动所需的时间。在Web应用程序中，启用延迟初始化将导致许多与Web相关的Bean直到收到HTTP请求后才被初始化。</p>
</div>
<div class="paragraph">
<p>延迟初始化的缺点是，它可能会延迟发现应用程序问题的时间。如果错误配置的Bean被延迟初始化，则启动期间将不再发生故障，
并且只有在初始化Bean时问题才会发现。还必须注意确保JVM有足够的内存来容纳所有应用程序的bean，
而不仅仅是启动期间初始化的bean。由于这些原因，默认情况下不会启用延迟初始化，
因此建议在启用延迟初始化之前先对JVM的堆大小进行微调。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>SpringApplicationBuilder</code> 上的 <code>lazyInitialization</code> 方法或 <code>SpringApplication</code> 上的
<code>setLazyInitialization</code> 方法以编程方式启用延迟初始化。另外，可以使用 <code>spring.main.lazy-initialization</code>
属性启用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.main.lazy-initialization=true</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要在对应用程序其余部分使用延迟初始化时禁用某些bean的延迟初始化，则可以使用 <code>@Lazy(false)</code>
注解将它们的延迟属性显式设置为 <code>false</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-banner">2.1.3. 自定义横幅</h4>
<div class="paragraph">
<p>可以通过将 <code>banner.txt</code> 文件添加到类路径或将 <code>spring.banner.location</code> 属性设置为此类文件的位置来更改启动时打印的横幅。
如果文件的编码不是UTF-8，则可以设置 <code>spring.banner.charset</code>。除了文本文件之外，你还可以将
<code>banner.gif</code>，<code>banner.jpg</code> 或 <code>banner.png</code> 图像文件添加到类路径中，或设置 <code>spring.banner.image.location</code> 属性。
图像将转换为ASCII艺术品并打印在任何文字横幅上方。</p>
</div>
<div class="paragraph">
<p>在 <code>banner.txt</code> 文件中，你可以使用以下任意占位符：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. 横幅变量</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Variable</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你的应用程序的版本号，在 <code>MANIFEST.MF</code> 中声明。例如：<code>Implementation-Version: 1.0</code> 被打印为 <code>1.0</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序版本号的格式化显示（用小括号括起来并以v开头）。例如：<code>(v1.0)</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本。例如 <code>2.2.2.RELEASE</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${spring-boot.formatted-version}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你正在使用的Spring Boot版本的格式化显示（用小括号括起来并以v开头）。例如：<code>(v2.2.2.RELEASE)</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${Ansi.NAME}</code> (or <code>${AnsiColor.NAME}</code>, <code>${AnsiBackground.NAME}</code>, <code>${AnsiStyle.NAME}</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其中 <code>NAME</code> 是ANSI转义代码的名称。有关详细信息，请参见
  <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java"><code>AnsiPropertySource</code></a>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>${application.title}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">你在 <code>MANIFEST.MF</code> 中声明的应用程序标题。例如：<code>Implementation-Title: MyApp</code> 被打印为 <code>MyApp</code>。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要以编程方式生成横幅，则可以使用 <code>SpringApplication.setBanner(&#8230;&#8203;)</code> 方法。
使用 <code>org.springframework.boot.Banner</code> 接口并实现自己的 <code>printBanner()</code> 方法。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.main.banner-mode</code> 属性来确定横幅是否必须在 <code>System.out</code>（<code>控制台</code>）上打印，
是否必须发送到配置的日志记录器（<code>log</code>）或根本不打印（<code>关闭</code>）。</p>
</div>
<div class="paragraph">
<p>打印的横幅用 <code>springBootBanner</code> 名称注册为单例bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-customizing-spring-application">2.1.4. 自定义SpringApplication</h4>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 的默认设置不符合你的喜好，你可以创建一个本地实例并对其进行自定义。例如：要关闭横幅，你可以编写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    SpringApplication app = new SpringApplication(MySpringConfiguration.class);
    app.setBannerMode(Banner.Mode.OFF);
    app.run(args);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
传递给 <code>SpringApplication</code> 的构造函数参数是Spring bean的配置源。在大多数情况下，
它们是对 <code>@Configuration</code> 类的引用，但也可以是对XML配置或应扫描的程序包的引用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也可以通过使用 <code>application.properties</code> 文件配置 <code>SpringApplication</code>。有关详细信息，请参见 <em><a href="#boot-features-external-config">外部化配置</a></em>。</p>
</div>
<div class="paragraph">
<p>有关配置选项的完整列表，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/SpringApplication.html"><code>SpringApplication</code> Javadoc</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-fluent-builder-api">2.1.5. 流式构建器API</h4>
<div class="paragraph">
<p>如果你需要构建 <code>ApplicationContext</code> 层次结构（具有父/子关系的多个上下文），或者如果你更喜欢使用“流式”构建器API，
则可以使用 <code>SpringApplicationBuilder</code>。</p>
</div>
<div class="paragraph">
<p><code>SpringApplicationBuilder</code> 使你可以将多个方法调用链接在一起，并包括允许你创建层次结构的 <code>parent</code> 和 <code>child</code> 方法，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">new SpringApplicationBuilder()
        .sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
创建 <code>ApplicationContext</code> 层次结构时有一些限制。例如，Web组件必须包含在子上下文中，
并且父上下文和子上下文都使用相同的 <code>Environment</code>。有关完整的详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/builder/SpringApplicationBuilder.html"><code>SpringApplicationBuilder</code> Javadoc</a> 。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-events-and-listeners">2.1.6. 应用程序事件和监听器</h4>
<div class="paragraph">
<p>除了通常的Spring Framework事件（例如：
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html"><code>ContextRefreshedEvent</code></a>）之外，
<code>SpringApplication</code> 还发送一些其他应用程序事件。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实际上在创建 <code>ApplicationContext</code> 之前会触发一些事件，因此你不能将监听器注册为 <code>@Bean</code>。
你可以使用 <code>SpringApplication.addListeners(&#8230;&#8203;)</code> 方法或 <code>SpringApplicationBuilder.listeners(&#8230;&#8203;)</code> 方法注册它们。</p>
</div>
<div class="paragraph">
<p>如果希望这些侦听器自动注册，而不管以何种方式创建应用程序，都可以将
<code>META-INF/spring.factories</code> 文件添加到你的项目中，并使用 <code>org.springframework.context.ApplicationListener</code>
键引用你的侦听器。如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.context.ApplicationListener=com.example.project.MyListener</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件在你的应用程序运行时按以下顺序发送：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在运行开始时但在任何处理之前（侦听器和初始化器的注册除外）发送 <code>ApplicationStartingEvent</code>。</p>
</li>
<li>
<p>已知晓要在上下文中使用的环境但在创建上下文之前，将发送 <code>ApplicationEnvironmentPreparedEvent</code>。</p>
</li>
<li>
<p>准备 <code>ApplicationContext</code> 并调用ApplicationContextInitializers之后但在加载任何bean
定义之前发送 <code>ApplicationContextInitializedEvent</code>。</p>
</li>
<li>
<p>在刷新开始之前但在加载bean定义之后发送 <code>ApplicationPreparedEvent</code>。</p>
</li>
<li>
<p>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前，将发送 <code>ApplicationStartedEvent</code>。</p>
</li>
<li>
<p>在调用任何应用程序和命令行运行程序之后，将发送 <code>ApplicationReadyEvent</code>。它指示该应用程序已准备就绪，可以处理请求。</p>
</li>
<li>
<p>如果启动时发生异常，则发送 <code>ApplicationFailedEvent</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面的列表仅包含绑定到 <code>SpringApplication</code> 的 <code>SpringApplicationEvents</code>。除这些以外，以下事件也在
<code>ApplicationPreparedEvent</code> 之后和 <code>ApplicationStartedEvent</code> 之前发布：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>刷新 <code>ApplicationContext</code> 后发送 <code>ContextRefreshedEvent</code>。</p>
</li>
<li>
<p>WebServer准备就绪后，将发送 <code>WebServerInitializedEvent</code>。<code>ServletWebServerInitializedEvent</code>
和 <code>ReactiveWebServerInitializedEvent</code> 分别是servlet和reactive的变体。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你通常不需要使用应用程序事件，但是知道它们的存在可能很方便。在Spring Boot内部使用事件来处理各种任务。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用程序事件是通过使用Spring Framework的事件发布机制发送的。
此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。
结果，如果你的应用程序使用 <code>SpringApplication</code> 实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。</p>
</div>
<div class="paragraph">
<p>为了使你的侦听器能够区分其上下文的事件和后代上下文的事件，则应请求注入其应用程序上下文，
然后将注入的上下文与事件的上下文进行比较。可以通过实现 <code>ApplicationContextAware</code> 来注入上下文，
或者如果侦听器是bean，则可以使用 <code>@Autowired</code> 注入上下文。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-web-environment">2.1.7. Web环境</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 尝试代表你创建正确的 <code>ApplicationContext</code> 类型。用于确定是 <code>WebApplicationType</code> 的算法非常简单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果存在Spring MVC，则使用 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
</li>
<li>
<p>如果不存在Spring MVC但存在Spring WebFlux，则使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></p>
</li>
<li>
<p>否则，将使用 <code>AnnotationConfigApplicationContext</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这意味着，如果你在同一应用程序中使用Spring MVC和Spring WebFlux中的新 <code>WebClient</code>，则默认情况下将使用Spring
MVC。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻松覆盖它。</p>
</div>
<div class="paragraph">
<p>也可以通过调用 <code>setApplicationContextClass(&#8230;&#8203;)</code> 完全控制要使用的 <code>ApplicationContext</code> 类型。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在JUnit测试中使用 <code>SpringApplication</code> 时，通常希望调用 <code>setWebApplicationType(WebApplicationType.NONE)</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-arguments">2.1.8. 访问应用程序参数</h4>
<div class="paragraph">
<p>如果你需要访问传递给 <code>SpringApplication.run(&#8230;&#8203;)</code> 的应用程序参数，
则可以注入 <code>org.springframework.boot.ApplicationArguments</code> bean。<code>ApplicationArguments</code> 接口提供对原始
<code>String[]</code> 参数以及已解析的 <code>option</code> 和 <code>non-option</code> 参数的访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.*;

@Component
public class MyBean {

    @Autowired
    public MyBean(ApplicationArguments args) {
        boolean debug = args.containsOption("debug");
        List&lt;String&gt; files = args.getNonOptionArgs();
        // if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot还向Spring <code>Environment</code> 注册了 <code>CommandLinePropertySource</code>。
这样，你还可以使用 <code>@Value</code> 注解注入单个应用程序参数。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-command-line-runner">2.1.9. 使用ApplicationRunner或CommandLineRunner</h4>
<div class="paragraph">
<p>如果 <code>SpringApplication</code> 启动后需要运行一些特定的代码，则可以实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口。
这两个接口以相同的方式工作并提供一个 <code>run</code> 方法，该方法在 <code>SpringApplication.run(&#8230;&#8203;)</code> 完成之前被调用。</p>
</div>
<div class="paragraph">
<p><code>CommandLineRunner</code> 接口以简单的字符串数组提供对应用程序参数的访问，而 <code>ApplicationRunner</code> 使用前面讨论的
<code>ApplicationArguments</code> 接口。以下示例显示了带有 <code>run</code> 方法的 <code>CommandLineRunner</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.*;
import org.springframework.stereotype.*;

@Component
public class MyBean implements CommandLineRunner {

    public void run(String... args) {
        // Do something...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了必须按特定顺序调用的几个 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> Beans，则可以另外实现
<code>org.springframework.core.Ordered</code> 接口或使用 <code>org.springframework.core.annotation.Order</code> 注解。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-exit">2.1.10. 应用程序退出</h4>
<div class="paragraph">
<p>每个 <code>SpringApplication</code> 向JVM注册一个关闭钩子，以确保 <code>ApplicationContext</code> 在退出时正常关闭。
可以使用所有标准的Spring生命周期回调（例如：<code>DisposableBean</code> 接口或 <code>@PreDestroy</code> 注解）。</p>
</div>
<div class="paragraph">
<p>另外，如果bean希望在调用 <code>SpringApplication.exit()</code> 时返回特定的退出码，
则可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口。然后可以将此退出码传递给 <code>System.exit()</code>，
以将其作为状态码返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ExitCodeApplication {

    @Bean
    public ExitCodeGenerator exitCodeGenerator() {
        return () -&gt; 42;
    }

    public static void main(String[] args) {
        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，<code>ExitCodeGenerator</code> 接口可以通过异常实现。遇到此类异常时，Spring Boot返回实现的 <code>getExitCode()</code> 方法提供的退出码。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-application-admin">2.1.11. 管理员功能</h4>
<div class="paragraph">
<p>通过指定 <code>spring.application.admin.enabled</code> 属性，可以为应用程序启用与管理员相关的功能。
这将在平台MBeanServer上公开 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java"><code>SpringApplicationAdminMXBean</code></a>。
你可以使用此功能来远程管理Spring Boot应用程序。此功能对于任何服务包装器实现也可能很有用。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你想知道应用程序在哪个HTTP端口上运行，请使用 <code>local.server.port</code> 键获取属性。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-external-config">2.2. 外部化配置</h3>
<div class="paragraph">
<p>Spring Boot使你可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。你可以使用properties文件，YAML文件，
环境变量和命令行参数来外部化配置。可以使用 <code>@Value</code> 注解将属性值直接注入到你的bean中，
可以通过Spring的 <code>Environment</code> 抽象访问，也可以通过 <code>@ConfigurationProperties</code>
<a href="#boot-features-external-config-typesafe-configuration-properties">绑定到结构化对象</a>。</p>
</div>
<div class="paragraph">
<p>Spring Boot使用一个非常特殊的 <code>PropertySource</code> 顺序，该顺序旨在允许合理地覆盖值。按以下顺序考虑属性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当devtools处于活动状态时，<code>$HOME/.config/spring-boot</code> 文件夹中的
<a href="using-spring-boot.html#using-boot-devtools-globalsettings">Devtools全局设置属性</a>。</p>
</li>
<li>
<p>测试上的 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a>注解。</p>
</li>
<li>
<p>测试中的properties属性。在 <code>@SpringBootTest</code> 和测试注解上可用，
用于<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试应用程序的特定部分</a>。</p>
</li>
<li>
<p>命令行参数。</p>
</li>
<li>
<p>来自 <code>SPRING_APPLICATION_JSON</code> 的属性（嵌入在环境变量或系统属性中的嵌入式JSON）。</p>
</li>
<li>
<p><code>ServletConfig</code> 的初始化参数。</p>
</li>
<li>
<p><code>ServletContext</code> 的初始化参数。</p>
</li>
<li>
<p>来自 <code>java:comp/env</code> 的JNDI属性。</p>
</li>
<li>
<p>Java系统属性（<code>System.getProperties()</code>）。</p>
</li>
<li>
<p>操作系统环境变量。</p>
</li>
<li>
<p>一个 <code>RandomValuePropertySource</code> 仅具有 <code>random.*</code> 属性。</p>
</li>
<li>
<p>打包jar之外的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的<a href="#boot-features-external-config-profile-specific-properties">特定于profile的应用程序属性</a>
（<code>application-{profile}.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar之外的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p>打包jar中的应用程序属性（<code>application.properties</code> 和YAML变体）。</p>
</li>
<li>
<p><code>@Configuration</code> 类上的 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>注解。
请注意，在刷新应用程序上下文之前，不会将此类属性源添加到 <code>Environment</code> 中。现在配置某些属性
（如 <code>logging.*</code> 和 <code>spring.main.*</code>）为时已晚，这些属性在刷新开始之前就已读取。</p>
</li>
<li>
<p>默认属性（通过设置 <code>SpringApplication.setDefaultProperties</code> 指定）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了提供一个具体的示例，假设你开发了一个使用 <code>name</code> 属性的 <code>@Component</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean {

    @Value("${name}")
    private String name;

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在你的应用程序类路径上（例如：在jar中），你可以拥有一个 <code>application.properties</code> 文件，该文件为 <code>name</code>
提供合理的默认属性值。在新环境中运行时，可以在jar外部提供一个覆盖 <code>name</code> 的 <code>application.properties</code> 文件。
对于一次性测试，可以使用特定的命令行开关启动（例如：<code>java -jar app.jar --name="Spring"</code>）。</p>
</div>
<div id="boot-features-external-config-application-json" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以在命令行中使用环境变量来提供 <code>SPRING_APPLICATION_JSON</code> 属性。例如，你可以在UN*X shell中使用以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ SPRING_APPLICATION_JSON='{"acme":{"name":"test"}}' java -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，你最终在Spring <code>Environment</code> 中获得了 <code>acme.name=test</code>。你还可以在System属性中将JSON作为
<code>spring.application.json</code> 提供，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -Dspring.application.json='{"name":"test"}' -jar myapp.jar</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用命令行参数来提供JSON，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --spring.application.json='{"name":"test"}'</pre>
</div>
</div>
<div class="paragraph">
<p>你还可以将JSON作为JNDI变量提供，如下所示： <code>java:comp/env/spring.application.json</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-random-values">2.2.1. 配置随机值</h4>
<div class="paragraph">
<p><code>RandomValuePropertySource</code> 可用于注入随机值（例如：注入密钥或测试用例）。它可以产生整数，longs，uuid或字符串，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.secret=${random.value}
my.number=${random.int}
my.bignumber=${random.long}
my.uuid=${random.uuid}
my.number.less.than.ten=${random.int(10)}
my.number.in.range=${random.int[1024,65536]}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>random.int*</code> 语法是 <code>OPEN value (,max) CLOSE</code>，其中 <code>OPEN,CLOSE</code> 是任何字符，
而 <code>value,max</code> 是整数。如果提供了 <code>max</code>，则 <code>value</code> 是最小值，而 <code>max</code> 是最大值（不包括它）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-command-line-args">2.2.2. 访问命令行Properties</h4>
<div class="paragraph">
<p>默认情况下，<code>SpringApplication</code> 将所有命令行选项参数（即以 <code>--</code> 开头的参数，例如 <code>--server.port=9000</code>）转换为属性，
并将其添加到Spring <code>Environment</code> 中。如前所述，命令行属性始终优先于其他属性源。</p>
</div>
<div class="paragraph">
<p>如果你不希望将命令行属性添加到环境中，可以使用 <code>SpringApplication.setAddCommandLineProperties(false)</code> 禁用它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-application-property-files">2.2.3. 应用程序属性文件</h4>
<div class="paragraph">
<p><code>SpringApplication</code> 在以下位置从 <code>application.properties</code> 文件加载属性，并将它们添加到Spring <code>Environment</code>：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当前目录的 <code>/config</code> 子目录</p>
</li>
<li>
<p>当前目录</p>
</li>
<li>
<p>类路径下的 <code>/config</code> 目录</p>
</li>
<li>
<p>类路径根目录</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>该列表按优先级排序（列表前面定义的属性会覆盖后面的）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以<a href="#boot-features-external-config-yaml">使用YAML ('.yml')文件</a>来替代 '.properties'。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不喜欢 <code>application.properties</code> 作为配置文件名，则可以通过指定 <code>spring.config.name</code> 环境属性来切换到另一个文件名。
你还可以通过使用 <code>spring.config.location</code> 环境属性（这是目录位置或以逗号分隔的文件路径列表）来显式引用位置。
下面的示例演示如何指定其他文件名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.name=myproject</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how to specify two locations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>spring.config.name</code> 和 <code>spring.config.location</code> 很早就被用于确定必须加载的文件。
必须将它们定义为环境属性（通常是操作系统环境变量，系统属性或命令行参数）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>配置位置以相反的顺序搜索。默认情况下，配置的位置是 <code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>spring.config.location</code> 配置自定义配置位置后，它们将替换默认位置。例如：如果 <code>spring.config.location</code> 配置为值
<code>classpath:custom-config/,file:./custom-config/</code>，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>另外，当使用 <code>spring.config.additional-location</code> 配置自定义配置位置时，除默认位置外，还会考虑使用它们。
在默认位置之前搜索其他附加位置。例如：如果配置了 <code>classpath:/custom-config/,file:./custom-config/</code> 的附加位置，则搜索顺序如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>file:./custom-config/</code></p>
</li>
<li>
<p><code>classpath:custom-config/</code></p>
</li>
<li>
<p><code>file:./config/</code></p>
</li>
<li>
<p><code>file:./</code></p>
</li>
<li>
<p><code>classpath:/config/</code></p>
</li>
<li>
<p><code>classpath:/</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>通过此搜索顺序，你可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。
你可以在默认位置之一的 <code>application.properties</code>（或使用 <code>spring.config.name</code> 选择的其他任何基本名称）中为应用程序提供默认值。
然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用环境变量而不是系统属性，则大多数操作系统都不允许使用句点分隔的键名，但是可以使用下划线
（例如：使用 <code>SPRING_CONFIG_NAME</code> 代替 <code>spring.config.name</code>）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你的应用程序在容器中运行，则可以使用JNDI属性（在 <code>java:comp/env</code> 中）或servlet上下文初始化参数代替环境变量或系统属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-profile-specific-properties">2.2.4. 特定于Profile的Properties</h4>
<div class="paragraph">
<p>除了 <code>application.properties</code> 文件之外，还可以使用以下命名约定来定义特定于profile的属性：
<code>application-{profile}.properties</code>。如果没有设置激活的profile，则 <code>Environment</code> 具有一组默认的profiles（默认为
<code>[default]</code>）。换句话说，如果未显式激活任何profiles，那么将从 <code>application-default.properties</code> 中加载属性。</p>
</div>
<div class="paragraph">
<p>特定于profile的属性是从与标准 <code>application.properties</code> 相同的位置加载的，特定于profile的文件始终会覆盖非特定文件，
而无论特定于profile的文件是位于打包jar的内部还是外部。</p>
</div>
<div class="paragraph">
<p>如果指定了多个profiles，则采用最后一个获胜策略。例如：将 <code>spring.profiles.active</code>
属性指定的profiles添加到通过SpringApplication API配置的profiles之后，因此具有优先权。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>spring.config.location</code> 中指定了任何文件，则不会考虑这些文件特定于profile的变体。
如果你还想使用特定于profile的属性，请使用 <code>spring.config.location</code> 中的目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-placeholders-in-properties">2.2.5. Properties中的占位符</h4>
<div class="paragraph">
<p><code>application.properties</code> 中的值在使用时会通过现有的 <code>Environment</code> 进行过滤，因此你可以参考在它之前定义的值（例如：从System属性中）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">app.name=MyApp
app.description=${app.name} is a Spring Boot application</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以使用这种技术来创建现有Spring Boot属性的“简短”变体。有关详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-use-short-command-line-arguments">使用“简短”命令行参数方法</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-encrypting-properties">2.2.6. 加密Properties</h4>
<div class="paragraph">
<p>Spring Boot不提供对加密属性值的任何内置支持，但是，它确实提供了修改Spring <code>Environment</code> 中包含的值所必需的钩子。
<code>EnvironmentPostProcessor</code> 界面允许你在应用程序启动之前操纵 <code>Environment</code>。
有关详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-customize-the-environment-or-application-context">在启动前自定义环境或ApplicationContext</a>。</p>
</div>
<div class="paragraph">
<p>如果你正在寻找一种安全的方式来存储凭据和密码， <a href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a>
项目提供了对在 <a href="https://www.vaultproject.io/">HashiCorp Vault</a>中存储外部配置的支持。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-yaml">2.2.7. 使用YAML代替Properties</h4>
<div class="paragraph">
<p><a href="https://yaml.org">YAML</a>是一个JSON超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在类路径上具有
<a href="https://bitbucket.org/asomov/snakeyaml">SnakeYAML</a>库，
<code>SpringApplication</code> 类就会自动支持YAML作为Properties的替代方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用“启动器”，则 <code>spring-boot-starter</code> 会自动提供SnakeYAML。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-loading-yaml">加载YAML</h5>
<div class="paragraph">
<p>Spring Framework提供了两个方便的类，可用于加载YAML文档。<code>YamlPropertiesFactoryBean</code> 将YAML作为 <code>Properties</code> 加载，
而 <code>YamlMapFactoryBean</code> 将YAML作为 <code>Map</code> 加载。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下YAML文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">environments:
    dev:
        url: https://dev.example.com
        name: Developer Setup
    prod:
        url: https://another.example.com
        name: My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App</code></pre>
</div>
</div>
<div class="paragraph">
<p>YAML列表用 <code>[index]</code> 解引用器表示为属性键。例如：考虑以下YAML：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">my:
   servers:
       - dev.example.com
       - another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将转换为以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">my.servers[0]=dev.example.com
my.servers[1]=another.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过使用Spring Boot的 <code>Binder</code> 实用程序（<code>@ConfigurationProperties</code> 所做的）绑定到类似的属性，
你需要在目标bean中拥有一个类型为 <code>java.util.List</code>（或 <code>Set</code>）属性，或者你需要提供一个setter或使用可变值对其进行初始化。
例如，以下示例绑定到前面显示的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="my")
public class Config {

    private List&lt;String&gt; servers = new ArrayList&lt;String&gt;();

    public List&lt;String&gt; getServers() {
        return this.servers;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-exposing-yaml-to-spring">在Spring环境中将YAML公开为Properties</h5>
<div class="paragraph">
<p><code>YamlPropertySourceLoader</code> 类可用于在Spring <code>Environment</code> 中将YAML公开为 <code>PropertySource</code>。
这样做可以让你使用 <code>@Value</code> 注解和占位符语法来访问YAML属性。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-multi-profile-yaml">Multi-profile的YAML文档</h5>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles</code> 键在一个文件中指定多个特定于profile的YAML文档，以指示何时应用该文档，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
    address: 192.168.1.100
---
spring:
    profiles: development
server:
    address: 127.0.0.1
---
spring:
    profiles: production &amp; eu-central
server:
    address: 192.168.1.120</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>development</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>127.0.0.1</code>。
同样，如果 <code>production</code> <strong>和</strong> <code>eu-central</code> profile处于激活状态，则 <code>server.address</code> 属性为 <code>192.168.1.120</code>。
如果 <strong>未</strong> 启用 <code>development</code>, <code>production</code> 和 <code>eu-central</code> profiles，则该属性的值为 <code>192.168.1.100</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>因此 <code>spring.profiles</code> 可以包含一个简单的profile名称（例如：<code>production</code>）或profile表达式。
profile表达式允许表达更复杂的profile逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。有关更多详细信息，请参阅
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#beans-definition-profiles-java">参考指南</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果在启动应用程序上下文时未明确激活任何profiles，则会激活默认的profiles。因此，在以下YAML中，我们为
<code>spring.security.user.password</code> 设置了一个值，该值 <strong>仅</strong> 在 "default" profile中可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: default
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>而在以下示例中，则会始终设置密码是因为该密码未附加到任何profile，并且必须根据需要在所有其他profiles中将其显式重置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
spring:
  security:
    user:
      password: weak</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>spring.profiles</code> 元素指定的Spring profiles可以选择使用 <code>!</code> 字符来否定。如果为单个文档指定了否定的和非否定的profiles，
则至少一个非否定的profile必须匹配，并且否定的profiles不能匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-yaml-shortcomings">YAML的缺点</h5>
<div class="paragraph">
<p>无法使用 <code>@PropertySource</code> 注解加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用properties文件。</p>
</div>
<div class="paragraph">
<p>在特定于profile的YAML文件中使用多YAML文档语法可能会导致意外行为。例如：考虑文件中的以下配置：</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 8000
---
spring:
  profiles: "!test"
  security:
    user:
      password: "secret"</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用参数 <code>--spring.profiles.active=dev</code> 运行该应用程序，则可能希望将 <code>security.user.password</code> 设置为“<code>secret</code>”，但事实并非如此。</p>
</div>
<div class="paragraph">
<p>嵌套文档将被过滤，因为主文件名为 <code>application-dev.yml</code>。它已经被认为是特定于profile的，并且嵌套文档将被忽略。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议你不要混用特定于profile的YAML文件和多个YAML文档。坚持只使用其中之一。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-external-config-typesafe-configuration-properties">2.2.8. 类型安全的配置Properties</h4>
<div class="paragraph">
<p>使用 <code>@Value("${property}")</code> 注解来注入配置属性有时会很麻烦，尤其是当你使用多个properties或数据本质上是分层的时。
Spring Boot提供了一种使用属性的替代方法，使用强类型的properties bean来管理和验证应用程序的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
另请参见<a href="#boot-features-external-config-vs-value"><code>@Value</code> 和类型安全的配置properties之间的区别</a>。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-java-bean-binding">JavaBean properties绑定</h5>
<div class="paragraph">
<p>可以绑定一个声明标准JavaBean属性的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties("acme")
public class AcmeProperties {

    private boolean enabled;

    private InetAddress remoteAddress;

    private final Security security = new Security();

    public boolean isEnabled() { ... }

    public void setEnabled(boolean enabled) { ... }

    public InetAddress getRemoteAddress() { ... }

    public void setRemoteAddress(InetAddress remoteAddress) { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private String username;

        private String password;

        private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton("USER"));

        public String getUsername() { ... }

        public void setUsername(String username) { ... }

        public String getPassword() { ... }

        public void setPassword(String password) { ... }

        public List&lt;String&gt; getRoles() { ... }

        public void setRoles(List&lt;String&gt; roles) { ... }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的POJO定义了以下属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>acme.enabled</code>，默认值为 <code>false</code>。</p>
</li>
<li>
<p><code>acme.remote-address</code>，其类型可以从 <code>String</code> 强制转换。</p>
</li>
<li>
<p><code>acme.security.username</code>，带有嵌套的“security”对象，其名称由属性名称确定。
特别是，返回类型根本没有使用，也可能是 <code>SecurityProperties</code>。</p>
</li>
<li>
<p><code>acme.security.password</code>。</p>
</li>
<li>
<p><code>acme.security.roles</code>，带有默认拥有单个 <code>USER</code> 的 <code>String</code> 集合。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot自动配置大量使用 <code>@ConfigurationProperties</code> 来轻松配置自动配置的bean。
与自动配置类相似，Spring Boot中可用的 <code>@ConfigurationProperties</code> 类仅供内部使用。
通过Properties文件、YAML文件、环境变量等配置映射到的类属性是公共API，但是该类本身的内容并不意味着可以直接使用。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这种自动配置依赖于默认的空构造函数，并且getter和setter通常是强制性的，因为绑定是通过标准Java Beans属性描述符进行的，
就像在Spring MVC中一样。在以下情况下，可以忽略setter：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Maps，只要它们被初始化，需要一个getter但不一定是setter，因为绑定器可以对它们进行修改。</p>
</li>
<li>
<p>可以通过索引（通常使用YAML）或使用单个逗号分隔的值（properties）来访问集合和数组。
在后一种情况下，必须使用setter。我们建议始终为此类类型添加setter。如果初始化集合，请确保它不是不可变的（如上例所示）。</p>
</li>
<li>
<p>如果初始化了嵌套的POJO属性（如前面示例中的 <code>Security</code> 字段），则不需要setter。
如果希望绑定器通过使用其默认构造函数动态创建实例，则需要一个setter。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有些人使用Lombok项目自动添加getters和setters。确保Lombok不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。</p>
</div>
<div class="paragraph">
<p>最后，仅考虑标准Java Bean属性，不支持对静态属性的绑定。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-constructor-binding">构造函数绑定</h5>
<div class="paragraph">
<p>上一节中的示例可以用不可变的方式重写，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example;

import java.net.InetAddress;
import java.util.List;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.ConstructorBinding;
import org.springframework.boot.context.properties.DefaultValue;

@ConstructorBinding
@ConfigurationProperties("acme")
public class AcmeProperties {

    private final boolean enabled;

    private final InetAddress remoteAddress;

    private final Security security;

    public AcmeProperties(boolean enabled, InetAddress remoteAddress, Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }

    public boolean isEnabled() { ... }

    public InetAddress getRemoteAddress() { ... }

    public Security getSecurity() { ... }

    public static class Security {

        private final String username;

        private final String password;

        private final List&lt;String&gt; roles;

        public Security(String username, String password,
                @DefaultValue("USER") List&lt;String&gt; roles) {
            this.username = username;
            this.password = password;
            this.roles = roles;
        }

        public String getUsername() { ... }

        public String getPassword() { ... }

        public List&lt;String&gt; getRoles() { ... }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此设置中，<code>@ConstructorBinding</code> 注解用于指示应使用构造函数绑定。这意味着绑定器将期望找到带有你希望绑定的参数的构造函数。</p>
</div>
<div class="paragraph">
<p><code>@ConstructorBinding</code> 类的嵌套成员（例如上例中的 <code>Security</code>）也将通过其构造函数进行绑定。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>@DefaultValue</code> 指定默认值，并且将应用相应的转换服务将 <code>String</code> 值强制转换为缺失属性的目标类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用构造函数绑定，必须使用 <code>@EnableConfigurationProperties</code> 或配置属性扫描来启用该类。你不能对通过常规Spring机制创建的bean
使用构造函数绑定（例如：<code>@Component</code> bean，通过 <code>@Bean</code> 方法创建的bean或使用 <code>@Import</code> 加载的bean）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的类具有多个构造函数，则还可以直接在应绑定的构造函数上使用 <code>@ConstructorBinding</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-enabling">启用被 <code>@ConfigurationProperties</code> 注解的类型</h5>
<div class="paragraph">
<p>Spring Boot提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为Bean的基础设施。
你可以逐类启用配置属性，也可以启用与组件扫描类似的方式进行配置属性扫描。</p>
</div>
<div class="paragraph">
<p>有时，用 <code>@ConfigurationProperties</code> 注解的类可能不适用于扫描，例如：如果你正在开发自己的自动配置，
或者想要有条件地启用它们。在这些情况下，请使用 <code>@EnableConfigurationProperties</code> 注解指定要处理的类型列表。
可以在任何 <code>@Configuration</code> 类上完成此操作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(AcmeProperties.class)
public class MyConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用配置属性扫描，请将 <code>@ConfigurationPropertiesScan</code> 注解添加到你的应用程序。
通常，它被添加到使用 <code>@SpringBootApplication</code> 注解的主应用程序类中，但可以将其添加到任何 <code>@Configuration</code> 类中。
默认情况下，将从声明注解的类的包中进行扫描。如果要定义待扫描的特定程序包，可以按照以下示例所示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@ConfigurationPropertiesScan({ "com.example.app", "org.acme.another" })
public class MyApplication {
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When the <code>@ConfigurationProperties</code> bean is registered using configuration property scanning or via <code>@EnableConfigurationProperties</code>, the bean has a conventional name: <code>&lt;prefix&gt;-&lt;fqn&gt;</code>, where <code>&lt;prefix&gt;</code> is the environment key prefix specified in the <code>@ConfigurationProperties</code> annotation and <code>&lt;fqn&gt;</code> is the fully qualified name of the bean.
If the annotation does not provide any prefix, only the fully qualified name of the bean is used.</p>
</div>
<div class="paragraph">
<p>使用配置属性扫描或通过 <code>@EnableConfigurationProperties</code> 注册 <code>@ConfigurationProperties</code> Bean时，
该Bean具有常规名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，其中 <code>&lt;prefix&gt;</code> 是 <code>@ConfigurationProperties</code> 注解中指定的环境键前缀。
<code>&lt;fqn&gt;</code> 是Bean的完全限定名称。如果注解不提供任何前缀，则仅使用Bean的完全限定名称。</p>
</div>
<div class="paragraph">
<p>上例中的bean名称是 <code>acme-com.example.AcmeProperties</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们建议 <code>@ConfigurationProperties</code> 仅处理环境，尤其不要从上下文中注入其他bean。
对于极端情况，可以使用setter注入或框架提供的任何 <code>*Aware</code> 接口（例如：需要访问 <code>Environment</code> 的 <code>EnvironmentAware</code>）。
如果仍然想使用构造函数注入其他bean，则必须使用 <code>@Component</code> 注解配置properties bean，并使用基于JavaBean的属性绑定。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-using">使用被 <code>@ConfigurationProperties</code> 注解的类型</h5>
<div class="paragraph">
<p>这种配置方式在 <code>SpringApplication</code> 外部的YAML配置中特别好用，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml"># application.yml

acme:
    remote-address: 192.168.1.1
    security:
        username: admin
        roles:
          - USER
          - ADMIN

# additional configuration as required</code></pre>
</div>
</div>
<div class="paragraph">
<p>要与 <code>@ConfigurationProperties</code> Bean一起使用，可以像其他任何Bean一样注入它们，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final AcmeProperties properties;

    @Autowired
    public MyService(AcmeProperties properties) {
        this.properties = properties;
    }

     //...

    @PostConstruct
    public void openConnection() {
        Server server = new Server(this.properties.getRemoteAddress());
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>@ConfigurationProperties</code> 还可让你生成元数据文件，IDE可以使用这些元数据文件为你自己的键提供自动完成功能。
有关详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#configuration-metadata">附录</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-3rd-party-configuration">第三方配置</h5>
<div class="paragraph">
<p>除了使用 <code>@ConfigurationProperties</code> 注解类外，还可以在public <code>@Bean</code> 方法上使用它。当你要将属性绑定到控件之外的第三方组件时，这样做特别有用。</p>
</div>
<div class="paragraph">
<p>要从 <code>Environment</code> 属性配置Bean，请将 <code>@ConfigurationProperties</code> 添加到其Bean注册中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix = "another")
@Bean
public AnotherComponent anotherComponent() {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 <code>another</code> 前缀定义的任何JavaBean属性都以类似于前面的 <code>AcmeProperties</code> 示例的方式映射到该 <code>AnotherComponent</code> bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-relaxed-binding">宽松绑定</h5>
<div class="paragraph">
<p>Spring Boot使用一些宽松的规则将 <code>Environment</code> 属性绑定到 <code>@ConfigurationProperties</code> bean，
因此 <code>Environment</code> 属性名称和bean属性名称之间不需要完全匹配。有用的常见示例包括：以破折号分隔的环境属性
（例如：<code>context-path</code> 绑定到 <code>contextPath</code>）和大写的环境属性（例如：<code>PORT</code> 绑定到 <code>port</code>）。</p>
</div>
<div class="paragraph">
<p>例如：考虑以下 <code>@ConfigurationProperties</code> 类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme.my-project.person")
public class OwnerProperties {

    private String firstName;

    public String getFirstName() {
        return this.firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用前面的代码，以下属性名称均可以使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. 宽松绑定</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my-project.person.first-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kebab格式，建议在 <code>.properties</code> 和 <code>.yml</code> 文件中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.myProject.person.firstName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准小驼峰式语法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acme.my_project.person.first_name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线表示法，是 <code>.properties</code> 和 <code>.yml</code> 文件中使用的另一种格式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">大写格式，使用系统环境变量时建议使用。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
注解的前缀值 <em>必须</em> 为kebab格式（小写，并用 <code>-</code> 分隔，例如：<code>acme.my-project.person</code>）。
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. 每个属性源的宽松绑定规则</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性源</th>
<th class="tableblock halign-left valign-top">支持</th>
<th class="tableblock halign-left valign-top">列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Properties文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">YAML文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard YAML list syntax or comma-separated values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">环境变量</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以下划线作为定界符的大写格式。<code>_</code> 不应在属性名称中使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">下划线包围的数值，例如：<code>MY_ACME_1_OTHER = my.acme[1].other</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统属性</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">小驼峰，kebab或下划线表示法</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>[]</code> 或逗号分隔值的标准列表语法</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议，如果可能，属性以小写kebab格式存储，例如：<code>my.property-name=acme</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>绑定到 <code>Map</code> 属性时，如果 <code>key</code> 包含小写字母数字字符或 <code>-</code> 以外的任何其他字符，则需要使用方括号表示法，以便保留原始值。
如果键没有被 <code>[]</code> 包围，则所有非字母数字或 <code>-</code> 字符都将被删除。例如，考虑将以下属性绑定到 <code>Map</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    "[/key1]": value1
    "[/key2]": value2
    /key3: value3</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的属性将以 <code>/key1</code>，<code>/key2</code> 和 <code>key3</code> 作为映射中的键被绑定到 <code>Map</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于YAML文件，方括号需要用引号引起来，以便正确解析。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-complex-type-merge">合并复杂类型</h5>
<div class="paragraph">
<p>如果在多个地方配置了列表，则通过替换整个列表来进行覆盖。</p>
</div>
<div class="paragraph">
<p>例如：假设 <code>MyPojo</code> 对象的 <code>name</code> 和 <code>description</code> 属性默认为 <code>null</code>。
下面的示例从 <code>AcmeProperties</code> 公开 <code>MyPojo</code> 对象的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;();

    public List&lt;MyPojo&gt; getList() {
        return this.list;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目，如先前所定义。
但是，如果启用了 <code>dev</code> profile，则该列表仍然仅包含一个条目（名称为 <code>my another name</code>，并且描述为 <code>null</code>）。
此配置 <em>不会</em> 将第二个 <code>MyPojo</code> 实例添加到列表中，并且不会合并条目。</p>
</div>
<div class="paragraph">
<p>在多个profiles中指定 <code>List</code> 时，将使用优先级最高的列表（并且仅使用那个列表）。考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  list:
    - name: my name
      description: my description
    - name: another name
      description: another description
---
spring:
  profiles: dev
acme:
  list:
    - name: my another name</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>dev</code> profile处于激活状态，则 <code>AcmeProperties.list</code> 包含一个 <code>MyPojo</code> 条目
（其名称为 <code>my another name</code>，并且描述为 <code>null</code>）。对于YAML，可以使用逗号分隔的列表和YAML列表来完全覆盖列表的内容。</p>
</div>
<div class="paragraph">
<p>对于 <code>Map</code> 属性，可以绑定从多个来源绘制的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。
下面的示例从 <code>AcmeProperties</code> 公开 <code>Map&lt;String, MyPojo&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    private final Map&lt;String, MyPojo&gt; map = new HashMap&lt;&gt;();

    public Map&lt;String, MyPojo&gt; getMap() {
        return this.map;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">acme:
  map:
    key1:
      name: my name 1
      description: my description 1
---
spring:
  profiles: dev
acme:
  map:
    key1:
      name: dev name 1
    key2:
      name: dev name 2
      description: dev description 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <code>dev</code> profile未处于激活状态，则 <code>AcmeProperties.map</code> 包含一个键为key1的条目（名称为 <code>my name 1</code>，描述为 <code>my description 1</code>）。
但是，如果启用了 <code>dev</code> profile，则map包含两个条目，其中键为key1的条目（名称为 <code>dev name 1</code>，描述为 <code>my description 1</code>）
和key2（名称为 <code>dev name 2</code>，描述为 <code>dev description 2</code>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前述合并规则不仅适用于YAML文件，而且适用于所有属性源中的属性。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-conversion">属性转换</h5>
<div class="paragraph">
<p>当Spring Boot绑定到 <code>@ConfigurationProperties</code> bean时，它尝试将外部应用程序属性强制为正确的类型。
如果需要自定义类型转换，则可以提供一个 <code>ConversionService</code> bean（具有一个名为 <code>conversionService</code> 的bean）
或自定义属性编辑器（通过 <code>CustomEditorConfigurer</code> bean）或自定义 <code>Converters</code>（具有定义为 <code>@ConfigurationPropertiesBinding</code> 的bean定义）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于在应用程序生命周期中非常早就请求了此bean，因此请确保限制你的 <code>ConversionService</code> 使用的依赖项。
通常，你需要的任何依赖项可能在创建时未完全初始化。如果配置键强制转换不需要自定义的转换服务，则可能要重命名自定义的
<code>ConversionService</code> 且它仅依赖于具有 <code>@ConfigurationPropertiesBinding</code> 限定的自定义转换器。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="boot-features-external-config-conversion-duration">转换持续时间</h6>
<div class="paragraph">
<p>Spring Boot为表达持续时间提供了专门的支持。如果公开 <code>java.time.Duration</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（使用毫秒作为默认单位，除非已指定 <code>@DurationUnit</code>）</p>
</li>
<li>
<p><a href="https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-"><code>java.time.Duration</code> 使用的</a>标准ISO-8601格式</p>
</li>
<li>
<p>值和单位相结合的更易读的格式（例如：10s表示10秒）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.system")
public class AppSystemProperties {

    @DurationUnit(ChronoUnit.SECONDS)
    private Duration sessionTimeout = Duration.ofSeconds(30);

    private Duration readTimeout = Duration.ofMillis(1000);

    public Duration getSessionTimeout() {
        return this.sessionTimeout;
    }

    public void setSessionTimeout(Duration sessionTimeout) {
        this.sessionTimeout = sessionTimeout;
    }

    public Duration getReadTimeout() {
        return this.readTimeout;
    }

    public void setReadTimeout(Duration readTimeout) {
        this.readTimeout = readTimeout;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要指定30秒的会话超时，则 <code>30</code>，<code>PT30S</code> 和 <code>30s</code> 都是等效的。可以使用以下任意形式指定500ms的读取超时：
<code>500</code>，<code>PT0.5S</code> 和 <code>500ms</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ns</code> 纳秒</p>
</li>
<li>
<p><code>us</code> 微秒</p>
</li>
<li>
<p><code>ms</code> 毫秒</p>
</li>
<li>
<p><code>s</code> 秒</p>
</li>
<li>
<p><code>m</code> 分钟</p>
</li>
<li>
<p><code>h</code> 小时</p>
</li>
<li>
<p><code>d</code> 天</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是毫秒，可以使用 <code>@DurationUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你要从仅使用 <code>Long</code> 表示持续时间的先前版本进行升级，原单位若不是毫秒那么请确保在切换到 <code>Duration</code>
时指定单位（使用 <code>@DurationUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-external-config-conversion-datasize">转换数据大小</h6>
<div class="paragraph">
<p>Spring Framework具有 <code>DataSize</code> 值类型，以字节为单位表示大小。如果公开 <code>DataSize</code> 属性，则应用程序属性中的以下格式可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>常规的 <code>long</code> 表示形式（除非已指定 <code>@DataSizeUnit</code>，否则使用字节作为默认单位）</p>
</li>
<li>
<p>值和单位耦合在一起的更易读的格式（例如：10MB表示10兆字节）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>考虑以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.io")
public class AppIoProperties {

    @DataSizeUnit(DataUnit.MEGABYTES)
    private DataSize bufferSize = DataSize.ofMegabytes(2);

    private DataSize sizeThreshold = DataSize.ofBytes(512);

    public DataSize getBufferSize() {
        return this.bufferSize;
    }

    public void setBufferSize(DataSize bufferSize) {
        this.bufferSize = bufferSize;
    }

    public DataSize getSizeThreshold() {
        return this.sizeThreshold;
    }

    public void setSizeThreshold(DataSize sizeThreshold) {
        this.sizeThreshold = sizeThreshold;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>若要指定10 MB的缓冲区大小，则 <code>10</code> 和 <code>10MB</code> 是等效的。256个字节大小的阈值可以指定为 <code>256</code> 或 <code>256B</code>。</p>
</div>
<div class="paragraph">
<p>你也可以使用任何受支持的单位：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>B</code> 字节</p>
</li>
<li>
<p><code>KB</code> 千字节</p>
</li>
<li>
<p><code>MB</code> 兆字节</p>
</li>
<li>
<p><code>GB</code> 千兆字节</p>
</li>
<li>
<p><code>TB</code> 兆兆字节</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认单位是字节，可以使用 <code>@DataSizeUnit</code> 覆盖，如上面的示例所示。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要从仅使用 <code>Long</code> 表示大小的先前版本进行升级，原单位若不是字节那么请确保在切换到 <code>DataSize</code>
时指定单位（使用 <code>@DataSizeUnit</code>）。这样做可以提供透明的升级路径，同时支持更丰富的格式。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-validation">@ConfigurationProperties验证</h5>
<div class="paragraph">
<p>每当使用Spring的 <code>@Validated</code> 注解对 <code>@ConfigurationProperties</code> 类进行批注时，
Spring Boot就会尝试对其进行验证。你可以在配置类上直接使用JSR-303 <code>javax.validation</code> 约束注解。
为此，请确保在类路径上有兼容的JSR-303实现，然后将约束注解添加到字段中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    // ... getters and setters

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以通过使用 <code>@Validated</code> 注解创建配置属性的 <code>@Bean</code> 方法来触发验证。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了确保始终为嵌套属性触发验证，即使未找到任何属性，也必须使用 <code>@Valid</code> 注解关联的字段。下面的示例基于前面的 <code>AcmeProperties</code> 示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="acme")
@Validated
public class AcmeProperties {

    @NotNull
    private InetAddress remoteAddress;

    @Valid
    private final Security security = new Security();

    // ... getters and setters

    public static class Security {

        @NotEmpty
        public String username;

        // ... getters and setters

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以通过创建一个名为 <code>configurationPropertiesValidator</code> 的bean定义来添加自定义Spring <code>Validator</code>。
<code>@Bean</code> 方法应声明为 <code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，
并且将 <code>@Bean</code> 方法声明为 <code>static</code> 可以使创建该bean而不必实例化 <code>@Configuration</code> 类。这样做避免了由早期实例化引起的任何问题。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring-boot-actuator</code> 模块包括一个公开所有 <code>@ConfigurationProperties</code> beans的端点。
将你的Web浏览器指向 <code>/actuator/configprops</code> 或使用等效的JMX端点访问。有关详细信息，请参见“
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready-endpoints">生产就绪功能</a>”部分。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-external-config-vs-value">@ConfigurationProperties vs @Value</h5>
<div class="paragraph">
<p><code>@Value</code> 注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。
下表总结了 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 支持的功能：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">功能</th>
<th class="tableblock halign-left valign-top"><code>@ConfigurationProperties</code></th>
<th class="tableblock halign-left valign-top"><code>@Value</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#boot-features-external-config-relaxed-binding">宽松绑定</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#configuration-metadata">元数据支持</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SpEL</code> 评估</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果你为自己的组件定义了一组配置键，我们建议你将它们组合在以 <code>@ConfigurationProperties</code> 注解的POJO中。
你还应该意识到，由于 <code>@Value</code> 不支持宽松的绑定，因此如果你需要使用环境变量来提供值，则它不是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>最后，尽管你可以在 <code>@Value</code> 中编写SpEL表达式，但不会从<a href="#boot-features-external-config-application-property-files">应用程序属性文件</a>中处理此类表达式。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-profiles">2.3. Profiles</h3>
<div class="paragraph">
<p>Spring Profiles提供了一种隔离应用程序配置部分并使之仅在某些环境中可用的方法。
任何 <code>@Component</code>，<code>@Configuration</code> 或 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 标记以限制其加载时间，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果 <code>@ConfigurationProperties</code> Bean是通过 <code>@EnableConfigurationProperties</code> 而非自动扫描注册的，
则需要在具有 <code>@EnableConfigurationProperties</code> 注解的 <code>@Configuration</code> 类上指定 <code>@Profile</code> 注解。
在自动扫描 <code>@ConfigurationProperties</code> 的情况下，可以在 <code>@ConfigurationProperties</code> 类本身上指定 <code>@Profile</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以使用 <code>spring.profiles.active</code> 环境属性来指定哪些配置文件处于激活状态。你可以通过本章前面介绍的任何方式指定属性。
例如，你可以将其包含在 <code>application.properties</code> 中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.profiles.active=dev,hsqldb</code></pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。</p>
</div>
<div class="sect3">
<h4 id="boot-features-adding-active-profiles">2.3.1. 添加活动Profiles</h4>
<div class="paragraph">
<p><code>spring.profiles.active</code> 属性遵循与其他属性相同的排序规则：最高的 <code>PropertySource</code> 获胜。这意味着你可以在
<code>application.properties</code> 中指定要激活配置文件，然后使用命令行开关 <strong>替换</strong> 它们。</p>
</div>
<div class="paragraph">
<p>有时，将特定于profile的属性 <strong>添加</strong> 到活动profiles而不是替换它们很有用。
<code>spring.profiles.include</code> 属性可用于无条件添加活动Profiles。<code>SpringApplication</code> 入口点还具有Java API，
用于设置其他附加的profiles（即在由 <code>spring.profiles.active</code> 属性激活的profiles之上）。
参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/SpringApplication.html">SpringApplication</a>中的 <code>setAdditionalProfiles()</code> 方法。</p>
</div>
<div class="paragraph">
<p>例如，当使用开关 <code>--spring.profiles.active=prod</code> 运行具有以下属性的应用程序时，<code>proddb</code> 和 <code>prodmq</code> 配置文件也会被激活：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">---
my.property: fromyamlfile
---
spring.profiles: prod
spring.profiles.include:
  - proddb
  - prodmq</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请记住，可以在YAML文档中定义 <code>spring.profiles</code> 属性，以确定该特定文档何时包含在配置中。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-change-configuration-depending-on-the-environment">根据环境更改配置</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-programmatically-setting-profiles">2.3.2. 以编程方式设置Profiles</h4>
<div class="paragraph">
<p>你可以在应用程序运行之前通过调用 <code>SpringApplication.setAdditionalProfiles(&#8230;&#8203;)</code> 以编程方式设置活动配置文件。
也可以使用Spring的 <code>ConfigurableEnvironment</code> 接口来激活profiles。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-profile-specific-configuration">2.3.3. 特定于Profile的配置文件</h4>
<div class="paragraph">
<p><code>application.properties</code>（或 <code>application.yml</code>）和通过
<code>@ConfigurationProperties</code> 所引用文件的特定于profile的变体都会被视为配置文件并加载。
有关详细信息，请参见“<a href="#boot-features-external-config-profile-specific-properties">特定于Profile的Properties</a>”。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-logging">2.4. 日志</h3>
<div class="paragraph">
<p>Spring Boot使用 <a href="https://commons.apache.org/logging">Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。
提供了 <a href="https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html">Java Util Logging</a>，
<a href="https://logging.apache.org/log4j/2.x/">Log4J2</a>和 <a href="https://logback.qos.ch/">Logback</a>的默认配置。
在每种情况下，日志记录器都已预先配置为使用控制台输出，同时还提供可选的文件输出。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果使用“<code>Starters</code>”，则使用Logback进行日志记录。还包括适当的Logback路由，以确保使用
Java Util Logging，Commons Logging，Log4J或SLF4J的从属库都可以正常工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Java有许多可用的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。
通常，你不需要更改日志记录依赖项，并且Spring Boot默认值可以正常工作。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
将应用程序部署到Servlet容器或应用程序服务器时，通过Java Util Logging API执行的日志记录不会路由到应用程序的日志中。
这样可以防止容器或其他已部署到容器中的应用程序执行的日志记录出现在应用程序的日志中。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-logging-format">2.4.1. 日志格式</h4>
<div class="paragraph">
<p>Spring Boot的默认日志输出类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms
2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</pre>
</div>
</div>
<div class="paragraph">
<p>默认输出以下条目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>日期和时间：毫秒精度，易于分类。</p>
</li>
<li>
<p>日志级别：<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code> 和 <code>TRACE</code>。</p>
</li>
<li>
<p>进程ID。</p>
</li>
<li>
<p><code>---</code> 分隔符用于区分实际日志消息的开始。</p>
</li>
<li>
<p>线程名：用方括号括起来（对于控制台输出，可能会被截断）。</p>
</li>
<li>
<p>记录器名称：这通常是源类名称（通常是缩写格式）。</p>
</li>
<li>
<p>日志消息。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Logback没有 <code>FATAL</code> 日志级别。它被映射到 <code>ERROR</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logging-console-output">2.4.2. 控制台输出</h4>
<div class="paragraph">
<p>默认日志配置在消息写入时将消息回显到控制台。默认情况下，将记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
你还可以通过使用 <code>--debug</code> 标志启动应用程序来启用“<code>debug</code>”模式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ java -jar myapp.jar --debug</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你还可以在 <code>application.properties</code> 中指定 <code>debug=true</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启用调试模式后，将配置一些核心日志记录器（嵌入式容器，Hibernate和Spring Boot）以输出更多信息。
启用调试模式 <em>不会</em> 将你的应用程序配置为记录所有具有 <code>DEBUG</code> 级别的消息。</p>
</div>
<div class="paragraph">
<p>或者，你可以通过使用 <code>--trace</code> 标志（或 <code>application.properties</code> 中的 <code>trace=true</code>）启动应用程序来启用“<code>trace</code>”模式。
这样做可以为某些核心记录器（嵌入式容器，Hibernate schema生成以及整个Spring产品组合）启用跟踪记录。</p>
</div>
<div class="sect4">
<h5 id="boot-features-logging-color-coded-output">颜色编码输出</h5>
<div class="paragraph">
<p>如果你的终端支持ANSI，则使用彩色输出来提高可读性。你可以将 <code>spring.output.ansi.enabled</code> 设置为
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/ansi/AnsiOutput.Enabled.html">支持的值</a>，以覆盖自动检测。</p>
</div>
<div class="paragraph">
<p>使用 <code>%clr</code> 转换字配置颜色编码。转换器以最简单的形式根据日志级别为输出着色，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%5p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表描述了日志级别到颜色的映射：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Level</th>
<th class="tableblock halign-left valign-top">Color</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FATAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ERROR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">红色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WARN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">黄色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INFO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEBUG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">绿色</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另外，你可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如：要使文本变黄，请使用以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){yellow}</code></pre>
</div>
</div>
<div class="paragraph">
<p>支持以下颜色和样式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>blue</code></p>
</li>
<li>
<p><code>cyan</code></p>
</li>
<li>
<p><code>faint</code></p>
</li>
<li>
<p><code>green</code></p>
</li>
<li>
<p><code>magenta</code></p>
</li>
<li>
<p><code>red</code></p>
</li>
<li>
<p><code>yellow</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logging-file-output">2.4.3. 文件输出</h4>
<div class="paragraph">
<p>默认情况下，Spring Boot仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，
则需要设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性（例如：在 <code>application.properties</code> 中）。</p>
</div>
<div class="paragraph">
<p>下表显示了如何结合使用 <code>logging.*</code> 属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. 日志属性</caption>
<colgroup>
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 14%;">
<col style="width: 57%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>logging.file.name</code></th>
<th class="tableblock halign-left valign-top"><code>logging.file.path</code></th>
<th class="tableblock halign-left valign-top">示例</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅控制台记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>my.log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写入指定的日志文件。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(none)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">特定目录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将 <code>spring.log</code> 写入指定目录。名称可以是确切位置，也可以是相对于当前目录的位置。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>日志文件达到10 MB时会旋转，并且与控制台输出一样，默认情况下会记录 <code>ERROR</code> 级别，<code>WARN</code> 级别和 <code>INFO</code> 级别的消息。
可以使用 <code>logging.file.max-size</code> 属性更改大小限制。除非已设置 <code>logging.file.max-history</code> 属性，
否则以前旋转的文件将无限期存档。可以使用 <code>logging.file.total-size-cap</code> 限制日志归档文件的总大小。
当日志归档的总大小超过该阈值时，将删除备份。要在应用程序启动时强制清除日志归档文件，
请使用 <code>logging.file.clean-history-on-start</code> 属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
日志记录属性独立于实际的日志记录基础设施。因此，特定的配置键（例如：Logback的 <code>logback.configurationFile</code>）不是由Spring Boot管理的。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-levels">2.4.4. 日志级别</h4>
<div class="paragraph">
<p>通过使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 可以在Spring <code>Environment</code> 中（例如：在 <code>application.properties</code> 中）
设置所有受支持的日志记录器级别。其中 <code>level</code> 是TRACE, DEBUG, INFO, WARN, ERROR, FATAL 或 OFF。
可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器。</p>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>application.properties</code> 中的潜在日志记录设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.root=warn
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用环境变量设置日志记录级别。例如：<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 会将
<code>org.springframework.web</code> 设置为 <code>DEBUG</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
以上方法仅适用于程序包级别的日志记录。由于宽松的绑定总是将环境变量转换为小写，因此无法以这种方式为单个类配置日志记录。
如果需要为类配置日志记录，则可以使用<a href="#boot-features-external-config-application-json"><code>SPRING_APPLICATION_JSON</code></a>变量。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-groups">2.4.5. 日志组</h4>
<div class="paragraph">
<p>能够将相关记录器分组在一起通常是很有用的，以便可以同时配置它们。例如：你可能通常会更改 <em>所有</em> 与Tomcat相关的记录器的日志级别，但是你不容易记住顶层软件包。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，Spring Boot允许你在Spring <code>Environment</code> 中定义日志记录组。例如：以下是通过将“<code>tomcat</code>”组添加到
<code>application.properties</code> 来定义它的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</code></pre>
</div>
</div>
<div class="paragraph">
<p>定义后，你可以仅使用一行就更改该组中所有记录器的日志级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">logging.level.tomcat=TRACE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot包含以下预定义的日志记录组，它们可以直接使用：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">记录器</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">web</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.core.codec</code>, <code>org.springframework.http</code>, <code>org.springframework.web</code>, <code>org.springframework.boot.actuate.endpoint.web</code>, <code>org.springframework.boot.web.servlet.ServletContextInitializerBeans</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sql</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.jdbc.core</code>, <code>org.hibernate.SQL</code>, <code>org.jooq.tools.LoggerListener</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-custom-log-configuration">2.4.6. 自定义日志配置</h4>
<div class="paragraph">
<p>可以通过在类路径中包括适当的库来激活各种日志记录系统，并可以通过在类路径的根目录中或在以下Spring
<code>Environment</code> 属性指定的位置中提供适当的配置文件来进一步自定义日志文件：<code>logging.config</code>。</p>
</div>
<div class="paragraph">
<p>你可以通过使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性来强制Spring Boot使用特定的日志记录系统。
该值应该是 <code>LoggingSystem</code> 实现的完全限定类名。你也可以使用 <code>none</code> 值完全禁用Spring Boot的日志记录配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于日志记录是在创建 <code>ApplicationContext</code> <strong>之前</strong> 初始化的，因此无法从Spring
<code>@Configuration</code> 文件中的 <code>@PropertySources</code> 控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>根据你的日志记录系统，将加载以下文件：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">志记录系统</th>
<th class="tableblock halign-left valign-top">自定义配置文件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> 或 <code>logback.groovy</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Log4j2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>log4j2-spring.xml</code> 或 <code>log4j2.xml</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JDK (Java Util Logging)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.properties</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果可能，我们建议你在日志配置中使用 <code>-spring</code> 变体（例如：使用 <code>logback-spring.xml</code> 而不是 <code>logback.xml</code>）。
如果使用标准配置位置，Spring将无法完全控制日志初始化。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
在“可执行jar”运行时，Java Util Logging存在一些已知的类加载问题，这会引起问题。我们建议你尽可能在“可执行jar”运行时避免使用它。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了帮助定制，将一些其他属性从Spring <code>Environment</code> 转移到系统属性，如下表所述：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Environment</th>
<th class="tableblock halign-left valign-top">System Property</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.exception-conversion-word</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_EXCEPTION_CONVERSION_WORD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录异常时使用的转换字。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.clean-history-on-start</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_CLEAN_HISTORY_ON_START</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否在启动时清除存档日志文件（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_SIZE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最大日志文件大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.max-history</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_MAX_HISTORY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的最大归档日志文件数（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_PATH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果定义，它将在默认日志配置中使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.file.total-size-cap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_FILE_TOTAL_SIZE_CAP</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要保留的备份日志的总大小（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.console</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONSOLE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制台上使用的日志模式（stdout）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.dateformat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_DATEFORMAT_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">记录日期格式的附加模式。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.file</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FILE_LOG_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件中使用的日志模式（如果启用了LOG_FILE）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOG_LEVEL_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">呈现日志级别时使用的格式（默认为 <code>%5p</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logging.pattern.rolling-file-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ROLLING_FILE_NAME_PATTERN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过渡日志文件名的模式（默认为 <code>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</code>）。（仅默认的Logback设置受支持。）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前进程ID（如果可能，并且尚未将其定义为操作系统环境变量时将被发现）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见 <code>spring-boot.jar</code> 中的默认配置：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util logging</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要在日志记录属性中使用占位符，则应使用<a href="#boot-features-external-config-placeholders-in-properties">Spring Boot的语法</a>而不是基础框架的语法。
值得注意的是，如果使用Logback，则应使用 <code>:</code> 作为属性名称与其默认值之间的分隔符，而不应使用 <code>:-</code>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你可以通过仅覆盖 <code>LOG_LEVEL_PATTERN</code>（或Logback的 <code>logging.pattern.level</code>）来将MDC和其他临时内容添加到日志行。
例如，如果你使用 <code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含一个名为“user”的MDC条目（如果存在），如以下示例所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller
Handling authenticated request</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-logback-extensions">2.4.7. Logback扩展</h4>
<div class="paragraph">
<p>Spring Boot包含许多Logback扩展，可以帮助进行高级配置。你可以在 <code>logback-spring.xml</code> 配置文件中使用这些扩展名。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于标准 <code>logback.xml</code> 配置文件加载得太早，因此无法在其中使用扩展名。你需要使用 <code>logback-spring.xml</code> 或定义 <code>logging.config</code> 属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
这些扩展不能与Logback的 <a href="https://logback.qos.ch/manual/configuration.html#autoScan">配置扫描</a>一起使用。
如果尝试这样做，则对配置文件进行更改将导致类似于以下日志之一的错误：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]
ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</pre>
</div>
</div>
<div class="sect4">
<h5 id="特定于profile的配置">特定于Profile的配置</h5>
<div class="paragraph">
<p>通过 <code>&lt;springProfile&gt;</code> 标记，你可以根据活动的Spring profiles有选择地包括或排除配置部分。
在 <code>&lt;configuration&gt;</code> 元素内的任何位置都支持profile部分。使用 <code>name</code> 属性指定哪个profile接受配置。
<code>&lt;springProfile&gt;</code> 标记可以包含简单的profile名称（例如：<code>staging</code>）或profile表达式。
profile表达式允许表达更复杂的配置文件逻辑，例如：<code>production &amp; (eu-central | eu-west)</code>。
有关更多详细信息，请参阅 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#beans-definition-profiles-java">参考指南</a>。
以下清单显示了三个样本profiles：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProfile name="staging"&gt;
    &lt;!-- configuration to be enabled when the "staging" profile is active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="dev | staging"&gt;
    &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;
&lt;/springProfile&gt;

&lt;springProfile name="!production"&gt;
    &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;
&lt;/springProfile&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="环境属性">环境属性</h5>
<div class="paragraph">
<p><code>&lt;springProperty&gt;</code> 标签使你可以从Spring <code>Environment</code> 中公开属性，以在Logback中使用。
如果要在Logback配置中访问 <code>application.properties</code> 文件中的值，则这样做很有用。
该标签的工作方式类似于Logback的标准 <code>&lt;property&gt;</code> 标签。但是，不是指定直接 <code>value</code>，而是指定属性的 <code>source</code>（来自 <code>Environment</code>）。
如果需要将属性存储在 <code>local</code> 作用域以外的其他位置，则可以使用 <code>scope</code> 属性。如果需要后备值（如果未在环境中设置该属性），
则可以使用 <code>defaultValue</code> 属性。以下示例显示如何公开在Logback中使用的属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;springProperty scope="context" name="fluentHost" source="myapp.fluentd.host"
        defaultValue="localhost"/&gt;
&lt;appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"&gt;
    &lt;remoteHost&gt;${fluentHost}&lt;/remoteHost&gt;
    ...
&lt;/appender&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>source</code> 必须以kebab格式指定（例如：<code>my.property-name</code>）。但是，可以使用宽松的规则将属性添加到 <code>Environment</code> 中。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-internationalization">2.5. 国际化</h3>
<div class="paragraph">
<p>Spring Boot支持本地化消息，因此你的应用程序可以迎合不同语言首选项的用户。
默认情况下，Spring Boot在类路径的根目录下查找存在的 <code>messages</code> 资源包。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当已配置资源束的默认属性文件可用时（即默认情况下为 <code>messages.properties</code>），将应用自动配置。
如果你的资源包仅包含特定于语言的属性文件，则需要添加默认文件。如果找不到与任何配置的基本名称匹配的属性文件，将没有自动配置的 <code>MessageSource</code> 可用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.messages</code> 命名空间配置资源包的基本名称以及其他几个属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.messages.basename=messages,config.i18n.messages
spring.messages.fallback-to-system-locale=false</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>spring.messages.basename</code> 支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根目录解析的资源。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java"><code>MessageSourceProperties</code></a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-json">2.6. JSON</h3>
<div class="paragraph">
<p>Spring Boot提供了与三个JSON映射库的集成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gson</p>
</li>
<li>
<p>Jackson</p>
</li>
<li>
<p>JSON-B</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jackson是首选的默认库。</p>
</div>
<div class="sect3">
<h4 id="boot-features-json-jackson">2.6.1. Jackson</h4>
<div class="paragraph">
<p>提供了Jackson的自动配置，并且Jackson是 <code>spring-boot-starter-json</code> 的一部分。当Jackson放在类路径上时，
将自动配置 <code>ObjectMapper</code> Bean。提供了几个配置属性，用于
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-customize-the-jackson-objectmapper">自定义 <code>ObjectMapper</code> 的配置</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-gson">2.6.2. Gson</h4>
<div class="paragraph">
<p>提供了Gson的自动配置。当Gson在类路径上时，将自动配置 <code>Gson</code> bean。提供了几个 <code>spring.gson.*</code>
配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个 <code>GsonBuilderCustomizer</code> bean。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-json-json-b">2.6.3. JSON-B</h4>
<div class="paragraph">
<p>提供了JSON-B的自动配置。当JSON-B API和实现位于类路径上时，将自动配置 <code>Jsonb</code> bean。首选的JSON-B实现是提供了依赖管理的
<a href="http://johnzon.apache.org/">Apache Johnzon</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-developing-web-applications">2.7. 开发Web应用程序</h3>
<div class="paragraph">
<p>Spring Boot非常适合于Web应用程序开发。你可以使用嵌入式Tomcat，Jetty，Undertow或Netty创建独立的HTTP服务器。
大多数Web应用程序都使用 <code>spring-boot-starter-web</code> 模块来快速启动和运行。
你还可以选择使用 <code>spring-boot-starter-webflux</code> 模块构建响应式Web应用程序。</p>
</div>
<div class="sect3">
<h4 id="boot-features-spring-mvc">2.7.1. Spring Web MVC框架</h4>
<div class="paragraph">
<p><a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">Spring Web MVC框架</a>
（通常简称为“Spring MVC”）是一个丰富的“<code>model view controller</code>”Web框架。
Spring MVC使你可以创建特殊的 <code>@Controller</code> 或 <code>@RestController</code> Bean来处理传入的HTTP请求。
使用 <code>@RequestMapping</code> 注解将控制器中的方法映射到HTTP。</p>
</div>
<div class="paragraph">
<p>以下代码显示了提供JSON数据返回的典型 <code>@RestController</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping(value="/users")
public class MyRestController {

    @RequestMapping(value="/{user}", method=RequestMethod.GET)
    public User getUser(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}/customers", method=RequestMethod.GET)
    List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @RequestMapping(value="/{user}", method=RequestMethod.DELETE)
    public User deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring MVC是核心Spring Framework的一部分，有关详细信息，请参阅 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">参考文档</a>。
在 spring.io/guides 上还有一些涵盖Spring MVC的指南。</p>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-auto-configuration">Spring MVC自动配置</h5>
<div class="paragraph">
<p>Spring Boot为Spring MVC提供了自动配置，可与大多数应用程序完美配合。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含 <code>ContentNegotiatingViewResolver</code> 和 <code>BeanNameViewResolver</code> Bean。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>Converter</code>，<code>GenericConverter</code> 和 <code>Formatter</code> Bean。</p>
</li>
<li>
<p>对 <code>HttpMessageConverters</code> 的支持（<a href="#boot-features-spring-mvc-message-converters">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动注册 <code>MessageCodesResolver</code>（<a href="#boot-features-spring-message-codes">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>静态 <code>index.html</code> 支持。</p>
</li>
<li>
<p>自定义 <code>Favicon</code> 支持（<a href="#boot-features-spring-mvc-favicon">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>自动使用 <code>ConfigurableWebBindingInitializer</code> Bean（<a href="#boot-features-spring-mvc-web-binding-initializer">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot MVC功能并想要添加其他 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc">MVC配置</a>（拦截器，格式化程序，视图控制器和其他功能），
则可以添加自己的类型为 <code>WebMvcConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不添加</strong> <code>@EnableWebMvc</code>。
如果希望提供 <code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code> 或
<code>ExceptionHandlerExceptionResolver</code> 的自定义实例，则可以声明一个 <code>WebMvcRegistrationsAdapter</code> 实例以提供此类组件。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring MVC，则可以添加自己的带有 <code>@EnableWebMvc</code> 注解的 <code>@Configuration</code> 类。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-message-converters">HttpMessageConverters</h5>
<div class="paragraph">
<p>Spring MVC使用 <code>HttpMessageConverter</code> 接口转换HTTP请求和响应。开箱即用中包含明智的默认设置。
例如：可以将对象自动转换为JSON（通过使用Jackson库）或XML（如果可用通过使用Jackson XML扩展或如果Jackson
XML扩展不可用通过使用JAXB）。默认情况下，字符串以 <code>UTF-8</code> 编码。</p>
</div>
<div class="paragraph">
<p>如果你需要添加或自定义转换器，则可以使用Spring Boot的 <code>HttpMessageConverters</code> 类，如以下清单所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.*;
import org.springframework.http.converter.*;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = ...
        HttpMessageConverter&lt;?&gt; another = ...
        return new HttpMessageConverters(additional, another);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上下文中存在的所有 <code>HttpMessageConverter</code> bean都将添加到转换器列表中。你也可以用相同的方法覆盖默认转换器。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-json-components">自定义JSON序列化器和反序列化器</h5>
<div class="paragraph">
<p>如果使用Jackson序列化和反序列化JSON数据，则可能要编写自己的 <code>JsonSerializer</code> 和 <code>JsonDeserializer</code> 类。
自定义序列化程序通常是 <a href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块向Jackson进行注册的</a>，
但是Spring Boot提供了替代的 <code>@JsonComponent</code> 注解，这使得直接注册Spring Bean更加容易。</p>
</div>
<div class="paragraph">
<p>你可以直接在 <code>JsonSerializer</code>，<code>JsonDeserializer</code> 或 <code>KeyDeserializer</code> 实现上使用 <code>@JsonComponent</code> 注解。
你还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

    public static class Serializer extends JsonSerializer&lt;SomeObject&gt; {
        // ...
    }

    public static class Deserializer extends JsonDeserializer&lt;SomeObject&gt; {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ApplicationContext</code> 中的所有 <code>@JsonComponent</code> bean都会自动向Jackson注册。
因为 <code>@JsonComponent</code> 用 <code>@Component</code> 进行元注解，所以适用常规的组件扫描规则。</p>
</div>
<div class="paragraph">
<p>Spring Boot还提供了 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java"><code>JsonObjectSerializer</code></a>
和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java"><code>JsonObjectDeserializer</code></a>基类，
这些基类在序列化对象时为标准Jackson版本提供了有用的替代方法。有关详细信息，请参见Javadoc中的
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jackson/JsonObjectSerializer.html"><code>JsonObjectSerializer</code></a>和
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jackson/JsonObjectDeserializer.html"><code>JsonObjectDeserializer</code></a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-message-codes">MessageCodesResolver</h5>
<div class="paragraph">
<p>Spring MVC有一种生成错误码以从绑定错误中呈现错误消息的策略：<code>MessageCodesResolver</code>。
如果你设置 <code>spring.mvc.message-codes-resolver-format</code> 属性为 <code>PREFIX_ERROR_CODE</code> 或 <code>POSTFIX_ERROR_CODE</code>，
Spring Boot会为你创建一个（请参见 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html"><code>DefaultMessageCodesResolver.Format</code></a>中的枚举）。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-static-content">静态内容</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中的 <code>/static</code> 目录（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/ resources</code>）
或ServletContext的根目录中提供静态内容。它使用Spring MVC中的 <code>ResourceHttpRequestHandler</code>，
以便你可以通过添加自己的 <code>WebMvcConfigurer</code> 并重写 <code>addResourceHandlers</code> 方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>在独立的Web应用程序中，还启用了容器中的默认Servlet，并将其用作降级方案，如果Spring决定不处理，
则从 <code>ServletContext</code> 的根目录提供内容。在大多数情况下，这不会发生（除非你修改默认的MVC配置），
因为Spring始终可以通过 <code>DispatcherServlet</code> 处理请求。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以使用 <code>spring.mvc.static-path-pattern</code> 属性进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以按如下方式实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 属性来自定义静态资源位置（用目录位置列表替换默认值）。
根Servlet上下文路径 <code>"/"</code> 也会作为位置自动添加。</p>
</div>
<div class="paragraph">
<p>除了前面提到的“标准”静态资源位置， <a href="https://www.webjars.org/">Webjars 内容</a>还有一个特殊情况。
如果jar文件以Webjars格式打包，则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你的应用程序打包为jar，则不要使用 <code>src/main/webapp</code> 目录。尽管此目录是一个通用标准，
但它仅与war打包一起使用，并且如果生成jar，大多数构建工具都将其忽略。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot还支持Spring MVC提供的高级资源处理功能，允许使用案例如：缓存清除静态资源或对Webjars使用版本无关的URL。</p>
</div>
<div class="paragraph">
<p>要对Webjars使用版本无关的URL，请添加 <code>webjars-locator-core</code> 依赖项，然后声明你的Webjar。
以jQuery为例，添加 <code>"/webjars/jquery/jquery.min.js"</code> 将得到 <code>"/webjars/jquery/x.y.z/jquery.min.js"</code>，
其中 <code>x.y.z</code> 是Webjar版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用JBoss，则需要声明 <code>webjars-locator-jboss-vfs</code> 依赖项，而不是 <code>webjars-locator-core</code>。
否则，所有Webjar都解析为 <code>404</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，并在URL中有效地添加了内容哈希，例如：
<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过为Thymeleaf和FreeMarker自动配置 <code>ResourceUrlEncodingFilter</code>，可以在运行时在模板中重写到资源的链接。
使用JSP时，你应该手动声明此过滤器。当前尚不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，以及使用
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如：当使用JavaScript模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以相互组合的原因。
“固定”策略在URL中添加静态版本字符串，而不更改文件名，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.resources.chain.strategy.content.enabled=true
spring.resources.chain.strategy.content.paths=/**
spring.resources.chain.strategy.fixed.enabled=true
spring.resources.chain.strategy.fixed.paths=/js/lib/
spring.resources.chain.strategy.fixed.version=v12</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这种配置，位于 <code>"/js/lib/"</code> 下的JavaScript模块使用固定的版本控制策略（<code>"/v12/js/lib/mymodule.js"</code>），
而其他资源仍使用内容版本（<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/&gt;</code>）。</p>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java"><code>ResourceProperties</code></a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该功能已在专门的 <a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">博客文章</a>
和Spring Framework的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-config-static-resources">参考文档</a>中进行了详细说明。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-welcome-page">欢迎页面</h5>
<div class="paragraph">
<p>Spring Boot支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找 <code>index.html</code> 文件。如果未找到，则寻找 <code>index</code>
模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-favicon">自定义图标</h5>
<div class="paragraph">
<p>与其他静态资源一样，Spring Boot在已配置的静态内容位置中查找 <code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-pathmatch">路径匹配和内容协商</h5>
<div class="paragraph">
<p>Spring MVC可以通过查看请求路径并将其匹配到应用程序中定义的映射（例如：Controller方法上的 <code>@GetMapping</code> 注解）来将传入的HTTP请求映射到处理程序。</p>
</div>
<div class="paragraph">
<p>Spring Boot选择默认情况下禁用后缀模式匹配，这意味着 <code>"GET /projects/spring-boot.json"</code> 之类的请求将不会与
<code>@GetMapping("/projects/spring-boot")</code> 映射进行匹配。这被认为是
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC应用程序的最佳实践</a>。
过去，此功能主要用于未发送正确的“Accept”请求头的HTTP客户端，我们需要确保将正确的内容类型发送给客户端。
如今，内容协商已变得更加可靠。</p>
</div>
<div class="paragraph">
<p>还有其他处理HTTP客户端的方法，这些客户端不能始终发送正确的“Accept”请求头。
除了使用后缀匹配，我们还可以使用查询参数来确保将诸如 <code>"GET /projects/spring-boot?format=json"</code> 之类的请求映射到
<code>@GetMapping("/projects/spring-boot")</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true

# We can change the parameter name, which is "format" by default:
# spring.mvc.contentnegotiation.parameter-name=myparam

# We can also register additional file extensions/media types with:
spring.mvc.contentnegotiation.media-types.markdown=text/markdown</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你了解了注意事项，但仍希望你的应用程序使用后缀模式匹配，则需要以下配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-suffix-pattern=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，与其打开所有后缀模式，不如只支持已注册的后缀模式，这更安全：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-path-extension=true
spring.mvc.pathmatch.use-registered-suffix-pattern=true

# You can also register additional file extensions/media types with:
# spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-web-binding-initializer">ConfigurableWebBindingInitializer</h5>
<div class="paragraph">
<p>Spring MVC使用 <code>WebBindingInitializer</code> 来为特定请求初始化 <code>WebDataBinder</code>。
如果创建自己的 <code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot会自动配置Spring MVC以使用它。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-mvc-template-engines">模板引擎</h5>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring MVC来提供动态HTML内容。Spring MVC支持各种模板技术，
包括Thymeleaf，FreeMarker和JSP。同样，许多其他模板引擎也提供包括他们自己的Spring MVC集成。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果可能，应避免使用JSP。将它们与嵌入式servlet容器一起使用时，存在几个<a href="#boot-features-jsp-limitations">已知的限制</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
根据你运行应用程序的方式，IntelliJ IDEA对类路径的排序不同。与使用Maven或Gradle或从其打包的jar运行应用程序时相比，
从IDE的main方法运行应用程序的顺序会有所不同。这可能导致Spring Boot无法在类路径上找到模板。
如果遇到此问题，可以在IDE中重新排序类路径，以首先放置模块的类和资源。
或者，你可以配置模板前缀以搜索类路径上的每个 <code>templates</code> 目录，例如：<code>classpath*:/templates/</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-error-handling">错误处理</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot提供一个 <code>/error</code> 映射，以一种明智的方式处理所有错误，并且在servlet容器中注册为“<code>global</code>”错误页面。
对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“<code>whitelabel</code>”错误视图以HTML格式呈现相同的数据（要对其进行自定义，请添加一个可解决 <code>error</code> 的 <code>View</code>）。
要完全替换默认行为，可以实现 <code>ErrorController</code> 并注册该类型的bean定义，或者添加类型为 <code>ErrorAttributes</code> 的bean以使用现有机制，但替换其内容。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>BasicErrorController</code> 可用作自定义 <code>ErrorController</code> 的基类。如果要为新的内容类型添加处理程序（默认是专门处理
<code>text/html</code> 并为其他所有内容提供降级功能），则此功能特别有用。为此，请继承 <code>BasicErrorController</code>，添加具有 <code>@RequestMapping</code>
的公共方法，该方法具有 <code>produces</code> 属性，并创建新类型的Bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以定义一个用 <code>@ControllerAdvice</code> 注解的类，以自定义JSON文档以针对特定的控制器和/或异常类型返回，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ControllerAdvice(basePackageClasses = AcmeController.class)
public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {

    @ExceptionHandler(YourException.class)
    @ResponseBody
    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new CustomErrorType(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == null) {
            return HttpStatus.INTERNAL_SERVER_ERROR;
        }
        return HttpStatus.valueOf(statusCode);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果与 <code>AcmeController</code> 在同一包中定义的控制器抛出 <code>YourException</code>，则使用 <code>CustomErrorType</code>
POJO的JSON表示形式而不是 <code>ErrorAttributes</code> 表示形式。</p>
</div>
<div class="sect5">
<h6 id="boot-features-error-handling-custom-error-pages">自定义错误页面</h6>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板来构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用FreeMarker模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于更复杂的映射，还可以添加实现 <code>ErrorViewResolver</code> 接口的bean，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request,
            HttpStatus status, Map&lt;String, Object&gt; model) {
        // Use the request or status to optionally return a ModelAndView
        return ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用常规的Spring MVC功能，例如： <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-exceptionhandlers"><code>@ExceptionHandler</code> 方法</a>和
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a>。然后，<code>ErrorController</code> 拾取所有未处理的异常。</p>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-error-handling-mapping-error-pages-without-mvc">在Spring MVC之外映射错误页面</h6>
<div class="paragraph">
<p>对于不使用Spring MVC的应用程序，可以使用 <code>ErrorPageRegistrar</code> 接口直接注册 <code>ErrorPages</code>。
此抽象直接与基础嵌入式servlet容器一起使用，即使你没有Spring MVC <code>DispatcherServlet</code> 它也可以使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ErrorPageRegistrar errorPageRegistrar(){
    return new MyErrorPageRegistrar();
}

// ...

private static class MyErrorPageRegistrar implements ErrorPageRegistrar {

    @Override
    public void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你在 <code>ErrorPage</code> 上注册了一个最终由 <code>Filter</code> 处理的路径（这在某些非Spring Web框架中很常见，如Jersey和Wicket），
则必须将 <code>Filter</code> 显式注册为 <code>ERROR</code> 调度程序，如下面的例子所示：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public FilterRegistrationBean myFilter() {
    FilterRegistrationBean registration = new FilterRegistrationBean();
    registration.setFilter(new MyFilter());
    ...
    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
    return registration;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，默认的 <code>FilterRegistrationBean</code> 不包含 <code>ERROR</code> 调度程序类型。</p>
</div>
<div id="boot-features-error-handling-websphere" class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
当部署到Servlet容器时，Spring Boot使用其错误页面过滤器将具有错误状态的请求转发到适当的错误页面。
如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0
及更高版本在成功完成servlet的服务方法后提交响应。
你应该通过将 <code>com.ibm.ws.webcontainer.invokeFlushAfterService</code> 设置为 <code>false</code> 来禁用此行为。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-hateoas">Spring HATEOAS</h5>
<div class="paragraph">
<p>如果你开发使用超媒体的RESTful API，Spring Boot将为Spring HATEOAS提供自动配置，
该配置可与大多数应用程序很好地兼容。自动配置取代了手动使用 <code>@EnableHypermediaSupport</code> 的需要，
并注册了许多bean来简化基于超媒体的应用程序的构建，其中包括 <code>LinkDiscoverers</code>（用于客户端支持）和 <code>ObjectMapper</code>
其配置为将响应正确地组装为所需的表示形式。通过设置各种 <code>spring.jackson.*</code> 属性，
或通过 <code>Jackson2ObjectMapperBuilder</code> bean（如果存在）来定制 <code>ObjectMapper</code>。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@EnableHypermediaSupport</code> 来控制Spring HATEOAS的配置。请注意，这样做会禁用前面所述的 <code>ObjectMapper</code> 定制。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-cors">CORS支持</h5>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>（CORS）是由 <a href="https://caniuse.com/#feat=cors">大多数浏览器</a>实施的
<a href="https://www.w3.org/TR/cors/">W3C 规范</a>，可让你灵活地指定授权哪种类型的跨域请求，而不是使用诸如IFRAME或JSONP之类的安全性较低，功能较弱的方法。</p>
</div>
<div class="paragraph">
<p>从4.2版本开始，Spring MVC <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors">支持CORS</a>。在Spring Boot应用程序中使用带有
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a>
注解的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors-controller">控制器方法CORS配置</a>不需要任何特定的配置。
可以通过使用自定义的 <code>addCorsMappings(CorsRegistry)</code> 方法注册 <code>WebMvcConfigurer</code> Bean来定义
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.html#mvc-cors-global">全局CORS配置</a>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        };
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webflux">2.7.2. Spring WebFlux框架</h4>
<div class="paragraph">
<p>Spring WebFlux是Spring Framework 5.0中引入的新响应式Web框架。
与Spring MVC不同，它不需要Servlet API，是完全异步和非阻塞的，并且通过 <a href="https://projectreactor.io/">Reactor项目</a>
实现 <a href="https://www.reactive-streams.org/">Reactive Streams</a>规范。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux有两种形式：函数式的和基于注解的。基于注解的模型非常类似于Spring MVC模型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/users")
public class MyRestController {

    @GetMapping("/{user}")
    public Mono&lt;User&gt; getUser(@PathVariable Long user) {
        // ...
    }

    @GetMapping("/{user}/customers")
    public Flux&lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
        // ...
    }

    @DeleteMapping("/{user}")
    public Mono&lt;User&gt; deleteUser(@PathVariable Long user) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>函数式变体“<code>WebFlux.fn</code>”将路由配置与请求的实际处理分开，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class RoutingConfiguration {

    @Bean
    public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(UserHandler userHandler) {
        return route(GET("/{user}").and(accept(APPLICATION_JSON)), userHandler::getUser)
                .andRoute(GET("/{user}/customers").and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)
                .andRoute(DELETE("/{user}").and(accept(APPLICATION_JSON)), userHandler::deleteUser);
    }

}

@Component
public class UserHandler {

    public Mono&lt;ServerResponse&gt; getUser(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
        // ...
    }

    public Mono&lt;ServerResponse&gt; deleteUser(ServerRequest request) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>WebFlux是Spring Framework的一部分，其 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-fn">参考文档</a>中提供了详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以根据需要定义任意数量的 <code>RouterFunction</code> beans，以对路由器的定义进行模块化。如果需要应用优先级，可以排序Beans。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>首先将 <code>spring-boot-starter-webflux</code> 模块添加到你的应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在应用程序中同时添加 <code>spring-boot-starter-web</code> 和 <code>spring-boot-starter-webflux</code> 模块会导致Spring
Boot自动配置Spring MVC，而不是WebFlux。之所以选择这种行为，是因为许多Spring开发人员将 <code>spring-boot-starter-webflux</code>
添加到其Spring MVC应用程序中以使用响应式 <code>WebClient</code>。你仍然可以通过将选定的应用程序类型设置为
<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code> 来强制执行选择。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-auto-configuration">Spring WebFlux自动配置</h5>
<div class="paragraph">
<p>Spring Boot为Spring WebFlux提供了自动配置，可与大多数应用程序很好地配合使用。</p>
</div>
<div class="paragraph">
<p>自动配置在Spring的默认设置之上添加了以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 实例配置编解码器（<a href="#boot-features-webflux-httpcodecs">在本文档后面</a>介绍）。</p>
</li>
<li>
<p>支持服务静态资源，包括对WebJars的支持（<a href="#boot-features-spring-mvc-static-content">在本文档后面</a>介绍）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你想保留Spring Boot WebFlux功能并想要添加其他WebFlux配置，则可以添加自己的类型为
<code>WebFluxConfigurer</code> 的 <code>@Configuration</code> 类，但 <strong>不</strong> 添加 <code>@EnableWebFlux</code>。</p>
</div>
<div class="paragraph">
<p>如果要完全控制Spring WebFlux，则可以添加带有 <code>@EnableWebFlux</code> 注解的自己的 <code>@Configuration</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-httpcodecs">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h5>
<div class="paragraph">
<p>Spring WebFlux使用 <code>HttpMessageReader</code> 和 <code>HttpMessageWriter</code> 接口转换HTTP请求和响应。
通过查看类路径中可用的库，使用 <code>CodecConfigurer</code> 将它们配置为具有合理的默认值。</p>
</div>
<div class="paragraph">
<p>Spring Boot为编解码器 <code>spring.codec.*</code> 提供了专用的配置属性。它还通过使用 <code>CodecCustomizer</code> 实例应用进一步的自定义。
例如，将 <code>spring.jackson.*</code> 配置keys应用于Jackson编解码器。</p>
</div>
<div class="paragraph">
<p>如果需要添加或自定义编解码器，则可以创建一个自定义 <code>CodecCustomizer</code> 组件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.codec.CodecCustomizer;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return codecConfigurer -&gt; {
            // ...
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以利用<a href="#boot-features-json-components">Boot&#8217;s自定义JSON序列化器和反序列化器</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-static-content">静态内容</h5>
<div class="paragraph">
<p>默认情况下，Spring Boot从类路径中名为 <code>/static</code>（或 <code>/public</code> 或 <code>/resources</code> 或 <code>/META-INF/resources</code>）的目录中提供静态内容。
它使用Spring WebFlux中的 <code>ResourceWebHandler</code>，以便你可以通过添加自己的 <code>WebFluxConfigurer</code> 并覆盖 <code>addResourceHandlers</code>
方法来修改该行为。</p>
</div>
<div class="paragraph">
<p>默认情况下，资源映射在 <code>/**</code> 上，但是你可以通过设置 <code>spring.webflux.static-path-pattern</code> 属性来对其进行调整。
例如：将所有资源重定位到 <code>/resources/**</code> 可以实现如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webflux.static-path-pattern=/resources/**</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以使用 <code>spring.resources.static-locations</code> 自定义静态资源位置。这样做会将默认值替换为目录位置列表。
如果这样做，默认的欢迎页面检测将切换到你的自定义位置。因此，如果启动时你指定的任何位置有 <code>index.html</code>，则它是应用程序的主页。</p>
</div>
<div class="paragraph">
<p>除了前面列出的“标准”静态资源位置外，https://www.webjars.org/[Webjar内容]有个特殊情况。如果jar文件以Webjars格式打包，
则从jar文件提供带有 <code>/webjars/**</code> 路径的所有资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring WebFlux应用程序不严格依赖Servlet API，因此不能将它们部署为war文件，也不使用 <code>src/main/webapp</code> 目录。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-template-engines">模板引擎</h5>
<div class="paragraph">
<p>除了REST Web服务之外，你还可以使用Spring WebFlux来提供动态HTML内容。
Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker和Mustache。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含对以下模板引擎的自动配置支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p>
</li>
<li>
<p><a href="https://www.thymeleaf.org">Thymeleaf</a></p>
</li>
<li>
<p><a href="https://mustache.github.io/">Mustache</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当你使用默认配置的这些模板引擎之一时，将从 <code>src/main/resources/templates</code> 中自动提取模板。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-error-handling">错误处理</h5>
<div class="paragraph">
<p>Spring Boot提供了一个 <code>WebExceptionHandler</code>，以一种明智的方式处理所有错误。它在处理顺序中的位置紧靠WebFlux提供的处理程序之前，
后者被认为是最后一个处理程序。对于机器客户端，它将生成一个JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，有一个“whitelabel”错误处理程序，以HTML格式呈现相同的数据。你还可以提供自己的HTML模板来显示错误（请参阅
<a href="#boot-features-webflux-error-handling-custom-error-pages">下一节</a>）。</p>
</div>
<div class="paragraph">
<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，你可以添加类型为 <code>ErrorAttributes</code> 的bean。</p>
</div>
<div class="paragraph">
<p>要更改错误处理行为，可以实现 <code>ErrorWebExceptionHandler</code> 并注册该类型的bean定义。由于 <code>WebExceptionHandler</code> 的级别很低，
因此Spring Boot还提供了一个方便的 <code>AbstractErrorWebExceptionHandler</code>，可让你以WebFlux函数式方式处理错误，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    // Define constructor here

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) {

        return RouterFunctions
                .route(aPredicate, aHandler)
                .andRoute(anotherPredicate, anotherHandler);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了获得更完整的图像，你还可以直接将 <code>DefaultErrorWebExceptionHandler</code> 子类化并重写特定方法。</p>
</div>
<div class="sect5">
<h6 id="boot-features-webflux-error-handling-custom-error-pages">自定义错误页面</h6>
<div class="paragraph">
<p>如果要显示给定状态码的自定义HTML错误页面，可以将文件添加到 <code>/error</code> 文件夹。
错误页面可以是静态HTML（即添加到任何静态资源文件夹下），也可以使用模板构建。文件名应为确切的状态码或系列掩码。</p>
</div>
<div class="paragraph">
<p>例如，要将 <code>404</code> 映射到静态HTML文件，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用Mustache模板映射所有 <code>5xx</code> 错误，你的文件夹结构如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- &lt;other templates&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-webflux-web-filters">Web过滤器</h5>
<div class="paragraph">
<p>Spring WebFlux提供了一个 <code>WebFilter</code> 接口，可以实现该接口来过滤HTTP请求-响应交换。
在应用程序上下文中找到的 <code>WebFilter</code> bean将自动用于过滤每个交换。</p>
</div>
<div class="paragraph">
<p>如果过滤器的顺序很重要，则可以实现 <code>Ordered</code> 或使用 <code>@Order</code> 进行注解。
Spring Boot自动配置会为你配置Web过滤器。这样做时，将使用下表中显示的顺序：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Web过滤器</th>
<th class="tableblock halign-left valign-top">顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MetricsWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilterChainProxy</code> (Spring Security)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-100</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpTraceWebFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE - 10</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jersey">2.7.3. JAX-RS和Jersey</h4>
<div class="paragraph">
<p>如果你更喜欢REST端点的JAX-RS编程模型，则可以使用可用的实现之一来代替Spring MVC。
<a href="https://jersey.github.io/">Jersey</a> 和 <a href="https://cxf.apache.org/">Apache CXF</a>开箱即用。
CXF要求你在应用程序上下文中将其 <code>Servlet</code> 或 <code>Filter</code> 注册为 <code>@Bean</code>。
Jersey提供了一些native Spring支持，因此我们还在Spring Boot中提供了对它的自动配置支持，以及一个启动器。</p>
</div>
<div class="paragraph">
<p>要开始使用Jersey，请将 <code>spring-boot-starter-jersey</code> 作为依赖项包括在内，然后需要一个
<code>ResourceConfig</code> 类型的 <code>@Bean</code>，在其中注册所有端点，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JerseyConfig extends ResourceConfig {

    public JerseyConfig() {
        register(Endpoint.class);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Jersey&#8217;s对扫描可执行档案的支持非常有限。例如：在运行可执行的war文件时，
它无法扫描在<a href="deployment.html#deployment-install">完全可执行的jar文件</a>或
<code>WEB-INF/classes</code> 中找到的包中的端点。为了避免这种限制，不应该使用 <code>packages</code> 方法，
而应该使用 <code>register</code> 方法分别注册端点，如前面的示例所示。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于更高级的定制，你还可以注册任意数量的 <code>ResourceConfigCustomizer</code> 实现beans。</p>
</div>
<div class="paragraph">
<p>所有注册的端点应为具有HTTP资源注解的 <code>@Components</code>（<code>@GET</code> 和其他注解），如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Path("/hello")
public class Endpoint {

    @GET
    public String message() {
        return "Hello";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于端点是Spring <code>@Component</code>，因此其生命周期由Spring管理，你可以使用 <code>@Autowired</code> 注解注入依赖项，
并使用 <code>@Value</code> 注解注入外部配置。默认情况下，Jersey servlet被注册并映射到 <code>/*</code>。
你可以通过将 <code>@ApplicationPath</code> 添加到 <code>ResourceConfig</code> 来更改映射。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jersey在名为 <code>jerseyServletRegistration</code> 的 <code>ServletRegistrationBean</code> 类型的 <code>@Bean</code> 中设置为Servlet。
默认情况下，该Servlet延迟初始化，但是你可以通过设置 <code>spring.jersey.servlet.load-on-startup</code> 来自定义该行为。
你可以通过创建自己的同名bean之一来禁用或覆盖该bean。你还可以通过设置 <code>spring.jersey.type=filter</code>
（在这种情况下，要替换或覆盖的 <code>@Bean</code> 是 <code>jerseyFilterRegistration</code>）来使用过滤器而不是servlet。
过滤器具有 <code>@Order</code>，你可以使用 <code>spring.jersey.filter.order</code> 进行设置。可以通过使用 <code>spring.jersey.init.*</code> 来指定属性映射，
从而为servlet和过滤器注册都赋予init参数。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-embedded-container">2.7.4. 嵌入式Servlet容器支持</h4>
<div class="paragraph">
<p>Spring Boot包括对嵌入式 <a href="https://tomcat.apache.org/">Tomcat</a>， <a href="https://www.eclipse.org/jetty/">Jetty</a>和
默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-servlets-filters-listeners">Servlets, Filters和listeners</h5>
<div class="paragraph">
<p>使用嵌入式Servlet容器时，可以通过使用Spring beans或扫描Servlet组件来注册Servlet规范中的servlets，过滤器和所有监听器（例如：<code>HttpSessionListener</code>）。</p>
</div>
<div class="sect5">
<h6 id="boot-features-embedded-container-servlets-filters-listeners-beans">将Servlets, Filters和Listeners注册为Spring Beans</h6>
<div class="paragraph">
<p>任何作为Spring Bean的 <code>Servlet</code>，<code>Filter</code> 或 <code>*Listener</code> 实例都向嵌入式容器注册。如果要在配置过程中引用
<code>application.properties</code> 中的值，这可能特别方便。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果上下文仅包含单个Servlet，则将其映射到 <code>/</code>。对于多个servlet bean，bean名称被用作路径前缀。
过滤器映射到 <code>/*</code>。</p>
</div>
<div class="paragraph">
<p>如果基于约定的映射不够灵活，则可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>
和 <code>ServletListenerRegistrationBean</code> 类进行完全控制。</p>
</div>
<div class="paragraph">
<p>通常可以使无序的过滤器beans处于安全状态。如果需要特定的顺序，则应使用 <code>@Order</code> 注解 <code>Filter</code> 或使其实现 <code>Ordered</code>。
你不能通过使用 <code>@Order</code> 注解 <code>Filter</code> 的bean方法来配置 <code>Filter</code> 的顺序。如果你不能更改 <code>Filter</code> 类以添加 <code>@Order</code> 或实现 <code>Ordered</code>，
则必须为 <code>Filter</code> 定义一个 <code>FilterRegistrationBean</code> 并使用 <code>setOrder(int)</code> 方法设置注册bean的顺序。
避免配置一个在 <code>Ordered.HIGHEST_PRECEDENCE</code> 上读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。
如果Servlet过滤器包装了请求，则应使用小于或等于 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 的顺序来配置它。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要查看应用程序中每个 <code>Filter</code> 的顺序，请为 <code>web</code> <a href="#boot-features-custom-log-groups">日志记录组</a>
（<code>logging.level.web=debug</code>）启用调试级别的日志记录。然后，将在启动时记录已注册过滤器的详细信息，包括其顺序和URL模式。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
注册 <code>Filter</code> beans时要小心，因为它们是在应用程序生命周期中很早就初始化的。如果需要注册与其他bean交互的 <code>Filter</code>
，请考虑改用 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/web/servlet/DelegatingFilterProxyRegistrationBean.html"><code>DelegatingFilterProxyRegistrationBean</code></a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-context-initializer">Servlet上下文初始化</h5>
<div class="paragraph">
<p>嵌入式Servlet容器不会直接执行Servlet 3.0+ <code>javax.servlet.ServletContainerInitializer</code> 接口或Spring的
<code>org.springframework.web.WebApplicationInitializer</code> 接口。这是一个有意的设计决定，
旨在降低在war中运行的第三方库可能破坏Spring Boot应用程序的风险。</p>
</div>
<div class="paragraph">
<p>如果你需要在Spring Boot应用程序中执行Servlet上下文初始化，则应该注册一个实现
<code>org.springframework.boot.web.servlet.ServletContextInitializer</code> 接口的bean。
单个 <code>onStartup</code> 方法提供对 <code>ServletContext</code> 的访问，并且在必要时可以轻松地用作现有 <code>WebApplicationInitializer</code> 的适配器。</p>
</div>
<div class="sect5">
<h6 id="boot-features-embedded-container-servlets-filters-listeners-scanning">扫描Servlets, Filters和Listeners</h6>
<div class="paragraph">
<p>使用嵌入式容器时，可以使用 <code>@ServletComponentScan</code> 启用自动注册带有 <code>@WebServlet</code>，<code>@WebFilter</code> 和 <code>@WebListener</code> 的类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>@ServletComponentScan</code> 在独立容器中无效，而是使用容器的内置发现机制。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-container-application-context">ServletWebServerApplicationContext</h5>
<div class="paragraph">
<p>在后台，Spring Boot使用另一种类型的 <code>ApplicationContext</code> 来支持嵌入式Servlet容器。
<code>ServletWebServerApplicationContext</code> 是 <code>WebApplicationContext</code> 的一种特殊类型，
它通过搜索单个 <code>ServletWebServerFactory</code> bean来自我引导。通常，已经自动配置了
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 或 <code>UndertowServletWebServerFactory</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通常，你不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表你创建了相应的 <code>ApplicationContext</code>
和 <code>ServletWebServerFactory</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-customizing-embedded-containers">自定义嵌入式Servlet容器</h5>
<div class="paragraph">
<p>可以使用Spring <code>Environment</code> 属性来配置常见的servlet容器设置。通常，你将在 <code>application.properties</code>
文件中定义属性。</p>
</div>
<div class="paragraph">
<p>常用服务器设置包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络设置：监听传入HTTP请求的端口（<code>server.port</code>），绑定到 <code>server.address</code> 的接口地址，等等。</p>
</li>
<li>
<p>会话设置：会话是否持久（<code>server.servlet.session.persistent</code>），会话超时（<code>server.servlet.session.timeout</code>），
会话数据的位置（<code>server.servlet.session.store-dir</code>）和会话cookie配置（<code>server.servlet.session.cookie.*</code>）。</p>
</li>
<li>
<p>错误管理：错误页面的位置（<code>server.error.path</code>）等。</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-configure-ssl">SSL</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#how-to-enable-http-response-compression">HTTP压缩</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot尝试尽可能多地公开通用设置，但这并不总是可能的。对于这些情况，
专用名称空间提供特定服务器的自定义项（请参阅 <code>server.tomcat</code> 和 <code>server.undertow</code>）。
例如：可以使用嵌入式servlet容器的特定功能配置 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-configure-accesslogs">访问日志</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关完整列表，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a>类。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="boot-features-programmatic-embedded-container-customization">编程定制</h6>
<div class="paragraph">
<p>如果需要以编程方式配置嵌入式Servlet容器，则可以注册一个实现 <code>WebServerFactoryCustomizer</code> 接口的Spring
Bean。<code>WebServerFactoryCustomizer</code> 提供对 <code>ConfigurableServletWebServerFactory</code>
的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code> 和 <code>UndertowServletWebServerFactory</code> 是
<code>ConfigurableServletWebServerFactory</code> 的专用变体，分别具有针对Tomcat，Jetty和Undertow的其他自定义设置方法。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-customizing-configurableservletwebserverfactory-directly">直接自定义ConfigurableServletWebServerFactory</h6>
<div class="paragraph">
<p>如果上述定制技术太有限，则可以自己注册 <code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>
或 <code>UndertowServletWebServerFactory</code> bean。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public ConfigurableServletWebServerFactory webServerFactory() {
    TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
    factory.setPort(9000);
    factory.setSessionTimeout(10, TimeUnit.MINUTES);
    factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, "/notfound.html"));
    return factory;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>提供了许多配置选项的设置器。如果你需要做一些更奇特的操作，还提供了几种受保护的方法“<code>hooks</code>”。有关详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">源代码文档</a>。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jsp-limitations">JSP局限性</h5>
<div class="paragraph">
<p>运行使用嵌入式servlet容器（并打包为可执行档案）的Spring Boot应用程序时，JSP支持存在一些限制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对于Jetty和Tomcat，如果使用war包装，它应该可以工作。
一个可执行的war在使用 <code>java -jar</code> 启动时可以工作，并且可以部署到任何标准容器中。使用可执行jar时不支持JSPs。</p>
</li>
<li>
<p>Undertow不支持JSPs。</p>
</li>
<li>
<p>创建定制的 <code>error.jsp</code> 页面不会覆盖默认视图以进行<a href="#boot-features-error-handling">错误处理</a>。应改用
<a href="#boot-features-error-handling-custom-error-pages">自定义错误页面</a>。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-reactive-server">2.7.5. 响应式嵌入服务器支持</h4>
<div class="paragraph">
<p>Spring Boot包含对以下响应式Web嵌入服务器的支持：Reactor Netty，Tomcat，Jetty和Undertow。
大多数开发人员使用适当的“Starter”来获取完全配置的实例。默认情况下，嵌入式服务器在端口8080上侦听HTTP请求。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-reactive-server-resources">2.7.6. 响应式服务器资源配置</h4>
<div class="paragraph">
<p>当自动配置Reactor Netty或Jetty服务器时，Spring Boot将创建特定的bean，这些bean将向服务器实例提供HTTP资源：
<code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，这些资源还将与Reactor Netty和Jetty客户端共享，以实现最佳性能，前提是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>服务器和客户端使用相同的技术</p>
</li>
<li>
<p>客户端实例是使用Spring Boot自动配置的 <code>WebClient.Builder</code> bean构建的</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>ReactorResourceFactory</code> 或 <code>JettyResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>你可以在<a href="#boot-features-webclient-runtime">WebClient Runtime部分</a>中了解有关客户端资源配置的更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-rsocket">2.8. RSocket</h3>
<div class="paragraph">
<p><a href="https://rsocket.io">RSocket</a>是用于字节流传输的二进制协议。它通过在单个连接上传递异步消息来支持对称交互模型。</p>
</div>
<div class="paragraph">
<p>Spring框架的 <code>spring-messaging</code> 模块在客户端和服务器端都支持RSocket请求者和响应者。有关更多详细信息，请参见Spring
Framework参考中的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#rsocket-spring">RSocket部分</a>，其中包括RSocket协议的概述。</p>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-strategies-auto-configuration">2.8.1. RSocket策略自动配置</h4>
<div class="paragraph">
<p>Spring Boot自动配置一个 <code>RSocketStrategies</code> bean，该bean提供了编码和解码RSocket有效载荷所需的所有基础设施。
默认情况下，自动配置将尝试（按顺序）配置以下内容：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Jackson的 <a href="https://cbor.io/">CBOR</a>编解码器</p>
</li>
<li>
<p>Jackson的JSON编解码器</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-socket</code> 启动器提供了两个依赖项。查阅<a href="#boot-features-json-jackson">Jackson支持部分</a>，
了解更多定制的可能性。</p>
</div>
<div class="paragraph">
<p>开发人员可以通过创建实现 <code>RSocketStrategiesCustomizer</code> 接口的bean来自定义 <code>RSocketStrategies</code> 组件。
请注意，它们的 <code>@Order</code> 很重要，因为它确定编解码器的顺序。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-server-auto-configuration">2.8.2. RSocket服务器自动配置</h4>
<div class="paragraph">
<p>Spring Boot提供了RSocket服务器自动配置。所需的依赖关系由 <code>spring-boot-starter-rsocket</code> 提供。</p>
</div>
<div class="paragraph">
<p>Spring Boot允许从WebFlux服务器通过WebSocket公开RSocket，或支持独立的RSocket服务器。这取决于应用程序的类型及其配置。</p>
</div>
<div class="paragraph">
<p>对于WebFlux应用程序（即 <code>WebApplicationType.REACTIVE</code> 类型），RSocket服务器只有在下列属性匹配时才会被插入到Web服务器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.mapping-path=/rsocket # a mapping path is defined
spring.rsocket.server.transport=websocket # websocket is chosen as a transport
#spring.rsocket.server.port= # no port is defined</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
只有Reactor Netty才支持将RSocket插入web服务器，因为RSocket本身就是用这个库构建的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外，RSocket TCP或Websocket服务器也可以作为独立的嵌入式服务器启动。除了依赖性要求之外，唯一需要的配置是为该服务器定义端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rsocket.server.port=9898 # the only required configuration
spring.rsocket.server.transport=tcp # you're free to configure other properties</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-messaging">2.8.3. Spring Messaging RSocket支持</h4>
<div class="paragraph">
<p>Spring Boot将为RSocket自动配置Spring Messaging基础设施。</p>
</div>
<div class="paragraph">
<p>这意味着Spring Boot将创建一个 <code>RSocketMessageHandler</code> bean，该bean将处理对你的应用程序的RSocket请求。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-rsocket-requester">2.8.4. 使用 <code>RSocketRequester</code> 调用RSocket服务</h4>
<div class="paragraph">
<p>在服务器和客户端之间建立RSocket通道后，任何一方都可以向另一方发送或接收请求。</p>
</div>
<div class="paragraph">
<p>作为服务器，你可以在RSocket <code>@Controller</code> 的任何处理程序方法上注入 <code>RSocketRequester</code> 实例。
作为客户端，你需要首先配置和建立RSocket连接。在这种情况下，Spring Boot会使用预期的编解码器自动配置 <code>RSocketRequester.Builder</code>。</p>
</div>
<div class="paragraph">
<p><code>RSocketRequester.Builder</code> 实例是一个原型bean，这意味着每个注入点将为你提供一个新实例。
这样做是有目的的，因为此构建器是有状态的，因此你不应使用同一实例创建具有不同设置的请求者。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RSocketRequester rsocketRequester;

    public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
        this.rsocketRequester = rsocketRequesterBuilder
                .connectTcp("example.org", 9898).block();
    }

    public Mono&lt;User&gt; someRSocketCall(String name) {
        return this.requester.route("user").data(name)
                .retrieveMono(User.class);
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-security">2.9. 安全</h3>
<div class="paragraph">
<p>如果 <a href="https://spring.io/projects/spring-security">Spring Security</a>在类路径上，则默认情况下Web应用程序是安全的。
Spring Boot依靠Spring Security的内容协商策略来确定是使用 <code>httpBasic</code> 还是 <code>formLogin</code>。
要将方法级安全性添加到Web应用程序，还可以使用所需的设置添加 <code>@EnableGlobalMethodSecurity</code>。
可以在 <a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#jc-method">Spring Security参考指南</a>中找到更多信息。</p>
</div>
<div class="paragraph">
<p>默认的 <code>UserDetailsService</code> 具有单个用户。用户名是 <code>user</code>，密码是随机的，并在应用程序启动时以INFO级别显示，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你微调日志记录配置，请确保将 <code>org.springframework.boot.autoconfigure.security</code> 类别设置为记录 <code>INFO</code>
级别的消息。否则，不会打印默认密码。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可以通过提供 <code>spring.security.user.name</code> 和 <code>spring.security.user.password</code> 来更改用户名和密码。</p>
</div>
<div class="paragraph">
<p>默认情况下，你在Web应用程序中获得的基本功能是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个具有内存存储的 <code>UserDetailsService</code>（如果是WebFlux应用程序，则为 <code>ReactiveUserDetailsService</code>）Bean，
一个具有已生成密码的用户（请参阅 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a>以获取用户属性）。</p>
</li>
<li>
<p>整个应用程序的基于表单的登录或HTTP基本安全性（取决于请求中的 <code>Accept</code> 头部）（包括执行器端点，如果执行器位于类路径上）。</p>
</li>
<li>
<p>用于发布身份验证事件的 <code>DefaultAuthenticationEventPublisher</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你可以通过为它添加一个bean来提供一个不同的 <code>AuthenticationEventPublisher</code>。</p>
</div>
<div class="sect3">
<h4 id="boot-features-security-mvc">2.9.1. MVC安全</h4>
<div class="paragraph">
<p>默认的安全配置在 <code>SecurityAutoConfiguration</code> 和 <code>UserDetailsServiceAutoConfiguration</code> 中实现。
<code>SecurityAutoConfiguration</code> 导入用于Web安全的 <code>SpringBootWebSecurityConfiguration</code>，
而 <code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。
要完全关闭默认的Web应用程序安全性配置或合并多个Spring Security组件（例如：OAuth 2客户端和资源服务器），
请添加类型为 <code>WebSecurityConfigurerAdapter</code> 的bean（这样做不会禁用 <code>UserDetailsService</code> 配置或Actuator的安全性）。</p>
</div>
<div class="paragraph">
<p>要关闭 <code>UserDetailsService</code> 配置，你可以添加
<code>UserDetailsService</code>、<code>AuthenticationProvider</code> 或 <code>AuthenticationManager</code> 类型的bean。</p>
</div>
<div class="paragraph">
<p>通过添加自定义 <code>WebSecurityConfigurerAdapter</code> 可以覆盖访问规则。
Spring Boot提供了便捷的方法，可用于覆盖actuator端点和静态资源的访问规则。
<code>EndpointRequest</code> 可用于创建基于 <code>management.endpoints.web.base-path</code> 属性的 <code>RequestMatcher</code>。
可以使用 <code>PathRequest</code> 为常用位置的资源创建一个 <code>RequestMatcher</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-webflux">2.9.2. WebFlux安全</h4>
<div class="paragraph">
<p>与Spring MVC应用程序类似，你可以通过添加 <code>spring-boot-starter-security</code> 依赖项来保护WebFlux应用程序。
默认的安全配置在 <code>ReactiveSecurityAutoConfiguration</code> 和 <code>UserDetailsServiceAutoConfiguration</code> 中实现。
<code>ReactiveSecurityAutoConfiguration</code> 导入 <code>WebFluxSecurityConfiguration</code> 以获得Web安全，
而 <code>UserDetailsServiceAutoConfiguration</code> 配置身份验证，这也与非Web应用程序相关。
要完全关闭默认的Web应用程序安全配置，你可以添加 <code>WebFilterChainProxy</code> 类型的Bean
（这样做不会禁用 <code>UserDetailsService</code> 配置或Actuator的安全性）。</p>
</div>
<div class="paragraph">
<p>要关闭 <code>UserDetailsService</code> 配置，你可以添加类型为 <code>ReactiveUserDetailsService</code> 或 <code>ReactiveAuthenticationManager</code>
的bean。</p>
</div>
<div class="paragraph">
<p>可以通过添加自定义 <code>SecurityWebFilterChain</code> bean来配置访问规则以及使用多个Spring Security组件
（例如：OAuth 2 Client和Resource Server）。Spring Boot提供了便捷的方法，可用于覆盖actuator端点和静态资源的访问规则。
<code>EndpointRequest</code> 可用于创建基于 <code>management.endpoints.web.base-path</code> 属性的 <code>ServerWebExchangeMatcher</code>。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>PathRequest</code> 为常用位置的资源创建 <code>ServerWebExchangeMatcher</code>。</p>
</div>
<div class="paragraph">
<p>例如，你可以通过添加以下内容来自定义安全配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    return http
        .authorizeExchange()
            .matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
            .pathMatchers("/foo", "/bar")
                .authenticated().and()
            .formLogin().and()
        .build();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-oauth2">2.9.3. OAuth2</h4>
<div class="paragraph">
<p><a href="https://oauth.net/2/">OAuth2</a>是Spring支持的一种广泛使用的授权框架。</p>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-client">客户端</h5>
<div class="paragraph">
<p>如果你在类路径中具有 <code>spring-security-oauth2-client</code>，则可以利用一些自动配置功能来轻松设置OAuth2/OpenID Connect客户端。
此配置使用 <code>OAuth2ClientProperties</code> 下的属性。相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>你可以在 <code>spring.security.oauth2.client</code> 前缀下注册多个OAuth2客户端和Provider，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client-1.client-id=abcd
spring.security.oauth2.client.registration.my-client-1.client-secret=password
spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-1.scope=user
spring.security.oauth2.client.registration.my-client-1.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-2.client-id=abcd
spring.security.oauth2.client.registration.my-client-2.client-secret=password
spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-2.scope=email
spring.security.oauth2.client.registration.my-client-2.redirect-uri=https://my-redirect-uri.com
spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic
spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server/oauth/authorize
spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server/oauth/token
spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server/userinfo
spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server/token_keys
spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect发现</a>的OpenID
Connect Providers，可以进一步简化配置。
供应商需要配置一个 <code>issuer-uri</code>，该URI是其声明的Issuer标识符。
例如，如果提供的 <code>issuer-uri</code> 是“https://example.com”，则将向“https://example.com/.well-known/openid-configuration”
发出 <code>OpenID Provider Configuration Request</code>。结果应为 <code>OpenID Provider Configuration Response</code>。
以下示例显示了如何使用 <code>issuer-uri</code> 配置OpenID Connect Provider：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，Spring Security的 <code>OAuth2LoginAuthenticationFilter</code> 仅处理与 <code>/login/oauth2/code/*</code> 匹配的URL。
如果要自定义 <code>redirect-uri</code> 以使用其他模式，则需要提供配置以处理该自定义模式。
例如，对于servlet应用程序，你可以添加自己的类似于以下内容的 <code>WebSecurityConfigurerAdapter</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
                .and()
            .oauth2Login()
                .redirectionEndpoint()
                    .baseUri("/custom-callback");
    }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="boot-features-security-oauth2-common-providers">常见供应商的OAuth2客户端注册</h6>
<div class="paragraph">
<p>对于常见的OAuth2和OpenID供应商，包括Google，Github，Facebook和Okta，我们提供了一组供应商默认值（分别为
<code>google</code>，<code>github</code>，<code>facebook</code> 和 <code>okta</code>）。</p>
</div>
<div class="paragraph">
<p>如果不需要自定义这些供应商，则可以将 <code>provider</code> 属性设置为需要为其推断默认值的属性。
另外，如果用于客户端注册的key与默认支持的供应商匹配，则Spring Boot也会进行推断。</p>
</div>
<div class="paragraph">
<p>换句话说，以下示例中的两个配置都使用Google供应商：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client.client-id=abcd
spring.security.oauth2.client.registration.my-client.client-secret=password
spring.security.oauth2.client.registration.my-client.provider=google

spring.security.oauth2.client.registration.google.client-id=abcd
spring.security.oauth2.client.registration.google.client-secret=password</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-security-oauth2-server">资源服务器</h5>
<div class="paragraph">
<p>如果你的类路径上有 <code>spring-security-oauth2-resource-server</code>，则Spring Boot可以设置OAuth2资源服务器。
对于JWT配置，需要指定JWK Set URI或OIDC Issuer URI，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果授权服务器不支持JWK Set URI，则可以使用用于验证JWT签名的公钥来配置资源服务器。
可以使用 <code>spring.security.oauth2.resourceserver.jwt.public-key-location</code> 属性来完成此操作，
该属性值需要指向包含PEM-encoded x509格式的公钥的文件。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>另外，你可以为Servlet应用程序定义自己的 <code>JwtDecoder</code> Bean，或者为响应式应用程序定义 <code>ReactiveJwtDecoder</code>。</p>
</div>
<div class="paragraph">
<p>如果使用opaque tokens而不是JWT，则可以配置以下属性以通过自省来验证tokens：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，相同的属性适用于servlet和响应式应用程序。</p>
</div>
<div class="paragraph">
<p>另外，你可以为Servlet应用程序定义自己的 <code>OpaqueTokenIntrospector</code> Bean，或者为响应式应用程序定义
<code>ReactiveOpaqueTokenIntrospector</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="授权服务器">授权服务器</h5>
<div class="paragraph">
<p>当前，Spring Security不提供对实现OAuth 2.0授权服务器的支持。但是， <a href="https://spring.io/projects/spring-security-oauth">Spring Security OAuth</a>项目提供了此功能，
最终将被Spring Security完全取代。在此之前，你可以使用 <code>spring-security-oauth2-autoconfigure</code>
模块轻松设置OAuth 2.0授权服务器；有关说明，请参见其 <a href="https://docs.spring.io/spring-security-oauth2-boot">文档</a>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-saml">2.9.4. SAML 2.0</h4>
<div class="sect4">
<h5 id="boot-features-security-saml2-relying-party">依赖方</h5>
<div class="paragraph">
<p>如果你在类路径中具有 <code>spring-security-saml2-service-provider</code>，则可以利用一些自动配置功能来轻松设置
SAML 2.0依赖方。此配置使用 <code>Saml2RelyingPartyProperties</code> 下的属性。</p>
</div>
<div class="paragraph">
<p>依赖方注册代表身份供应商IDP和服务供应商SP之间的配对配置。你可以在 <code>spring.security.saml2.relyingparty</code> 前缀下注册多个依赖方，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.identityprovider.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.identityprovider.sso-url=https://remoteidp2.sso.url</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-security-actuator">2.9.5. Actuator安全</h4>
<div class="paragraph">
<p>为了安全起见，默认情况下禁用 <code>/health</code> 和 <code>/info</code> 以外的所有actuators。
<code>management.endpoints.web.exposure.include</code> 属性可用于启用actuators。</p>
</div>
<div class="paragraph">
<p>如果Spring Security位于类路径上，并且不存在其他 <code>WebSecurityConfigurerAdapter</code>，
则除 <code>/health</code> 和 <code>/info</code> 以外的所有actuators均由Spring Boot自动配置保护。
如果定义自定义 <code>WebSecurityConfigurerAdapter</code>，则Spring Boot自动配置将退出，你将完全控制actuator访问规则。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在设置 <code>management.endpoints.web.exposure.include</code> 之前，请确保暴露的actuators不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如
Spring Security之类的方法进行保护。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-security-csrf">跨站请求伪造保护</h5>
<div class="paragraph">
<p>由于Spring Boot依赖于Spring Security的默认设置，因此CSRF保护默认情况下处于启用状态。
这意味着在使用默认安全配置时，需要POST（shutdown和loggers端点），PUT或DELETE的actuator端点将收到403 forbidden错误。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们建议仅在创建非浏览器客户端使用的服务时完全禁用CSRF保护。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>关于CSRF保护的其他信息可以在 <a href="https://docs.spring.io/spring-security/site/docs/5.2.1.RELEASE/reference/htmlsingle/#csrf">Spring Security参考指南</a>中找到。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-sql">2.10. 使用SQL数据库</h3>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-framework">Spring Framework</a>为使用SQL数据库提供了广泛的支持，从使用 <code>JdbcTemplate</code> 的直接JDBC
访问到完整的“<code>对象关系映射</code>”技术（例如：Hibernate）。
<a href="https://spring.io/projects/spring-data">Spring Data</a>提供了更高级别的功能：直接从接口创建 <code>Repository</code> 实现，并使用约定从你的方法名称生成查询。</p>
</div>
<div class="sect3">
<h4 id="boot-features-configure-datasource">2.10.1. 配置DataSource</h4>
<div class="paragraph">
<p>Java的 <code>javax.sql.DataSource</code> 接口提供了使用数据库连接的标准方法。传统上，“DataSource”使用 <code>URL</code> 和一些凭据来建立数据库连接。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多高级示例，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-configure-a-datasource">"How-to"部分</a>，通常可以完全控制DataSource的配置。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-database-support">嵌入式数据库支持</h5>
<div class="paragraph">
<p>使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。你需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
"How-to"部分包括有关 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-database-initialization">如何初始化数据库的部分</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot可以自动配置嵌入式 <a href="https://www.h2database.com">H2</a>， <a href="http://hsqldb.org/">HSQL</a>和
<a href="https://db.apache.org/derby/">Derby</a>数据库。你无需提供任何连接URL。你只需要包含要使用的嵌入式数据库的构建依赖项即可。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你在测试中使用此功能，则可能会注意到，整个测试套件将重复使用同一数据库，而不管你使用的应用程序上下文有多少。
如果要确保每个上下文都有一个单独的嵌入式数据库，则应将 <code>spring.datasource.generate-unique-name</code> 设置为true。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，典型的POM依赖关系如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;
    &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你需要依赖 <code>spring-jdbc</code> 来自动配置嵌入式数据库。在此示例中，它通过 <code>spring-boot-starter-data-jpa</code> 传递性地传入。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果出于某种原因确实为嵌入式数据库配置了连接URL，请务必确保禁用了数据库的自动关闭功能。
如果使用H2，则应使用 <code>DB_CLOSE_ON_EXIT=FALSE</code> 进行操作。如果使用HSQLDB，则应确保未使用 <code>shutdown=true</code>。
通过禁用数据库的自动关闭功能，Spring Boot可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以进行自动关闭。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connect-to-production-database">连接到生产数据库</h5>
<div class="paragraph">
<p>生产数据库连接也可以通过使用池化 <code>DataSource</code> 来自动配置。Spring Boot使用以下算法来选择特定的实现：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>我们更喜欢 <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>的性能和并发性。如果有HikariCP，我们总是选择它。</p>
</li>
<li>
<p>反之，如果Tomcat池化 <code>DataSource</code> 可用，我们将使用它。</p>
</li>
<li>
<p>HikariCP和Tomcat池数据源均不可用，如果 <a href="https://commons.apache.org/proper/commons-dbcp/">Commons DBCP2</a>可用，我们将使用它。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果你使用 <code>spring-boot-starter-jdbc</code> 或 <code>spring-boot-starter-data-jpa</code> “<code>starters</code>”，则会自动获得对
<code>HikariCP</code> 的依赖。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你可以通过设置 <code>spring.datasource.type</code> 属性来完全绕过该算法，并指定要使用的连接池。
如果你在Tomcat容器中运行应用程序，这一点尤其重要，因为默认情况下提供了 <code>tomcat-jdbc</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
其他连接池始终可以手动配置。如果定义自己的 <code>DataSource</code> bean，则不会进行自动配置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>DataSource配置由 <code>spring.datasource.*</code> 中的外部配置属性控制。例如：你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你至少应通过设置 <code>spring.datasource.url</code> 属性来指定URL。否则，Spring Boot会尝试自动配置嵌入式数据库。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你通常不需要指定 <code>driver-class-name</code> 名称，因为Spring Boot可以根据 <code>url</code> 从大多数数据库推断出它。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于要创建池化 <code>DataSource</code>，我们需要能够验证有效的 <code>Driver</code> 类是否可用，因此我们在进行任何操作之前都要进行检查。
换句话说，如果设置 <code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，则该类必须是可加载的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java"><code>DataSourceProperties</code></a>。
这些是不管实际实现如何都会起作用的标准选项。也可以使用它们各自的前缀（
<code>spring.datasource.hikari.*</code>, <code>spring.datasource.tomcat.*</code> 和 <code>spring.datasource.dbcp2.*</code>）
微调实现特定的设置。有关更多详细信息，请参阅所用连接池实现的文档。</p>
</div>
<div class="paragraph">
<p>例如，如果使用 <a href="https://tomcat.apache.org/tomcat-9.0-doc/jdbc-pool.html#Common_Attributes">Tomcat连接池</a>，则可以自定义许多其他设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Number of ms to wait before throwing an exception if no connection is available.
spring.datasource.tomcat.max-wait=10000

# Maximum number of active connections that can be allocated from this pool at the same time.
spring.datasource.tomcat.max-active=50

# Validate the connection before borrowing it from the pool.
spring.datasource.tomcat.test-on-borrow=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-a-jndi-datasource">连接到JNDI数据源</h5>
<div class="paragraph">
<p>如果你将Spring Boot应用程序部署到Application Server，则可能需要使用Application Server的内置功能来配置和管理DataSource，并使用JNDI对其进行访问。</p>
</div>
<div class="paragraph">
<p><code>spring.datasource.jndi-name</code> 属性可以用作 <code>spring.datasource.url</code>，<code>spring.datasource.username</code> 和
<code>spring.datasource.password</code> 属性的替代方案，以从特定的JNDI位置访问 <code>DataSource</code>。
例如：<code>application.properties</code> 中的以下部分显示了如何访问JBoss AS定义的 <code>DataSource</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.datasource.jndi-name=java:jboss/datasources/customers</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-using-jdbc-template">2.10.2. 使用JdbcTemplate</h4>
<div class="paragraph">
<p>Spring的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的，你可以将它们直接 <code>@Autowire</code>
到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public MyBean(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>spring.jdbc.template.*</code> 属性来自定义模板的某些属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jdbc.template.max-rows=500</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NamedParameterJdbcTemplate</code> 在幕后重用相同的 <code>JdbcTemplate</code> 实例。如果定义了多个 <code>JdbcTemplate</code>
并且不存在主要候选对象，则不会自动配置 <code>NamedParameterJdbcTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jpa-and-spring-data">2.10.3. JPA和Spring Data JPA</h4>
<div class="paragraph">
<p>Java Persistence API是一种标准技术，可让你将对象“映射”到关系数据库。
<code>spring-boot-starter-data-jpa</code> POM提供了一种快速入门的方法。它提供以下关键依赖：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hibernate: 最受欢迎的JPA实现之一。</p>
</li>
<li>
<p>Spring Data JPA: 使基于JPA的存储库的实现变得容易。</p>
</li>
<li>
<p>Spring ORMs: Spring框架对ORM的核心支持。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在这里，我们不会过多讨论JPA或 <a href="https://spring.io/projects/spring-data">Spring Data</a>。
你可以按照 <a href="https://spring.io" class="bare">https://spring.io</a> 的 <a href="https://spring.io/guides/gs/accessing-data-jpa/">“使用JPA访问数据”</a>指南进行操作，
并阅读 <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a>和 <a href="https://hibernate.org/orm/documentation/">Hibernate</a>参考文档。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-entity-classes">实体类</h5>
<div class="paragraph">
<p>传统上，JPA“<code>Entity</code>”类在 <code>persistence.xml</code> 文件中指定。在Spring Boot中，此文件不是必需的，而是使用“实体扫描”。
默认情况下，将搜索主配置类（用 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的一个）下的所有软件包。</p>
</div>
<div class="paragraph">
<p>考虑任何带有 <code>@Entity</code>，<code>@Embeddable</code> 或 <code>@MappedSuperclass</code> 注解的类。典型的实体类类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.io.Serializable;
import javax.persistence.*;

@Entity
public class City implements Serializable {

    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String state;

    // ... additional members, often include @OneToMany mappings

    protected City() {
        // no-args constructor required by JPA spec
        // this one is protected since it shouldn't be used directly
    }

    public City(String name, String state) {
        this.name = name;
        this.state = state;
    }

    public String getName() {
        return this.name;
    }

    public String getState() {
        return this.state;
    }

    // ... etc

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以使用 <code>@EntityScan</code> 注解来自定义实体扫描位置。请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-separate-entity-definitions-from-spring-configuration">“从Spring配置中分离@Entity定义”</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-jpa-repositories">Spring Data JPA存储库</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a>存储库是可以定义以访问数据的接口。JPA查询是根据你的方法名称自动创建的。
例如：<code>CityRepository</code> 接口可能声明了 <code>findAllByState(String state)</code> 方法来查找给定状态下的所有城市。</p>
</div>
<div class="paragraph">
<p>对于更复杂的查询，你可以使用Spring Data的 <a href="https://docs.spring.io/spring-data/jpa/docs/2.2.3.RELEASE/api/org/springframework/data/jpa/repository/Query.html"><code>Query</code></a>注解对方法进行注释。</p>
</div>
<div class="paragraph">
<p>Spring Data存储库通常从 <a href="https://docs.spring.io/spring-data/commons/docs/2.2.3.RELEASE/api/org/springframework/data/repository/Repository.html"><code>Repository</code></a>或
<a href="https://docs.spring.io/spring-data/commons/docs/2.2.3.RELEASE/api/org/springframework/data/repository/CrudRepository.html"><code>CrudRepository</code></a>接口继承。
如果使用自动配置，则会从包含主配置类（以 <code>@EnableAutoConfiguration</code> 或 <code>@SpringBootApplication</code> 注解的主配置类）的包中搜索存储库。</p>
</div>
<div class="paragraph">
<p>以下示例显示了典型的Spring Data存储库接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Data JPA存储库支持三种不同的引导模式：default, deferred 和 lazy。
要启用deferred引导或lazy引导，请将 <code>spring.data.jpa.repositories.bootstrap-mode</code> 属性分别设置为 <code>deferred</code> 或 <code>lazy</code>。
使用deferred或lazy启动时，自动配置的 <code>EntityManagerFactoryBuilder</code> 将使用上下文的 <code>AsyncTaskExecutor</code>（如果有）作为引导执行器。
如果存在多个，则将使用一个名为 <code>applicationTaskExecutor</code> 的执行器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们仅仅触及了Spring Data JPA的皮毛。有关完整的详细信息，请参阅 <a href="https://docs.spring.io/spring-data/jdbc/docs/1.1.3.RELEASE/reference/html/">Spring Data JPA参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-creating-and-dropping-jpa-databases">创建和删除JPA数据库</h5>
<div class="paragraph">
<p>默认情况下，<strong>仅</strong> 当你使用嵌入式数据库（H2，HSQL或Derby）时，才会自动创建JPA数据库。
你可以使用 <code>spring.jpa.*</code> 属性显式配置JPA设置。
例如：要创建和删除表，可以将以下行添加到 <code>application.properties</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.hibernate.ddl-auto=create-drop</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为此，Hibernate自己的内部属性名称是 <code>hibernate.hbm2ddl.auto</code>。
你可以使用 <code>spring.jpa.properties.*</code>（将它们添加到实体管理器时，会先剔除前缀）来设置它以及其他Hibernate本地属性。
下面的行显示了为Hibernate设置JPA属性的示例：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>spring.jpa.properties.hibernate.globally_quoted_identifiers=true</pre>
</div>
</div>
<div class="paragraph">
<p>前面示例中的行将 <code>hibernate.globally_quoted_identifiers</code> 属性值设置为 <code>true</code> 传递给Hibernate实体管理器。</p>
</div>
<div class="paragraph">
<p>默认情况下，DDL执行（或验证）推迟到 <code>ApplicationContext</code> 启动之后。还有一个 <code>spring.jpa.generate-ddl</code> 标志，
但是如果Hibernate自动配置处于活动状态，则不会使用它，因为 <code>ddl-auto</code> 设置粒度更细。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jpa-in-web-environment">在视图中打开EntityManager</h5>
<div class="paragraph">
<p>如果你正在运行Web应用程序，则Spring Boot默认情况下会注册
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html"><code>OpenEntityManagerInViewInterceptor</code></a>
以应用“在视图中打开EntityManager”模式，以允许在Web视图中进行延迟加载。
如果你不希望出现这种情况，则应在 <code>application.properties</code> 中将 <code>spring.jpa.open-in-view</code> 设置为 <code>false</code>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-data-jdbc">2.10.4. Spring Data JDBC</h4>
<div class="paragraph">
<p>Spring Data包括对JDBC的存储库支持，并将为 <code>CrudRepository</code> 上的方法自动生成SQL。对于更高级的查询，提供了 <code>@Query</code> 注解。</p>
</div>
<div class="paragraph">
<p>当必要的依赖项位于类路径上时，Spring Boot将自动配置Spring Data的JDBC存储库。
可以将它们添加到你的项目中，而只需依赖 <code>spring-boot-starter-data-jdbc</code>。
如有必要，你可以通过在应用程序中添加 <code>@EnableJdbcRepositories</code> 注解或
<code>JdbcConfiguration</code> 子类来控制Spring Data JDBC的配置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data JDBC的完整详细信息，请参考 <a href="https://docs.spring.io/spring-data/jdbc/docs/1.1.3.RELEASE/reference/html/">参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-sql-h2-console">2.10.5. 使用H2的Web控制台</h4>
<div class="paragraph">
<p><a href="https://www.h2database.com">H2数据库</a>提供了一个 <a href="https://www.h2database.com/html/quickstart.html#h2_console">基于浏览器</a>的控制台，
Spring Boot可以为你自动配置该控制台。满足以下条件时，将自动配置控制台：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你正在开发基于servlet的Web应用程序。</p>
</li>
<li>
<p><code>com.h2database:h2</code> 在类路径上。</p>
</li>
<li>
<p>你正在使用 <a href="using-spring-boot.html#using-boot-devtools">Spring Boot的开发者工具</a>。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你未使用Spring Boot的开发者工具，但仍想使用H2的控制台，则可以将 <code>spring.h2.console.enabled</code> 属性配置为 <code>true</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
H2控制台仅在开发期间使用，因此应注意确保在生产中未将 <code>spring.h2.console.enabled</code> 设置为 <code>true</code>。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-sql-h2-console-custom-path">更改H2控制台的路径</h5>
<div class="paragraph">
<p>默认情况下，该控制台在 <code>/h2-console</code> 端点可用。你可以使用 <code>spring.h2.console.path</code> 属性来自定义控制台的路径。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jooq">2.10.6. 使用jOOQ</h4>
<div class="paragraph">
<p>jOOQ Object Oriented Querying (<a href="https://www.jooq.org/">jOOQ</a>)是 <a href="https://www.datageekery.com/">Data Geekery</a>
的一种流行产品，它可以从数据库中生成Java代码，并允许你通过其流式API构建类型安全的SQL查询。商业版和开源版都可以与Spring Boot一起使用。</p>
</div>
<div class="sect4">
<h5 id="代码生成">代码生成</h5>
<div class="paragraph">
<p>为了使用jOOQ类型安全查询，你需要从数据库schema中生成Java类。你可以按照 <a href="https://www.jooq.org/doc/3.12.3/manual-single-page/#jooq-in-7-steps-step3">jOOQ用户手册</a>中的说明进行操作。
如果你使用 <code>jooq-codegen-maven</code> 插件，并且还使用 <code>spring-boot-starter-parent</code> “父POM”，
则可以安全地忽略该插件的 <code>&lt;version&gt;</code> 标签。你还可以使用Spring Boot定义的版本变量（例如：<code>h2.version</code>）
来声明插件的数据库依赖关系。以下清单显示了一个示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.jooq&lt;/groupId&gt;
    &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;
    &lt;executions&gt;
        ...
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.h2database&lt;/groupId&gt;
            &lt;artifactId&gt;h2&lt;/artifactId&gt;
            &lt;version&gt;${h2.version}&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;configuration&gt;
        &lt;jdbc&gt;
            &lt;driver&gt;org.h2.Driver&lt;/driver&gt;
            &lt;url&gt;jdbc:h2:~/yourdatabase&lt;/url&gt;
        &lt;/jdbc&gt;
        &lt;generator&gt;
            ...
        &lt;/generator&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="使用dslcontext">使用DSLContext</h5>
<div class="paragraph">
<p>jOOQ提供的流式API是通过 <code>org.jooq.DSLContext</code> 接口启动的。
Spring Boot将 <code>DSLContext</code> 自动配置为Spring Bean，并将其连接到你的应用程序 <code>DataSource</code>。
要使用 <code>DSLContext</code>，可以使用 <code>@Autowire</code>，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class JooqExample implements CommandLineRunner {

    private final DSLContext create;

    @Autowired
    public JooqExample(DSLContext dslContext) {
        this.create = dslContext;
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
jOOQ手册倾向于使用名为 <code>create</code> 的变量来保存 <code>DSLContext</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，可以使用 <code>DSLContext</code> 构造查询，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public List&lt;GregorianCalendar&gt; authorsBornAfter1980() {
    return this.create.selectFrom(AUTHOR)
        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(new GregorianCalendar(1980, 0, 1)))
        .fetch(AUTHOR.DATE_OF_BIRTH);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jooq-sql方言">jOOQ SQL方言</h5>
<div class="paragraph">
<p>除非已配置 <code>spring.jooq.sql-dialect</code> 属性，否则Spring Boot会确定要用于数据源的SQL方言。如果Spring Boot无法检测到方言，则使用 <code>DEFAULT</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot只能自动配置开源版本的jOOQ支持的方言。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="自定义jooq">自定义jOOQ</h5>
<div class="paragraph">
<p>可以通过定义自己的 <code>@Bean</code> 定义来实现更高级的自定义，这在创建jOOQ <code>Configuration</code> 时将使用。你可以为以下jOOQ类型定义bean：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConnectionProvider</code></p>
</li>
<li>
<p><code>ExecutorProvider</code></p>
</li>
<li>
<p><code>TransactionProvider</code></p>
</li>
<li>
<p><code>RecordMapperProvider</code></p>
</li>
<li>
<p><code>RecordUnmapperProvider</code></p>
</li>
<li>
<p><code>Settings</code></p>
</li>
<li>
<p><code>RecordListenerProvider</code></p>
</li>
<li>
<p><code>ExecuteListenerProvider</code></p>
</li>
<li>
<p><code>VisitListenerProvider</code></p>
</li>
<li>
<p><code>TransactionListenerProvider</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果要完全控制jOOQ配置，也可以创建自己的 <code>org.jooq.Configuration</code> <code>@Bean</code>。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-nosql">2.11. 使用NoSQL技术</h3>
<div class="paragraph">
<p>Spring Data提供了其他项目来帮助你访问各种NoSQL技术，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/projects/spring-data-mongodb">MongoDB</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-neo4j">Neo4J</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-elasticsearch">Elasticsearch</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-solr">Solr</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-redis">Redis</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-gemfire">GemFire</a> or <a href="https://spring.io/projects/spring-data-geode">Geode</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-cassandra">Cassandra</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="https://spring.io/projects/spring-data-ldap">LDAP</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot为Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase和LDAP提供自动配置。
你可以使用其他项目，但必须自己进行配置。请参阅 <a href="https://spring.io/projects/spring-data" class="bare">https://spring.io/projects/spring-data</a> 中的相应参考文档。</p>
</div>
<div class="sect3">
<h4 id="boot-features-redis">2.11.1. Redis</h4>
<div class="paragraph">
<p><a href="https://redis.io/">Redis</a>是一个缓存，消息代理和功能丰富的键值存储。
Spring Boot为 <a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>和 <a href="https://github.com/xetorthio/jedis/">Jedis</a>
客户端库以及Spring Data Redis提供的基于它们的抽象提供了基本的自动配置。</p>
</div>
<div class="paragraph">
<p>有一个 <code>spring-boot-starter-data-redis</code> &#8220;Starter&#8221; 便于收集依赖项。默认情况下，它使用
<a href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。
该启动器可以处理传统应用程序和响应式应用程序。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们还提供了一个 <code>spring-boot-starter-data-redis-reactive</code> “<code>Starter</code>”，以与具有响应式支持的其他存储保持一致。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-redis">连接到Redis</h5>
<div class="paragraph">
<p>你可以像注入其他任何Spring Bean一样注入自动配置的 <code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code> 或vanilla
<code>RedisTemplate</code> 实例。默认情况下，该实例尝试连接到位于 <code>localhost:6379</code> 的Redis服务器。
下面的清单显示了这种Bean的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private StringRedisTemplate template;

    @Autowired
    public MyBean(StringRedisTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你还可以注册任意数量的Bean，这些Bean实现 <code>LettuceClientConfigurationBuilderCustomizer</code> 以获得更高级的自定义。
如果使用Jedis，则可以使用 <code>JedisClientConfigurationBuilderCustomizer</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果添加自己的任何自动配置类型的 <code>@Bean</code>，它将替换默认值
（<code>RedisTemplate</code> 除外，除非排除是基于bean名称 <code>redisTemplate</code> 而不是其类型时）。
默认情况下，如果 <code>commons-pool2</code> 在类路径上，则会得到一个池化的连接工厂。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-mongodb">2.11.2. MongoDB</h4>
<div class="paragraph">
<p><a href="https://www.mongodb.com/">MongoDB</a>是一个开源NoSQL文档数据库，它使用类似JSON的结构而不是传统的基于表的关系数据。
Spring Boot为MongoDB的使用提供了许多便利，包括 <code>spring-boot-starter-data-mongodb</code> 和
<code>spring-boot-starter-data-mongodb-reactive</code> &#8220;Starter&#8221;。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-mongodb">连接到MongoDB数据库</h5>
<div class="paragraph">
<p>要访问Mongo数据库，可以注入自动配置的 <code>org.springframework.data.mongodb.MongoDbFactory</code>。
默认情况下，该实例尝试通过 <code>mongodb://localhost/test</code> 连接到MongoDB服务器。
以下示例显示了如何连接到MongoDB数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.data.mongodb.MongoDbFactory;
import com.mongodb.DB;

@Component
public class MyBean {

    private final MongoDbFactory mongo;

    @Autowired
    public MyBean(MongoDbFactory mongo) {
        this.mongo = mongo;
    }

    // ...

    public void example() {
        DB db = mongo.getDb();
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以设置 <code>spring.data.mongodb.uri</code> 属性来更改URL并配置其他设置，例如 <em>副本集</em>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.uri=mongodb://user:secret@mongo1.example.com:12345,mongo2.example.com:23456/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，只要你使用Mongo 2.x，就可以指定 <code>host</code>/<code>port</code>。例如：你可以在 <code>application.properties</code> 中声明以下设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.mongodb.host=mongoserver
spring.data.mongodb.port=27017</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你定义了自己的 <code>MongoClient</code>，它将用于自动配置合适的 <code>MongoDbFactory</code>。<code>com.mongodb.MongoClient</code> 和
<code>com.mongodb.client.MongoClient</code> 均受支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用Mongo 3.0 Java驱动程序，则不支持 <code>spring.data.mongodb.host</code> 和 <code>spring.data.mongodb.port</code>。
在这种情况下，应使用 <code>spring.data.mongodb.uri</code> 提供所有配置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果未指定 <code>spring.data.mongodb.port</code>，则使用默认值 <code>27017</code>。你可以从前面显示的示例中删除此行。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不使用Spring Data Mongo，则可以注入 <code>com.mongodb.MongoClient</code> bean，而不是使用 <code>MongoDbFactory</code>。
如果你想完全控制建立MongoDB连接的方式，还可以声明自己的 <code>MongoDbFactory</code> 或 <code>MongoClient</code> bean。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用响应式驱动程序，则SSL需要Netty。如果Netty可用并且尚未自定义要使用的工厂，则自动配置会自动配置该工厂。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-mongo-template">MongoTemplate</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-mongodb">Spring Data MongoDB</a>提供了一个 <a href="https://docs.spring.io/spring-data/mongodb/docs/2.2.3.RELEASE/api/org/springframework/data/mongodb/core/MongoTemplate.html"><code>MongoTemplate</code></a>类，
该类的设计与Spring的 <code>JdbcTemplate</code> 非常相似。与 <code>JdbcTemplate</code> 一样，Spring Boot为你自动配置一个Bean来注入模板，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final MongoTemplate mongoTemplate;

    @Autowired
    public MyBean(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关完整的详细信息，请参见 <a href="https://docs.spring.io/spring-data/mongodb/docs/2.2.3.RELEASE/api/org/springframework/data/mongodb/core/MongoOperations.html"><code>MongoOperations</code> Javadoc</a>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-mongodb-repositories">Spring Data MongoDB存储库</h5>
<div class="paragraph">
<p>Spring Data包括对MongoDB的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动构造查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data MongoDB共享相同的通用基础设施。你可以从以前的JPA示例开始，并假设 <code>City</code> 现在是Mongo数据类，而不是JPA
<code>@Entity</code>，它的工作方式相同，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import org.springframework.data.domain.*;
import org.springframework.data.repository.*;

public interface CityRepository extends Repository&lt;City, Long&gt; {

    Page&lt;City&gt; findAll(Pageable pageable);

    City findByNameAndStateAllIgnoringCase(String name, String state);

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以使用 <code>@EntityScan</code> 注解来自定义文档扫描位置。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data MongoDB的完整详细信息，包括其丰富的对象映射技术，请参阅其 <a href="https://spring.io/projects/spring-data-mongodb">参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-mongo-embedded">嵌入式Mongo</h5>
<div class="paragraph">
<p>Spring Boot为 <a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo">Embedded Mongo</a>提供自动配置。
要在Spring Boot应用程序中使用它，请添加对 <code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code> 的依赖。</p>
</div>
<div class="paragraph">
<p>可以通过设置 <code>spring.data.mongodb.port</code> 属性来配置Mongo监听的端口。要使用随机分配的空闲端口，请使用0值。
<code>MongoAutoConfiguration</code> 创建的 <code>MongoClient</code> 将自动配置为使用随机分配的端口。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果未配置自定义端口，则默认情况下，嵌入式支持会使用随机端口（而不是27017）。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果类路径上有SLF4J，则Mongo产生的输出将自动路由到名为 <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code> 的记录器。</p>
</div>
<div class="paragraph">
<p>你可以声明自己的 <code>IMongodConfig</code> 和 <code>IRuntimeConfig</code> bean，以控制Mongo实例的配置和日志记录路由。
可以通过声明 <code>DownloadConfigBuilderCustomizer</code> bean来定制下载配置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-neo4j">2.11.3. Neo4j</h4>
<div class="paragraph">
<p><a href="https://neo4j.com/">Neo4j</a>是一个开源NoSQL图形数据库，它使用了由一级关系连接的节点的丰富数据模型，
与传统的RDBMS方法相比，它更适合于连接的大数据。Spring Boot为Neo4j的使用提供了许多便利，包括 <code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221;。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-neo4j">连接到Neo4j数据库</h5>
<div class="paragraph">
<p>要访问Neo4j服务器，你可以注入自动配置的 <code>org.neo4j.ogm.session.Session</code>。
默认情况下，该实例尝试使用Bolt协议连接到 <code>localhost:7687</code> 处的Neo4j服务器。下面的示例显示如何注入Neo4j <code>Session</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final Session session;

    @Autowired
    public MyBean(Session session) {
        this.session = session;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以通过设置 <code>spring.data.neo4j.*</code> 属性来配置要使用的uri和凭据，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.uri=bolt://my-server:7687
spring.data.neo4j.username=neo4j
spring.data.neo4j.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过添加 <code>org.neo4j.ogm.config.Configuration</code> bean或 <code>org.neo4j.ogm.session.SessionFactory</code>
bean，可以完全控制会话的创建。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-neo4j-embedded">使用嵌入式模式</h5>
<div class="paragraph">
<p>如果将 <code>org.neo4j:neo4j-ogm-embedded-driver</code> 添加到应用程序的依赖项中，
则Spring Boot会自动配置Neo4j的进程内嵌入式实例，该实例在应用程序关闭时不会保留任何数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于嵌入式Neo4j OGM驱动程序本身不提供Neo4j内核，因此你必须自己声明 <code>org.neo4j:neo4j</code> 为依赖项。
有关兼容版本的列表，请参阅 <a href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started">Neo4j OGM文档</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当类路径上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。你可以通过设置 <code>spring.data.neo4j.embedded.enabled=false</code> 显式禁用嵌入式模式。</p>
</div>
<div class="paragraph">
<p>如果嵌入式驱动程序和Neo4j内核位于上述类路径上，
则<a href="#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test">Data Neo4j Tests</a>会自动使用嵌入式Neo4j实例。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你可以通过在配置中提供数据库文件的路径来启用嵌入式模式的持久性。
例如: <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-neo4j-ogm-native-types">使用Native类型</h5>
<div class="paragraph">
<p>Neo4j-OGM可以将某些类型（例如：<code>java.time.*</code> 中的类型）映射到基于String的属性或Neo4j提供的原生类型之一。
出于向后兼容的原因，Neo4j-OGM的默认设置是使用基于字符串的表示形式。要使用原生类型，请添加对
<code>org.neo4j:neo4j-ogm-bolt-native-types</code> 或 <code>org.neo4j:neo4j-ogm-embedded-native-types</code> 的依赖关系，
并配置 <code>spring.data.neo4j.use-native-types</code> 属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.use-native-types=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-neo4j-ogm-session">Neo4jSession</h5>
<div class="paragraph">
<p>默认情况下，如果你正在运行Web应用程序，则会话将绑定到线程以进行请求的整个处理（即，它使用“Open Session in View”模式）。
如果你不希望出现这种情况，请将以下行添加到 <code>application.properties</code> 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.neo4j.open-in-view=false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-neo4j-repositories">Spring Data Neo4j存储库</h5>
<div class="paragraph">
<p>Spring Data包括对Neo4j的存储库支持。</p>
</div>
<div class="paragraph">
<p>Spring Data Neo4j与许多其他Spring Data模块一样，与Spring Data JPA共享公共基础设施。
你可以采用前面的JPA示例，并将 <code>City</code> 定义为Neo4j OGM <code>@NodeEntity</code> 而不是JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">package com.example.myapp.domain;

import java.util.Optional;

import org.springframework.data.neo4j.repository.*;

public interface CityRepository extends Neo4jRepository&lt;City, Long&gt; {

    Optional&lt;City&gt; findOneByNameAndState(String name, String state);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-data-neo4j</code> &#8220;Starter&#8221; 可支持存储库以及事务管理。
你可以通过分别在 <code>@Configuration</code>-bean上使用 <code>@EnableNeo4jRepositories</code> 和 <code>@EntityScan</code> 来定制位置以查找存储库和实体。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data Neo4j的完整详细信息，包括其对象映射技术，请参阅 <a href="https://docs.spring.io/spring-data/neo4j/docs/5.2.3.RELEASE/reference/html/">参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-solr">2.11.4. Solr</h4>
<div class="paragraph">
<p><a href="https://lucene.apache.org/solr/">Apache Solr</a>是一个搜索引擎。
Spring Boot为Solr 5客户端库提供了基本的自动配置，并由 <a href="https://github.com/spring-projects/spring-data-solr">Spring Data Solr</a>在其之上提供了抽象。
<code>spring-boot-starter-data-solr</code> &#8220;Starter&#8221; 用于以方便的方式收集依赖项。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-solr">连接到Solr</h5>
<div class="paragraph">
<p>你可以像插入其他任何Spring Bean一样注入自动配置的 <code>SolrClient</code> 实例。默认情况下，该实例尝试连接到位于
<code><a href="http://localhost:8983/solr" class="bare">http://localhost:8983/solr</a></code> 的服务器。以下示例显示如何注入Solr bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private SolrClient solr;

    @Autowired
    public MyBean(SolrClient solr) {
        this.solr = solr;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果添加自己的类型为 <code>SolrClient</code> 的 <code>@Bean</code>，它将替换默认值。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-solr-repositories">Spring Data Solr存储库</h5>
<div class="paragraph">
<p>Spring Data包括对Apache Solr的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动为你构建查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data Solr共享相同的通用基础设施。你可以从以前的JPA示例开始，并假设 <code>City</code> 现在是
<code>@SolrDocument</code> 类，而不是JPA <code>@Entity</code>，它的工作方式相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data Solr的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/solr/docs/4.1.3.RELEASE/reference/html/">参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-elasticsearch">2.11.5. Elasticsearch</h4>
<div class="paragraph">
<p><a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>是一个开源，分布式，RESTful搜索和分析引擎。
Spring Boot为Elasticsearch提供了基本的自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot支持多个客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>官方Java“低级”和“高级”REST客户端</p>
</li>
<li>
<p>Spring Data Elasticsearch提供的 <code>ReactiveElasticsearchClient</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>传输客户端仍然可用，但是 <a href="https://github.com/spring-projects/spring-data-elasticsearch">Spring Data Elasticsearch</a>和Elasticsearch本身已弃用了它的支持。
它将在未来的版本中删除。Spring Boot提供了专用的 &#8220;Starter&#8221;, 即 <code>spring-boot-starter-data-elasticsearch</code>。</p>
</div>
<div class="paragraph">
<p>由于Elasticsearch和Spring Data Elasticsearch为REST客户端提供了官方支持，因此 <a href="https://github.com/searchbox-io/Jest">Jest</a>客户端也已被弃用。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-rest">使用REST客户端连接到Elasticsearch</h5>
<div class="paragraph">
<p>Elasticsearch附带了两个可用于查询集群的 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">REST客户端</a>：
“低级”客户端和“高级”客户端。</p>
</div>
<div class="paragraph">
<p>如果你的类路径具有 <code>org.elasticsearch.client:elasticsearch-rest-client</code> 依赖关系，Spring Boot将自动配置并注册一个 <code>RestClient</code>
Bean，默认情况下，它连接到 <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code>。你可以进一步调整 <code>RestClient</code> 的配置方式，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.rest.uris=https://search.example.com:9200
spring.elasticsearch.rest.read-timeout=10s
spring.elasticsearch.rest.username=user
spring.elasticsearch.rest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以注册任意数量的Bean，它们实现了 <code>RestClientBuilderCustomizer</code> 来进行更高级的自定义。要完全控制注册，请定义 <code>RestClient</code> bean。</p>
</div>
<div class="paragraph">
<p>如果你的类路径具有 <code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code> 依赖关系，
则Spring Boot将自动配置 <code>RestHighLevelClient</code>，它将包装任何现有的 <code>RestClient</code> bean，并重用其HTTP配置。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-reactive-rest">使用响应式REST客户端连接到Elasticsearch</h5>
<div class="paragraph">
<p><a href="https://spring.io/projects/spring-data-elasticsearch">Spring Data Elasticsearch</a> 提供了 <code>ReactiveElasticsearchClient</code>，用于以响应式方式查询Elasticsearch实例。
它基于WebFlux的 <code>WebClient</code> 构建，因此 <code>spring-boot-starter-elasticsearch</code> 和 <code>spring-boot-starter-webflux</code>
依赖关系对于启用此支持都是有用的。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Boot将自动配置并注册一个针对 <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code> 的 <code>ReactiveElasticsearchClient</code>
bean。你可以进一步调整其配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.client.reactive.endpoints=search.example.com:9200
spring.data.elasticsearch.client.reactive.use-ssl=true
spring.data.elasticsearch.client.reactive.socket-timeout=10s
spring.data.elasticsearch.client.reactive.username=user
spring.data.elasticsearch.client.reactive.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果配置属性不够，并且你想完全控制客户端配置，则可以注册自定义 <code>ClientConfiguration</code> bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-jest">使用Jest连接到Elasticsearch</h5>
<div class="paragraph">
<p>现在，Spring Boot支持官方的 <code>RestHighLevelClient</code>，不再支持Jest。</p>
</div>
<div class="paragraph">
<p>如果在类路径上有 <code>Jest</code>，则可以注入默认情况下以 <code><a href="http://localhost:9200" class="bare">http://localhost:9200</a></code> 为目标的自动配置的 <code>JestClient</code>。
你可以进一步调整客户端的配置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.elasticsearch.jest.uris=https://search.example.com:9200
spring.elasticsearch.jest.read-timeout=10000
spring.elasticsearch.jest.username=user
spring.elasticsearch.jest.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以注册任意数量的实现 <code>HttpClientConfigBuilderCustomizer</code> 的bean，以进行更高级的自定义。以下示例调整其他HTTP设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static class HttpSettingsCustomizer implements HttpClientConfigBuilderCustomizer {

    @Override
    public void customize(HttpClientConfig.Builder builder) {
        builder.maxTotalConnection(100).defaultMaxTotalConnectionPerRoute(5);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>要完全控制注册，请定义 <code>JestClient</code> bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-elasticsearch-spring-data">使用Spring Data连接到Elasticsearch</h5>
<div class="paragraph">
<p>要连接到Elasticsearch，必须定义由Spring Boot自动配置或由应用程序手动提供的 <code>RestHighLevelClient</code> bean（请参阅前面的部分）。
有了此配置后，可以像其他任何Spring bean一样注入 <code>ElasticsearchRestTemplate</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final ElasticsearchRestTemplate template;

    public MyBean(ElasticsearchRestTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在存在 <code>spring-data-elasticsearch</code> 和使用 <code>WebClient</code> 所需的依赖关系（通常是 <code>spring-boot-starter-webflux</code> ）的情况下，
Spring Boot还可以将 <code>ReactiveElasticsearchClient</code> 和 <code>ReactiveElasticsearchTemplate</code> 自动配置为bean。它们与其他REST
客户端是等效的。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-elasticsearch-repositories">Spring Data Elasticsearch存储库</h5>
<div class="paragraph">
<p>Spring Data包括对Elasticsearch的存储库支持。与前面讨论的JPA存储库一样，基本原理是根据方法名称自动为你构造查询。</p>
</div>
<div class="paragraph">
<p>实际上，Spring Data JPA和Spring Data Elasticsearch共享相同的通用基础设施。你可以从以前的JPA示例开始，并假设 <code>City</code> 现在是Elasticsearch
<code>@Document</code> 类而不是JPA <code>@Entity</code>，它的工作方式相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data Elasticsearch的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">参考文档</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot使用 <code>ElasticsearchRestTemplate</code> 或 <code>ReactiveElasticsearchTemplate</code>
bean支持经典和响应式Elasticsearch存储库。如果提供了所需的依赖项，这些bean很可能是通过Spring Boot自动配置的。</p>
</div>
<div class="paragraph">
<p>如果你希望使用自己的模板来支持Elasticsearch存储库，则可以添加自己的 <code>ElasticsearchRestTemplate</code> 或
<code>ElasticsearchOperations</code> <code>@Bean</code>，只要它名为 “<code>elasticsearchTemplate</code>” 即可。同样适用于
<code>ReactiveElasticsearchTemplate</code> 和 <code>ReactiveElasticsearchOperations</code>，其bean名称为
“<code>reactiveElasticsearchTemplate</code>”。</p>
</div>
<div class="paragraph">
<p>你可以选择使用以下属性禁用存储库支持：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.elasticsearch.repositories.enabled=false</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-cassandra">2.11.6. Cassandra</h4>
<div class="paragraph">
<p><a href="https://cassandra.apache.org/">Cassandra</a> 是一个开源的分布式数据库管理系统，旨在处理许多商用服务器上的大量数据。
Spring Boot为Cassandra提供自动配置，并由 <a href="https://github.com/spring-projects/spring-data-cassandra">Spring Data Cassandra</a>在其之上提供抽象。
有一个 <code>spring-boot-starter-data-cassandra</code> &#8220;Starter&#8221;，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-cassandra">连接到Cassandra</h5>
<div class="paragraph">
<p>你可以像使用其他任何Spring Bean一样注入自动配置的 <code>CassandraTemplate</code> 或Cassandra <code>Session</code> 实例。
<code>spring.data.cassandra.*</code> 属性可用于自定义连接。通常，你会提供 <code>keyspace-name</code> 和 <code>contact-points</code> 属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.data.cassandra.keyspace-name=mykeyspace
spring.data.cassandra.contact-points=cassandrahost1,cassandrahost2</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以注册任意数量的Bean，这些Bean实现 <code>ClusterBuilderCustomizer</code> 以获得更高级的自定义。</p>
</div>
<div class="paragraph">
<p>以下代码清单显示了如何注入Cassandra bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private CassandraTemplate template;

    @Autowired
    public MyBean(CassandraTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果添加自己的 <code>CassandraTemplate</code> 类型的 <code>@Bean</code>，它将替换默认值。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-cassandra-repositories">Spring Data Cassandra存储库</h5>
<div class="paragraph">
<p>Spring Data包括对Cassandra的基本存储库支持。当前，这比前面讨论的JPA存储库受到更多限制，并且需要使用 <code>@Query</code> 注解finder方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关Spring Data Cassandra的完整详细信息，请参阅 <a href="https://docs.spring.io/spring-data/cassandra/docs/">参考文档</a>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-couchbase">2.11.7. Couchbase</h4>
<div class="paragraph">
<p><a href="https://www.couchbase.com/">Couchbase</a> 是一个开源，分布式，多模型的NoSQL面向文档的数据库，已针对交互式应用程序进行了优化。
Spring Boot为Couchbase提供自动配置，并由 <a href="https://github.com/spring-projects/spring-data-couchbase">Spring Data Couchbase</a>在其之上提供抽象。
有 <code>spring-boot-starter-data-couchbase</code>
和 <code>spring-boot-starter-data-couchbase-reactive</code> &#8220;Starters&#8221;，用于以方便的方式收集依赖项。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-couchbase">连接到Couchbase</h5>
<div class="paragraph">
<p>你可以通过添加Couchbase SDK和一些配置来获取 <code>Bucket</code> 和 <code>Cluster</code>。
<code>spring.couchbase.*</code> 属性可用于自定义连接。通常，你会提供引导主机，存储桶名称和密码，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.bootstrap-hosts=my-host-1,192.168.1.123
spring.couchbase.bucket.name=my-bucket
spring.couchbase.bucket.password=secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你 <em>至少</em> 需要提供引导主机，在这种情况下，存储桶名称为 <code>default</code>，密码为空字符串。另外，你可以定义自己的
<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code> 来控制整个配置。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>还可以自定义某些 <code>CouchbaseEnvironment</code> 设置。例如，以下配置更改了用于打开新 <code>Bucket</code> 并启用SSL支持的超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.couchbase.env.timeouts.connect=3000
spring.couchbase.env.ssl.key-store=/location/of/keystore.jks
spring.couchbase.env.ssl.key-store-password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>检查 <code>spring.couchbase.env.*</code> 属性以获取更多详细信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spring-data-couchbase-repositories">Spring Data Couchbase Repositories</h5>
<div class="paragraph">
<p>Spring Data包括对Couchbase的存储库支持。有关Spring Data Couchbase的完整详细信息，请参阅
<a href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/">参考文档</a>。</p>
</div>
<div class="paragraph">
<p>你可以像使用任何其他Spring Bean一样注入自动配置的 <code>CouchbaseTemplate</code> 实例，前提是提供的 <em>默认</em> <code>CouchbaseConfigurer</code> 可用
（如前所述，当启用Couchbase支持时会发生这种情况）。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何注入Couchbase bean：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final CouchbaseTemplate template;

    @Autowired
    public MyBean(CouchbaseTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以在自己的配置中定义一些Bean，以覆盖自动配置所提供的那些：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个名为 <code>couchbaseTemplate</code> 的 <code>CouchbaseTemplate</code> <code>@Bean</code>。</p>
</li>
<li>
<p>一个名为 <code>couchbaseIndexManager</code> 的 <code>IndexManager</code> <code>@Bean</code>。</p>
</li>
<li>
<p>一个名为 <code>couchbaseCustomConversions</code> 的 <code>CustomConversions</code> <code>@Bean</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了避免在你自己的配置中对这些名称进行硬编码，你可以重用Spring Data Couchbase提供的 <code>BeanNames</code>。
例如，你可以自定义要使用的转换器，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class SomeConfiguration {

    @Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
    public CustomConversions myCustomConversions() {
        return new CustomConversions(...);
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果要完全绕过Spring Data Couchbase的自动配置，请提供自己的 <code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code> 实现。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-ldap">2.11.8. LDAP</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a>（轻型目录访问协议）是一种开放的，与供应商无关的行业标准应用协议，
用于通过IP网络访问和维护分布式目录信息服务。Spring Boot为任何兼容的LDAP服务器提供自动配置，
并从 <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>支持嵌入式内存LDAP服务器。</p>
</div>
<div class="paragraph">
<p>LDAP抽象由 <a href="https://github.com/spring-projects/spring-data-ldap">Spring Data LDAP</a>提供。
有一个 <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221;，以方便的方式收集依赖项。</p>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-connecting">连接到LDAP服务器</h5>
<div class="paragraph">
<p>要连接到LDAP服务器，请确保声明对 <code>spring-boot-starter-data-ldap</code> &#8220;Starter&#8221;
或 <code>spring-ldap-core</code> 的依赖关系，然后在 <code>application.properties</code> 中声明服务器的URL，如下面的例子所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.urls=ldap://myserver:1235
spring.ldap.username=admin
spring.ldap.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要自定义连接设置，则可以使用 <code>spring.ldap.base</code> 和 <code>spring.ldap.base-environment</code> 属性。</p>
</div>
<div class="paragraph">
<p>将基于这些设置自动配置 <code>LdapContextSource</code>。如果 <code>DirContextAuthenticationStrategy</code> Bean可用，
则将其与自动配置的 <code>LdapContextSource</code> 关联。如果你需要对其进行自定义（例如：使用 <code>PooledContextSource</code>），
则仍然可以注入自动配置的 <code>LdapContextSource</code>。确保将自定义的 <code>ContextSource</code> 标记为 <code>@Primary</code>，以便自动配置的 <code>LdapTemplate</code> 使用它。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-spring-data-repositories">Spring Data LDAP存储库</h5>
<div class="paragraph">
<p>Spring Data包括对LDAP的存储库支持。有关Spring Data LDAP的完整详细信息，请参阅
<a href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">参考文档</a>。</p>
</div>
<div class="paragraph">
<p>你还可以像使用其他任何Spring Bean一样注入自动配置的 <code>LdapTemplate</code> 实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final LdapTemplate template;

    @Autowired
    public MyBean(LdapTemplate template) {
        this.template = template;
    }

    // ...

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-ldap-embedded">嵌入式内存LDAP服务器</h5>
<div class="paragraph">
<p>出于测试目的，Spring Boot支持从 <a href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>自动配置内存中的LDAP服务器。
要配置服务器，请添加 <code>com.unboundid:unboundid-ldapsdk</code> 依赖项，并声明 <code>spring.ldap.embedded.base-dn</code> 属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn=dc=spring,dc=io</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以定义多个base-dn值，但是，由于可分辨的名称通常包含逗号，因此必须使用正确的符号来定义它们。</p>
</div>
<div class="paragraph">
<p>在yaml文件中，你可以使用yaml列表符号：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">spring.ldap.embedded.base-dn:
  - dc=spring,dc=io
  - dc=pivotal,dc=io</code></pre>
</div>
</div>
<div class="paragraph">
<p>在属性文件中，必须将索引包括在属性名称中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.ldap.embedded.base-dn[0]=dc=spring,dc=io
spring.ldap.embedded.base-dn[1]=dc=pivotal,dc=io</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，服务器在随机端口上启动并触发常规LDAP支持，无需指定 <code>spring.ldap.urls</code> 属性。</p>
</div>
<div class="paragraph">
<p>如果你的类路径上有一个 <code>schema.ldif</code> 文件，则该文件用于初始化服务器。如果要从其他资源加载初始化脚本，则也可以使用 <code>spring.ldap.embedded.ldif</code> 属性。</p>
</div>
<div class="paragraph">
<p>默认情况下，使用标准架构来验证 <code>LDIF</code> 文件。你可以通过设置 <code>spring.ldap.embedded.validation.enabled</code> 属性来完全关闭验证。
如果具有自定义属性，那么可以使用 <code>spring.ldap.embedded.validation.schema</code> 定义自定义属性类型或对象类。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-influxdb">2.11.9. InfluxDB</h4>
<div class="paragraph">
<p><a href="https://www.influxdata.com/">InfluxDB</a>是一个开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，
物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。</p>
</div>
<div class="sect4">
<h5 id="boot-features-connecting-to-influxdb">连接到InfluxDB</h5>
<div class="paragraph">
<p>只要 <code>influxdb-java</code> 客户端位于类路径上并设置了数据库的URL，Spring Boot就会自动配置 <code>InfluxDB</code> 实例，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.influx.url=https://172.0.0.1:8086</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果与InfluxDB的连接需要用户和密码，则可以相应地设置 <code>spring.influx.user</code> 和 <code>spring.influx.password</code> 属性。</p>
</div>
<div class="paragraph">
<p>InfluxDB依赖OkHttp。如果需要在后台调整 <code>InfluxDB</code> 使用的http客户端，则可以注册 <code>InfluxDbOkHttpClientBuilderProvider</code> bean。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-caching">2.12. 缓存</h3>
<div class="paragraph">
<p>Spring框架提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。
缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过 <code>@EnableCaching</code> 注解启用了缓存支持，Spring Boot就会自动配置缓存基础设施。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
检查Spring Framework指南的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache">相关部分</a>以获取更多详细信息。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>简而言之，将缓存添加到服务的操作就像将相关注解添加到其方法一样容易，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MathService {

    @Cacheable("piDecimals")
    public int computePiDecimal(int i) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>本示例说明了在潜在的昂贵操作上使用缓存的方法。在调用 <code>computePiDecimal</code> 之前，抽象将在 <code>piDecimals</code> 缓存中查找与 <code>i</code> 参数匹配的条目。
如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
你还可以透明地使用标准JSR-107（JCache）注解（例如：<code>@CacheResult</code>）。但是，我们强烈建议你不要混合使用Spring Cache和JCache注解。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你不添加任何特定的缓存库，Spring Boot会自动配置一个使用内存中concurrent maps的<a href="#boot-features-caching-provider-simple">简单供应商</a>。
当需要缓存时（例如：上例中的 <code>piDecimals</code>），此供应商将为你创建它。实际上，不建议将该简单供应商用于生产环境，
但是它对于入门并确保你了解功能非常有用。确定要使用的缓存供应商后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。
几乎所有供应商都要求你显式配置在应用程序中使用的每个缓存。有些提供自定义 <code>spring.cache.cache-names</code> 属性来定义默认缓存的方法。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
还可以透明地 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache-annotations-put">更新</a>或从缓存中
<a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#cache-annotations-evict">驱逐</a>数据。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-caching-provider">2.12.1. 支持的缓存供应商</h4>
<div class="paragraph">
<p>缓存抽象不提供实际的存储，而是依赖于由 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口实现的抽象。</p>
</div>
<div class="paragraph">
<p>如果尚未定义 <code>CacheManager</code> 类型的Bean或名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>
（请参阅 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a>），
则Spring Boot尝试检测以下供应商（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#boot-features-caching-provider-generic">Generic</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, and others)</p>
</li>
<li>
<p><a href="#boot-features-caching-provider-ehcache2">EhCache 2.x</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-hazelcast">Hazelcast</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-infinispan">Infinispan</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-couchbase">Couchbase</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-redis">Redis</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-caffeine">Caffeine</a></p>
</li>
<li>
<p><a href="#boot-features-caching-provider-simple">Simple</a></p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
也可以通过设置 <code>spring.cache.type</code> 属性来 <em>强制</em> 指定特定的缓存供应商。如果你需要在某些环境（例如测试）中
<a href="#boot-features-caching-provider-none">完全禁用缓存</a>，请使用此属性。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>spring-boot-starter-cache</code> “<code>Starter</code>”快速添加基本的缓存依赖项。入门程序提供了 <code>spring-context-support</code>。
如果手动添加依赖项，则必须包括 <code>spring-context-support</code> 才能使用JCache，EhCache 2.x或Caffeine支持。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>CacheManager</code> 是由Spring Boot自动配置的，则可以通过公开实现 <code>CacheManagerCustomizer</code> 接口的bean，
在完全初始化之前进一步调整其配置。下面的示例设置一个标志，指示应该将 <code>null</code> 值向下传递到基础映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; cacheManagerCustomizer() {
    return new CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() {
        @Override
        public void customize(ConcurrentMapCacheManager cacheManager) {
            cacheManager.setAllowNullValues(false);
        }
    };
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在前面的示例中，需要一个自动配置的 <code>ConcurrentMapCacheManager</code>。
如果不是这种情况（你提供了自己的配置，或者自动配置了其他缓存供应商），则根本不会调用定制程序。
你可以根据需要拥有任意数量的定制程序，也可以使用 <code>@Order</code> 或 <code>Ordered</code> 对其进行排序。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-generic">泛型</h5>
<div class="paragraph">
<p>如果上下文定义了 <em>至少一个</em> <code>org.springframework.cache.Cache</code> bean，则使用泛型缓存。
创建一个包装所有该类型Bean的 <code>CacheManager</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-jcache">JCache (JSR-107)</h5>
<div class="paragraph">
<p>通过在类路径上存在 <code>javax.cache.spi.CachingProvider</code> 引导 <a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>（即，在类路径上存在符合JSR-107的缓存库），
并且 <code>JCacheCacheManager</code> 由 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供。
提供了各种兼容的库，Spring Boot为Ehcache 3，Hazelcast和Infinispan提供了依赖管理。也可以添加任何其他兼容的库。</p>
</div>
<div class="paragraph">
<p>可能会出现多个供应商，在这种情况下，必须明确指定供应商。即使JSR-107标准没有强制采用标准化的方式来定义配置文件的位置，
Spring Boot也会尽其最大努力来容纳具有实现细节的缓存，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties"># Only necessary if more than one provider is present
spring.cache.jcache.provider=com.acme.MyCachingProvider
spring.cache.jcache.config=classpath:acme.xml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当缓存库同时提供native实现和JSR-107支持时，Spring Boot会首选JSR-107支持，因此，如果你切换到其他JSR-107实现，则可以使用相同的功能。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring Boot对<a href="#boot-features-hazelcast">Hazelcast具有常规支持</a>。
如果有单个 <code>HazelcastInstance</code> 可用，则除非指定了 <code>spring.cache.jcache.config</code> 属性，否则它也会自动用于 <code>CacheManager</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>自定义基础 <code>javax.cache.cacheManager</code> 有两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建缓存。
如果自定义了 <code>javax.cache.configuration.Configuration</code> Bean，则将其用于自定义它们。</p>
</li>
<li>
<p>使用 <code>CacheManager</code> 的引用调用 <code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code>
Bean以进行完全定制。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果定义了标准的 <code>javax.cache.CacheManager</code> bean，它将自动包装在抽象期望的 <code>org.springframework.cache
.CacheManager</code> 实现中。不再对其应用定制。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-ehcache2">EhCache 2.x</h5>
<div class="paragraph">
<p>如果可以在类路径的根目录下找到名为 <code>ehcache.xml</code> 的文件，则使用 <a href="https://www.ehcache.org/">EhCache</a> 2.x。
如果找到EhCache 2.x，则使用 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供的 <code>EhCacheCacheManager</code> 来引导缓存管理器。
也可以提供备用配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.ehcache.config=classpath:config/another-config.xml</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-hazelcast">Hazelcast</h5>
<div class="paragraph">
<p>Spring Boot对<a href="#boot-features-hazelcast">Hazelcast具有常规支持</a>。
如果已经自动配置了 <code>HazelcastInstance</code>，则将其自动包装在 <code>CacheManager</code> 中。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-infinispan">Infinispan</h5>
<div class="paragraph">
<p><a href="https://infinispan.org/">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.infinispan.config=infinispan.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建缓存。
如果定义了自定义 <code>ConfigurationBuilder</code> bean，则将其用于自定义缓存。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot对Infinispan的支持仅限于嵌入式模式，并且非常基础。
如果你需要更多选择，则应该使用官方的Infinispan Spring Boot启动器。有关更多详细信息，请参见
<a href="https://github.com/infinispan/infinispan-spring-boot">Infinispan的文档</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-couchbase">Couchbase</h5>
<div class="paragraph">
<p>如果可以使用 <a href="https://www.couchbase.com/">Couchbase</a> Java客户端和 <code>couchbase-spring-cache</code>
实现，并且<a href="#boot-features-couchbase">已配置</a>Couchbase，则将自动配置 <code>CouchbaseCacheManager</code>。
通过设置 <code>spring.cache.cache-names</code> 属性，还可以在启动时创建其他缓存。
这些缓存在自动配置的 <code>Bucket</code> 上运行。你 <em>还</em> 可以使用定制程序在另一个 <code>Bucket</code> 上创建其他缓存。
假设你在"main" <code>Bucket</code> 上需要两个缓存（<code>cache1</code> 和 <code>cache2</code>），在"another" <code>Bucket</code>
上需要一个自定义的存活时间为2秒的缓存（<code>cache3</code>）。
你可以通过配置创建前两个缓存，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以定义一个 <code>@Configuration</code> 类来配置额外的 <code>Bucket</code> 和 <code>cache3</code> 缓存，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class CouchbaseCacheConfiguration {

    private final Cluster cluster;

    public CouchbaseCacheConfiguration(Cluster cluster) {
        this.cluster = cluster;
    }

    @Bean
    public Bucket anotherBucket() {
        return this.cluster.openBucket("another", "secret");
    }

    @Bean
    public CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; cacheManagerCustomizer() {
        return c -&gt; {
            c.prepareCache("cache3", CacheBuilder.newInstance(anotherBucket())
                    .withExpiration(2));
        };
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例配置重用了通过自动配置创建的 <code>Cluster</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-redis">Redis</h5>
<div class="paragraph">
<p>如果 <a href="https://redis.io/">Redis</a>可用并已配置，则 <code>RedisCacheManager</code> 将自动配置。
通过设置 <code>spring.cache.cache-names</code> 属性可以在启动时创建其他缓存，
并且可以使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值。
例如，以下配置创建的 <code>cache1</code> 和 <code>cache2</code> 缓存的 <em>存活时间</em> 为10分钟：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=600000</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
默认情况下，会添加键前缀，这样，如果两个单独的缓存使用相同的键，则Redis不会有重叠的键，也不会返回无效值。
如果你创建自己的 <code>RedisCacheManager</code>，我们强烈建议将此设置保持启用状态。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过添加自己的 <code>RedisCacheConfiguration</code> <code>@Bean</code> 来完全控制配置。如果你要自定义序列化策略，这可能会很有用。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-caffeine">Caffeine</h5>
<div class="paragraph">
<p><a href="https://github.com/ben-manes/caffeine">Caffeine</a>是对Guava缓存的Java 8重写，取代了对Guava的支持。
如果存在Caffeine，则会自动配置 <code>CaffeineCacheManager</code>（由 <code>spring-boot-starter-cache</code> “<code>Starter</code>”提供）。
缓存可以在启动时通过设置 <code>spring.cache.cache-names</code> 属性来创建，并且可以通过以下方式之一自定义（按指示的顺序）：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>由 <code>spring.cache.caffeine.spec</code> 定义的缓存规范</p>
</li>
<li>
<p>定义了一个 <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</p>
</li>
<li>
<p>定义了一个 <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例如：以下配置将创建最大大小为500，<em>存活时间</em> 为10分钟的 <code>cache1</code> 和 <code>cache2</code> 缓存。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了 <code>com.github.benmanes.caffeine.cache.CacheLoader</code> Bean，它将自动与 <code>CaffeineCacheManager</code> 关联。
由于 <code>CacheLoader</code> 将与由缓存管理器管理的 <em>所有</em> 缓存相关联，因此必须将其定义为 <code>CacheLoader&lt;Object, Object&gt;</code>。
自动配置将忽略任何其他泛型类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-simple">Simple</h5>
<div class="paragraph">
<p>如果找不到其他供应商，则配置使用 <code>ConcurrentHashMap</code> 作为缓存存储区的简单实现。如果你的应用程序中不存在任何缓存库，则这是默认设置。
默认情况下，将根据需要创建缓存，但是你可以通过设置 <code>cache-names</code> 属性来限制可用缓存的列表。
例如，如果只需要 <code>cache1</code> 和 <code>cache2</code> 高速缓存，请按如下所示设置 <code>cache-names</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这样做，并且你的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但在启动时不会失败。
这与使用未声明的缓存时“实际”缓存供应商的行为类似。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-caching-provider-none">None</h5>
<div class="paragraph">
<p>当你的配置中存在 <code>@EnableCaching</code> 时，也需要合适的缓存配置。如果你需要在某些环境中完全禁用缓存，
请强制将缓存类型设置为 <code>none</code> 以使用no-op实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.cache.type=none</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-messaging">2.13. 消息</h3>
<div class="paragraph">
<p>Spring Framework为与消息传递系统集成提供了广泛的支持，从使用 <code>JmsTemplate</code> 简化JMS API到使用完整的基础设施异步接收消息。
Spring AMQP为高级消息队列协议提供了类似的功能集。Spring Boot还为 <code>RabbitTemplate</code> 和RabbitMQ提供了自动配置选项。
Spring WebSocket本身就包含对STOMP消息的支持，而Spring Boot通过启动器和少量的自动配置对此提供了支持。
Spring Boot还支持Apache Kafka。</p>
</div>
<div class="sect3">
<h4 id="boot-features-jms">2.13.1. JMS</h4>
<div class="paragraph">
<p><code>javax.jms.ConnectionFactory</code> 接口提供了创建用于与JMS代理进行交互的 <code>javax.jms.Connection</code> 的标准方法。
尽管Spring需要一个 <code>ConnectionFactory</code> 来与JMS一起使用，但是你通常不需要自己直接使用它，而可以依赖于更高级别的消息传递抽象。
（有关详细信息，请参见Spring Framework参考文档的 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#jms">相关部分</a>。）Spring
Boot还会自动配置必要的基础设施，以发送和接收消息。</p>
</div>
<div class="sect4">
<h5 id="boot-features-activemq">ActiveMQ支持</h5>
<div class="paragraph">
<p>当 <a href="https://activemq.apache.org/">ActiveMQ</a>在类路径上可用时，Spring Boot也可以配置 <code>ConnectionFactory</code>。
如果存在broker，则将自动启动和配置嵌入式broker（前提是未通过配置指定代理URL）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用 <code>spring-boot-starter-activemq</code>，则将提供连接或嵌入ActiveMQ实例所需的依赖关系，
以及与JMS集成的Spring基础设施。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ActiveMQ配置由 <code>spring.activemq.*</code> 中的外部配置属性控制。
例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>CachingConnectionFactory</code> 用适当的设置包装native <code>ConnectionFactory</code>，你可以通过 <code>spring.jms.*</code>
中的外部配置属性来控制这些设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想使用native池，则可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖项并相应地配置
<code>JmsPoolConnectionFactory</code> 来实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a>。
你还可以注册任意数量的实现 <code>ActiveMQConnectionFactoryCustomizer</code> 的Bean，以进行更高级的自定义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，如果destination尚不存在ActiveMQ会创建，以便根据其提供的名称来解析destinations。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-artemis">Artemis支持</h5>
<div class="paragraph">
<p>当Spring Boot检测到 <a href="https://activemq.apache.org/artemis/">Artemis</a>在类路径中可用时，它可以自动配置 <code>ConnectionFactory</code>。
如果存在broker，则将自动启动和配置嵌入式broker（除非已明确设置mode属性）。
受支持的模式是 <code>embedded</code>（以明确表明需要嵌入式broker，并且如果类路径上不存在该broker，则将发生错误）和
<code>native</code>（使用Netty传输协议连接到broker）。配置后者后，Spring Boot会配置一个 <code>ConnectionFactory</code>，
该工厂将使用默认设置连接到在本地计算机上运行的broker。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你使用 <code>spring-boot-starter-artemis</code>，则将提供连接到现有Artemis实例所需的依赖项，以及与JMS集成的Spring基础设施。
将 <code>org.apache.activemq:artemis-jms-server</code> 添加到你的应用程序中可以使你使用嵌入式模式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Artemis配置由 <code>spring.artemis.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.mode=native
spring.artemis.host=192.168.1.210
spring.artemis.port=9876
spring.artemis.user=admin
spring.artemis.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>嵌入broker时，可以选择是否要启用持久性并列出应使其可用的destinations。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，
或者你可以定义 <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> 或
<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code> 类型的bean，分别用于高级队列和主题配置。</p>
</div>
<div class="paragraph">
<p>默认情况下，<code>CachingConnectionFactory</code> 用适当的设置包装native <code>ConnectionFactory</code>，你可以通过
<code>spring.jms.*</code> 中的外部配置属性来控制这些设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你想使用native池，则可以通过向 <code>org.messaginghub:pooled-jms</code> 添加依赖项并相应地配置
<code>JmsPoolConnectionFactory</code> 来实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a>。</p>
</div>
<div class="paragraph">
<p>使用Artemis配置中的 <code>name</code> 属性或通过配置提供的名称，来根据destinations名称解析destinations，不涉及JNDI查找。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-jms-jndi">使用JNDI ConnectionFactory</h5>
<div class="paragraph">
<p>如果你正在应用程序服务器中运行应用程序，Spring Boot会尝试使用JNDI来查找JMS <code>ConnectionFactory</code>。
默认情况下，将检查 <code>java:/JmsXA</code> 和 <code>java:/XAConnectionFactory</code> 位置。
如果需要指定备用位置，则可以使用 <code>spring.jms.jndi-name</code> 属性，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jms.jndi-name=java:/MyConnectionFactory</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-jms-sending">发送消息</h5>
<div class="paragraph">
<p>Spring的 <code>JmsTemplate</code> 是自动配置的，你可以将其直接自动注入到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    @Autowired
    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html"><code>JmsMessagingTemplate</code></a>可以类似的方式注入。
如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> bean，则将其自动关联到自动配置的 <code>JmsTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-jms-receiving">接收消息</h5>
<div class="paragraph">
<p>存在JMS基础设施时，可以使用 <code>@JmsListener</code> 注解任何bean以创建监听器端点。如果未定义 <code>JmsListenerContainerFactory</code>
，则会自动配置一个默认值。如果定义了 <code>DestinationResolver</code> 或 <code>MessageConverter</code> Bean，则将其自动关联到默认工厂。</p>
</div>
<div class="paragraph">
<p>默认情况下，默认工厂是事务性的。如果你在存在 <code>JtaTransactionManager</code> 的基础设施中运行，则默认情况下它将与侦听器容器关联。
如果不是，则启用 <code>sessionTransacted</code> 标志。在后一种情况下，你可以通过在监听器方法（或其委托）上添加 <code>@Transactional</code>
来将本地数据存储事务与传入消息的处理相关联。这样可以确保本地事务完成后，接收的消息得到确认。这还包括发送已在同一JMS会话上执行的响应消息。</p>
</div>
<div class="paragraph">
<p>以下组件在 <code>someQueue</code> 目标上创建一个监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参见 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html"><code>@EnableJms</code> 的Javadoc</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你需要创建更多的 <code>JmsListenerContainerFactory</code> 实例，或者想要覆盖默认实例，Spring
Boot提供了一个 <code>DefaultJmsListenerContainerFactoryConfigurer</code>
，你可以使用它来初始化具有与自动配置相同设置的 <code>DefaultJmsListenerContainerFactory</code>。</p>
</div>
<div class="paragraph">
<p>例如，以下示例公开了另一个使用特定 <code>MessageConverter</code> 的工厂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class JmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory());
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以在任何 <code>@JmsListener</code> 注释的方法中使用工厂，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @JmsListener(destination = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-amqp">2.13.2. AMQP</h4>
<div class="paragraph">
<p>Advanced Message Queuing Protocol (AMQP) 是面向消息中间件的与平台无关的有线级别协议。
Spring AMQP项目将Spring的核心概念应用于基于AMQP的消息传递解决方案的开发。
Spring Boot为通过RabbitMQ使用AMQP提供了许多便利，包括 <code>spring-boot-starter-amqp</code> “<code>Starter</code>”。</p>
</div>
<div class="sect4">
<h5 id="boot-features-rabbitmq">RabbitMQ支持</h5>
<div class="paragraph">
<p><a href="https://www.rabbitmq.com/">RabbitMQ</a>是基于AMQP协议的轻型，可靠，可伸缩和便携式消息broker。
Spring使用 <code>RabbitMQ</code> 通过AMQP协议进行通信。</p>
</div>
<div class="paragraph">
<p>RabbitMQ配置由 <code>spring.rabbitmq.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，你可以使用 <code>addresses</code> 属性配置相同的连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.addresses=amqp://admin:secret@localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果上下文中存在 <code>ConnectionNameStrategy</code> Bean，它将自动用于命名由自动配置的 <code>ConnectionFactory</code> 创建的连接。
有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参阅 <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">了解RabbitMQ使用的AMQP协议</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-amqp-sending">发送消息</h5>
<div class="paragraph">
<p>Spring的 <code>AmqpTemplate</code> 和 <code>AmqpAdmin</code> 是自动配置的，你可以将它们直接自动注入到自己的bean中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;
    private final AmqpTemplate amqpTemplate;

    @Autowired
    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://docs.spring.io/spring-amqp/docs/2.2.2.RELEASE/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html"><code>RabbitMessagingTemplate</code></a>可以类似的方式注入。
如果定义了 <code>MessageConverter</code> bean，它将自动关联到自动配置的 <code>AmqpTemplate</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如有必要，任何定义为 <code>org.springframework.amqp.core.Queue</code> 的bean都会自动用于在RabbitMQ实例上声明相应的队列。</p>
</div>
<div class="paragraph">
<p>要重试操作，可以在 <code>AmqpTemplate</code> 上启用重试（例如，在broker连接丢失的情况下）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，重试是禁用的。你也可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean来以编程方式自定义 <code>RetryTemplate</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-using-amqp-receiving">接收消息</h5>
<div class="paragraph">
<p>存在Rabbit基础设施时，可以使用 <code>@RabbitListener</code> 注解任何bean以创建监听器端点。
如果未定义 <code>RabbitListenerContainerFactory</code>，则会自动配置默认的 <code>SimpleRabbitListenerContainerFactory</code>，
你可以使用 <code>spring.rabbitmq.listener.type</code> 属性切换到直接容器。
如果定义了 <code>MessageConverter</code> 或 <code>MessageRecoverer</code> Bean，它将自动与默认工厂关联。</p>
</div>
<div class="paragraph">
<p>以下示例组件在 <code>someQueue</code> 队列上创建一个监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关更多详细信息，请参见 <a href="https://docs.spring.io/spring-amqp/docs/2.2.2.RELEASE/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html"><code>@EnableRabbit</code> 的Javadoc</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你需要创建更多 <code>RabbitListenerContainerFactory</code> 实例，或者想要覆盖默认实例，
Spring Boot提供了一个 <code>SimpleRabbitListenerContainerFactoryConfigurer</code>
和 <code>DirectRabbitListenerContainerFactoryConfigurer</code>，
你可以使用它们来初始化 <code>SimpleRabbitListenerContainerFactory</code> 和 <code>DirectRabbitListenerContainerFactory</code>
，其设置与自动配置所使用的工厂相同。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
选择哪种容器都没有关系。这两个bean通过自动配置公开。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如，以下配置类公开了另一个使用特定 <code>MessageConverter</code> 的工厂：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
static class RabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(
            SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory =
                new SimpleRabbitListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(myMessageConverter());
        return factory;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以在任何 <code>@RabbitListener</code> 注释的方法中使用工厂，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", <strong>containerFactory="myFactory"</strong>)
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以启用重试来处理监听器引发异常的情况。默认情况下，使用 <code>RejectAndDontRequeueRecoverer</code>，
但是你可以定义自己的 <code>MessageRecoverer</code>。当重试耗尽时，消息将被拒绝，如果将broker配置为这样做，则消息将被丢弃或路由到死信交换器。
默认情况下，重试是禁用的。你也可以通过声明 <code>RabbitRetryTemplateCustomizer</code> bean来以编程方式自定义 <code>RetryTemplate</code>。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
默认情况下，如果禁用了重试，并且监听器抛出异常，则会无限期地重试传递。你可以通过两种方式修改此行为：
将 <code>defaultRequeueRejected</code> 属性设置为 <code>false</code>，以便尝试零次重新传递，或者引发
<code>AmqpRejectAndDontRequeueException</code> 以指示应拒绝该消息。后者是启用重试并达到最大传递尝试次数时使用的机制。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-kafka">2.13.3. Apache Kafka支持</h4>
<div class="paragraph">
<p>通过提供 <code>spring-kafka</code> 项目的自动配置来支持 <a href="https://kafka.apache.org/">Apache Kafka</a>。</p>
</div>
<div class="paragraph">
<p>Kafka配置由 <code>spring.kafka.*</code> 中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明以下部分：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=myGroup</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在启动时创建主题，请添加 <code>NewTopic</code> 类型的Bean。如果该主题已经存在，则将忽略该Bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有关更多受支持的选项，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a>。</p>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-sending-a-message">发送消息</h5>
<div class="paragraph">
<p>Spring的 <code>KafkaTemplate</code> 是自动配置的，你可以直接在自己的bean中自动对其进行注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    private final KafkaTemplate kafkaTemplate;

    @Autowired
    public MyBean(KafkaTemplate kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    // ...

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果定义了 <code>spring.kafka.producer.transaction-id-prefix</code> 属性，则会自动配置 <code>KafkaTransactionManager</code>。
另外，如果定义了 <code>RecordMessageConverter</code> bean，它将自动关联到自动配置的 <code>KafkaTemplate</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-receiving-a-message">接收消息</h5>
<div class="paragraph">
<p>存在Apache Kafka基础设施时，可以使用 <code>@KafkaListener</code> 注释任何bean以创建监听器端点。
如果未定义 <code>KafkaListenerContainerFactory</code>，则会使用 <code>spring.kafka.listener.*</code> 中定义的键自动配置默认值。</p>
</div>
<div class="paragraph">
<p>以下组件在 <code>someTopic</code> 主题上创建监听器端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyBean {

    @KafkaListener(topics = "someTopic")
    public void processMessage(String content) {
        // ...
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果定义了 <code>KafkaTransactionManager</code> bean，它将自动关联到容器工厂。同样，如果定义了 <code>ErrorHandler</code>，<code>AfterRollbackProcessor</code>
或 <code>ConsumerAwareRebalanceListener</code> bean，它将自动与默认工厂关联。</p>
</div>
<div class="paragraph">
<p>根据监听器类型，将 <code>RecordMessageConverter</code> 或 <code>BatchMessageConverter</code> bean与默认工厂关联。
如果对于批处理监听器仅存在一个 <code>RecordMessageConverter</code> bean，则将其包装在 <code>BatchMessageConverter</code> 中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
自定义 <code>ChainedKafkaTransactionManager</code> 必须标记为 <code>@Primary</code>，因为它通常引用自动配置的 <code>KafkaTransactionManager</code> bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-streams">Kafka流</h5>
<div class="paragraph">
<p>用于Apache Kafka的Spring提供了一个工厂bean来创建 <code>StreamsBuilder</code> 对象并管理其流的生命周期。
只要 <code>kafka-streams</code> 在类路径上并且通过 <code>@EnableKafkaStreams</code> 注解启用Kafka Streams，
Spring Boot就会自动配置所需的 <code>KafkaStreamsConfiguration</code> bean。</p>
</div>
<div class="paragraph">
<p>启用Kafka Streams意味着必须设置应用程序ID和引导服务器。
可以使用 <code>spring.kafka.streams.application-id</code> 来配置前者，如果未设置，则默认为 <code>spring.application.name</code>。
后者可以全局设置，也可以仅针对流进行覆盖。</p>
</div>
<div class="paragraph">
<p>使用专用属性可以获得几个附加属性。可以使用 <code>spring.kafka.streams.properties</code> 命名空间设置其他任意Kafka属性。
另请参见<a href="#boot-features-kafka-extra-props">Kafka的其他属性</a>。</p>
</div>
<div class="paragraph">
<p>要使用工厂bean，只需将 <code>StreamsBuilder</code> 连接到你的 <code>@Bean</code> 中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public static class KafkaStreamsExampleConfiguration {

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder streamsBuilder) {
        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream("ks1In");
        stream.map((k, v) -&gt; new KeyValue&lt;&gt;(k, v.toUpperCase())).to("ks1Out",
                Produced.with(Serdes.Integer(), new JsonSerde&lt;&gt;()));
        return stream;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，由它创建的 <code>StreamBuilder</code> 对象管理的流将自动启动。你可以使用 <code>spring.kafka.streams.auto-startup</code> 属性来自定义此行为。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-kafka-extra-props">Kafka的其他属性</h5>
<div class="paragraph">
<p>自动配置支持的属性显示在 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#common-application-properties">通用应用程序属性</a>中。
请注意，在大多数情况下，这些属性（hyphenated或camelCase）直接映射到Apache Kafka dotted属性。有关详细信息，请参阅Apache Kafka文档。</p>
</div>
<div class="paragraph">
<p>这些属性的前几个属性适用于所有组件（生产者，消费者，管理员和流），但如果你希望使用不同的值，则可以在组件级别上指定。
Apache Kafka指定属性的重要性为HIGH，MEDIUM或LOW。Spring Boot自动配置支持所有HIGH重要性属性，一些选定的MEDIUM和LOW属性以及任何没有默认值的属性。</p>
</div>
<div class="paragraph">
<p>通过 <code>KafkaProperties</code> 类可以直接使用Kafka支持的属性的子集。如果希望使用不直接支持的其他属性来配置生产者或消费者，请使用以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.properties.prop.one=first
spring.kafka.admin.properties.prop.two=second
spring.kafka.consumer.properties.prop.three=third
spring.kafka.producer.properties.prop.four=fourth
spring.kafka.streams.properties.prop.five=fifth</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将常见的 <code>prop.one</code> Kafka属性设置为 <code>first</code>（适用于生产者，消费者和管理员），<code>prop.two</code> 管理员属性设置为 <code>second</code>，
<code>prop.three</code> 消费者属性设置为 <code>third</code>，<code>prop.four</code> 生产者属性设置为 <code>fourth</code>，<code>prop.five</code> 流属性设置为 <code>fifth</code>。</p>
</div>
<div class="paragraph">
<p>你还可以如下配置Spring Kafka <code>JsonDeserializer</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.value.default.type=com.example.Invoice
spring.kafka.consumer.properties.spring.json.trusted.packages=com.example,org.acme</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，你可以禁用 <code>JsonSerializer</code> 在头部发送类型信息的默认行为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties.spring.json.add.type.headers=false</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
以这种方式设置的属性将覆盖Spring Boot显式支持的任何配置项。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-embedded-kafka">使用嵌入式Kafka进行测试</h5>
<div class="paragraph">
<p>Spring for Apache Kafka提供了一种使用嵌入式Apache Kafka broker测试项目的便捷方法。
要使用此功能，请在 <code>spring-kafka-test</code> 模块中使用 <code>@EmbeddedKafka</code> 注释测试类。
有关更多信息，请参阅Spring for Apache Kafka <a href="https://docs.spring.io/spring-kafka/docs/current/reference/html/#embedded-kafka-annotation">参考手册</a>。</p>
</div>
<div class="paragraph">
<p>要使Spring Boot自动配置与上述嵌入式Apache Kafka broker一起使用，你需要将嵌入式broker地址（由 <code>EmbeddedKafkaBroker</code> 填充）
的系统属性重新映射到Apache Kafka的Spring Boot配置属性中。有几种方法可以做到这一点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>提供一个系统属性，以将嵌入式broker地址映射到测试类中的 <code>spring.kafka.bootstrap-servers</code> 中：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <code>@EmbeddedKafka</code> 注解上配置属性名称：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@EmbeddedKafka(topics = "someTopic",
        bootstrapServersProperty = "spring.kafka.bootstrap-servers")</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>在配置属性中使用占位符：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-resttemplate">2.14. 使用 <code>RestTemplate</code> 调用REST服务</h3>
<div class="paragraph">
<p>如果你需要从应用程序中调用远程REST服务，则可以使用Spring Framework的 <a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html"><code>RestTemplate</code></a>类。
由于 <code>RestTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>RestTemplate</code> bean。
但是，它确实会自动配置 <code>RestTemplateBuilder</code>，可在需要时将其用于创建 <code>RestTemplate</code> 实例。
自动配置的 <code>RestTemplateBuilder</code> 确保将明智的 <code>HttpMessageConverters</code> 应用于 <code>RestTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>RestTemplateBuilder</code> 包含许多有用的方法，可用于快速配置 <code>RestTemplate</code>。例如：要添加BASIC身份验证支持，
可以使用 <code>builder.basicAuthentication("user", "password").build()</code>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-resttemplate-customization">2.14.1. RestTemplate自定义</h4>
<div class="paragraph">
<p><code>RestTemplate</code> 自定义有三种主要方法，具体取决于你要应用自定义的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>RestTemplateBuilder</code>，然后根据需要调用其方法。
每个方法调用都返回一个新的 <code>RestTemplateBuilder</code> 实例，因此自定义项仅影响此builder的使用。</p>
</div>
<div class="paragraph">
<p>要进行应用程序作用域的附加自定义，请使用 <code>RestTemplateCustomizer</code> bean。
所有此类bean都会自动注册到自动配置的 <code>RestTemplateBuilder</code> 中，并应用于使用它构建的任何模板。</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个定制程序，该定制程序为除 <code>192.168.0.5</code> 之外的所有主机配置使用代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，最极端（很少使用）的选项是创建自己的 <code>RestTemplateBuilder</code> bean。
这样做会关闭 <code>RestTemplateBuilder</code> 的自动配置，并阻止使用任何 <code>RestTemplateCustomizer</code> Bean。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webclient">2.15. 使用 <code>WebClient</code> 调用REST服务</h3>
<div class="paragraph">
<p>如果你的类路径中包含Spring WebFlux，则还可以选择使用 <code>WebClient</code> 调用远程REST服务。
与 <code>RestTemplate</code> 相比，此客户端具有更强的功能性，并且是完全响应性的。
你可以在 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-client">Spring Framework文档的专用部分</a>中了解有关 <code>WebClient</code> 的更多信息。</p>
</div>
<div class="paragraph">
<p>Spring Boot为你创建并预配置了 <code>WebClient.Builder</code>。强烈建议将其注入你的组件中，并使用它来创建 <code>WebClient</code> 实例。
Spring Boot将该builder配置为共享HTTP资源，以与服务器相同的方式反映编解码器的设置
（请参阅<a href="#boot-features-webflux-httpcodecs">WebFlux HTTP codecs自动配置</a>），等等。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name)
                        .retrieve().bodyToMono(Details.class);
    }

}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webclient-runtime">2.15.1. WebClient运行时</h4>
<div class="paragraph">
<p>Spring Boot将根据应用程序类路径上可用的库自动检测要使用哪个 <code>ClientHttpConnector</code> 来驱动 <code>WebClient</code>。
目前支持Reactor Netty和Jetty RS客户端。</p>
</div>
<div class="paragraph">
<p><code>spring-boot-starter-webflux</code> 启动器默认情况下依赖于 <code>io.projectreactor.netty:reactor-netty</code>，
这带来了服务器和客户端的实现。如果选择使用Jetty作为响应式服务器，则应该添加对Jetty响应式HTTP客户端库
<code>org.eclipse.jetty:jetty-reactive-httpclient</code> 的依赖。
对服务器和客户端使用相同的技术具有优势，因为它将自动在客户端和服务器之间共享HTTP资源。</p>
</div>
<div class="paragraph">
<p>通过提供自定义的 <code>JettyResourceFactory</code> 或 <code>ReactorResourceFactory</code> bean，开发人员可以覆盖Jetty和Reactor
Netty的资源配置&#8201;&#8212;&#8201;这将同时应用于客户端和服务器。</p>
</div>
<div class="paragraph">
<p>如果你希望为客户端覆盖该选项，则可以定义自己的 <code>ClientHttpConnector</code> bean，并完全控制客户端配置。</p>
</div>
<div class="paragraph">
<p>你可以 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-client-builder">在Spring Framework参考文档中了解有关 <code>WebClient</code> 配置选项</a>的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webclient-customization">2.15.2. WebClient自定义</h4>
<div class="paragraph">
<p><code>WebClient</code> 自定义有三种主要方法，具体取决于你希望自定义应用的范围。</p>
</div>
<div class="paragraph">
<p>为了使所有自定义项的作用域尽可能狭窄，请注入自动配置的 <code>WebClient.Builder</code>，然后根据需要调用其方法。
<code>WebClient.Builder</code> 实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有客户端中。
如果要使用同一构建器创建多个客户端，则还可以考虑使用 <code>WebClient.Builder other = builder.clone();</code> 克隆该构建器。</p>
</div>
<div class="paragraph">
<p>要对所有 <code>WebClient.Builder</code> 实例进行应用程序作用域的附加自定义，可以声明 <code>WebClientCustomizer</code> bean
并在注入点本地更改 <code>WebClient.Builder</code>。</p>
</div>
<div class="paragraph">
<p>最后，你可以回退到原始API并使用 <code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或 <code>WebClientCustomizer</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-validation">2.16. 验证</h3>
<div class="paragraph">
<p>只要JSR-303实现（例如：Hibernate验证器）位于类路径上，就会自动启用Bean验证1.1支持的方法验证功能。
这使bean方法的参数和/或返回值可以使用 <code>javax.validation</code> 约束进行注解。
具有此类注解方法的目标类需要在类型级别使用 <code>@Validated</code> 注解进行注释，以便在其方法中搜索内联约束注解。</p>
</div>
<div class="paragraph">
<p>例如：以下服务触发第一个参数的验证，确保其大小在8到10之间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
@Validated
public class MyBean {

    public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code,
            Author author) {
        ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-email">2.17. 发送邮件</h3>
<div class="paragraph">
<p>Spring Framework通过使用 <code>JavaMailSender</code> 接口提供了用于发送电子邮件的简单抽象，Spring Boot为它提供了自动配置以及starter模块。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关如何使用 <code>JavaMailSender</code> 的详细说明，请参见 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlintegration.html#mail">参考文档</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>spring.mail.host</code> 和相关库（由 <code>spring-boot-starter-mail</code> 定义）可用，且不存在默认 <code>JavaMailSender</code>，
则创建一个。可以通过 <code>spring.mail</code> 命名空间中的配置项进一步自定义sender。
有关更多详细信息，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a>。</p>
</div>
<div class="paragraph">
<p>特别是，某些默认超时值是无限的，你可能需要更改此值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=3000
spring.mail.properties.mail.smtp.writetimeout=5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用来自JNDI的现有 <code>Session</code> 配置 <code>JavaMailSender</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.mail.jndi-name=mail/Session</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置 <code>jndi-name</code> 时，它优先于所有其他与Session相关的其他设置。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jta">2.18. JTA的分布式事务</h3>
<div class="paragraph">
<p>通过使用 <a href="https://www.atomikos.com/">Atomikos</a>或 <a href="https://github.com/bitronix/btm">Bitronix</a>嵌入式事务管理器，
Spring Boot支持跨多个XA资源的分布式JTA事务。部署到合适的Java EE应用程序服务器时，还支持JTA事务。</p>
</div>
<div class="paragraph">
<p>当检测到JTA环境时，将使用Spring的 <code>JtaTransactionManager</code> 来管理事务。
自动配置的JMS，DataSource和JPA Bean已升级为支持XA事务。
你可以使用标准的Spring习惯用法（例如：<code>@Transactional</code>）来参与分布式事务。
如果你在JTA环境中，并且仍要使用本地事务，则可以将 <code>spring.jta.enabled</code> 属性设置为 <code>false</code> 以禁用JTA自动配置。</p>
</div>
<div class="sect3">
<h4 id="boot-features-jta-atomikos">2.18.1. 使用Atomikos事务管理器</h4>
<div class="paragraph">
<p><a href="https://www.atomikos.com/">Atomikos</a>是一种流行的开源事务管理器，可以嵌入到你的Spring Boot应用程序中。
你可以使用 <code>spring-boot-starter-jta-atomikos</code> 启动器引入相应的Atomikos库。
Spring Boot自动配置Atomikos，并确保将适当的 <code>depends-on</code> 设置应用于Spring Bean，以实现正确的启动和关闭顺序。</p>
</div>
<div class="paragraph">
<p>默认情况下，Atomikos事务日志将写入应用程序主目录（应用程序jar文件所在的目录）中的 <code>transaction-logs</code> 目录。
你可以通过在 <code>application.properties</code> 文件中设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。
以 <code>spring.jta.atomikos.properties</code> 开头的属性也可以用于自定义Atomikos <code>UserTransactionServiceImp</code>。
有关完整的详细信息，请参见 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api//org/springframework/boot/jta/atomikos/AtomikosProperties.html"><code>AtomikosProperties</code> Javadoc</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Atomikos实例配置一个唯一的ID。
默认情况下，此ID是运行Atomikos的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-bitronix">2.18.2. 使用Bitronix事务管理器</h4>
<div class="paragraph">
<p><a href="https://github.com/bitronix/btm">Bitronix</a>是流行的开源JTA事务管理器实现。
你可以使用 <code>spring-boot-starter-jta-bitronix</code> 启动器将适当的Bitronix依赖项添加到项目中。
与Atomikos一样，Spring Boot自动配置Bitronix并对你的bean进行后处理，以确保启动和关闭顺序正确。</p>
</div>
<div class="paragraph">
<p>默认情况下，Bitronix事务日志文件（<code>part1.btm</code> 和 <code>part2.btm</code>）被写入应用程序主目录中的 <code>transaction-logs</code> 目录。
你可以通过设置 <code>spring.jta.log-dir</code> 属性来自定义此目录的位置。以 <code>spring.jta.bitronix.properties</code>
开头的属性也绑定到 <code>bitronix.tm.Configuration</code> Bean，从而可以进行完全自定义。
有关详细信息，请参见 <a href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix文档</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了确保多个事务管理器可以安全地协调同一资源管理器，必须为每个Bitronix实例配置唯一的ID。
默认情况下，此ID是运行Bitronix的计算机的IP地址。为确保生产中的唯一性，应为每个应用程序实例将
<code>spring.jta.transaction-manager-id</code> 属性配置为不同的值。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-javaee">2.18.3. 使用Java EE托管事务管理器</h4>
<div class="paragraph">
<p>如果将Spring Boot应用程序打包为 <code>war</code> 或 <code>ear</code> 文件，并将其部署到Java EE应用程序服务器，则可以使用应用程序服务器的内置事务管理器。
Spring Boot通过查看常见的JNDI位置（<code>java:comp/UserTransaction</code>, <code>java:comp/TransactionManager</code> 等）来尝试自动配置事务管理器。
如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器管理并通过JNDI公开。
Spring Boot尝试通过在JNDI路径（<code>java:/JmsXA</code> 或 <code>java:/XAConnectionFactory</code>）中查找 <code>ConnectionFactory</code> 来自动配置JMS，
并且你可以使用 <a href="#boot-features-connecting-to-a-jndi-datasource"><code>spring.datasource.jndi-name</code> 属性</a>配置你的 <code>DataSource</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-mixed-jms">2.18.4. 混合XA和非XA JMS连接</h4>
<div class="paragraph">
<p>使用JTA时，主要的JMS <code>ConnectionFactory</code> bean是XA-aware，并参与分布式事务。
在某些情况下，你可能想通过使用非XA <code>ConnectionFactory</code> 处理某些JMS消息。
例如：你的JMS处理逻辑可能需要比XA超时更长的时间。</p>
</div>
<div class="paragraph">
<p>如果要使用非XA <code>ConnectionFactory</code>，则可以注入 <code>nonXaJmsConnectionFactory</code> bean，
而不是 <code>@Primary</code> <code>jmsConnectionFactory</code> bean。
为了保持一致性，还可使用bean别名 <code>xaJmsConnectionFactory</code> 提供了 <code>jmsConnectionFactory</code> bean。</p>
</div>
<div class="paragraph">
<p>以下示例显示如何注入 <code>ConnectionFactory</code> 实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">// Inject the primary (XA aware) ConnectionFactory
@Autowired
private ConnectionFactory defaultConnectionFactory;

// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)
@Autowired
@Qualifier("xaJmsConnectionFactory")
private ConnectionFactory xaConnectionFactory;

// Inject the non-XA aware ConnectionFactory
@Autowired
@Qualifier("nonXaJmsConnectionFactory")
private ConnectionFactory nonXaConnectionFactory;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-jta-supporting-alternative-embedded">2.18.5. 支持替代嵌入式事务管理器</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java"><code>XAConnectionFactoryWrapper</code></a>和
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java"><code>XADataSourceWrapper</code></a>接口可用于支持其他嵌入式事务管理器。
这些接口负责包装 <code>XAConnectionFactory</code> 和 <code>XADataSource</code> Bean，并将它们作为常规的 <code>ConnectionFactory</code> 和
<code>DataSource</code> Bean公开，以透明方式注册分布式事务。如果你在 <code>ApplicationContext</code> 中注册了
<code>JtaTransactionManager</code> bean和适当的XA包装bean，则 <code>DataSource</code> 和JMS自动配置使用JTA变体。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java">BitronixXAConnectionFactoryWrapper</a>和
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java">BitronixXADataSourceWrapper</a>
提供了有关如何编写XA包装器的良好示例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-hazelcast">2.19. Hazelcast</h3>
<div class="paragraph">
<p>如果 <a href="https://hazelcast.com/">Hazelcast</a>位于类路径上，并且找到了合适的配置，
则Spring Boot会自动配置一个 <code>HazelcastInstance</code>，你可以将其注入应用程序中。</p>
</div>
<div class="paragraph">
<p>如果定义 <code>com.hazelcast.config.Config</code> bean，Spring Boot会使用它。
如果你的配置定义了一个实例名称，Spring Boot会尝试查找现有实例，而不是创建一个新实例。</p>
</div>
<div class="paragraph">
<p>你还可以通过配置指定使用的Hazelcast配置文件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.hazelcast.config=classpath:config/my-hazelcast.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>否则，Spring Boot会尝试从默认位置查找Hazelcast配置：
工作目录中或类路径根目录中的 <code>hazelcast.xml</code>，或相同位置中的 <code>.yaml</code> 副本。
我们还检查是否设置了 <code>hazelcast.config</code> 系统属性。有关更多详细信息，请参见
<a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast文档</a>。</p>
</div>
<div class="paragraph">
<p>如果在类路径中存在 <code>hazelcast-client</code>，Spring Boot首先尝试通过检查以下配置选项来创建客户端：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.client.config.ClientConfig</code> bean的存在。</p>
</li>
<li>
<p>由 <code>spring.hazelcast.config</code> 属性定义的配置文件。</p>
</li>
<li>
<p><code>hazelcast.client.config</code> 系统属性的存在。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.xml</code>。</p>
</li>
<li>
<p>工作目录中或类路径根目录中的 <code>hazelcast-client.yaml</code>。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot还具有<a href="#boot-features-caching-provider-hazelcast">对Hazelcast的显式缓存支持</a>。
如果启用了缓存，则 <code>HazelcastInstance</code> 将自动包装在 <code>CacheManager</code> 实现中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-quartz">2.20. Quartz调度器</h3>
<div class="paragraph">
<p>Spring Boot为使用 <a href="https://www.quartz-scheduler.org/">Quartz scheduler</a>提供了许多便利，包括
<code>spring-boot-starter-quartz</code> &#8220;Starter&#8221;。如果Quartz可用，则自动配置 <code>Scheduler</code>（通过 <code>SchedulerFactoryBean</code> 抽象）。</p>
</div>
<div class="paragraph">
<p>以下类型的Bean将自动被拾取并与 <code>Scheduler</code> 关联：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JobDetail</code>: 定义一个特定的Job。
<code>JobDetail</code> 实例可以使用JobBuilder API构建。</p>
</li>
<li>
<p><code>Calendar</code>.</p>
</li>
<li>
<p><code>Trigger</code>: 定义何时触发特定job。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，使用内存中的 <code>JobStore</code>。但是，如果应用程序中有可用的 <code>DataSource</code> bean，并且相应地配置了
<code>spring.quartz.job-store-type</code> 属性，则可以配置基于JDBC的存储，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.job-store-type=jdbc</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JDBC存储时，可以在启动时初始化schema，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.quartz.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
默认情况下，使用Quartz库随附的标准脚本检测并初始化数据库。这些脚本将删除现有表，并在每次重新启动时删除所有触发器。
还可以通过设置 <code>spring.quartz.jdbc.schema</code> 属性来提供自定义脚本。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使Quartz使用应用程序的主 <code>DataSource</code> 以外的 <code>DataSource</code>，
请声明一个 <code>DataSource</code> bean，并用 <code>@QuartzDataSource</code> 注解其 <code>@Bean</code> 方法。
这样可以确保 <code>SchedulerFactoryBean</code> 和Schema初始化都使用特定于Quartz的 <code>DataSource</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过配置创建的jobs将不会覆盖从持久性job存储中读取的已注册jobs。要启用覆盖现有作业定义的功能，
请设置 <code>spring.quartz.overwrite-existing-jobs</code> 属性。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>spring.quartz</code> 属性和 <code>SchedulerFactoryBeanCustomizer</code> bean来定制Quartz Scheduler配置，
这允许以编程方式进行 <code>SchedulerFactoryBean</code> 定制。可以使用 <code>spring.quartz.properties.*</code> 自定义高级Quartz配置属性。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
特别是，<code>Executor</code> bean没有与调度程序关联，因为Quartz提供了一种通过 <code>spring.quartz.properties</code>
配置调度程序的方法。如果需要自定义任务执行程序，请考虑实现 <code>SchedulerFactoryBeanCustomizer</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jobs可以定义设置器以注入数据映射属性。常规beans也可以用类似的方式注入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class SampleJob extends QuartzJobBean {

    private MyService myService;

    private String name;

    // Inject "MyService" bean
    public void setMyService(MyService myService) { ... }

    // Inject the "name" job data property
    public void setName(String name) { ... }

    @Override
    protected void executeInternal(JobExecutionContext context)
            throws JobExecutionException {
        ...
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-task-execution-scheduling">2.21. 任务执行和调度</h3>
<div class="paragraph">
<p>在上下文中没有 <code>Executor</code> bean的情况下，Spring Boot会使用合理的默认值自动配置 <code>ThreadPoolTaskExecutor</code>，
这些默认值可以自动与异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理相关联。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果你在上下文中定义一个自定义 <code>Executor</code>，则常规任务执行（即 <code>@EnableAsync</code>）将透明地使用它，
但是Spring MVC支持将不会被配置，因为它需要一个 <code>AsyncTaskExecutor</code> 实现(名为 <code>applicationTaskExecutor</code>)。
根据你的目标安排，你可以将 <code>Executor</code> 更改为 <code>ThreadPoolTaskExecutor</code>，
或者定义一个 <code>ThreadPoolTaskExecutor</code> 和包装自定义 <code>Executor</code> 的 <code>AsyncConfigurer</code>。</p>
</div>
<div class="paragraph">
<p>自动配置的 <code>TaskExecutorBuilder</code> 可让你轻松创建实例，以重用默认情况下自动配置的功能。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>线程池使用8个核心线程，这些线程可以根据负载增长和收缩。可以使用 <code>spring.task.execution</code> 命名空间微调这些默认设置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.task.execution.pool.max-size=16
spring.task.execution.pool.queue-capacity=100
spring.task.execution.pool.keep-alive=10s</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会将线程池更改为使用有界队列，以便在队列已满（100个任务）时，线程池最多增加到16个线程。
池的收缩更加激进，因为当线程空闲10秒（而不是默认情况下的60秒）时，它们将被回收。</p>
</div>
<div class="paragraph">
<p>如果需要将 <code>ThreadPoolTaskScheduler</code> 与计划的任务执行（<code>@EnableScheduling</code>）关联，也可以对其进行自动配置。
线程池默认使用一个线程，可以使用 <code>spring.task.scheduling</code> 命名空间对这些设置进行微调。</p>
</div>
<div class="paragraph">
<p>如果需要创建自定义执行器或调度器，则可以在上下文中使用 <code>TaskExecutorBuilder</code> bean和 <code>TaskSchedulerBuilder</code> bean。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-integration">2.22. Spring Integration</h3>
<div class="paragraph">
<p>Spring Boot为使用 <a href="https://spring.io/projects/spring-integration">Spring Integration</a>提供了许多便利，包括
<code>spring-boot-starter-integration</code> “<code>Starter</code>”。
Spring Integration提供消息传递以及其他传输（例如：HTTP，TCP等）的抽象。
如果Spring Integration在你的类路径中可用，则通过 <code>@EnableIntegration</code> 注解对其进行初始化。</p>
</div>
<div class="paragraph">
<p>Spring Boot还配置了一些功能，这些功能由其他Spring Integration模块的存在触发。
如果 <code>spring-integration-jmx</code> 也位于类路径上，则消息处理统计信息将通过JMX发布。
如果 <code>spring-integration-jdbc</code> 可用，则可以在启动时创建默认的数据库schema，如以下行所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.integration.jdbc.initialize-schema=always</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a>
和 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a>类。</p>
</div>
<div class="paragraph">
<p>默认情况下，如果存在Micrometer <code>meterRegistry</code> bean，那么Spring Integration指标将由Micrometer管理。
如果你希望使用旧版Spring Integration指标，请将 <code>DefaultMetricsFactory</code> bean添加到应用程序上下文中。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-session">2.23. Spring Session</h3>
<div class="paragraph">
<p>Spring Boot为各种数据存储提供了 <a href="https://spring.io/projects/spring-session">Spring Session</a>自动配置。在构建Servlet Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JDBC</p>
</li>
<li>
<p>Redis</p>
</li>
<li>
<p>Hazelcast</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>构建响应式Web应用程序时，可以自动配置以下存储：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redis</p>
</li>
<li>
<p>MongoDB</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果类路径上存在单个Spring Session模块，则Spring Boot会自动使用该存储实现。
如果你有多个实现，则必须选择要用于存储会话的 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java"><code>StoreType</code></a>。
例如：要将JDBC用作后端存储，可以按以下方式配置应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.store-type=jdbc</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过将 <code>store-type</code> 设置为 <code>none</code> 来禁用Spring Session。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个存储都有特定的附加设置。例如：可以为JDBC存储定制表的名称，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.session.jdbc.table-name=SESSIONS</code></pre>
</div>
</div>
<div class="paragraph">
<p>要设置会话的超时时间，可以使用 <code>spring.session.timeout</code> 属性。如果未设置该属性，则自动配置将降级到 <code>server.servlet.session.timeout</code> 的值。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-jmx">2.24. 通过JMX进行监视和管理</h3>
<div class="paragraph">
<p>Java Management Extensions (JMX) 提供了监视和管理应用程序的标准机制。
Spring Boot将最合适的 <code>MBeanServer</code> 公开为ID为 <code>mbeanServer</code> 的bean。
带有Spring JMX注解（<code>@ManagedResource</code>，<code>@ManagedAttribute</code> 或 <code>@ManagedOperation</code>）的任何bean都可以使用它。</p>
</div>
<div class="paragraph">
<p>如果你的平台提供了标准的 <code>MBeanServer</code>，则Spring Boot将使用该标准，并在必要时默认使用VM <code>MBeanServer</code>。
如果所有操作失败，将创建一个新的 <code>MBeanServer</code>。</p>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java"><code>JmxAutoConfiguration</code></a>类。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-testing">2.25. 测试</h3>
<div class="paragraph">
<p>请移步 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-boot-test.html">这里</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-websockets">2.26. WebSockets</h3>
<div class="paragraph">
<p>Spring Boot为嵌入式Tomcat，Jetty和Undertow提供了WebSockets自动配置。
如果将war文件部署到独立容器，Spring Boot会假定该容器负责其WebSocket支持的配置。</p>
</div>
<div class="paragraph">
<p>Spring Framework为MVC Web应用程序提供了 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb.html#websocket">丰富的WebSocket支持</a>，
可以通过 <code>spring-boot-starter-websocket</code> 模块轻松访问。</p>
</div>
<div class="paragraph">
<p>WebSocket支持也可用于 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlweb-reactive.html#webflux-websocket">响应式Web应用程序</a>，
需要在 <code>spring-boot-starter-webflux</code> 旁包含WebSocket API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-webservices">2.27. Web服务</h3>
<div class="paragraph">
<p>Spring Boot提供了Web服务自动配置，因此你所要做的就是定义 <code>Endpoints</code>。</p>
</div>
<div class="paragraph">
<p>使用 <code>spring-boot-starter-webservices</code> 模块可以轻松访问 <a href="https://docs.spring.io/spring-ws/docs/5.2.1.RELEASE/reference/">Spring Web Services功能</a>。</p>
</div>
<div class="paragraph">
<p>可以分别为你的WSDL和XSD自动创建 <code>SimpleWsdl11Definition</code> 和 <code>SimpleXsdSchema</code> Bean。为此请配置其位置，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.webservices.wsdl-locations=classpath:/wsdl</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-webservices-template">2.27.1. 使用 <code>WebServiceTemplate</code> 调用Web服务</h4>
<div class="paragraph">
<p>如果需要从应用程序中调用远程Web服务，则可以使用 <a href="https://docs.spring.io/spring-ws/docs/5.2.1.RELEASE/reference/#client-web-service-template"><code>WebServiceTemplate</code></a>类。
由于 <code>WebServiceTemplate</code> 实例在使用前通常需要自定义，因此Spring Boot不提供任何单个自动配置的 <code>WebServiceTemplate</code> bean。
但是，它会自动配置 <code>WebServiceTemplateBuilder</code>，可在需要时将其用于创建 <code>WebServiceTemplate</code> 实例。</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个典型示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

    private final WebServiceTemplate webServiceTemplate;

    public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
        this.webServiceTemplate = webServiceTemplateBuilder.build();
    }

    public DetailsResp someWsCall(DetailsReq detailsReq) {
         return (DetailsResp) this.webServiceTemplate.marshalSendAndReceive(detailsReq, new SoapActionCallback(ACTION));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，<code>WebServiceTemplateBuilder</code> 使用类路径上的可用HTTP客户端库来检测合适的基于HTTP的 <code>WebServiceMessageSender</code>。
你还可以像下面那样自定义读取和连接超时：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
    return builder.messageSenders(new HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(5000).setReadTimeout(2000).build()).build();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-developing-auto-configuration">2.28. 创建自己的自动配置</h3>
<div class="paragraph">
<p>如果你在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以捆绑在外部jar中，并且仍由Spring Boot拾取。</p>
</div>
<div class="paragraph">
<p>自动配置可以与“<code>starter</code>”相关联，该“<code>starter</code>”提供自动配置代码以及你将使用的典型库。
我们首先介绍构建自己的自动配置所需的知识，然后继续介绍<a href="#boot-features-custom-starter">创建自定义启动器所需的典型步骤</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有一个 <a href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">demo项目</a>可以展示如何逐步创建starter。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="boot-features-understanding-auto-configured-beans">2.28.1. 了解自动配置的Bean</h4>
<div class="paragraph">
<p>在后台，自动配置是通过标准 <code>@Configuration</code> 类实现的。其他 <code>@Conditional</code> 注解用于约束何时应应用自动配置。
通常，自动配置类使用 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingBean</code> 注解。
这样可以确保仅当找到相关的类并且没有声明自己的 <code>@Configuration</code> 时，才应用自动配置。</p>
</div>
<div class="paragraph">
<p>你可以浏览 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure"><code>spring-boot-autoconfigure</code></a>的源代码以查看Spring提供的
<code>@Configuration</code> 类（请参阅 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories"><code>META-INF/spring.factories</code></a>文件）。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-locating-auto-configuration-candidates">2.28.2. 查找自动配置候选人</h4>
<div class="paragraph">
<p>Spring Boot检查发布的jar中是否存在 <code>META-INF/spring.factories</code> 文件。
该文件应在 <code>EnableAutoConfiguration</code> 键下列出你的配置类，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\
com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
自动配置 <em>只能</em> 以这种方式加载。
确保在特定的程序包空间中定义它们，并且决不要将它们作为组件扫描的目标。
此外，自动配置类不应启用组件扫描以查找其他组件。应该使用特定的 <code>@Imports</code> 代替。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果需要按特定顺序应用配置，则可以使用 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java"><code>@AutoConfigureAfter</code></a>或
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java"><code>@AutoConfigureBefore</code></a>注解。
例如：如果你提供特定于Web的配置，则可能需要在 <code>WebMvcAutoConfiguration</code> 之后应用你的类。</p>
</div>
<div class="paragraph">
<p>如果要排序某些彼此之间不具有任何直接了解的自动配置，则也可以使用 <code>@AutoConfigureOrder</code>。
该注解与常规 <code>@Order</code> 注解具有相同的语义，但为自动配置类提供了专用的顺序。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-condition-annotations">2.28.3. 条件注解</h4>
<div class="paragraph">
<p>你几乎总是希望在自动配置类中包含一个或多个 <code>@Conditional</code> 注解。
<code>@ConditionalOnMissingBean</code> 注解是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
</div>
<div class="paragraph">
<p>Spring Boot包含许多 <code>@Conditional</code> 注解，你可以通过标注 <code>@Configuration</code> 类或单个 <code>@Bean</code> 方法在自己的代码中重用它。
这些注解包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#boot-features-class-conditions">Class条件</a></p>
</li>
<li>
<p><a href="#boot-features-bean-conditions">Bean条件</a></p>
</li>
<li>
<p><a href="#boot-features-property-conditions">Property条件</a></p>
</li>
<li>
<p><a href="#boot-features-resource-conditions">Resource条件</a></p>
</li>
<li>
<p><a href="#boot-features-web-application-conditions">Web应用条件</a></p>
</li>
<li>
<p><a href="#boot-features-spel-conditions">SpEL表达式条件</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="boot-features-class-conditions">Class条件</h5>
<div class="paragraph">
<p>通过 <code>@ConditionalOnClass</code> 和 <code>@ConditionalOnMissingClass</code> 注解，可以根据是否存在特定类来包含 <code>@Configuration</code> 类。
由于注解元数据是通过使用 <a href="https://asm.ow2.org/">ASM</a>进行解析的，因此即使该类可能实际上未出现在正在运行的应用程序类路径上，
你也可以使用 <code>value</code> 属性来引用真实的类。如果你更喜欢通过使用 <code>String</code> 值来指定类名称，则也可以使用 <code>name</code> 属性。</p>
</div>
<div class="paragraph">
<p>这种机制不适用于通常将返回类型作为该条件目标的 <code>@Bean</code> 方法：在方法上的条件应用之前，JVM将加载该类和可能处理的方法引用，如果类不存在，这些引用将失败。</p>
</div>
<div class="paragraph">
<p>为了处理这种情况，可以使用单独的 <code>@Configuration</code> 类隔离条件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
// Some conditions
public class MyAutoConfiguration {

    // Auto-configured beans

    @Configuration(proxyBeanMethods = false)
    @ConditionalOnClass(EmbeddedAcmeService.class)
    static class EmbeddedConfiguration {

        @Bean
        @ConditionalOnMissingBean
        public EmbeddedAcmeService embeddedAcmeService() { ... }

    }

}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果在元注解中使用 <code>@ConditionalOnClass</code> 或 <code>@ConditionalOnMissingClass</code> 来组成自己的组合注解，
则在不处理这种情况下，必须使用 <code>name</code> 来引用该类。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-bean-conditions">Bean条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解允许根据是否存在特定bean来包含bean。
你可以使用 <code>value</code> 属性按类型指定bean或使用 <code>name</code> 属性按名称指定bean。
<code>search</code> 属性使你可以限制在搜索bean时应考虑的 <code>ApplicationContext</code> 层次结构。</p>
</div>
<div class="paragraph">
<p>当放置在 <code>@Bean</code> 方法上时，目标类型默认为该方法的返回类型，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class MyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public MyService myService() { ... }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，如果 <code>ApplicationContext</code> 中没有包含 <code>MyService</code> 类型的bean，将创建 <code>myService</code> bean。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你要特别注意添加bean定义的顺序，因为这些条件是根据到目前为止已处理的内容来评估的。
出于这个原因，我们建议在自动配置类上仅使用 <code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 注解
（因为可以保证在添加任何用户定义的bean定义后加载它们）。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@ConditionalOnBean</code> 和 <code>@ConditionalOnMissingBean</code> 不会阻止创建 <code>@Configuration</code> 类。
在类级别使用这些条件与使用注解标记每个包含的 <code>@Bean</code> 方法之间的唯一区别是，如果条件不匹配，则前者会阻止将 <code>@Configuration</code> 类注册为bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-property-conditions">Property条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnProperty</code> 注解允许基于Spring <code>Environment</code> 属性包含的配置，使用 <code>prefix</code> 和 <code>name</code> 属性指定应检查的属性。
默认情况下，将匹配存在且不等于 <code>false</code> 的任何属性。你也可以使用 <code>havingValue</code> 和 <code>matchIfMissing</code> 属性来创建更高级的检查。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-resource-conditions">Resource条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnResource</code> 注解仅在存在特定资源时才包含配置。可以使用常规的Spring约定来指定资源，
如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-web-application-conditions">Web应用条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnWebApplication</code> 和 <code>@ConditionalOnNotWebApplication</code> 注解允许根据应用程序是否为“Web应用程序”来包含配置。
基于Servlet的Web应用程序是使用Spring <code>WebApplicationContext</code>，定义 <code>session</code> 作用域或具有 <code>ConfigurableWebEnvironment</code> 的任何应用程序。
响应式Web应用程序是使用 <code>ReactiveWebApplicationContext</code> 或具有 <code>ConfigurableReactiveWebEnvironment</code> 的任何应用程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-spel-conditions">SpEL表达式条件</h5>
<div class="paragraph">
<p><code>@ConditionalOnExpression</code> 注解允许基于 <a href="https://xiaojiac.github.io/hello-world/cookbook/spring-mvc.htmlcore.html#expressions">SpEL表达式</a>的结果来包含配置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-test-autoconfig">2.28.4. 测试你的自动配置</h4>
<div class="paragraph">
<p>自动配置可能受许多因素影响：用户配置（<code>@Bean</code> 定义和 <code>Environment</code> 自定义），条件评估（存在特定库）以及其他因素。
具体而言，每个测试都应创建定义良好的 <code>ApplicationContext</code>，以表示这些自定义项的组合。
<code>ApplicationContextRunner</code> 提供了一种实现此目标的好方法。</p>
</div>
<div class="paragraph">
<p>通常将 <code>ApplicationContextRunner</code> 定义为测试类的字段，以收集基本的通用配置。
下面的示例确保始终调用 <code>UserServiceAutoConfiguration</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果必须定义多个自动配置，则无需按照与运行应用程序时完全相同的顺序调用它们的声明。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个测试都可以使用运行器来表示特定的用例。例如：下面的示例调用一个用户配置（<code>UserConfiguration</code>）并检查自动配置是否正确退出。
调用 <code>run</code> 提供了可与 <code>Assert4J</code> 一起使用的回调上下文。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void defaultServiceBacksOff() {
    this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context).getBean("myUserService").isSameAs(context.getBean(UserService.class));
    });
}

@Configuration(proxyBeanMethods = false)
static class UserConfiguration {

    @Bean
    UserService myUserService() {
        return new UserService("mine");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以轻松自定义 <code>Environment</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceNameCanBeConfigured() {
    this.contextRunner.withPropertyValues("user.name=test123").run((context) -&gt; {
        assertThat(context).hasSingleBean(UserService.class);
        assertThat(context.getBean(UserService.class).getName()).isEqualTo("test123");
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行器还可以用于显示 <code>ConditionEvaluationReport</code>。
可以以 <code>INFO</code> 或 <code>DEBUG</code> 级别打印报告。以下示例显示如何使用 <code>ConditionEvaluationReportLoggingListener</code> 在自动配置测试中打印报告。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
public void autoConfigTest {
    ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener(
            LogLevel.INFO);
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withInitializer(initializer).run((context) -&gt; {
                    // Do something...
            });
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="模拟一个web上下文">模拟一个Web上下文</h5>
<div class="paragraph">
<p>如果你需要测试仅在Servlet或Reactive Web应用程序上下文中运行的自动配置，请分别使用
<code>WebApplicationContextRunner</code> 或 <code>ReactiveWebApplicationContextRunner</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="覆盖类路径">覆盖类路径</h5>
<div class="paragraph">
<p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。
Spring Boot附带有 <code>FilteredClassLoader</code>，运行器可以轻松使用。
在以下示例中，我们断言，如果不存在 <code>UserService</code>，则会自动禁用自动配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Test
void serviceIsIgnoredIfLibraryIsNotPresent() {
    this.contextRunner.withClassLoader(new FilteredClassLoader(UserService.class))
            .run((context) -&gt; assertThat(context).doesNotHaveBean("userService"));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-features-custom-starter">2.28.5. 创建自己的Starter</h4>
<div class="paragraph">
<p>一个库的完整Spring Boot starter可能包含以下组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>autoconfigure</code> 模块：包含自动配置代码。</p>
</li>
<li>
<p><code>starter</code> 模块：提供对 <code>autoconfigure</code> 模块以及其库的依赖，和通常有用的任何其他依赖项。
简而言之，添加starter应提供开始使用该库所需的一切。</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果不需要将这两个问题分开，则可以将自动配置代码和依赖管理组合在一起。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-naming">命名</h5>
<div class="paragraph">
<p>你应该确保为启动器提供适当的命名空间。即使你使用其他Maven <code>groupId</code>，也不要以 <code>spring-boot</code> 开头模块名称。
将来，我们可能会为你自动配置的内容提供官方支持。</p>
</div>
<div class="paragraph">
<p>根据经验，你应该在启动器后命名一个组合模块。例如：假设你要为“acme”创建starter，
并命名自动配置模块 <code>acme-spring-boot-autoconfigure</code> 和启动器 <code>acme-spring-boot-starter</code>。
如果只有一个模块将两者结合在一起，则将其命名为 <code>acme-spring-boot-starter</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-configuration-keys">配置键</h5>
<div class="paragraph">
<p>如果你的starter提供了配置键，请为其使用唯一的命名空间。
特别是，不要将键包含在Spring Boot使用的名称空间中（例如：<code>server</code>, <code>management</code>, <code>spring</code> 等）。
如果使用相同的命名空间，将来我们可能会以破坏模块的方式修改这些命名空间。
根据经验，所有键都必须拥有自己的命名空间（例如：<code>acme</code>）。</p>
</div>
<div class="paragraph">
<p>通过为每个属性添加字段javadoc来确保文档化配置键，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("acme")
public class AcmeProperties {

    /**
     * Whether to check the location of acme resources.
     */
    private boolean checkLocation = true;

    /**
     * Timeout for establishing a connection to the acme server.
     */
    private Duration loginTimeout = Duration.ofSeconds(3);

    // getters &amp; setters

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
你仅应将简单文本与 <code>@ConfigurationProperties</code> 字段Javadoc一起使用，因为在将它们添加到JSON之前不会对其进行处理。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这是我们内部遵循的一些规则，以确保描述一致：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>请勿以“The”或“A”开头描述。</p>
</li>
<li>
<p>对于 <code>boolean</code> 类型，请以“Whether”或“Enable”开始描述。</p>
</li>
<li>
<p>对于基于集合的类型，请以“Comma-separated list”开始描述。</p>
</li>
<li>
<p>使用 <code>java.time.Duration</code> 而不是 <code>long</code>，如果它不为毫秒，请描述默认单位，例如：“If a duration suffix is not specified, seconds will be used”。</p>
</li>
<li>
<p>除非必须在运行时确定默认值，否则请不要在描述中提供默认值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保<a href="appendix-configuration-metadata.html#configuration-metadata-annotation-processor">触发元数据生成</a>，
以便IDE助手也可用于你的键。你可能需要查看生成的元数据（<code>META-INF/spring-configuration-metadata.json</code>），
以确保正确记录了你的键。在兼容的IDE中使用自己的starter也是验证元数据质量的好主意。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-module-autoconfigure"><code>autoconfigure</code> 模块</h5>
<div class="paragraph">
<p><code>autoconfigure</code> 模块包含开始使用该库所需的所有内容。它还可能包含配置键定义（例如：<code>@ConfigurationProperties</code>）
和可用于进一步自定义组件初始化方式的任何回调接口。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你应该将对库的依赖项标记为optional，以便可以更轻松地在项目中包括 <code>autoconfigure</code> 模块。
如果这样做，则不提供该库，并且默认情况下，Spring Boot会回退。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot使用注解处理器来收集元数据文件（<code>META-INF/spring-autoconfigure-metadata.properties</code>）中自动配置的条件。
如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.5及更早版本，应在配置中使用 <code>compileOnly</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compileOnly "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle 4.6和更高版本，应在配置中使用 <code>annotationProcessor</code> 声明依赖项，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="boot-features-custom-starter-module-starter">starter模块</h5>
<div class="paragraph">
<p>Starter确实是一个空jar。其唯一目的是提供必要的依赖关系以使用库。你可以将其视为对入门所需。</p>
</div>
<div class="paragraph">
<p>不要对添加了启动器的项目做任何假设。如果你要自动配置的库通常需要其他启动器，请同时提及它们。
如果可选依赖项的数量很高，则提供一组适当的 <em>默认</em> 依赖项可能会很困难，因此你应该避免包括对于库的典型用法不必要的依赖项。
换句话说，你不应包括可选的依赖项。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无论哪种方式，你的starter都必须直接或间接引用（即如果你的starter依赖于另一个starter，则无需添加它）
核心Spring Boot starter（<code>spring-boot-starter</code>）。如果仅使用你的自定义starter创建项目，
则会通过使用该核心starter来支持Spring Boot的核心功能。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boot-features-whats-next">2.29. 接下来要读什么</h3>
<div class="paragraph">
<p>如果你想了解有关本节中讨论的任何类的更多信息，可以查看 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api/">Spring Boot API文档</a>或
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE">直接浏览源代码</a>。</p>
</div>
<div class="paragraph">
<p>如果你有特定问题，请查看 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto">how-to</a>部分。</p>
</div>
<div class="paragraph">
<p>如果你对Spring Boot的核心功能感到满意，则可以继续阅读有关
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#production-ready-endpoints">生产就绪功能</a>的信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="production-ready">3. Spring Boot Actuator: 生产就绪功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot包含许多其他功能，可帮助你在将应用程序投入生产时监控和管理你的应用程序。
你可以选择使用HTTP端点或JMX管理和监视你的应用程序。审计，健康状况和指标收集也可以自动应用于你的应用程序。</p>
</div>
<div class="sect2">
<h3 id="production-ready-enabling">3.1. 启用生产就绪功能</h3>
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator"><code>spring-boot-actuator</code></a>模块提供了Spring Boot生产就绪的所有功能。
启用这些功能的最简单方法是添加 <code>spring-boot-starter-actuator</code> &#8216;Starter&#8217; 依赖项。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Actuator的定义</div>
<div class="paragraph">
<p>执行器是制造术语，是指用于移动或控制某些物体的机械设备。执行器可以通过很小的变化产生大量的运动。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>要将执行器添加到基于Maven的项目中，请添加以下 &#8216;Starter&#8217; 依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle，请使用以下声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compile("org.springframework.boot:spring-boot-starter-actuator")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-endpoints">3.2. 端点</h3>
<div class="paragraph">
<p>执行器端点使你可以监视应用程序并与之交互。Spring Boot包含许多内置端点，你可以添加自己的端点。例如：<code>health</code> 端点提供基本的应用程序运行状况信息。</p>
</div>
<div class="paragraph">
<p>每个端点都可以启用或禁用。这控制了是否创建端点以及它的bean是否在应用程序上下文中存在。
为了可以远程访问，端点还必须通过JMX或HTTP公开。大多数应用程序选择HTTP，其中端点的ID和 <code>/actuator</code> 前缀被映射到一个URL。
例如，默认情况下，<code>health</code> 端点映射到 <code>/actuator/health</code>。</p>
</div>
<div class="paragraph">
<p>可以使用以下与技术无关的端点：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 28%;">
<col style="width: 71%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>auditevents</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">公开当前应用程序的审计事件信息。需要一个 <code>AuditEventRepository</code> bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beans</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用程序中所有Spring Beans的完整列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>caches</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">公开可用的缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>configprops</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示所有 <code>@ConfigurationProperties</code> 的整理列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>env</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">公开Spring的 <code>ConfigurableEnvironment</code> 中的属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flyway</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示已应用的所有Flyway数据库迁移。需要一个或多个 <code>Flyway</code> beans。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>health</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用程序运行状况信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>httptrace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示HTTP跟踪信息（默认情况下，公开最近100个HTTP请求-响应交换）。需要一个 <code>HttpTraceRepository</code> bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>info</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示任意应用程序信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>integrationgraph</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示Spring Integration图。依赖于 <code>spring-integration-core</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loggers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示和修改应用程序中日志记录器的配置。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>liquibase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示已应用的所有Liquibase数据库迁移。需要一个或多个 <code>Liquibase</code> bean。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>metrics</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示当前应用程序的度量指标信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mappings</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示整理的所有 <code>@RequestMapping</code> 路径列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scheduledtasks</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示应用程序中的所有计划任务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sessions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>shutdown</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使应用程序正常关闭。默认禁用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>threaddump</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行线程转储。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果你的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 28%;">
<col style="width: 71%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>heapdump</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回一个 <code>hprof</code> 堆转储文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。需要依赖于 <code>jolokia-core</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logfile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回日志文件的内容（如果已设置 <code>logging.file.name</code> 或 <code>logging.file.path</code> 属性）。支持使用HTTP <code>Range</code> 标头来检索部分日志文件的内容。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prometheus</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">以Prometheus服务器可以抓取的格式公开指标。需要依赖于 <code>micrometer-registry-prometheus</code>。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要了解有关执行器端点及其请求和响应格式的更多信息，请参阅单独的API文档（ <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/actuator-api//html/">HTML</a> 或
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf">PDF</a>）。</p>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-enabling-endpoints">3.2.1. 启用端点</h4>
<div class="paragraph">
<p>默认情况下，除 <code>shutdown</code> 外的所有端点均处于启用状态。要配置端点的启用，请使用其 <code>management.endpoint.&lt;id&gt;.enabled</code> 属性。以下示例启用
<code>shutdown</code> 端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.shutdown.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果你希望端点支持选择加入而不是选择退出，请将 <code>management.endpoints.enabled-by-default</code> 属性设置为 <code>false</code> 并使用单个端点的 <code>enabled</code> 属性重新启用。
以下示例仅启用 <code>info</code> 端点并禁用所有其他端点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.enabled-by-default=false
management.endpoint.info.enabled=true</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
禁用的端点将从应用程序上下文中完全删除。如果只想更改公开端点的技术，请改用<a href="#production-ready-endpoints-exposing-endpoints"><code>include</code> 和 <code>exclude</code> 属性</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-exposing-endpoints">3.2.2. 暴露端点</h4>
<div class="paragraph">
<p>由于端点可能包含敏感信息，因此应谨慎考虑何时公开它们。下表显示了默认暴露的内置端点：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">ID</th>
<th class="tableblock halign-left valign-top">JMX</th>
<th class="tableblock halign-left valign-top">Web</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>auditevents</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beans</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>caches</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>conditions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>configprops</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>env</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flyway</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>health</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>heapdump</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>httptrace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>info</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>integrationgraph</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logfile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loggers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>liquibase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>metrics</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mappings</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>prometheus</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scheduledtasks</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sessions</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>shutdown</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>threaddump</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要更改暴露哪些端点，请使用以下特定于技术的 <code>include</code> 和 <code>exclude</code> 属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 75%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.endpoints.jmx.exposure.exclude</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.endpoints.jmx.exposure.include</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.endpoints.web.exposure.exclude</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.endpoints.web.exposure.include</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>info, health</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><code>include</code> 属性列出了公开的端点的ID。
<code>exclude</code> 属性列出了不应公开的端点的ID。
<code>exclude</code> 属性优先于 <code>include</code> 属性。
<code>include</code> 和 <code>exclude</code> 属性都可以使用端点ID列表进行配置。</p>
</div>
<div class="paragraph">
<p>例如，要停止通过JMX公开所有端点，而仅公开 <code>health</code> 和 <code>info</code> 端点，请使用以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.jmx.exposure.include=health,info</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>*</code> 可用于选择所有端点。
例如，要通过HTTP公开除 <code>env</code> 和 <code>bean</code> 端点之外的所有端点，请使用以下属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=env,beans</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>*</code> 在YAML中具有特殊含义，因此，如果要包括（或排除）所有端点，请确保添加引号，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">management:
  endpoints:
    web:
      exposure:
        include: "*"</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你的应用程序是公开的，我们强烈建议你<a href="#production-ready-endpoints-security">保护端点</a>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果你想在端点暴露时实现自己的策略，则可以注册 <code>EndpointFilter</code> bean。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-security">3.2.3. 保护HTTP端点</h4>
<div class="paragraph">
<p>你应该像对待其他任何敏感URL一样，小心保护HTTP端点的安全。
如果存在Spring Security，则默认情况下将使用Spring Security的内容协商策略保护端点的安全。
例如，如果你希望为HTTP端点配置自定义安全性，只允许具有特定角色的用户访问它们，
Spring Boot提供了一些方便的 <code>RequestMatcher</code> 对象，可以将它们与Spring Security结合使用。</p>
</div>
<div class="paragraph">
<p>典型的Spring Security配置可能类似于以下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class ActuatorSecurity extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) -&gt;
                requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
        http.httpBasic();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例使用 <code>EndpointRequest.toAnyEndpoint()</code> 将请求匹配到任何端点，然后确保所有端点具有 <code>ENDPOINT_ADMIN</code> 角色才可访问。
<code>EndpointRequest</code> 还提供了其他几种匹配器方法。有关详细信息，请参见API文档（
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/actuator-api//html">HTML</a> 或
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf">PDF</a>）。</p>
</div>
<div class="paragraph">
<p>如果将应用程序部署在防火墙后面，则可能希望无需进行身份验证即可访问所有执行器端点。
你可以通过更改 <code>management.endpoints.web.exposure.include</code> 属性来做到这一点，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.exposure.include=*</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，如果存在Spring Security，则需要添加自定义安全配置，该配置允许未经身份验证的端点访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Configuration(proxyBeanMethods = false)
public class ActuatorSecurity extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests((requests) -&gt;
            requests.anyRequest().permitAll());
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-caching">3.2.4. 配置端点</h4>
<div class="paragraph">
<p>端点自动缓存不带任何参数的读取操作的响应。要配置端点缓存响应的时间，请使用其 <code>cache.time-to-live</code> 属性。
以下示例将 <code>beans</code> 端点的缓存的生存时间设置为10秒：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.beans.cache.time-to-live=10s</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前缀 <code>management.endpoint.&lt;name&gt;</code> 用于唯一标识正在配置的端点。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
发出经过身份验证的HTTP请求时，将 <code>Principal</code> 视为端点的输入，因此不会缓存响应。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-hypermedia">3.2.5. 用于执行器Web端点的超媒体</h4>
<div class="paragraph">
<p>添加了“发现页面”，其中包含指向所有端点的链接。默认情况下，在 <code>/actuator</code> 上提供“发现页面”。</p>
</div>
<div class="paragraph">
<p>配置自定义管理上下文路径后，“发现页面”会自动从 <code>/actuator</code> 移至管理上下文的根目录。例如，如果管理上下文路径为 <code>/management</code>，则可以从
<code>/management</code> 访问发现页面。当管理上下文路径设置为 <code>/</code> 时，将禁用发现页面，以防止与其他映射发生冲突的可能性。</p>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-cors">3.2.6. CORS支持</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a> (CORS)
是 <a href="https://www.w3.org/TR/cors/">W3C 规范</a>，使你可以灵活地指定授权哪种类型的跨域请求。
如果你使用Spring MVC或Spring WebFlux，则可以将Actuator的Web端点配置为支持这种情况。</p>
</div>
<div class="paragraph">
<p>默认情况下，CORS支持是禁用的，并且仅在设置了 <code>management.endpoints.web.cors.allowed-origins</code> 属性后才启用。
以下配置允许来自 <code>example.com</code> 域的 <code>GET</code> 和 <code>POST</code> 调用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.cors.allowed-origins=https://example.com
management.endpoints.web.cors.allowed-methods=GET,POST</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
有关选项的完整列表，请参见 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java">CorsEndpointProperties</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-endpoints-custom">3.2.7. 实现自定义端点</h4>
<div class="paragraph">
<p>如果添加带 <code>@Endpoint</code> 注解的 <code>@Bean</code>，则带 <code>@ReadOperation</code>，<code>@WriteOperation</code> 或 <code>@DeleteOperation</code>
注解的任何方法都将通过JMX以及Web应用程序通过HTTP自动公开。
可以使用Jersey，Spring MVC或Spring WebFlux通过HTTP公开端点。如果同时提供Jersey和Spring MVC，将使用Spring MVC。</p>
</div>
<div class="paragraph">
<p>你也可以使用 <code>@JmxEndpoint</code> 或 <code>@WebEndpoint</code> 编写特定于技术的端点。这些端点仅限于各自的技术。例如，<code>@WebEndpoint</code> 仅通过HTTP公开，而不通过JMX公开。</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>@EndpointWebExtension</code> 和 <code>@EndpointJmxExtension</code> 编写特定于技术的扩展。这些注解使你可以提供特定于技术的操作来扩展现有端点。</p>
</div>
<div class="paragraph">
<p>最后，如果你需要访问特定于Web框架的功能，则可以实现Servlet或Spring <code>@Controller</code> 和 <code>@RestController</code> 端点，但代价是它们在JMX上不可用，或者在使用其他web框架时不可用。</p>
</div>
<div class="sect4">
<h5 id="production-ready-endpoints-custom-input">接收输入</h5>
<div class="paragraph">
<p>端点上的操作通过其参数接收输入。通过网络公开时，这些参数的值取自URL的查询参数和JSON请求正文。
通过JMX公开时，参数将映射到MBean操作的参数。默认情况下，参数是必需的。
可以通过使用 <code>@org.springframework.lang.Nullable</code> 对其进行注释来使它们成为可选的。</p>
</div>
<div class="paragraph">
<p>JSON请求正文中的每个根属性都可以映射到端点的参数。考虑以下JSON请求正文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json">{
    "name": "test",
    "counter": 42
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这可用于调用采用 <code>String name</code> 和 <code>int counter</code> 参数的写操作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是不支持使用定义 <code>name</code> 和 <code>counter</code> 属性的自定义类型声明单个参数。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了使输入映射到操作方法的参数，实现端点的Java代码应使用 <code>-parameters</code> 进行编译，
而实现端点的Kotlin代码应使用 <code>-java-parameters</code> 进行编译。如果你使用的是Spring Boot的Gradle插件，
或者使用的是Maven和 <code>spring-boot-starter-parent</code>，则此操作会自动发生。
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-input-conversion">输入类型转换</h6>
<div class="paragraph">
<p>如有必要，传递给端点操作方法的参数会自动转换为所需的类型。
在调用操作方法之前，使用 <code>ApplicationConversionService</code> 实例以及任何具有 <code>@EndpointConverter</code> 限定的
<code>Converter</code> 或 <code>GenericConverter</code> Bean，将通过JMX或HTTP请求接收的输入转换为所需的类型。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-endpoints-custom-web">自定义Web端点</h5>
<div class="paragraph">
<p><code>@Endpoint</code>，<code>@WebEndpoint</code> 或 <code>@EndpointWebExtension</code> 上的操作会使用Jersey，Spring MVC或Spring
WebFlux通过HTTP自动公开。如果同时提供Jersey和Spring MVC，将使用Spring MVC。</p>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-predicate">Web端点请求谓词</h6>
<div class="paragraph">
<p>对于在暴露于Web的端点上的每个操作，都会自动生成一个请求谓词。</p>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-predicate-path">路径</h6>
<div class="paragraph">
<p>谓词的路径由端点的ID和暴露于Web的端点的基本路径确定。默认的基本路径是 <code>/actuator</code>。
例如：具有 <code>sessions</code> ID的端点将使用 <code>/actuator/sessions</code> 作为其谓词的路径。</p>
</div>
<div class="paragraph">
<p>通过使用 <code>@Selector</code> 注解操作方法的一个或多个参数，可以进一步自定义路径。这样的参数作为路径变量添加到路径谓词。
调用端点操作时，变量的值将传递到操作方法中。如果要捕获所有剩余的路径元素，可以将
<code>@Selector(Match=ALL_REMAINING)</code> 添加到最后一个参数，并将其设置为与 <code>String[]</code> 转换兼容的类型。</p>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-predicate-http-method">HTTP方法</h6>
<div class="paragraph">
<p>谓词的HTTP方法由操作类型决定，如下表所示：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP方法</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@ReadOperation</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GET</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@WriteOperation</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POST</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@DeleteOperation</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DELETE</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-predicate-consumes">消费</h6>
<div class="paragraph">
<p>对于使用请求体的 <code>@WriteOperation</code> (HTTP <code>POST</code>)，谓词的消费类型为
<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，消费类型为空。</p>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-predicate-produces">生产</h6>
<div class="paragraph">
<p>谓词的生产类型可以通过 <code>@DeleteOperation</code>，<code>@ReadOperation</code> 和 <code>@WriteOperation</code> 注解的 <code>produces</code> 属性来确定。
该属性是可选的。如果未使用，则会自动确定生产类型。</p>
</div>
<div class="paragraph">
<p>如果操作方法返回 <code>void</code> 或 <code>Void</code>，则生产类型为空。如果操作方法返回 <code>org.springframework.core.io.Resource</code>，
则生产类型为 <code>application/octet-stream</code>。对于所有其他操作，生产类型为
<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。</p>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-response-status">Web端点响应状态</h6>
<div class="paragraph">
<p>端点操作的默认响应状态取决于操作类型（读，写或删除）以及该操作返回的内容（如果有）。</p>
</div>
<div class="paragraph">
<p><code>@ReadOperation</code> 返回一个值，响应状态将为 200 (OK)。如果未返回值，则响应状态将为 404 (Not Found)。</p>
</div>
<div class="paragraph">
<p>如果 <code>@WriteOperation</code> 或 <code>@DeleteOperation</code> 返回一个值，则响应状态将为 200 (OK)。如果未返回值，则响应状态将为 204 (No Content)。</p>
</div>
<div class="paragraph">
<p>如果在没有必需参数或无法将参数转换为必需类型的参数的情况下调用操作，则不会调用该操作方法，并且响应状态将为 400 (Bad Request)。</p>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-range-requests">Web端点范围请求</h6>
<div class="paragraph">
<p>HTTP Range请求可用于请求HTTP资源的一部分。使用Spring MVC或Spring Web Flux时，返回 <code>org.springframework.core.io.Resource</code>
的操作会自动支持范围请求。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用Jersey时，范围请求不受支持。
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="production-ready-endpoints-custom-web-security">Web端点安全</h6>
<div class="paragraph">
<p>Web端点或Web特定端点扩展上的操作可以接收当前的 <code>java.security.Principal</code> 或
<code>org.springframework.boot.actuate.endpoint.SecurityContext</code> 作为方法参数。
前者通常与 <code>@Nullable</code> 结合使用，以为经过身份验证和未经身份验证的用户提供不同的行为。
后者通常用于使用其 <code>isUserInRole(String)</code> 方法执行授权检查。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-endpoints-custom-servlet">Servlet端点</h5>
<div class="paragraph">
<p>通过实现带有 <code>@ServletEndpoint</code> 注解的类（也可以实现 <code>Supplier&lt;EndpointServlet&gt;</code>），可以将Servlet公开为端点。
Servlet端点提供了与Servlet容器更深层次的集成，但以牺牲可移植性为代价。它们用于将现有Servlet公开为端点。
对于新的端点，尽可能使用 <code>@Endpoint</code> 和 <code>@WebEndpoint</code> 注解。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-endpoints-custom-controller">控制器端点</h5>
<div class="paragraph">
<p><code>@ControllerEndpoint</code> 和 <code>@RestControllerEndpoint</code> 可用于实现仅由Spring MVC或Spring WebFlux公开的端点。
使用Spring MVC和Spring WebFlux的标准注解（例如： <code>@RequestMapping</code> 和 <code>@GetMapping</code> ）映射方法，并将端点的ID用作路径的前缀。
控制器端点提供了与Spring Web框架更深层次的集成，但以牺牲可移植性为代价。尽可能使用 <code>@Endpoint</code> 和 <code>@WebEndpoint</code> 注解。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-health">3.2.8. 健康信息</h4>
<div class="paragraph">
<p>你可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件通常使用它在生产系统出现故障时向某人发出警报。
<code>health</code> 端点公开的信息取决于 <code>management.endpoint.health.show-details</code> 和
<code>management.endpoint.health.show-components</code> 属性，可以使用以下值之一配置属性：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>never</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">详细信息永远不会显示。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>when-authorized</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">详细信息仅显示给授权用户。可以使用 <code>management.endpoint.health.roles</code> 配置授权角色。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>always</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">向所有用户显示详细信息。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>默认值为 <code>never</code>。当用户担任端点的一个或多个角色时，该用户被视为已授权。如果端点没有配置的角色（默认值），
则所有通过身份验证的用户均被视为已授权。可以使用 <code>management.endpoint.health.roles</code> 属性配置角色。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果你已保护应用程序安全并希望使用 <code>always</code>，则安全配置必须允许经过身份验证的用户和未经身份验证的用户都可以访问运行状况端点。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>运行状况信息是从 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributorRegistry.java"><code>HealthContributorRegistry</code></a>
的内容（默认情况下，在 <code>ApplicationContext</code> 中定义的所有 <code>HealthContributor</code> 实例）中收集的。
Spring Boot包括许多自动配置的 <code>HealthContributor</code>，你也可以编写自己的 <code>HealthContributor</code>。</p>
</div>
<div class="paragraph">
<p><code>HealthContributor</code> 可以是 <code>HealthIndicator</code> 或 <code>CompositeHealthContributor</code>。<code>HealthIndicator</code> 提供实际的健康信息，包括 <code>Status</code>。
<code>CompositeHealthContributor</code> 提供了其他 <code>HealthContributor</code> 的组合。所有贡献者合起来形成一个树形结构来代表整个系统的健康状况。</p>
</div>
<div class="paragraph">
<p>默认情况下，最终的系统运行状况是由 <code>StatusAggregator</code> 派生的，<code>StatusAggregator</code> 根据状态的有序列表对每个 <code>HealthIndicator</code> 的状态进行排序。
排序列表中的第一个状态用作整体健康状态。如果没有 <code>HealthIndicator</code> 返回 <code>StatusAggregator</code> 已知的状态，则使用 <code>UNKNOWN</code> 状态。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>HealthContributorRegistry</code> 可用于在运行时注册和注销健康指标。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="自动配置的healthindicators">自动配置的HealthIndicators</h5>
<div class="paragraph">
<p>适当时，Spring Boot会自动配置以下 <code>HealthIndicators</code>：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java"><code>CassandraHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Cassandra数据库是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java"><code>CouchbaseHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Couchbase集群是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java"><code>DiskSpaceHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查磁盘空间不足。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticSearchRestHealthContributorAutoConfiguration.java"><code>ElasticSearchRestHealthContributorAutoConfiguration</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Elasticsearch集群是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/hazelcast/HazelcastHealthIndicator.java"><code>HazelcastHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Hazelcast服务器是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java"><code>InfluxDbHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查InfluxDB服务器是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java"><code>JmsHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查JMS代理是否启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/ldap/LdapHealthIndicator.java"><code>LdapHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查LDAP服务器是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java"><code>MailHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查邮件服务器是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java"><code>MongoHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Mongo数据库是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java"><code>Neo4jHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Neo4j数据库是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/PingHealthIndicator.java"><code>PingHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">始终以 <code>UP</code> 响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java"><code>RabbitHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Rabbit服务器是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java"><code>RedisHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Redis服务器是否启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java"><code>SolrHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Solr服务器是否已启动。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你可以通过设置 <code>management.health.defaults.enabled</code> 属性来禁用它们。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="编写自定义健康指标">编写自定义健康指标</h5>
<div class="paragraph">
<p>为了提供自定义的健康信息，你可以注册实现 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java"><code>HealthIndicator</code></a>接口的Spring bean。
你需要提供 <code>health()</code> 方法的实现并返回 <code>Health</code> 响应。<code>Health</code> 响应应包括状态，并且可以选择包括要显示的其他详细信息。
以下代码显示了示例 <code>HealthIndicator</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;
@Component
public class MyHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        int errorCode = check(); // perform some specific health check
        if (errorCode != 0) {
            return Health.down().withDetail("Error Code", errorCode).build();
        }
        return Health.up().build();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
给定 <code>HealthIndicator</code> 的标识符是不带有 <code>HealthIndicator</code> 后缀（如果存在）的bean的名称。在前面的示例中，健康信息在名为 <code>my</code> 的条目中可用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除了Spring Boot的预定义 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java"><code>Status</code></a>类型外，
<code>Health</code> 还可以返回代表新系统状态的自定义 <code>Status</code>。
在这种情况下，还需要提供 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/StatusAggregator.java"><code>StatusAggregator</code></a>接口的自定义实现，
或者必须使用 <code>management.endpoint.health.status.order</code> 配置属性来配置默认实现。</p>
</div>
<div class="paragraph">
<p>例如，假设在你的 <code>HealthIndicator</code> 实现之一中使用了代码为 <code>FATAL</code> 的新 <code>Status</code>。要配置严重性顺序，请将以下属性添加到你的应用程序属性中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.health.status.order=fatal,down,out-of-service,unknown,up</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应中的HTTP状态码反映了总体健康状态（例如：<code>UP</code> 映射为200，而 <code>OUT_OF_SERVICE</code> 和 <code>DOWN</code> 映射为503）。
如果通过HTTP访问health端点，则可能还需要注册自定义状态映射。例如，以下属性将 <code>FATAL</code> 映射到503 (service unavailable)：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.health.status.http-mapping.fatal=503</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要更多控制，则可以定义自己的 <code>HttpCodeStatusMapper</code> bean。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下表显示了内置状态的默认HTTP状态映射：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">映射</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOWN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVICE_UNAVAILABLE (503)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OUT_OF_SERVICE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVICE_UNAVAILABLE (503)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下没有映射，因此http状态为200</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNKNOWN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认情况下没有映射，因此http状态为200</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="reactive-health-indicators">Reactive健康指标</h5>
<div class="paragraph">
<p>对于诸如使用Spring WebFlux的响应式应用程序，<code>ReactiveHealthContributor</code> 提供了一个非阻塞契约来获取应用程序的运行状况。
与传统的 <code>HealthContributor</code> 相似，健康信息是从 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.java"><code>ReactiveHealthContributorRegistry</code></a>
（默认情况下，在 <code>ApplicationContext</code> 中定义的所有 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java"><code>HealthContributor</code></a>和
<a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java"><code>ReactiveHealthContributor</code></a>实例）的内容中收集的。
不检查reactive API的常规 <code>HealthContributor</code> 在弹性调度器上执行。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在响应式应用程序中，<code>ReactiveHealthContributorRegistry</code> 可用于在运行时注册和注销健康指标。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了从响应式API提供自定义健康信息，你可以注册实现 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java"><code>ReactiveHealthIndicator</code></a>
接口的Spring bean。以下代码显示了示例 <code>ReactiveHealthIndicator</code> 实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class MyReactiveHealthIndicator implements ReactiveHealthIndicator {
    @Override
    public Mono&lt;Health&gt; health() {
        return doHealthCheck() //perform some specific health check that returns a Mono&lt;Health&gt;
            .onErrorResume(ex -&gt; Mono.just(new Health.Builder().down(ex).build()));
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要自动处理错误，请考虑继承自 <code>AbstractReactiveHealthIndicator</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="自动配置的reactivehealthindicators">自动配置的ReactiveHealthIndicators</h5>
<div class="paragraph">
<p>适当时，Spring Boot会自动配置以下 <code>ReactiveHealthIndicators</code>：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java"><code>CassandraReactiveHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Cassandra数据库是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java"><code>CouchbaseReactiveHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Couchbase集群是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java"><code>MongoReactiveHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Mongo数据库是否已启动。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java"><code>RedisReactiveHealthIndicator</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">检查Redis服务器是否启动。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如有必要，可用reactive指示器代替常规指示器。另外，任何未明确处理的 <code>HealthIndicator</code> 都会自动包装。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="健康组">健康组</h5>
<div class="paragraph">
<p>有时候，将健康指标分为不同的组很有用。例如，如果将应用程序部署到Kubernetes，则可能需要一组不同的运行状况指示器来进行 &#8220;liveness&#8221; 和 &#8220;readiness&#8221; 探针。</p>
</div>
<div class="paragraph">
<p>要创建运行状况指示器组，可以使用 <code>management.endpoint.health.group.&lt;name&gt;</code> 属性，
并指定要 <code>include</code> 或 <code>exclude</code> 的运行状况指示器ID的列表。例如，要创建仅包含数据库指示符的组，可以定义以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.health.group.custom.include=db</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，你可以通过单击 <code><a href="http://localhost:8080/actuator/health/custom" class="bare">http://localhost:8080/actuator/health/custom</a></code> 来检查结果。</p>
</div>
<div class="paragraph">
<p>默认情况下，组将继承与系统运行状况相同的 <code>StatusAggregator</code> 和 <code>HttpCodeStatusMapper</code> 设置，
但是，这些设置也可以基于每个组进行定义。如果需要，也可以覆盖 <code>show-details</code> 和 <code>role</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.health.group.custom.show-details=when-authorized
management.endpoint.health.group.custom.roles=admin
management.endpoint.health.group.custom.status.order=fatal,up
management.endpoint.health.group.custom.status.http-mapping.fatal=500</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要注册自定义 <code>StatusAggregator</code> 或 <code>HttpCodeStatusMapper</code> Bean以便与该组一起使用，则可以使用 <code>@Qualifier("groupname")</code>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-application-info">3.2.9. 应用信息</h4>
<div class="paragraph">
<p>应用程序信息公开了从 <code>ApplicationContext</code> 中定义的所有 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a> Bean收集的各种信息。Spring
Boot包含许多自动配置的 <code>InfoContributor</code> Bean，你可以编写自己的bean。</p>
</div>
<div class="sect4">
<h5 id="production-ready-application-info-autoconfigure">自动配置的InfoContributors</h5>
<div class="paragraph">
<p>适当时，Spring Boot会自动配置以下 <code>InfoContributor</code> Bean：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java"><code>EnvironmentInfoContributor</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 <code>info</code> 键下公开 <code>Environment</code> 中的任何键。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java"><code>GitInfoContributor</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 <code>git.properties</code> 文件可用，则公开git信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java"><code>BuildInfoContributor</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果 <code>META-INF/build-info.properties</code> 文件可用，则公开构建信息。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
通过设置 <code>management.info.defaults.enabled</code> 属性，可以全部禁用它们。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-application-info-env">自定义应用信息</h5>
<div class="paragraph">
<p>你可以通过设置 <code>info.*</code> Spring属性来自定义 <code>info</code> 端点公开的数据。
<code>info</code> 键下的所有 <code>Environment</code> 属性将自动显示。例如，你可以将以下设置添加到 <code>application.properties</code> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">info.app.encoding=UTF-8
info.app.java.source=1.8
info.app.java.target=1.8</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除了对这些值进行硬编码之外，你还可以 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-automatic-expansion">在构建时展开信息属性</a>。</p>
</div>
<div class="paragraph">
<p>假设你使用Maven，则可以按如下所示重写前面的示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">info.app.encoding=@project.build.sourceEncoding@
info.app.java.source=@java.version@
info.app.java.target=@java.version@</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-application-info-git">Git提交信息</h5>
<div class="paragraph">
<p><code>info</code> 端点的另一个有用的功能是它能够在项目构建时发布有关 <code>git</code> 源代码存储库状态的信息。如果有 <code>GitProperties</code> Bean，
则将公开 <code>git.branch</code>，<code>git.commit.id</code> 和 <code>git.commit.time</code> 属性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果 <code>git.properties</code> 文件在类路径的根目录下可用，则会自动配置 <code>GitProperties</code> bean。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-git-info">生成git信息</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果要显示完整的git信息（即 <code>git.properties</code> 的完整内容），请使用 <code>management.info.git.mode</code> 属性，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.info.git.mode=full</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-application-info-build">构建信息</h5>
<div class="paragraph">
<p>如果有 <code>BuildProperties</code> Bean，则 <code>info</code> 端点也可以发布有关你的构建的信息。如果在类路径中有 <code>META-INF/build-info.properties</code> 文件，则会发生这种情况。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Maven和Gradle插件都可以生成该文件。有关更多详细信息，请参见
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#howto-build-info">生成构建信息</a>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-application-info-custom">编写自定义InfoContributors</h5>
<div class="paragraph">
<p>为了提供自定义的应用程序信息，你可以注册实现 <a href="https://github.com/spring-projects/spring-boot/tree/v2.2.2.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java"><code>InfoContributor</code></a>接口的Spring bean。</p>
</div>
<div class="paragraph">
<p>以下示例使用单个值提供 <code>example</code> 条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">import java.util.Collections;
import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;
@Component
public class ExampleInfoContributor implements InfoContributor {
    @Override
    public void contribute(Info.Builder builder) {
        builder.withDetail("example",
                Collections.singletonMap("key", "value"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果请求 <code>info</code> 端点，则应该看到包含以下附加条目的响应：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json">{
    "example": {
        "key" : "value"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-monitoring">3.3. 通过HTTP进行监视和管理</h3>
<div class="paragraph">
<p>如果你正在开发Web应用程序，则Spring Boot Actuator会自动配置所有启用的端点以通过HTTP公开。
默认约定是使用带有 <code>/actuator</code> 前缀的端点的ID作为URL路径。例如：<code>health</code> 公开为 <code>/actuator/health</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Spring MVC，Spring WebFlux和Jersey本身支持Actuator。如果同时提供Jersey和Spring MVC，将使用Spring MVC。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="production-ready-customizing-management-server-context-path">3.3.1. 自定义管理端点路径</h4>
<div class="paragraph">
<p>有时，自定义管理端点的前缀很有用。例如，你的应用程序可能已经将 <code>/actuator</code> 用于其他目的。你可以使用
<code>management.endpoints.web.base-path</code> 属性更改管理端点的前缀，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.base-path=/manage</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的 <code>application.properties</code> 示例将端点从 <code>/actuator/{id}</code> 更改为 <code>/manage/{id}</code>（例如： <code>/manage/info</code>）。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
除非管理端口已配置为<a href="#production-ready-customizing-management-server-port">使用其他HTTP端口公开端点</a>，
否则 <code>management.endpoints.web.base-path</code> 是相对于 <code>server.servlet.context-path</code> 的。
如果配置了 <code>management.server.port</code>，则 <code>management.endpoints.web.base-path</code> 相对于 <code>management.server.servlet.context-path</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果要将端点映射到其他路径，则可以使用 <code>management.endpoints.web.path-mapping</code> 属性。</p>
</div>
<div class="paragraph">
<p>以下示例将 <code>/actuator/health</code> 重新映射到  <code>/healthcheck</code>：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.base-path=/
management.endpoints.web.path-mapping.health=healthcheck</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-customizing-management-server-port">3.3.2. 自定义管理服务器端口</h4>
<div class="paragraph">
<p>对于基于云的部署，通过使用默认的HTTP端口公开管理端点是明智的选择。但是，如果你的应用程序在自己的数据中心内运行，则你可能更喜欢使用其他HTTP端口公开端点。</p>
</div>
<div class="paragraph">
<p>你可以设置 <code>management.server.port</code> 属性以更改HTTP端口，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.server.port=8081</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在Cloud Foundry上，默认情况下，应用程序仅在端口8080上接收HTTP和TCP路由请求。
如果要在Cloud Foundry上使用自定义管理端口，则需要明确设置应用程序的路由，以将流量转发到自定义端口。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-management-specific-ssl">3.3.3. 配置特定于管理的SSL</h4>
<div class="paragraph">
<p>当配置为使用定制端口时，还可以通过使用各种 <code>management.server.ssl.*</code> 属性将管理服务器配置为其自身的SSL。
例如，这样做可以使管理服务器通过HTTP可用，而主应用程序使用HTTPS，如以下属性设置所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:store.jks
server.ssl.key-password=secret
management.server.port=8080
management.server.ssl.enabled=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，主服务器和管理服务器都可以使用SSL，但具有不同的密钥库，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:main.jks
server.ssl.key-password=secret
management.server.port=8080
management.server.ssl.enabled=true
management.server.ssl.key-store=classpath:management.jks
management.server.ssl.key-password=secret</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-customizing-management-server-address">3.3.4. 自定义管理服务器地址</h4>
<div class="paragraph">
<p>你可以通过设置 <code>management.server.address</code> 属性来自定义管理端点可用的地址。如果你只想在内部或面向操作的网络上侦听或仅侦听来自本地主机的连接，则这样做很有用。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅当端口与主服务器端口不同时，你才能在其他地址上侦听。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例 <code>application.properties</code> 不允许远程管理连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.server.port=8081
management.server.address=127.0.0.1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-disabling-http-endpoints">3.3.5. 禁用HTTP端点</h4>
<div class="paragraph">
<p>如果你不想通过HTTP公开端点，则可以将管理端口设置为 <code>-1</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.server.port=-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>management.endpoints.web.exposure.exclude</code> 属性来实现，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.web.exposure.exclude=*</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-jmx">3.4. 通过JMX进行监视和管理</h3>
<div class="paragraph">
<p>Java管理扩展（JMX）提供了监视和管理应用程序的标准机制。默认情况下，此功能未启用，
可以通过将配置属性 <code>spring.jmx.enabled</code> 设置为 <code>true</code> 来启用。默认情况下，Spring Boot将管理端点公开为
<code>org.springframework.boot</code> 域下的JMX MBean。</p>
</div>
<div class="sect3">
<h4 id="production-ready-custom-mbean-names">3.4.1. 自定义MBean名称</h4>
<div class="paragraph">
<p>MBean的名称通常是根据端点的ID生成的。例如，<code>health</code> 端点显示为 <code>org.springframework.boot:type=Endpoint,name=Health</code>。</p>
</div>
<div class="paragraph">
<p>如果你的应用程序包含多个Spring <code>ApplicationContext</code>，则可能会发现名称冲突。要解决此问题，可以将
<code>spring.jmx.unique-names</code> 属性设置为 <code>true</code>，以便MBean名称始终是唯一的。</p>
</div>
<div class="paragraph">
<p>你还可以自定义暴露端点的JMX域。以下设置在 <code>application.properties</code> 中显示了如何这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jmx.unique-names=true
management.endpoints.jmx.domain=com.example.myapp</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-disable-jmx-endpoints">3.4.2. 禁用JMX端点</h4>
<div class="paragraph">
<p>如果你不想通过JMX公开端点，则可以将 <code>management.endpoints.jmx.exposure.exclude</code> 属性设置为 <code>*</code>，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoints.jmx.exposure.exclude=*</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-jolokia">3.4.3. 通过HTTP将Jolokia用于JMX</h4>
<div class="paragraph">
<p>Jolokia是一个JMX-HTTP桥，它提供了另一种访问JMX bean的方法。要使用Jolokia，请包括对 <code>org.jolokia:jolokia-core</code>
的依赖。例如，使用Maven，你将添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
    &lt;artifactId&gt;jolokia-core&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以通过将 <code>jolokia</code> 或 <code>*</code> 添加到 <code>management.endpoints.web.exposure.include</code> 属性来暴露Jolokia端点。
然后，你可以在管理HTTP服务器上使用 <code>/actuator/jolokia</code> 访问它。</p>
</div>
<div class="sect4">
<h5 id="production-ready-customizing-jolokia">自定义Jolokia</h5>
<div class="paragraph">
<p>Jolokia具有许多设置，这些设置通常是通过设置servlet参数进行配置的。
通过Spring Boot，你可以使用 <code>application.properties</code> 文件。为此，请在参数前面加上 <code>management.endpoint.jolokia.config</code>。
如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.jolokia.config.debug=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-disabling-jolokia">禁用Jolokia</h5>
<div class="paragraph">
<p>如果你使用Jolokia但不希望Spring Boot对其进行配置，则可将 <code>management.endpoint.jolokia.enabled</code> 属性设置为 <code>false</code>，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.endpoint.jolokia.enabled=false</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-loggers">3.5. 日志记录器</h3>
<div class="paragraph">
<p>Spring Boot Actuator可以在运行时查看和配置应用程序的日志级别。
你可以查看整个列表或单个记录器的配置，该配置由显式配置的日志记录级别以及日志记录框架为其指定的有效日志记录级别组成。
这些级别可以是以下之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TRACE</code></p>
</li>
<li>
<p><code>DEBUG</code></p>
</li>
<li>
<p><code>INFO</code></p>
</li>
<li>
<p><code>WARN</code></p>
</li>
<li>
<p><code>ERROR</code></p>
</li>
<li>
<p><code>FATAL</code></p>
</li>
<li>
<p><code>OFF</code></p>
</li>
<li>
<p><code>null</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>null</code> 表示没有显式配置。</p>
</div>
<div class="sect3">
<h4 id="production-ready-logger-configuration">3.5.1. 配置记录器</h4>
<div class="paragraph">
<p>要配置给定的记录器，请将部分实体 <code>POST</code> 到资源的URI中，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json" data-lang="json">{
    "configuredLevel": "DEBUG"
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要“重置”日志记录器的特定级别（并使用默认配置），可以传递一个 <code>null</code> 值作为 <code>configuredLevel</code>。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-metrics">3.6. 指标</h3>
<div class="paragraph">
<p>Spring Boot Actuator为 <a href="https://micrometer.io">Micrometer</a>提供依赖项管理和自动配置，Micrometer是一种支持多种监视系统的应用程序指标外观，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#production-ready-metrics-export-appoptics">AppOptics</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-atlas">Atlas</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-datadog">Datadog</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-dynatrace">Dynatrace</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-elastic">Elastic</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-ganglia">Ganglia</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-graphite">Graphite</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-humio">Humio</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-influx">Influx</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-jmx">JMX</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-kairos">KairosDB</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-newrelic">New Relic</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-prometheus">Prometheus</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-signalfx">SignalFx</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-simple">Simple (in-memory)</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-stackdriver">Stackdriver</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-statsd">StatsD</a></p>
</li>
<li>
<p><a href="#production-ready-metrics-export-wavefront">Wavefront</a></p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要了解有关Micrometer功能的更多信息，请参阅其 <a href="https://micrometer.io/docs">参考文档</a>，特别是 <a href="https://micrometer.io/docs/concepts">概念部分</a>。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-getting-started">3.6.1. 入门</h4>
<div class="paragraph">
<p>Spring Boot自动配置组合的 <code>MeterRegistry</code>，并为其在类路径上找到的每个受支持的实现向组合添加注册表。在运行时类路径中具有对
<code>micrometer-registry-{system}</code> 的依赖足以使Spring Boot配置注册表。</p>
</div>
<div class="paragraph">
<p>大多数注册表具有共同的特征。例如，即使Micrometer注册表实现位于类路径中，你也可以禁用特定的注册表。例如，禁用Datadog：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.datadog.enabled=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot还会将任何自动配置的注册表添加到Metrics类的全局静态复合注册表中，除非你明确告诉它不要这么做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.use-global-registry=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以注册任意数量的 <code>MeterRegistryCustomizer</code> Bean来进一步配置注册表，例如在向注册表注册任何度量器之前应用通用标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
MeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCommonTags() {
    return registry -&gt; registry.config().commonTags("region", "us-east-1");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>你可以应用自定义到特定的注册表实现更具体的泛型类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
MeterRegistryCustomizer&lt;GraphiteMeterRegistry&gt; graphiteMetricsNamingConvention() {
    return registry -&gt; registry.config().namingConvention(MY_CUSTOM_CONVENTION);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成该设置后，你可以将 <code>MeterRegistry</code> 注入组件并注册指标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
public class SampleBean {

    private final Counter counter;

    public SampleBean(MeterRegistry registry) {
        this.counter = registry.counter("received.messages");
    }

    public void handleMessage(String message) {
        this.counter.increment();
        // handle message implementation
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot还<a href="#production-ready-metrics-meter">配置了内置工具</a>（即 <code>MeterBinder</code> 实现），你可以通过配置或专用注解标记来控制它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-export">3.6.2. 支持的监控系统</h4>
<div class="sect4">
<h5 id="production-ready-metrics-export-appoptics">AppOptics</h5>
<div class="paragraph">
<p>默认情况下，AppOptics注册表会定期将指标推送到 <code><a href="https://api.appoptics.com/v1/measurements" class="bare">https://api.appoptics.com/v1/measurements</a></code>。
要将指标导出到SaaS <a href="https://micrometer.io/docs/registry/appoptics">AppOptics</a>，必须提供你的API令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.appoptics.api-token=YOUR_TOKEN</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-atlas">Atlas</h5>
<div class="paragraph">
<p>默认情况下，度量标准将导出到在本地计算机上运行的 <a href="https://micrometer.io/docs/registry/atlas">Atlas</a>。
可以使用以下命令提供要使用的 <a href="https://github.com/Netflix/atlas">Atlas服务器</a>的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.atlas.uri=https://atlas.example.com:7101/api/v1/publish</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-datadog">Datadog</h5>
<div class="paragraph">
<p>Datadog注册表会定期将指标推送到 <a href="https://www.datadoghq.com">datadoghq</a>。
要将指标导出到 <a href="https://micrometer.io/docs/registry/datadog">Datadog</a>，必须提供你的API密钥：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.datadog.api-key=YOUR_KEY</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到Datadog的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.datadog.step=30s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-dynatrace">Dynatrace</h5>
<div class="paragraph">
<p>Dynatrace注册表会定期将指标推送到配置的URI。
要将指标导出到 <a href="https://micrometer.io/docs/registry/dynatrace">Dynatrace</a>，必须提供你的API令牌，设备ID和URI：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.dynatrace.api-token=YOUR_TOKEN
management.metrics.export.dynatrace.device-id=YOUR_DEVICE_ID
management.metrics.export.dynatrace.uri=YOUR_URI</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到Dynatrace的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.dynatrace.step=30s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-elastic">Elastic</h5>
<div class="paragraph">
<p>默认情况下，指标会导出到在本地计算机上运行的 <a href="https://micrometer.io/docs/registry/elastic">Elastic</a>。
可以使用以下属性提供要使用的Elastic服务器的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.elastic.host=https://elastic.example.com:8086</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-ganglia">Ganglia</h5>
<div class="paragraph">
<p>默认情况下，指标将导出到在本地计算机上运行的 <a href="https://micrometer.io/docs/registry/ganglia">Ganglia</a>。
可以使用以下命令提供要使用的 <a href="http://ganglia.sourceforge.net">Ganglia服务器</a>主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.ganglia.host=ganglia.example.com
management.metrics.export.ganglia.port=9649</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-graphite">Graphite</h5>
<div class="paragraph">
<p>默认情况下，指标会导出到本地计算机上运行的 <a href="https://micrometer.io/docs/registry/graphite">Graphite</a>。
可以使用以下方式提供要使用的 <a href="https://graphiteapp.org">Graphite服务器</a>主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.graphite.host=graphite.example.com
management.metrics.export.graphite.port=9004</code></pre>
</div>
</div>
<div class="paragraph">
<p>Micrometer提供了默认的 <code>HierarchicalNameMapper</code>，用于控制如何将计量器ID <a href="https://micrometer.io/docs/registry/graphite#_hierarchical_name_mapping">映射到平面层次结构名称</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要控制此行为，请定义 <code>GraphiteMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>。除非你定义自己的，否则将提供自动配置的 <code>GraphiteConfig</code> 和 <code>Clock</code> Bean：
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public GraphiteMeterRegistry graphiteMeterRegistry(GraphiteConfig config, Clock clock) {
    return new GraphiteMeterRegistry(config, clock, MY_HIERARCHICAL_MAPPER);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-humio">Humio</h5>
<div class="paragraph">
<p>默认情况下，Humio注册表会定期将指标推送到 <a href="https://cloud.humio.com。" class="bare">https://cloud.humio.com。</a>
要将指标导出到SaaS <a href="https://micrometer.io/docs/registry/humio">Humio</a>，必须提供你的API令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.humio.api-token=YOUR_TOKEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还应该配置一个或多个tags以标识将度量标准推送到的数据源：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.humio.tags.alpha=a
management.metrics.export.humio.tags.bravo=b</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-influx">Influx</h5>
<div class="paragraph">
<p>默认情况下，指标会导出到本地计算机上运行的 <a href="https://micrometer.io/docs/registry/influx">Influx</a>。
可使用以下命令提供要使用的 <a href="https://www.influxdata.com">Influx服务器</a>的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.influx.uri=https://influx.example.com:8086</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-jmx">JMX</h5>
<div class="paragraph">
<p>Micrometer提供了到 <a href="https://micrometer.io/docs/registry/jmx">JMX</a>的层次结构映射，主要是作为一种便宜且可移植的方式在本地查看指标。
默认情况下，度量标准被导出到 <code>metrics</code> JMX域。可以使用以下方式提供要使用的域：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.jmx.domain=com.example.app.metrics</code></pre>
</div>
</div>
<div class="paragraph">
<p>Micrometer提供了默认的 <code>HierarchicalNameMapper</code>，用于控制如何将计量器ID <a href="https://micrometer.io/docs/registry/jmx#_hierarchical_name_mapping">映射到平面层次结构名称</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要控制此行为，请定义 <code>JmxMeterRegistry</code> 并提供自己的 <code>HierarchicalNameMapper</code>。除非你定义自己的，否则将提供自动配置的 <code>JmxConfig</code>
和 <code>Clock</code> Bean。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public JmxMeterRegistry jmxMeterRegistry(JmxConfig config, Clock clock) {
    return new JmxMeterRegistry(config, clock, MY_HIERARCHICAL_MAPPER);
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-kairos">KairosDB</h5>
<div class="paragraph">
<p>默认情况下，度量标准将导出到在本地计算机上运行的 <a href="https://micrometer.io/docs/registry/kairos">KairosDB</a>。
可以使用以下方式提供使用的 <a href="https://kairosdb.github.io/">KairosDB服务器</a>的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.kairos.uri=https://kairosdb.example.com:8080/api/v1/datapoints</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-newrelic">New Relic</h5>
<div class="paragraph">
<p>New Relic注册表会定期将指标推送到 <a href="https://micrometer.io/docs/registry/new-relic">New Relic</a>。
要将指标导出到 <a href="https://newrelic.com">New Relic</a>，必须提供你的API密钥和帐户ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.newrelic.api-key=YOUR_KEY
management.metrics.export.newrelic.account-id=YOUR_ACCOUNT_ID</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到New Relic的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.newrelic.step=30s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-prometheus">Prometheus</h5>
<div class="paragraph">
<p><a href="https://micrometer.io/docs/registry/prometheus">Prometheus</a>希望抓取或轮询单个应用程序实例以获取指标。
Spring Boot在 <code>/actuator/prometheus</code> 提供了一个执行器端点，以适当的格式显示 <a href="https://prometheus.io">Prometheus scrape</a>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
端点默认情况下不可用，若需公开，有关更多详细信息，请参见<a href="#production-ready-endpoints-exposing-endpoints">暴露端点</a>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这是添加到 <code>prometheus.yml</code> 的示例 <code>scrape_config</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml" data-lang="yaml">scrape_configs:
  - job_name: 'spring'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['HOST:PORT']</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于短暂的或批处理的jobs，其时间可能不够长，无法被捕获，可以使用
<a href="https://github.com/prometheus/pushgateway">Prometheus Pushgateway</a>支持将其指标暴露给Prometheus。
要启用Prometheus Pushgateway支持，请在项目中添加以下依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;
    &lt;artifactId&gt;simpleclient_pushgateway&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当在类路径上存在Prometheus Pushgateway依赖项时，Spring Boot会自动配置 <code>PrometheusPushGatewayManager</code> bean。
这可以管理将指标推送到Prometheus Pushgateway。可以使用 <code>management.metrics.export.prometheus.pushgateway</code>
下的属性来调整 <code>PrometheusPushGatewayManager</code>。对于高级配置，你还可以提供自己的 <code>PrometheusPushGatewayManager</code> bean。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-signalfx">SignalFx</h5>
<div class="paragraph">
<p>SignalFx注册表会定期将指标推送到 <a href="https://micrometer.io/docs/registry/signalfx">SignalFx</a>。
要将指标导出到 <a href="https://www.signalfx.com">SignalFx</a>，必须提供访问令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.signalfx.access-token=YOUR_ACCESS_TOKEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到SignalFx的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.signalfx.step=30s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-simple">Simple</h5>
<div class="paragraph">
<p>Micrometer附带一个简单的内存后端，如果未配置其他注册表，该后端将自动用作后备。
这使你可以查看在<a href="#production-ready-metrics-endpoint">metrics端点</a>中收集了哪些指标。</p>
</div>
<div class="paragraph">
<p>使用任何其他可用后端时，内存后端都会自动禁用。你也可以显式禁用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.simple.enabled=false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-stackdriver">Stackdriver</h5>
<div class="paragraph">
<p>Stackdriver注册表会定期将指标推送到 <a href="https://cloud.google.com/stackdriver/">Stackdriver</a>。
要将指标导出到SaaS <a href="https://micrometer.io/docs/registry/stackdriver">Stackdriver</a>，必须提供你的Google Cloud项目ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.stackdriver.project-id=my-project</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到Stackdriver的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.stackdriver.step=30s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-statsd">StatsD</h5>
<div class="paragraph">
<p>StatsD注册表急切地通过UDP将度量标准推送到StatsD agent。
默认情况下，指标会导出到本地计算机上运行的 <a href="https://micrometer.io/docs/registry/statsd">StatsD</a> agent。
可以使用以下方式提供要使用的StatsD agent主机和端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.statsd.host=statsd.example.com
management.metrics.export.statsd.port=9125</code></pre>
</div>
</div>
<div class="paragraph">
<p>你还可以更改要使用的StatsD线路协议（默认为Datadog）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.statsd.flavor=etsy</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-export-wavefront">Wavefront</h5>
<div class="paragraph">
<p>Wavefront注册表会定期将指标推送到 <a href="https://micrometer.io/docs/registry/wavefront">Wavefront</a>。
如果直接将指标导出到 <a href="https://www.wavefront.com/">Wavefront</a>，则必须提供API令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.wavefront.api-token=YOUR_API_TOKEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，你可以使用在你的环境中设置的Wavefront sidecar或内部代理，将指标数据转发到Wavefront API主机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.wavefront.uri=proxy://localhost:2878</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果将指标发布到Wavefront代理（如 <a href="https://docs.wavefront.com/proxies_installing.html">文档</a>中所述），
则主机必须采用 <code>proxy://HOST:PORT</code> 格式。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以更改将度量标准发送到Wavefront的时间间隔：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.export.wavefront.step=30s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-meter">3.6.3. 支持的指标</h4>
<div class="paragraph">
<p>如果适用，Spring Boot将注册以下核心指标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JVM指标，报告以下各项的利用率：</p>
<div class="ulist">
<ul>
<li>
<p>各种内存和缓冲池</p>
</li>
<li>
<p>与垃圾收集有关的统计数据</p>
</li>
<li>
<p>线程利用率</p>
</li>
<li>
<p>加载/卸载的类数</p>
</li>
</ul>
</div>
</li>
<li>
<p>CPU指标</p>
</li>
<li>
<p>文件描述符指标</p>
</li>
<li>
<p>Kafka消费者指标</p>
</li>
<li>
<p>Log4j2指标: 记录每个级别记录到Log4j2的事件数</p>
</li>
<li>
<p>Logback指标: 记录每个级别记录到Logback的事件数</p>
</li>
<li>
<p>Uptime指标: 报告正常运行时间的量度和代表应用程序绝对启动时间的固定量度</p>
</li>
<li>
<p>Tomcat指标 (必须将 <code>server.tomcat.mbeanregistry.enabled</code> 设置为 <code>true</code> 才能注册所有Tomcat指标)</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-integration/docs/5.2.2.RELEASE/reference/html/system-management.html#micrometer-integration">Spring Integration</a>指标</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-spring-mvc">Spring MVC指标</h5>
<div class="paragraph">
<p>通过自动配置，可以检测由Spring MVC处理的请求。
当 <code>management.metrics.web.server.request.autotime.enabled</code> 为 <code>true</code> 时，将对所有请求进行这种检测。
另外，当设置为 <code>false</code> 时，可以通过将 <code>@Timed</code> 添加到请求处理方法来启用检测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@RestController
@Timed <i class="conum" data-value="1"></i><b>(1)</b>
public class MyController {

    @GetMapping("/api/people")
    @Timed(extraTags = { "region", "us-east-1" }) <i class="conum" data-value="2"></i><b>(2)</b>
    @Timed(value = "all.people", longTask = true) <i class="conum" data-value="3"></i><b>(3)</b>
    public List&lt;Person&gt; listPeople() { ... }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>控制器类，用于对控制器中的每个请求处理程序启用计时。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一种启用单个端点的方法。如果你将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在 <code>longTask = true</code> 的方法为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，使用名称 <code>http.server.requests</code> 生成度量。
可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，与Spring MVC相关的指标带有以下信息标签：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理请求时引发的任何异常的简单类名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的方法（例如： <code>GET</code> 或 <code>POST</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outcome</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的结果基于响应的状态码。
  1xx是 <code>INFORMATIONAL</code>，2xx是 <code>SUCCESS</code>，3xx是 <code>REDIRECTION</code>，4xx是 <code>CLIENT_ERROR</code>，5xx是 <code>SERVER_ERROR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的HTTP状态码（例如： <code>200</code> 或 <code>500</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求在变量替换之前的URI模板，如果可能的话(例如： <code>/api/person/{id}</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义标签，请提供实现 <code>WebMvcTagsProvider</code> 的 <code>@Bean</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-web-flux">Spring WebFlux指标</h5>
<div class="paragraph">
<p>通过自动配置，可以检测WebFlux控制器和函数式处理程序处理的所有请求。</p>
</div>
<div class="paragraph">
<p>默认情况下，度量标准的名称为 <code>http.server.requests</code>。
你可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，与WebFlux相关的指标带有以下信息标签：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理请求时引发的任何异常的简单类名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的方法（例如： <code>GET</code> 或 <code>POST</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outcome</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的结果基于响应的状态码。
  1xx是 <code>INFORMATIONAL</code>，2xx是 <code>SUCCESS</code>，3xx是 <code>REDIRECTION</code>，4xx是 <code>CLIENT_ERROR</code>，5xx是 <code>SERVER_ERROR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的HTTP状态码（例如： <code>200</code> 或 <code>500</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求在变量替换之前的URI模板，如果可能的话(例如： <code>/api/person/{id}</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义标签，请提供实现 <code>WebFluxTagsProvider</code> 的 <code>@Bean</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-jersey-server">Jersey服务器指标</h5>
<div class="paragraph">
<p>当Micrometer的 <code>micrometer-jersey2</code> 模块位于类路径上时，自动配置将启用对Jersey JAX-RS实现所处理的请求的检测。
当 <code>management.metrics.web.server.request.autotime.enabled</code> 为 <code>true</code> 时，将对所有请求进行这种检测。
另外，当设置为 <code>false</code> 时，可以通过将 <code>@Timed</code> 添加到请求处理方法来启用检测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Component
@Path("/api/people")
@Timed <i class="conum" data-value="1"></i><b>(1)</b>
public class Endpoint {

    @GET
    @Timed(extraTags = { "region", "us-east-1" }) <i class="conum" data-value="2"></i><b>(2)</b>
    @Timed(value = "all.people", longTask = true) <i class="conum" data-value="3"></i><b>(3)</b>
    public List&lt;Person&gt; listPeople() { ... }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在资源类上，以对资源中的每个请求处理程序启用计时。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>关于启用单个端点的方法。如果你将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在 <code>longTask = true</code> 的方法上为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下，使用名称 <code>http.server.requests</code> 生成度量。
可以通过设置 <code>management.metrics.web.server.request.metric-name</code> 属性来自定义名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，Jersey服务器指标带有以下信息：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处理请求时引发的任何异常的简单类名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的方法（例如： <code>GET</code> 或 <code>POST</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outcome</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的结果基于响应的状态码。
  1xx是 <code>INFORMATIONAL</code>，2xx是 <code>SUCCESS</code>，3xx是 <code>REDIRECTION</code>，4xx是 <code>CLIENT_ERROR</code>，5xx是 <code>SERVER_ERROR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的HTTP状态码（例如： <code>200</code> 或 <code>500</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求在变量替换之前的URI模板，如果可能的话(例如： <code>/api/person/{id}</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义标签，请提供实现 <code>JerseyTagsProvider</code> 的 <code>@Bean</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-http-clients">HTTP客户端指标</h5>
<div class="paragraph">
<p>Spring Boot Actuator管理 <code>RestTemplate</code> 和 <code>WebClient</code> 的工具。为此，你必须注入自动配置的构建器并使用它来创建实例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RestTemplateBuilder</code> for <code>RestTemplate</code></p>
</li>
<li>
<p><code>WebClient.Builder</code> for <code>WebClient</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>也可以手动应用负责此工具的定制程序，即 <code>MetricsRestTemplateCustomizer</code> 和 <code>MetricsWebClientCustomizer</code>。</p>
</div>
<div class="paragraph">
<p>默认情况下，将使用名称 <code>http.client.requests</code> 生成度量。
可以通过设置 <code>management.metrics.web.client.request.metric-name</code> 属性来自定义名称。</p>
</div>
<div class="paragraph">
<p>默认情况下，通过检测的客户端所生成的指标带有以下信息标签：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标签</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URI的主机部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的方法（例如： <code>GET</code> 或 <code>POST</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>outcome</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求的结果基于响应的状态码。
  1xx是 <code>INFORMATIONAL</code>，2xx是 <code>SUCCESS</code>，3xx是 <code>REDIRECTION</code>，4xx是 <code>CLIENT_ERROR</code>，5xx是 <code>SERVER_ERROR</code>，否则是 <code>UNKNOWN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>status</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">响应的HTTP状态码（例如： <code>200</code> 或 <code>500</code>），如果有I/O问题，则为 <code>IO_ERROR</code>；否则为 <code>CLIENT_ERROR</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求在变量替换之前的URI模板，如果可能的话(例如： <code>/api/person/{id}</code>)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义标签，可以根据你选择的客户端，提供一个实现 <code>RestTemplateExchangeTagsProvider</code> 或
<code>WebClientExchangeTagsProvider</code> 的 <code>@Bean</code>。 <code>RestTemplateExchangeTags</code> 和 <code>WebClientExchangeTags</code> 中有便捷的静态函数。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-cache">缓存指标</h5>
<div class="paragraph">
<p>通过自动配置，可以在启动时使用前缀为 <code>cache</code> 的指标来检测所有可用的 <code>Cache</code>s。
高速缓存检测针对一组基本指标进行了标准化。还提供其他特定于缓存的指标。</p>
</div>
<div class="paragraph">
<p>支持以下缓存库：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caffeine</p>
</li>
<li>
<p>EhCache 2</p>
</li>
<li>
<p>Hazelcast</p>
</li>
<li>
<p>任何兼容的JCache (JSR-107)实现</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>根据缓存的名称和从bean名称派生的 <code>CacheManager</code> 的名称对指标进行标记。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只有启动时可用的缓存才绑定到注册表。对于在启动阶段后即时或以编程方式创建的缓存，需要显式注册。提供 <code>CacheMetricsRegistrar</code> Bean可简化该过程。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-jdbc">数据源指标</h5>
<div class="paragraph">
<p>通过自动配置，可以使用前缀为 <code>jdbc.connections</code> 的度量来检测所有可用的 <code>DataSource</code> 对象。
数据源检测产生的指标表示池中当前活动，空闲，最大允许和最小允许的连接。</p>
</div>
<div class="paragraph">
<p>指标还根据基于bean名称计算的 <code>DataSource</code> 名称进行标记。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
默认情况下，Spring Boot为所有支持的数据源提供元数据。如果你喜欢的数据源不支持开箱即用，则可以添加额外的
<code>DataSourcePoolMetadataProvider</code> bean。有关示例，请参见 <code>DataSourcePoolMetadataProvidersConfiguration</code>。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外，使用Hikaricp前缀公开特定于Hikari的指标。每个度量指标都以池的名称标记（可以通过 <code>spring.datasource.name</code> 进行控制）。</p>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-hibernate">Hibernate指标</h5>
<div class="paragraph">
<p>自动配置启用所有可用的Hibernate <code>EntityManagerFactory</code> 实例的检测，这些实例使用名为 <code>hibernate</code>
的指标启用了统计信息。</p>
</div>
<div class="paragraph">
<p>指标还使用来自bean名称的 <code>EntityManagerFactory</code> 名称进行标记。</p>
</div>
<div class="paragraph">
<p>要启用统计信息，必须将标准JPA属性 <code>hibernate.generate_statistics</code> 设置为 <code>true</code>。
你可以在自动配置的 <code>EntityManagerFactory</code> 上启用它，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">spring.jpa.properties.hibernate.generate_statistics=true</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-rabbitmq">RabbitMQ指标</h5>
<div class="paragraph">
<p>自动配置将使用名为 <code>rabbitmq</code> 的指标启用所有可用的RabbitMQ连接工厂的检测。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-custom">3.6.4. 注册自定义指标</h4>
<div class="paragraph">
<p>要注册自定义指标，请将 <code>MeterRegistry</code> 注入你的组件，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">class Dictionary {

    private final List&lt;String&gt; words = new CopyOnWriteArrayList&lt;&gt;();

    Dictionary(MeterRegistry registry) {
        registry.gaugeCollectionSize("dictionary.size", Tags.empty(), this.words);
    }

    // …

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果发现重复测量了跨组件或应用程序的一组指标，则可以将此指标封装在 <code>MeterBinder</code> 实现中。
默认情况下，所有 <code>MeterBinder</code> Bean的指标都将自动绑定到Spring管理的 <code>MeterRegistry</code>。</p>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-per-meter-properties">3.6.5. 自定义单个指标</h4>
<div class="paragraph">
<p>如果需要将自定义应用于特定的 <code>Meter</code> 实例，则可以使用 <code>io.micrometer.core.instrument.config.MeterFilter</code> 接口。
默认情况下，所有 <code>MeterFilter</code> bean都将自动应用于micrometer <code>MeterRegistry.Config</code>。</p>
</div>
<div class="paragraph">
<p>例如，如果要将所有以 <code>com.example</code> 开头的计量器ID的 <code>mytag.region</code> 标签重命名为 <code>mytag.area</code>，则可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">@Bean
public MeterFilter renameRegionTagMeterFilter() {
    return MeterFilter.renameTag("com.example", "mytag.region", "mytag.area");
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="production-ready-metrics-common-tags">通用标签</h5>
<div class="paragraph">
<p>通用标签通常用于在操作环境（如主机，实例，区域，堆栈等）上进行维度深入分析。通用标签适用于所有计量器，并可以按以下示例所示进行配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.tags.region=us-east-1
management.metrics.tags.stack=prod</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的示例将 <code>region</code> 标签和 <code>stack</code> 标签添加到所有计量器，其值分别为 <code>us-east-1</code> 和 <code>prod</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用Graphite，则通用标签的顺序很重要。由于使用这种方法无法保证通用标签的顺序，因此建议Graphite用户定义自定义 <code>MeterFilter</code>。
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="per-meter属性">Per-meter属性</h5>
<div class="paragraph">
<p>除了 <code>MeterFilter</code> bean之外，还可以使用属性在per-meter基础上应用一组有限的自定义设置。
Per-meter定制适用于任何以给定名称开头的所有计量器IDs。例如，以下将禁用所有ID以 <code>example.remote</code> 开头的计量器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties" data-lang="properties">management.metrics.enable.example.remote=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下属性允许按per-meter自定义：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. Per-meter自定义</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">属性</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.metrics.enable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否拒绝计量器发出任何指标。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.metrics.distribution.percentiles-histogram</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否发布适合计算可聚合(跨维度)百分比近似值的直方图。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.metrics.distribution.minimum-expected-value</code>, <code>configprop:management.metrics.distribution.maximum-expected-value</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过限制期望值的范围来发布较少的直方图桶。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.metrics.distribution.percentiles</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布在应用程序中计算的百分位值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>management.metrics.distribution.sla</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布带有SLAs定义的桶的累积直方图。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关 <code>percentiles-histogram</code>，<code>percentiles</code> 和 <code>sla</code> 背后的概念的更多详细信息，请参阅micrometer文档的
<a href="https://micrometer.io/docs/concepts#_histograms_and_percentiles">直方图和百分位数</a>部分。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-metrics-endpoint">3.6.6. 指标端点</h4>
<div class="paragraph">
<p>Spring Boot提供了一个 <code>metrics</code> 端点，可用于诊断检查应用程序收集的指标。端点默认情况下不可用，若需公开，
有关更多详细信息，请参见<a href="#production-ready-endpoints-exposing-endpoints">暴露端点</a>。</p>
</div>
<div class="paragraph">
<p>导航到 <code>/actuator/metrics</code> 会显示可用计量器名称的列表。你可以通过提供特定名称作为选择器来深入查看有关特定计量器的信息，
例如： <code>/actuator/metrics/jvm.memory.max</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>你在此处使用的名称应与代码中使用的名称相匹配，而不是已经针对其附带的监视系统进行了命名约定标准化后的名称。
换句话说，如果 <code>jvm.memory.max</code> 由于其蛇形命名约定而在Prometheus中显示为 <code>jvm_memory_max</code>，
则在检查 <code>metrics</code> 端点中的计量器时，仍应使用 <code>jvm.memory.max</code> 作为选择器。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你还可以在网址末尾添加任意数量的 <code>tag=KEY:VALUE</code> 查询参数，以在维度上更深入地了解计量器，例如： <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>报告的测量值是与计量器名称和已应用的任何标签相匹配的所有计量器的统计信息的总和。
因此，在上面的示例中，返回的“值”统计量是堆的“代码缓存”，“压缩类空间”和“元空间”区域的最大内存占用量的总和。
如果你只想查看“元空间”的最大大小，则可以添加一个额外的 <code>tag=id:Metaspace</code>，
即 <code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;tag=id:Metaspace</code>。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-auditing">3.7. 审计</h3>
<div class="paragraph">
<p>一旦启动了Spring Security，Spring Boot Actuator将拥有一个灵活的审核框架来发布事件
（默认情况下，“身份验证成功”，“失败”和“拒绝访问”异常）。此功能对于基于身份验证失败的报告和实施锁定策略非常有用。</p>
</div>
<div class="paragraph">
<p>可以通过在应用程序的配置中提供类型为 <code>AuditEventRepository</code> 的bean来启用审核。为了方便起见，Spring Boot提供了一个
<code>InMemoryAuditEventRepository</code>。<code>InMemoryAuditEventRepository</code> 具有有限的功能，我们建议仅将其用于开发环境。
对于生产环境，请考虑创建自己的替代 <code>AuditEventRepository</code> 实现。</p>
</div>
<div class="sect3">
<h4 id="production-ready-auditing-custom">3.7.1. 自定义审计</h4>
<div class="paragraph">
<p>要自定义已发布的安全事件，可以提供自己的 <code>AbstractAuthenticationAuditListener</code> 和
<code>AbstractAuthorizationAuditListener</code> 的实现。</p>
</div>
<div class="paragraph">
<p>你也可以将审计服务用于自己的业务事件。
为此，可以将 <code>AuditEventRepository</code> bean注入你自己的组件中并直接使用它，或者通过Spring
<code>ApplicationEventPublisher</code>（通过实现 <code>ApplicationEventPublisherAware</code>）发布 <code>AuditApplicationEvent</code>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-http-tracing">3.8. HTTP追踪</h3>
<div class="paragraph">
<p>可以通过在应用程序的配置中提供 <code>HttpTraceRepository</code> 类型的Bean来启用HTTP追踪。
为了方便起见，Spring Boot默认提供了一个 <code>InMemoryHttpTraceRepository</code>，用于存储最近100次请求-响应交换的追踪。
与其他追踪解决方案相比，<code>InMemoryHttpTraceRepository</code> 受到限制，我们建议仅将其用于开发环境。
对于生产环境，建议使用可用于生产的追踪或可观察性解决方案，
例如：Zipkin或Spring Cloud Sleuth。或者，创建自己的 <code>HttpTraceRepository</code> 来满足你的需求。</p>
</div>
<div class="paragraph">
<p><code>httptrace</code> 端点可用于获取有关存储在 <code>HttpTraceRepository</code> 中的请求-响应交换的信息。</p>
</div>
<div class="sect3">
<h4 id="production-ready-http-tracing-custom">3.8.1. 自定义HTTP追踪</h4>
<div class="paragraph">
<p>要自定义每个追踪中包含的条目，请使用 <code>management.trace.http.include</code> 配置属性。对于高级定制，请考虑注册自己的 <code>HttpExchangeTracer</code> 实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-process-monitoring">3.9. 进程监控</h3>
<div class="paragraph">
<p>在 <code>spring-boot</code> 模块中，你可以找到两个类来创建通常对进程监视有用的文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ApplicationPidFileWriter</code> 创建一个包含应用程序PID的文件（默认情况下，在应用程序目录中，文件名为 <code>application.pid</code>）。</p>
</li>
<li>
<p><code>WebServerPortFileWriter</code> 创建一个文件（一个或多个），其中包含正在运行的Web服务器的端口（默认情况下，在应用程序目录中，文件名为 <code>application.port</code>）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，这些写入器不会被激活，但你可以启用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#production-ready-process-monitoring-configuration">通过扩展配置</a></p>
</li>
<li>
<p><a href="#production-ready-process-monitoring-programmatically">以编程方式</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="production-ready-process-monitoring-configuration">3.9.1. 扩展配置</h4>
<div class="paragraph">
<p>在 <code>META-INF/spring.factories</code> 文件中，你可以激活写入PID文件的监听器，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.context.ApplicationListener=\
org.springframework.boot.context.ApplicationPidFileWriter,\
org.springframework.boot.web.context.WebServerPortFileWriter</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="production-ready-process-monitoring-programmatically">3.9.2. 以编程方式</h4>
<div class="paragraph">
<p>你还可以通过调用 <code>SpringApplication.addListeners(&#8230;&#8203;)</code> 方法并传递适当的
<code>Writer</code> 对象来激活监听器。此方法还允许你自定义 <code>Writer</code> 构造函数中的文件名和路径。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="production-ready-whats-next">3.10. 接下来要读什么</h3>
<div class="paragraph">
<p>你可能需要阅读有关 <a href="https://graphiteapp.org">Graphite</a>等绘图工具的信息。</p>
</div>
<div class="paragraph">
<p>否则，你可以继续阅读 <a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#deployment">部署选项</a>，也可以继续阅读有关Spring Boot的
<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#build-tool-plugins">构建工具插件</a>的详细信息。</p>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>