[[using-boot]]
= Spring Boot
include::attributes.adoc[]

本节将详细介绍如何使用Spring Boot。它涵盖了诸如构建系统，自动配置以及如何运行应用程序之类的主题。
我们还将介绍一些Spring Boot最佳实践。尽管Spring Boot并没有什么特别的地方（它只是另一个可以使用的库），
但是有一些建议可以使你的开发过程更轻松一些。

[[using-boot-build-systems]]
== 构建系统

强烈建议你选择一个支持<<using-boot-dependency-management,_依赖关系管理_>>并且可以使用发布到“ Maven Central”存储库的工件的构建系统。
我们建议你选择Maven或Gradle。可以使Spring Boot与其他构建系统（例如，Ant）一起使用，但是它们并没有得到很好的支持。


[[using-boot-dependency-management]]
=== 依赖管理

每个Spring Boot版本都提供了它所支持的依赖关系的精选列表。实际上，你不需要为构建配置中的所有这些依赖项提供版本，
因为Spring Boot会为你管理该版本。当你升级Spring Boot本身时，这些依赖项也会以一致的方式升级。

NOTE: 你仍然可以指定版本，并在需要时覆盖Spring Boot的建议版本。

精选列表包含可与Spring Boot一起使用的所有spring模块以及完善的第三方库列表。
该列表作为可与<<using-boot-maven-parent-pom,Maven>>和<<using-boot-gradle,Gradle>>
一起使用的<<using-boot-maven-without-a-parent,标准物料清单(`spring-boot-dependencies`)>>提供。

WARNING: Spring Boot的每个发行版都与Spring Framework的基本版本相关联。**强烈** 建议你不要更改其版本。

[[using-boot-maven]]
=== Maven

Maven用户可以从 `spring-boot-starter-parent` 项目继承来获得合理的默认值。父项目提供以下功能：

* Java 1.8是默认的编译器级别。
* UTF-8源编码。
* 从spring-boot-dependencies pom继承的<<using-boot-dependency-management,依赖管理部分>>，
  它管理公共依赖项的版本。当在自己的pom中使用这些依赖关系时，可以为这些依赖关系省略 `<version>` 标记。
* 使用 `repackage` 执行id执行 {spring-boot-maven-plugin-docs}/repackage-mojo.html[`repackage` 目标]。
* 明智的 https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html[资源过滤].
* 明智的插件配置 (https://www.mojohaus.org/exec-maven-plugin/[exec plugin],
  https://github.com/ktoso/maven-git-commit-id-plugin[Git commit ID] 和
  https://maven.apache.org/plugins/maven-shade-plugin/[shade]).
* 对 `application.properties` 和 `application.yml` 进行明智的资源过滤，包括特定于环境的文件
  （例如：`application-dev.properties` 和 `application-dev.yml`）

请注意，由于 `application.properties` 和 `application.yml` 文件接受Spring样式的占位符（`${...}`），
因此Maven过滤已更改为使用 `@..@` 占位符。（你可以通过设置一个名为 `resource.delimiter` 的Maven属性来覆盖它。）


[[using-boot-maven-parent-pom]]
==== 继承Starter Parent

要将项目配置为从 `spring-boot-starter-parent` 继承，请设置 `parent`，如下所示：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <!-- Inherit defaults from Spring Boot -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>{spring-boot-version}</version>
    </parent>
----

NOTE: 你只需要为此依赖项指定Spring Boot版本号。如果导入其他starter，则可以安全地省略版本号。

使用该设置，你还可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，要升级到另一个Spring Data发布系列，
可以将以下内容添加到 `pom.xml` 中：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <properties>
        <spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>
    </properties>
----

TIP: 检查 {spring-boot-code}/spring-boot-project/spring-boot-dependencies/pom.xml[`spring-boot-dependencies` pom]以获取受支持属性的列表。


[[using-boot-maven-without-a-parent]]
==== 在没有父POM的情况下使用Spring Boot

并非每个人都喜欢从 `spring-boot-starter-parent` 父POM继承。你可能需要使用自己公司的标准父POM，或者可能希望显式声明所有Maven配置。

如果你不想使用 `spring-boot-starter-parent`，仍然可以通过使用 `scope=import` 依赖项来保留依赖项管理（而不是插件管理）的好处，如下所示：


[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <dependencyManagement>
        <dependencies>
            <dependency>
                <!-- Import dependency management from Spring Boot -->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>{spring-boot-version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
----

如上所述，前面的示例设置不允许你使用属性来覆盖各个依赖项。为了获得相同的结果，
需要在项目的 `dependencyManagement` 中 `spring-boot-dependencies` 条目 **之前** 添加一个条目。
例如，要升级到另一个Spring Data发布系列，可以将以下元素添加到 `pom.xml` 中：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <dependencyManagement>
        <dependencies>
            <!-- Override Spring Data release train provided by Spring Boot -->
            <dependency>
                <groupId>org.springframework.data</groupId>
                <artifactId>spring-data-releasetrain</artifactId>
                <version>Fowler-SR2</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>{spring-boot-version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
----

NOTE: 在前面的示例中，我们指定了 _BOM_，但是可以以相同方式覆盖任何依赖项类型。


[[using-boot-maven-plugin]]
==== 使用Spring Boot Maven插件

Spring Boot包含一个 <<build-tool-plugins.adoc#build-tool-plugins-maven-plugin, Maven插件>>，
可以将项目打包为可执行jar。如果要使用插件，请将其添加到你的 `<plugins>` 部分，如以下示例所示：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
----

NOTE: 如果你使用Spring Boot starter parent pom，则只需添加插件。除非你要更改父级中定义的设置，否则无需对其进行配置。

[[using-boot-gradle]]
=== Gradle

要了解有关将Spring Boot与Gradle结合使用的信息，请参阅Spring Boot的Gradle插件的文档：

* 参考（ {spring-boot-gradle-plugin-docs}[HTML] 和 {spring-boot-gradle-plugin-pdfdocs}[PDF]）
* {spring-boot-gradle-plugin-api}[API]


[[using-boot-ant]]
===  Ant

可以使用Apache Ant+Ivy构建Spring Boot项目。`spring-boot-antlib` “`AntLib`”模块也可用于帮助Ant创建可执行jar。

为了声明依赖关系，典型的 `ivy.xml` 文件看起来类似于以下示例：

[source,xml,indent=0]
----
    <ivy-module version="2.0">
        <info organisation="org.springframework.boot" module="spring-boot-sample-ant" />
        <configurations>
            <conf name="compile" description="everything needed to compile this module" />
            <conf name="runtime" extends="compile" description="everything needed to run this module" />
        </configurations>
        <dependencies>
            <dependency org="org.springframework.boot" name="spring-boot-starter"
                rev="${spring-boot.version}" conf="compile" />
        </dependencies>
    </ivy-module>
----

典型的 `build.xml` 类似于以下示例：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <project
        xmlns:ivy="antlib:org.apache.ivy.ant"
        xmlns:spring-boot="antlib:org.springframework.boot.ant"
        name="myapp" default="build">

        <property name="spring-boot.version" value="{spring-boot-version}" />

        <target name="resolve" description="--> retrieve dependencies with ivy">
            <ivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" />
        </target>

        <target name="classpaths" depends="resolve">
            <path id="compile.classpath">
                <fileset dir="lib/compile" includes="*.jar" />
            </path>
        </target>

        <target name="init" depends="classpaths">
            <mkdir dir="build/classes" />
        </target>

        <target name="compile" depends="init" description="compile">
            <javac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" />
        </target>

        <target name="build" depends="compile">
            <spring-boot:exejar destfile="build/myapp.jar" classes="build/classes">
                <spring-boot:lib>
                    <fileset dir="lib/runtime" />
                </spring-boot:lib>
            </spring-boot:exejar>
        </target>
    </project>
----

如果你不想使用 `spring-boot-antlib` 模块，请参阅 {spring-boot-docs}/htmlsingle/#howto-build-an-executable-archive-with-ant[不使用spring-boot-antlib “`How-to`”从Ant构建可执行存档]。


[[using-boot-starter]]
=== Starters

启动器是一组便捷的依赖项描述符，你可以在应用程序中包括它们。你可以一站式安装所需的所有Spring和相关技术，
而不必遍历示例代码和依赖描述符复制粘贴它。例如，如果要开始使用Spring和JPA进行数据库访问，请在项目中包括 `spring-boot-starter-data-jpa` 依赖项。

启动器包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的被管理的传递性依赖项。

.名字叫什么
****
所有 **official** 启动器都遵循类似的命名方式。`+spring-boot-starter-*+`，其中 `+*+` 是特定类型的应用程序。
这种命名结构旨在在你需要寻找启动器时提供帮助。许多IDE中的Maven集成使你可以按名称搜索依赖项。
例如，在安装了适当的Eclipse或STS插件的情况下，你可以在POM编辑器中按 `ctrl-space` 并键入“`spring-boot-starter`”以获取完整启动器列表。

如“<<spring-boot-features#boot-features-custom-starter,创建自己的启动器>>”部分中所述，
第三方starters不应以 `spring-boot` 开始，因为它是为Spring Boot官方工件保留的。
而是，第三方启动程序通常以项目名称开头。例如，一个名为 `thirdpartyproject` 的第三方启动程序项目通常会被命名为
`thirdpartyproject-spring-boot-starter`。
****

Spring Boot在 `org.springframework.boot` 组下提供了以下应用程序启动器：

.Spring Boot application starters
include::application-starters.adoc[]

除了应用程序启动程序，以下启动程序可用于添加 _{spring-boot-docs}/htmlsingle/#production-ready[生产就绪]_ 功能：

.Spring Boot production starters
include::production-starters.adoc[]

最后，Spring Boot还包括以下启动程序，如果你想排除或替换特定的技术方面，可以使用这些启动程序：

.Spring Boot technical starters
include::technical-starters.adoc[]

TIP: 有关社区贡献的其他启动程序的列表，请参阅GitHub上 `spring-boot-starters` 模块中的
{spring-boot-master-code}/spring-boot-project/spring-boot-starters/README.adoc[README文件]。


[[using-boot-structuring-your-code]]
== 结构化你的代码

Spring Boot不需要任何特定的代码布局即可工作。但是，有一些最佳做法对你会有所帮助。


[[using-boot-using-the-default-package]]
=== 使用“`default`”包

当类不包含 `package` 声明时，将其视为在“`default package`”中。通常不建议使用“`default package`”，应避免使用。
对于使用 `@ComponentScan`，`@ConfigurationPropertiesScan`，`@EntityScan` 或 `@SpringBootApplication`
注解的Spring Boot应用程序，这可能会引起特定的问题，因为每个jar中的每个类都会被读取。

TIP: 我们建议你遵循Java建议的程序包命名约定，并使用反向域名（例如：`com.example.project`）。

[[using-boot-locating-the-main-class]]
=== 找到应用程序主类

我们通常建议你将应用程序主类放在其他类之上的根包中。<<using-boot-using-springbootapplication-annotation,
`@SpringBootApplication` 注解>>通常放在你的主类上，它隐式定义某些条目的基本“`search package`”。
例如，如果你正在编写JPA应用程序，则使用带 `@SpringBootApplication` 注解的类的包来搜索 `@Entity` 条目。
使用根软件包还允许组件扫描仅应用于你的项目。

TIP: 如果你不想使用 `@SpringBootApplication`，则可以通过导入的
`@EnableAutoConfiguration` 和 `@ComponentScan` 注解来定义该行为，因此也可以使用它们。

以下清单显示了典型的布局：

[indent=0]
----
    com
     +- example
         +- myapplication
             +- Application.java
             |
             +- customer
             |   +- Customer.java
             |   +- CustomerController.java
             |   +- CustomerService.java
             |   +- CustomerRepository.java
             |
             +- order
                 +- Order.java
                 +- OrderController.java
                 +- OrderService.java
                 +- OrderRepository.java
----

`Application.java` 文件将声明 `main` 方法以及基本的 `@SpringBootApplication` 注解，如下所示：

[source,java,indent=0]
----
    package com.example.myapplication;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class Application {

        public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
        }

    }
----


[[using-boot-configuration-classes]]
== 配置类

Spring Boot支持基于Java的配置。尽管可以将 `SpringApplication` 与XML源一起使用，但是我们通常建议你的主要源为单个
`@Configuration` 类。通常，定义 `main` 方法的类是首选的 `@Configuration`。

TIP: 在互联网上已经发布了许多使用XML配置的Spring配置示例。如果可能，请始终尝试使用等效的基于Java的配置。
搜索 `+Enable*+` 注解可能是一个不错的起点。

[[using-boot-importing-configuration]]
=== 导入其他配置类

你无需将所有 `@Configuration` 放在单个类中。`@Import` 注解可用于导入其他配置类。
另外，你可以使用 `@ComponentScan` 自动拾取所有Spring组件，包括 `@Configuration` 类。

[[using-boot-importing-xml-configuration]]
=== 导入XML配置

如果绝对必须使用基于XML的配置，我们建议你仍然从 `@Configuration` 类开始。然后使用 `@ImportResource` 注解来加载XML配置文件。


[[using-boot-auto-configuration]]
== 自动配置

Spring Boot自动配置会尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果 `HSQLDB` 在类路径上，
并且你尚未手动配置任何数据库连接bean，则Spring Boot会自动配置内存数据库。

你需要通过将 `@EnableAutoConfiguration` 或 `@SpringBootApplication` 注解添加到你的 `@Configuration`
类之一来启用自动配置。

TIP: 你应该只添加一个 `@SpringBootApplication` 或 `@EnableAutoConfiguration` 注解。
我们通常建议你仅将它们中的一个添加到你的主要 `@Configuration` 类中。


[[using-boot-replacing-auto-configuration]]
=== 逐渐取代自动配置

自动配置是非侵入性的。在任何时候，你都可以开始定义自己的配置，以替换自动配置的特定部分。
例如，如果你添加自己的 `DataSource` bean，则默认的嵌入式数据库支持将回退。

如果你需要了解当前正在应用哪些自动配置以及原因，请使用 `--debug` 开关启动你的应用程序。
这样做可以启用调试日志以供选择核心记录器，并将条件报告记录到控制台。


[[using-boot-disabling-specific-auto-configuration]]
=== 禁用特定的自动配置类

如果发现正在应用某个不需要的特定自动配置类，则可以使用 `@EnableAutoConfiguration` 的 `exclude` 属性禁用它们，如以下示例所示：

[source,java,indent=0]
----
    import org.springframework.boot.autoconfigure.*;
    import org.springframework.boot.autoconfigure.jdbc.*;
    import org.springframework.context.annotation.*;

    @Configuration(proxyBeanMethods = false)
    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
    public class MyConfiguration {
    }
----

如果该类不在类路径中，则可以使用注解的 `excludeName` 属性，并指定完全限定的名称。最后，你还可以使用
`spring.autoconfigure.exclude` 属性控制要排除的自动配置类的列表。

TIP: 你可以在注解级别和使用属性来定义排除项。

NOTE: 即使自动配置类是 `public`，类中唯一被认为是公共API的是类的名称，它可以用来禁用自动配置。
这些类的实际内容（例如：嵌套配置类或Bean方法）仅供内部使用，我们不建议直接使用它们。


[[using-boot-spring-beans-and-dependency-injection]]
== Spring Beans和依赖注入

你可以自由使用任何标准的Spring Framework技术来定义bean及其注入依赖关系。为简单起见，我们经常发现使用
`@ComponentScan`（查找你的bean）和使用 `@Autowired`（进行构造函数注入）效果很好。

如果按照上面的建议构造代码（将应用程序类放在根包中），则可以添加 `@ComponentScan`，而无需添加任何参数。
你的所有应用程序组件（`@Component`，`@Service`，`@Repository`，`@Controller` 等）都将自动注册为Spring Bean。

以下示例显示了一个 `@Service` Bean，它使用构造函数注入来获取所需的 `RiskAssessor` Bean：

[source,java,indent=0]
----
    package com.example.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    @Service
    public class DatabaseAccountService implements AccountService {

        private final RiskAssessor riskAssessor;

        @Autowired
        public DatabaseAccountService(RiskAssessor riskAssessor) {
            this.riskAssessor = riskAssessor;
        }

        // ...

    }
----

如果bean具有一个构造函数，则可以省略 `@Autowired`，如以下示例所示：

[source,java,indent=0]
----
    @Service
    public class DatabaseAccountService implements AccountService {

        private final RiskAssessor riskAssessor;

        public DatabaseAccountService(RiskAssessor riskAssessor) {
            this.riskAssessor = riskAssessor;
        }

        // ...

    }
----

TIP: 请注意如何使用构造函数注入将 `riskAssessor` 字段标记为 `final`，以表示它随后不能更改。


[[using-boot-using-springbootapplication-annotation]]
== 使用@SpringBootApplication注解

许多Spring Boot开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。
单个 `@SpringBootApplication` 注解可用于同时启用这三个功能，即：

* `@EnableAutoConfiguration`: 启用<<using-boot-auto-configuration,Spring Boot的自动配置机制>>
* 在应用程序所在的软件包上启用 `@Component` 扫描（请参阅<<using-boot-structuring-your-code,最佳实践>>）
* `@Configuration`: 允许在上下文中注册额外的bean或导入其他配置类

[source,java,indent=0]
----
    package com.example.myapplication;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
    public class Application {

        public static void main(String[] args) {
            SpringApplication.run(Application.class, args);
        }

    }
----

NOTE: `@SpringBootApplication` 还提供别名以自定义 `@EnableAutoConfiguration` 和 `@ComponentScan` 的属性。

[NOTE]
====
这些功能都不是强制性的，你可以选择用它启用的任何功能替换这个单个注解。例如，你可能不想在应用程序中使用组件扫描或配置属性扫描：

[source,java,indent=0]
----
    package com.example.myapplication;

    import org.springframework.boot.SpringApplication;
    import org.springframework.context.annotation.ComponentScan
    import org.springframework.context.annotation.Configuration;
    import org.springframework.context.annotation.Import;

    @Configuration(proxyBeanMethods = false)
    @EnableAutoConfiguration
    @Import({ MyConfig.class, MyAnotherConfig.class })
    public class Application {

        public static void main(String[] args) {
                SpringApplication.run(Application.class, args);
        }

    }
----

在此示例中，除了没有自动检测到 `@Component` 和 `@ConfigurationProperties` 注解的类并且显式导入了用户定义的Bean外，
`Application` 就像其他任何Spring Boot应用程序一样（请参阅 `@Import`）。
====


[[using-boot-running-your-application]]
== 运行你的应用程序

将应用程序打包为jar并使用嵌入式HTTP服务器的最大优势之一是，你可以像运行其他应用程序一样运行应用程序。
调试Spring Boot应用程序也很容易。你不需要任何特殊的IDE插件或扩展。

NOTE: 本节仅介绍基于jar的包装。如果选择将应用程序打包为war文件，则应参考服务器和IDE文档。


[[using-boot-running-from-an-ide]]
=== 从IDE运行

你可以将IDE中的Spring Boot应用程序作为简单的Java应用程序运行。但是，你首先需要导入你的项目。
导入步骤因你的IDE和构建系统而异。大多数IDE可以直接导入Maven项目。例如：Eclipse用户可以从 `File` 中选择 `Import...` -> `Existing Maven Projects`。

如果你不能直接将项目导入IDE，则可以使用构建插件生成IDE元数据。Maven包括用于
https://maven.apache.org/plugins/maven-eclipse-plugin/[Eclipse] 和 https://maven.apache.org/plugins/maven-idea-plugin/[IDEA]的插件。
Gradle提供了用于 {gradle-docs}/userguide.html[各种IDE]的插件。

TIP: 如果不小心两次运行Web应用程序，则会看到“`Port already in use`”错误。
STS用户可以使用 `Relaunch` 按钮而不是 `Run` 按钮来确保关闭任何现有实例。


[[using-boot-running-as-a-packaged-application]]
=== 作为打包的应用程序运行

如果使用Spring Boot Maven或Gradle插件创建可执行jar，则可以使用 `java -jar` 运行应用程序，如以下示例所示：

[indent=0,subs="attributes"]
----
    $ java -jar target/myapplication-0.0.1-SNAPSHOT.jar
----

也可以在启用了远程调试支持的情况下运行打包的应用程序。这样做使你可以将调试器附加到打包的应用程序，如以下示例所示：

[indent=0,subs="attributes"]
----
    $ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
           -jar target/myapplication-0.0.1-SNAPSHOT.jar
----



[[using-boot-running-with-the-maven-plugin]]
=== 使用Maven插件

Spring Boot Maven插件包含一个 `run` 目标，可用于快速编译和运行你的应用程序。应用程序以爆炸形式运行，就像在IDE中一样。
以下示例显示了运行Spring Boot应用程序的典型Maven命令：

[indent=0,subs="attributes"]
----
    $ mvn spring-boot:run
----

你可能还想使用 `MAVEN_OPTS` 操作系统环境变量，如以下示例所示：

[indent=0,subs="attributes"]
----
    $ export MAVEN_OPTS=-Xmx1024m
----



[[using-boot-running-with-the-gradle-plugin]]
=== 使用Gradle插件

Spring Boot Gradle插件包含一个 `bootRun` 任务，该任务可用于以爆炸形式运行你的应用程序。每当你应用
`org.springframework.boot` 和 `java` 插件时，都会添加 `bootRun` 任务，在以下示例中显示：

[indent=0,subs="attributes"]
----
    $ gradle bootRun
----

你可能还想使用 `JAVA_OPTS` 操作系统环境变量，如以下示例所示：

[indent=0,subs="attributes"]
----
    $ export JAVA_OPTS=-Xmx1024m
----


[[using-boot-hot-swapping]]
=== 热交换

由于Spring Boot应用程序只是普通的Java应用程序，因此JVM热交换应该可以立即使用。
JVM热交换在一定程度上受到它可以替换的字节码的限制。对于更完整的解决方案，可以使用 https://jrebel.com/software/jrebel/[JRebel]。

`spring-boot-devtools` 模块还包括对应用程序快速重启的支持。有关详细信息，请参见本章后面的<<using-boot-devtools>>部分和
{spring-boot-docs}/htmlsingle#howto-hotswapping["`How-to`" 热交换]。

[[using-boot-devtools]]
== 开发者工具

Spring Boot包含一组额外的工具，这些工具可以使应用程序开发体验更加愉快。
`spring-boot-devtools` 模块可以包含在任何项目中，以提供其他开发时功能。要包括devtools支持，
请将模块依赖项添加到你的构建中，如以下Maven和Gradle清单所示：

.Maven
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
----

.Gradle
[source,groovy,indent=0,subs="attributes"]
----
    configurations {
        developmentOnly
        runtimeClasspath {
            extendsFrom developmentOnly
        }
    }
    dependencies {
        developmentOnly("org.springframework.boot:spring-boot-devtools")
    }
----

NOTE: 运行完全打包的应用程序时，将自动禁用开发者工具。如果你的应用程序是以 `java -jar` 启动的，
或者是从特殊的类加载器启动的，则将其视为“`生产应用程序`”。如果这不适用于你（即如果你从容器中运行应用程序），
请考虑排除devtools或设置 `-Dspring.devtools.restart.enabled=false` 系统属性。

TIP: 在Maven中将依赖项标记为optional或在Gradle中使用自定义 `developmentOnly` 配置（如上所示）是一种最佳实践，
它可以防止将devtools过渡地应用到使用你项目的其他模块。

TIP: 重新打包的存档默认情况下不包含devtools。如果要使用<<using-boot-devtools-remote,某个远程devtools功能>>，
则需要禁用 `excludeDevtools` 构建属性以包括它。Maven和Gradle插件均支持该属性。

[[using-boot-devtools-property-defaults]]
=== 属性默认值

Spring Boot支持的一些库使用缓存来提高性能。例如：<<spring-boot-features#boot-features-spring-mvc-template-engines,模板引擎>>缓存已编译的模板，以避免重复解析模板文件。
另外，Spring MVC可以在提供静态资源时向响应添加HTTP缓存头。

尽管缓存在生产中非常有益，但在开发过程中可能适得其反，从而使你无法看到刚刚在应用程序中所做的更改。因此，默认情况下，`spring-boot-devtools` 禁用缓存选项。

缓存选项通常由 `application.properties` 文件中的设置配置。例如，Thymeleaf提供 `spring.thymeleaf.cache` 属性。
`spring-boot-devtools` 模块不需要手动设置这些属性，而是自动应用合理的开发时配置。

由于在开发Spring MVC和Spring WebFlux应用程序时需要有关Web请求的更多信息，因此开发者工具将为 `web` 日志记录组启用 `DEBUG` 日志记录。
这将为你提供有关传入请求，正在处理的处理程序，响应结果等的信息。如果你希望记录所有请求详细信息（包括潜在的敏感信息），
则可以打开 `spring.http.log-request-details` 配置属性。

NOTE: 如果你不希望应用默认属性，则可以在 `application.properties` 中将 `spring.devtools.add-properties` 设置为 `false`。

TIP: 有关devtools应用的属性完整列表，请参见
{spring-boot-devtools-module-code}/env/DevToolsPropertyDefaultsPostProcessor.java[DevToolsPropertyDefaultsPostProcessor]。


[[using-boot-devtools-restart]]
=== 自动重启

每当classpath上的文件更改时，使用 `spring-boot-devtools` 的应用程序都会自动重新启动。在IDE中工作时，
这可能是一个有用的功能，因为它为代码更改提供了非常快速的反馈循环。默认情况下，
将监视类路径上指向文件夹的任何条目的更改。请注意，某些资源（例如静态资产和视图模板）
<<using-boot-devtools-restart-exclude,不需要重新启动应用程序>>。

.触发重启
****
当DevTools监视类路径资源时，触发重启的唯一方法是更新类路径。导致类路径更新的方式取决于所使用的IDE。
在Eclipse中，保存修改后的文件将导致类路径被更新并触发重新启动。
在IntelliJ IDEA中，构建项目（`Build +->+ Build Project`）具有相同的效果。
****

NOTE: 只要启用了forking，你还可以使用受支持的构建插件（Maven和Gradle）启动应用程序，
因为DevTools需要一个隔离的应用程序类加载器才能正常运行。默认情况下，Gradle和Maven插件会fork应用程序进程。


TIP: 与LiveReload一起使用时，自动重启非常有效。有关详细信息，请参见<<using-boot-devtools-livereload,LiveReload部分>>。
如果使用JRebel，则禁用自动重新启动，而支持动态类重新加载。其他devtools功能（例如LiveReload和属性覆盖）仍可以使用。

NOTE: DevTools依赖于应用程序上下文的关闭钩子在重新启动期间将其关闭。如果你禁用了关闭钩子
（`SpringApplication.setRegisterShutdownHook(false)`），它将无法正常工作。

NOTE: 在确定类路径上的条目是否应在更改后触发重新启动时，DevTools会自动忽略名为 `spring-boot`，
`spring-boot-devtools`，`spring-boot-autoconfigure`，`spring-boot-actuator` 和 `spring-boot-starter` 的项目。

NOTE: DevTools需要自定义 `ApplicationContext` 使用的 `ResourceLoader`。如果你的应用程序已经提供了，它将被包装。
不支持在 `ApplicationContext` 上直接重写 `getResource` 方法。

[[using-spring-boot-restart-vs-reload]]
.重新启动 vs 重新加载
****
Spring Boot提供的重启技术通过使用两个类加载器来工作。不变的类（例如：来自第三方jar的类）将被加载到 _基本_ 类加载器中。
你正在积极开发的类将加载到 _重启_ 类加载器中。重新启动应用程序时，将丢弃 _重启_ 类加载器，并创建一个新的类加载器。
这种方法意味着应用程序的重启通常比“`冷启动`”要快得多，因为 _基本_ 类加载器已经可用并已填充完毕。

如果发现重新启动对于你的应用程序来说不够快，或者遇到类加载问题，则可以考虑使用ZeroTurnaround重新加载技术，例如：
https://jrebel.com/software/jrebel/[JRebel]。这些方法通过在加载类时重写类来使其更易于重新加载。
****



[[using-boot-devtools-restart-logging-condition-delta]]
==== 记录条件评估中的更改

默认情况下，每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量变化。
该报告显示了你进行代码更改（例如：添加或删除Bean以及设置配置属性）时所造成的对应用程序自动配置的更改。

要禁用报告的日志记录，请设置以下属性：

[indent=0]
----
    spring.devtools.restart.log-condition-evaluation-delta=false
----


[[using-boot-devtools-restart-exclude]]
==== 排除资源

某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf模板可以就地编辑。默认情况下，
更改 `/META-INF/maven`，`/META-INF/resources`，`/resources`，`/static`，`/public` 或 `/templates`
中的资源不会触发重新启动，但会触发<<using-boot-devtools-livereload,实时重新加载>>。如果要自定义这些排除项，则可以使用
`spring.devtools.restart.exclude` 属性。例如：仅排除 `/static` 和 `/public`，可以设置以下属性：

[indent=0]
----
    spring.devtools.restart.exclude=static/**,public/**
----

TIP: 如果要保留这些默认值并 _添加_ 其他排除项，请改用 `spring.devtools.restart.additional-exclude` 属性。


[[using-boot-devtools-restart-additional-paths]]
==== 监视其他路径

当你对不在类路径上的文件进行更改时，你可能希望重新启动或重新加载应用程序。为此，
请使用 `spring.devtools.restart.additional-paths` 属性配置其他路径以监视更改。
你可以使用<<using-boot-devtools-restart-exclude,前面所述>>的 `spring.devtools.restart.exclude`
属性来控制其他路径下的更改是触发完全重启还是<<using-boot-devtools-livereload,实时重新加载>>。


[[using-boot-devtools-restart-disable]]
==== 禁用重启

如果你不想使用重新启动功能，则可以使用 `spring.devtools.restart.enabled` 属性将其禁用。在大多数情况下，你可以在
`application.properties` 中设置此属性（这样做仍会初始化重启类加载器，但它不会监视文件更改）。

如果你需要 _完全_ 禁用重启支持（例如：因为它不适用于特定的库），则需要在调用 `SpringApplication.run(...)` 之前将
`spring.devtools.restart.enabled` 系统属性设置为 `false`。如以下示例所示：

[source,java,indent=0]
----
    public static void main(String[] args) {
        System.setProperty("spring.devtools.restart.enabled", "false");
        SpringApplication.run(MyApp.class, args);
    }
----



[[using-boot-devtools-restart-triggerfile]]
==== 使用触发文件

如果使用持续编译更改文件的IDE，则可能更喜欢仅在特定时间触发重新启动。为此，你可以使用“`触发文件`”，
这是一个特殊文件，当你要实际触发重新启动检查时必须对其进行修改。

NOTE: 对文件的任何更新都将触发检查，但是只有在Devtools检测到有事情要做的情况下，重启才真正发生。

要使用触发文件，请将 `spring.devtools.restart.trigger-file` 属性设置为触发文件的名称（不包括任何路径）。
触发文件必须出现在类路径上的某个位置。

例如，如果你的项目具有以下结构：

[indent=0]
----
    src
    +- main
       +- resources
          +- .reloadtrigger
----

然后，你的 `trigger-file` 属性将是：

[source,properties,indent=0,configprops]
----
    spring.devtools.restart.trigger-file=.reloadtrigger
----

现在仅在更新 `src/main/resources/.reloadtrigger` 时才可能发生重启。


TIP: 你可能需要将 `spring.devtools.restart.trigger-file` 设置为<<using-boot-devtools-globalsettings,全局设置>>，以便所有项目的行为均相同。

某些IDE具有使你不必手动更新触发器文件的功能。 https://spring.io/tools[Spring Tools for Eclipse]和
https://www.jetbrains.com/idea/[IntelliJ IDEA (最终版)]都具有这种支持。
使用Spring Tools，你可以从控制台视图使用“`reload`”按钮（只要你的 `trigger-file` 为 `.reloadtrigger`）。
对于IntelliJ，你可以按照
https://www.jetbrains.com/help/idea/spring-boot.html#configure-application-update-policies-with-devtools[其文档中的说明]进行操作。


[[using-boot-devtools-customizing-classload]]
==== 自定义重启类加载器

如前面的<<using-spring-boot-restart-vs-reload>>部分所述，重新启动功能是通过使用两个类加载器实现的。
对于大多数应用程序，此方法效果很好。但是，有时可能会导致类加载问题。

默认情况下，IDE中的任何打开的项目都使用“`重启`”类加载器加载，而任何常规的 `.jar` 文件都使用“`基本`”类加载器加载。
如果你在多模块项目上工作，并且并非每个模块都导入到IDE中，则可能需要自定义内容。为此，你可以创建一个
`META-INF/spring-devtools.properties` 文件。

`spring-devtools.properties` 文件可以包含带有 `restart.exclude` 和 `restart.include` 前缀的属性。
`include` 元素是应上拉到“`重启`”类加载器中的项目，而 `exclude` 元素是应下推到“`基本`”类加载器中的项目。
该属性的值是应用于类路径的正则表达式模式，如以下示例所示：

[source,properties,indent=0]
----
    restart.exclude.companycommonlibs=/mycorp-common-[\\w\\d-\.]+\.jar
    restart.include.projectcommon=/mycorp-myproj-[\\w\\d-\.]+\.jar
----

NOTE: 所有属性键都必须是唯一的。只要属性以 `restart.include` 或 `restart.exclude` 开头，它就会被考虑。

TIP: 将加载类路径中的所有 `META-INF/spring-devtools.properties`。你可以将文件打包到项目内部，也可以打包到项目使用的库中。


[[using-boot-devtools-known-restart-limitations]]
==== 已知局限性

重新启动功能不适用于使用标准 `ObjectInputStream` 反序列化的对象。如果你需要反序列化数据，
则可能需要将Spring的 `ConfigurableObjectInputStream` 与 `Thread.currentThread().getContextClassLoader()` 结合使用。

不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，则需要向库的原始作者请求修复。


[[using-boot-devtools-livereload]]
=== LiveReload

`spring-boot-devtools` 模块包括一个嵌入式LiveReload服务器，该服务器可用于在更改资源时触发浏览器刷新。
可从 http://livereload.com/extensions/[livereload.com]免费获得适用于Chrome，Firefox和Safari的LiveReload浏览器扩展。

如果你不想在应用程序运行时启动LiveReload服务器，则可以将 `spring.devtools.livereload.enabled` 属性设置为 `false`。

NOTE: 一次只能运行一台LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。
如果从IDE启动多个应用程序，则只有第一个具有LiveReload支持。


[[using-boot-devtools-globalsettings]]
=== 全局设置

你可以通过将以下任何文件添加到 `$HOME/.config/spring-boot` 文件夹来配置全局devtools设置：

. `spring-boot-devtools.properties`
. `spring-boot-devtools.yaml`
. `spring-boot-devtools.yml`

添加到这些文件的任何属性都将应用于使用devtools的 _所有_ Spring Boot应用程序。例如：要将重新启动配置为始终使用
<<using-boot-devtools-restart-triggerfile,触发文件>>，应添加以下属性：

.~/.config/spring-boot/spring-boot-devtools.properties
[source,properties,indent=0,configprops]
----
    spring.devtools.restart.trigger-file=.reloadtrigger
----

NOTE: 如果在 `$HOME/.config/spring-boot` 中找不到devtools配置文件，则在 `$HOME` 文件夹的根目录中搜索是否存在
`.spring-boot-devtools.properties` 文件。这使你可以与不支持 `$HOME/.config/spring-boot`
位置的较旧版本的Spring Boot上的应用程序共享devtools全局配置。

NOTE: 上述文件中激活的Profiles不会影响
<<spring-boot-features.adoc#boot-features-external-config-profile-specific-properties,特定于环境的配置文件>>的加载。


[[using-boot-devtools-remote]]
=== 远程应用

Spring Boot开发者工具不仅限于本地开发。远程运行应用程序时，你还可以使用多种功能。
选择启用远程支持，因为启用它可能会带来安全风险。仅当在受信任的网络上运行或使用SSL保护时，才应启用它。
如果这两个选项都不可用，则不应使用DevTools的远程支持。你永远不要在生产部署上启用支持。

要启用它，你需要确保在重新打包的档案中包含 `devtools`，如以下清单所示：

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludeDevtools>false</excludeDevtools>
                </configuration>
            </plugin>
        </plugins>
    </build>
----

然后，你需要设置 `spring.devtools.remote.secret` 属性。像任何重要的密码或机密一样，该值应唯一且强壮，以免被猜测或强行使用。

远程devtools支持分为两部分：接受连接的服务器端端点和在IDE中运行的客户端应用程序。设置
 `spring.devtools.remote.secret` 属性后，将自动启用服务器组件，客户端组件必须手动启动。


==== 运行远程客户端应用程序

远程客户端应用程序旨在在你的IDE中运行。你需要使用与你连接到的远程项目相同的类路径来运行
`org.springframework.boot.devtools.RemoteSpringApplication`。该应用程序的唯一必需参数是它连接到的远程URL。

例如，如果你使用的是Eclipse或STS，并且有一个名为 `my-app` 的项目已部署到Cloud Foundry，则可以执行以下操作：

* 从 `Run` 菜单中选择 `Run Configurations...`。
* 创建一个新的 `Java Application` “启动配置”。
* 浏览 `my-app` 项目。
* 使用 `org.springframework.boot.devtools.RemoteSpringApplication` 作为主类。
* 将 `+++https://myapp.cfapps.io+++` 添加到 `Program arguments`（或任何远程URL）。

正在运行的远程客户端可能类似于以下清单：

[indent=0,subs="attributes"]
----
      .   ____          _                                              __ _ _
     /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
    ( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
     \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
      '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
     =========|_|==============|___/===================================/_/_/_/
     :: Spring Boot Remote :: {spring-boot-version}

    2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)
    2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
    2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
    2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
    2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
----

NOTE: 因为远程客户端使用与真实应用程序相同的类路径，所以它可以直接读取应用程序属性。这就是读取 `spring.devtools.remote.secret` 属性并将其传递给服务器进行身份验证的方式。

TIP: 始终建议使用 `https://` 作为连接协议，以便对通信进行加密并且不能截获密码。

TIP: 如果需要使用代理来访问远程应用程序，请配置 `spring.devtools.remote.proxy.host` 和 `spring.devtools.remote.proxy.port` 属性。


[[using-boot-devtools-remote-update]]
==== 远程更新

远程客户端以与<<using-boot-devtools-restart,本地重新启动>>相同的方式监视应用程序类路径中的更改。
任何更新的资源都会推送到远程应用程序，并且（_如果需要_）会触发重新启动。
如果你迭代使用本地没有的云服务的功能，这将很有帮助。通常，远程更新和重新启动比完整的重新构建和部署周期快得多。

NOTE: 仅在远程客户端正在运行时监视文件。如果在启动远程客户端之前更改文件，则不会将其推送到远程服务器。


[[configuring-file-system-watcher]]
==== 配置文件系统观察器

{spring-boot-devtools-module-code}/filewatch/FileSystemWatcher.java[FileSystemWatcher]
的工作方式是按一定的时间间隔轮询类更改，然后等待预定义的静默期以确保没有更多更改。
然后将更改上传到远程应用程序。在较慢的开发环境中，可能会发生静默期不够的情况，并且类中的更改可能会分为几批。
第一批类更改上传后，服务器将重新启动。由于服务器正在重新启动，因此下一批不能发送到应用程序。

这通常通过 `RemoteSpringApplication` 日志中的警告来证明，即有关上载某些类失败的消息，然后进行重试。
但是，这也可能导致应用程序代码不一致，并且在上传第一批更改后无法重新启动。

如果你经常观察到此类问题，请尝试将 `spring.devtools.restart.poll-interval` 和
`spring.devtools.restart.quiet-period` 参数增加到适合你的开发环境的值：

[source,properties,indent=0,configprops]
----
    spring.devtools.restart.poll-interval=2s
    spring.devtools.restart.quiet-period=1s
----

现在每2秒轮询一次受监视的classpath文件夹以进行更改，并保持1秒钟的静默时间以确保没有其他类更改。


[[using-boot-packaging-for-production]]
== 打包你的应用程序用于生产

可执行jar可以用于生产部署。由于它们是独立的，因此它们也非常适合云部署。

对于其他“生产就绪”功能，例如运行状况，审核和度量REST或JMX端点，请考虑添加 `spring-boot-actuator`。
有关详细信息，请参见 _{spring-boot-docs}/htmlsingle/#production-ready[生产就绪]_。

[[using-boot-whats-next]]
== 接下来要读什么

现在，你应该了解了如何使用Spring Boot以及应遵循的一些最佳实践。现在，你可以继续深入了解特定的
_<<spring-boot-features#boot-features,Spring Boot功能>>_，或者可以跳过并阅读有关
Spring Boot的 _{spring-boot-docs}/htmlsingle/#production-ready[生产就绪]_ 方面的信息。