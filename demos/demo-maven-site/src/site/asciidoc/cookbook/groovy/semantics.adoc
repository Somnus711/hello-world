[[semantics]]
= 语义
:spock: http://spockframework.github.io/spock/docs/current/index.html

本章介绍了Groovy编程语言的语义。

== 语句
=== 变量定义

可以使用类型（如 `String`）或使用关键字 `def` 定义变量：

[source,groovy]
----
String x
def o
----

`def` 是类型名称的替代品。在变量定义中，它用于表示你不关心类型。在变量定义中，必须明确提供类型名称或使用“def”替代。这需要使Groovy解析器可以检测到变量定义。

你可以将 `def` 视为 `Object` 的别名，这样你将很好理解它。

可以使用泛型来改进变量定义类型，例如 `List <String> names`。要了解有关泛型支持的更多信息，请阅读<<semantics.generics,泛型部分>>。

=== 变量赋值

你可以为变量赋值以供以后使用。请尝试以下方法：

[source,groovy]
----
x = 1
println x

x = new java.util.Date()
println x

x = -3.1499392
println x

x = false
println x

x = "Hi"
println x
----

==== 多重赋值

Groovy支持多重赋值，即可以同时赋值多个变量，例如：

[source,groovy]
----
def (a, b, c) = [10, 20, 'foo']
assert a == 10 && b == 20 && c == 'foo'
----

如果你愿意，可以提供类型作为声明的一部分：

[source,groovy]
----
def (int i, String j) = [10, 'foo']
assert i == 10 && j == 'foo'
----

除了在声明变量时使用，它也适用于已有变量：

[source,groovy]
----
def nums = [1, 3, 5]
def a, b, c
(a, b, c) = nums
assert a == 1 && b == 3 && c == 5
----

该语法适用于数组和列表，以及返回其中任一类型的方法：

[source,groovy]
----
def (_, month, year) = "18th June 2009".split()
assert "In $month of $year" == 'In June of 2009'
----

==== 上溢和下溢

如果左侧有太多变量，多余的变量用null填充：

[source,groovy]
----
def (a, b, c) = [1, 2]
assert a == 1 && b == 2 && c == null
----

如果右侧有太多变量，则会忽略额外的变量：

[source,groovy]
----
def (a, b) = [1, 2, 3]
assert a == 1 && b == 2
----

==== 具有多重赋值的对象解构

在描述各种<<operators,Groovy运算符>>的部分中，已经介绍了<<operators.subscript-operator,下标运算符>>的情况，解释了如何覆盖 `getAt()`/`putAt()` 方法。

使用这种技术，我们可以组合多重赋值和下标运算符方法来实现__对象解构__。

考虑以下不可变的 `Coordinates` 类，包含一对经度和纬度的双精度，并注意我们的 `getAt()` 方法的实现：

[source,groovy]
----
@Immutable
class Coordinates {
    double latitude
    double longitude

    double getAt(int idx) {
        if (idx == 0) latitude
        else if (idx == 1) longitude
        else throw new Exception("Wrong coordinate index, use 0 or 1")
    }
}
----

现在让我们实例化这个类并解构它的经度和纬度：

[source,groovy]
----
def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) // <1>

def (la, lo) = coordinates                                          // <2>

assert la == 43.23                                                  // <3>
assert lo == 3.67
----
<1> 我们创建一个 `Coordinates` 类的实例
<2> 然后，我们使用多重赋值来获取各个经度和纬度值
<3> 最后断言他们的值

=== 控制结构

==== 条件结构

===== `if / else`

Groovy支持Java中常用的if-else语法

[source,groovy]
----
def x = false
def y = false

if ( !x ) {
    x = true
}

assert x == true

if ( x ) {
    x = false
} else {
    y = true
}

assert x == y
----

Groovy还支持普通的Java“嵌套”if then else if语法

[source,groovy]
----
if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}
----

===== `switch / case`

Groovy中的switch语句向后兼容Java代码；因此，你可以fall through case为多个匹配共享相同的代码。

但有一点不同的是，Groovy switch语句可以处理任何类型的switch值，并且可以执行不同类型的匹配。

[source,groovy]
----
def x = 1.23
def result = ""

switch ( x ) {
    case "foo":
        result = "found foo"
        // lets fall through

    case "bar":
        result += "bar"

    case [4, 5, 6, 'inList']:
        result = "list"
        break

    case 12..30:
        result = "range"
        break

    case Integer:
        result = "integer"
        break

    case Number:
        result = "number"
        break

    case ~/fo*/: // toString() representation of x matches the pattern?
        result = "foo regex"
        break

    case { it < 0 }: // or { x < 0 }
        result = "negative"
        break

    default:
        result = "default"
}

assert result == "number"
----

Switch支持以下类型的比较：

* 如果switch值是类的实例，则类用例值匹配
* 如果switch值的 `toString()` 表示与正则表达式匹配，则正则表达式用例值匹配
* 如果switch值包含在集合中，则集合用例值匹配。这还包括范围（因为它们是列表）
* 如果根据<<semantics.groovy-truth,Groovy truth>>调用闭包返回结果为true，则闭包用例值匹配
* 如果不使用上述任何一个，那么如果用例值等于switch值，则该用例值匹配

使用闭包用例值时，默认 `it` 参数实际上是switch值（在我们的示例中，变量 `x`）。

==== 循环结构

===== `经典循环`

Groovy支持标准的Java/C for循环：

[source,groovy]
----
String message = ''
for (int i = 0; i < 5; i++) {
    message += 'Hi '
}
assert message == 'Hi Hi Hi Hi Hi '
----

===== `for in循环`

Groovy中的for循环更简单，适用于任何类型的数组，集合，Map等。

[source,groovy]
----
// iterate over a range
def x = 0
for ( i in 0..9 ) {
    x += i
}
assert x == 45

// iterate over a list
x = 0
for ( i in [0, 1, 2, 3, 4] ) {
    x += i
}
assert x == 10

// iterate over an array
def array = (0..4).toArray()
x = 0
for ( i in array ) {
    x += i
}
assert x == 10

// iterate over a map
def map = ['abc':1, 'def':2, 'xyz':3]
x = 0
for ( e in map ) {
    x += e.value
}
assert x == 6

// iterate over values in a map
x = 0
for ( v in map.values() ) {
    x += v
}
assert x == 6

// iterate over the characters in a string
def text = "abc"
def list = []
for (c in text) {
    list.add(c)
}
assert list == ["a", "b", "c"]
----

Groovy还支持使用冒号的Java冒号变体：`for (char c : text) {}`，其中变量的类型是必需的。

===== `while循环`

Groovy支持像Java一样的 while{...}循环：

[source,groovy]
----
def x = 0
def y = 5

while ( y-- > 0 ) {
    x++
}

assert x == 5
----

==== 异常处理

异常处理与Java相同。

==== try / catch / finally

你可以指定一个完整的try-catch-finally，try-catch或try-finally块。

每个块体都需要大括号包围。

[source,groovy]
----
try {
    'moo'.toLong()   // 这将产生一个异常
    assert false     // 永远不会到达这的断言语句
} catch ( e ) {
    assert e in NumberFormatException
}
----

我们可以在匹配的'try'子句后面的'finally'子句中放置代码，这样无论'try'子句中的代码是否抛出异常，finally子句中的代码总是会执行：

[source,groovy]
----
def z
try {
    def i = 7, j = 0
    try {
        def k = i / j
        assert false        // 由于前一行中的异常而从未到达过
    } finally {
        z = 'reached here'  // 即使抛出Exception也总是执行
    }
} catch ( e ) {
    assert e in ArithmeticException
    assert z == 'reached here'
}
----

==== 多重catch

使用多catch块（从Groovy 2.0开始），我们可以定义几个异常，以便捕获并由同一个catch块处理：

[source,groovy]
----
try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* 一个块来处理2种异常 */
}
----

=== Power assertion

Groovy与Java共享 `assert` 关键字，但在Groovy中表现得非常不同。首先，始终执行Groovy中的断言，而与JVM的 `-ea` 标志无关。它使它成为单元测试的首选。“power asserts”的概念与Groovy `assert` 的行为方式直接相关。

power assertion分解为3个部分：

[source,groovy]
----
assert [left expression] == [right expression] : (optional message)
----

断言的结果与Java中的结果非常不同。如果断言为真，则没有任何反应。如果断言为假，则它提供被断言的表达式的每个子表达式的值的直观表示。例如：

[source,groovy]
----
assert 1+1 == 3
----

将产生：

[source,groovy]
----
Caught: Assertion failed:

assert 1+1 == 3
        |  |
        2  false
----

当表达式更复杂时，幂断言变得非常有趣，如下一个示例所示：

[source,groovy]
----
def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == [x,z].sum()
----

这将打印每个子表达式的值：

[source,groovy]
----
assert calc(x,y) == [x,z].sum()
       |    | |  |   | |  |
       15   2 7  |   2 5  7
                 false
----

如果你不想像上面那样打印漂亮的错误消息，可以通过更改断言的可选消息部分来回退到自定义错误消息，如下例所示：

[source,groovy]
----
def x = 2
def y = 7
def z = 5
def calc = { a,b -> a*b+1 }
assert calc(x,y) == z*z : 'Incorrect computation result'
----

这将打印以下错误消息：

[source,groovy]
----
Incorrect computation result. Expression: (calc.call(x, y) == (z * z)). Values: z = 5, z = 5
----

=== 标签语句

任何语句都可以与标签相关联。标签不会影响代码的语义，可以用来使代码更容易阅读，如下例所示：

[source,groovy]
----
given:
    def x = 1
    def y = 2
when:
    def z = x+y
then:
    assert z == 3
----

尽管没有更改标记语句的语义，但可以使用break指令中的标签作为跳转目标，如下一个示例所示。但是，即使这是允许的，这种编码风格通常被认为是一种不好的做法：

[source,groovy]
----
for (int i=0;i<10;i++) {
    for (int j=0;j<i;j++) {
        println "j=$j"
        if (j == 5) {
            break exit
        }
    }
    exit: println "i=$i"
}
----

重要的是要理解默认情况下标签对代码的语义没有影响，但它们属于抽象语法树（AST），因此AST转换可以使用该信息对代码执行转换，因此导致不同的语义。这正是 {spock}[Spock Framework]为简化测试所做的工作。

== 表达式

(TBD)

=== GPath表达式

GPath是一种集成到Groovy中的路径表达式语言，它允许识别嵌套结构化数据的一部分。从这个意义上说，它具有与XPath对XML相似的目标和范围。GPath通常用于处理XML的上下文中，但它确实适用于任何对象图。XPath使用类似文件系统的路径表示法，树形层次结构的部分用斜杠 `/` 分隔，GPath使用**点对象表示法**来执行对象导航。

例如，你可以指定感兴趣的对象或元素的路径：

* `a.b.c` -> 对于XML，产生 `a` 内的 `b` 内的所有 `c` 元素
* `a.b.c` -> 对于POJO，产生 `a` 的所有 `b` 属性下的 `c` 属性（类似于JavaBeans中的 `a.getB().getC()`）

在这两种情况下，GPath表达式都可以被视为对象图上的查询。对于POJO，对象图通常由通过对象实例化和组合编写的程序构建;对于XML处理，对象图是解析XML文本的结果，通常使用类似XmlParser或XmlSlurper的类。有关在Groovy中使用XML的更深入的详细信息，请参阅处理XML。

查询从XmlParser或XmlSlurper生成的对象图时，GPath表达式可以引用使用 `@` 表示法在元素上定义的属性：

* `a["@href"]` -> map-like表示法：a元素的所有href属性
* `a.'@href'` -> property表示法：表达相同含义的另一种方式
* `a.@href` -> direct表示法：表达相同含义的另一种方式

==== 对象导航

让我们看一个简单对象图上的GPath表达式示例，使用java反射获得。假设你处于具有另一个名为 `aMethodFoo` 的方法的类的非静态方法中

[source,groovy]
----
void aMethodFoo() { println "This is aMethodFoo." } // <0>
----

以下GPath表达式将获取该方法的名称：

[source,groovy]
----
assert ['aMethodFoo'] == this.class.methods.name.grep(~/.*Foo/)
----

更确切地说，上面的GPath表达式生成一个String列表，每个String都是 `this` 中以 `Foo` 结尾的现有方法的名称。

现在，给定了该类中定义的以下方法：

[source,groovy]
----
void aMethodBar() { println "This is aMethodBar." }             // <1>
void anotherFooMethod() { println "This is anotherFooMethod." } // <2>
void aSecondMethodBar() { println "This is aSecondMethodBar." } // <3>
----

那么下面的GPath表达式将获得**(1)**和**(3)**的名称，但不是**(2)**或**(0)**：

[source,groovy]
----
assert ['aMethodBar', 'aSecondMethodBar'] as Set == this.class.methods.name.grep(~/.*Bar/) as Set
----

==== 表达式解构

我们可以分解表达式 `this.class.methods.name.grep(~/.*Bar/)` 以了解如何评估GPath：

`this.class`::
属性访问器，相当于Java中的 `this.getClass()`，产生一个 `Class` 对象。

`this.class.methods`::
属性访问器，等效于 `this.getClass().getMethods()`，产生一个 `Method` 对象数组。

`this.class.methods.name`::
在数组的每个元素上应用属性访问器并生成结果列表。

`this.class.methods.name.grep(…​)`::
对 `this.class.methods.name` 生成的列表的每个元素调用 `grep` 方法，并生成结果列表。

像 `this.class.methods` 这样的子表达式产生一个数组，因为这是调用Java中的 `this.getClass().getMethods()` 产生的。`GPath` 表达式没有约定，其中 `s` 表示列表或类似的东西。

GPath表达式的一个强大功能是__对集合的属性访问转换为集合的每个元素的属性访问__，并将结果收集到集合中。因此，表达式 `this.class.methods.name` 在Java中表示如下：

[source,groovy]
----
List<String> methodNames = new ArrayList<String>();
for (Method method : this.getClass().getMethods()) {
   methodNames.add(method.getName());
}
return methodNames;
----

数组访问表示法也可用于存在集合的GPath表达式中：

[source,groovy]
----
assert 'aSecondMethodBar' == this.class.methods.name.grep(~/.*Bar/).sort()[1]
----

数组访问在GPath表达式中从零开始

==== 用于XML导航的GPath

以下是XML文档和各种形式的GPath表达式的示例：

[source,groovy]
----
def xmlText = """
              | <root>
              |   <level>
              |      <sublevel id='1'>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>value 123</value>
              |        </keyVal>
              |      </sublevel>
              |      <sublevel id='2'>
              |        <keyVal>
              |          <key>anotherKey</key>
              |          <value>42</value>
              |        </keyVal>
              |        <keyVal>
              |          <key>mykey</key>
              |          <value>fizzbuzz</value>
              |        </keyVal>
              |      </sublevel>
              |   </level>
              | </root>
              """
def root = new XmlSlurper().parseText(xmlText.stripMargin())
assert root.level.size() == 1 // <1>
assert root.level.sublevel.size() == 2 // <2>
assert root.level.sublevel.findAll { it.@id == 1 }.size() == 1 // <3>
assert root.level.sublevel[1].keyVal[0].key.text() == 'anotherKey' // <4>
----
<1> `root` 目录下有一个 `level` 节点
<2> `root/level` 下有两个 `sublevel` 节点
<3> 有一个 `sublevel` 元素具有值为 `1` 的 `id` 属性
<4> `root/level` 下第二个 `sublevel` 元素的第一个 `keyVal` 元素的 `key` 元素的文本值是 'anotherKey'

== 提升和强转

=== 数字提升

数字提升的规则在<<syntax.math-operations,数学运算>>部分中已介绍。

[[semantics.closure-coercion]]
=== 闭包到类型的强转

==== 为SAM类型赋值闭包

SAM类型是定义单个抽象方法的类型。这包括：

函数式接口

[source,groovy]
----
interface Predicate<T> {
    boolean accept(T obj)
}
----

单抽象方法的抽象类

[source,groovy]
----
abstract class Greeter {
    abstract String getName()
    void greet() {
        println "Hello, $name"
    }
}
----

可以使用 `as` 运算符将任何闭包转换为SAM类型：

[source,groovy]
----
Predicate filter = { it.contains 'G' } as Predicate
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' } as Greeter
greeter.greet()
----

但是，`as Type` 表达式是Groovy 2.2.0以来的可选项。你可以省略它并简写为：

[source,groovy]
----
Predicate filter = { it.contains 'G' }
assert filter.accept('Groovy') == true

Greeter greeter = { 'Groovy' }
greeter.greet()
----

这意味着你还可以使用方法指针，如以下示例所示：

[source,groovy]
----
boolean doFilter(String s) { s.contains('G') }

Predicate filter = this.&doFilter
assert filter.accept('Groovy') == true

Greeter greeter = GroovySystem.&getVersion
greeter.greet()
----

==== 调用接受带有闭包的SAM类型的方法

带有闭包SAM类型强转的第二个也许更重要的用例是调用接受SAM类型的方法。想象一下以下方法：

[source,groovy]
----
public <T> List<T> filter(List<T> source, Predicate<T> predicate) {
    source.findAll { predicate.accept(it) }
}
----

然后，你可以使用闭包调用它，而无需创建接口的显式实现：

[source,groovy]
----
assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']
----

但是从Groovy 2.2.0开始，你也可以省略显式强转并调用方法，就好像它使用了一个闭包：

[source,groovy]
----
但是从Groovy 2.2.0开始，你也可以省略显式强制并调用方法，就好像它使用了一个闭包：
----

如你所见，这样做的好处是可以让你使用闭包语法进行方法调用，也就是说将闭包放在括号之外，从而提高代码的可读性。

==== 闭包到任意类型的强转

除了SAM类型之外，还可以将闭包强制转换为任何类型，特别是接口。让我们定义以下接口：

[source,groovy]
----
interface FooBar {
    int foo()
    void bar()
}
----

你可以使用 `as` 关键字强制转换闭包为接口：

[source,groovy]
----
def impl = { println 'ok'; 123 } as FooBar
----

这将生成一个类，所有方法都使用闭包来实现：

[source,groovy]
----
assert impl.foo() == 123
impl.bar()
----

但也有可能强制转换闭包为任意类。例如，我们可以在不更改断言的情况下使用 `class` 替换我们定义的 `interface`：

[source,groovy]
----
class FooBar {
    int foo() { 1 }
    void bar() { println 'bar' }
}

def impl = { println 'ok'; 123 } as FooBar

assert impl.foo() == 123
impl.bar()
----

=== Map到类型的强转

通常使用单个闭包来实现接口或具有多个方法的类是不可取的。作为替代方案，Groovy允许你将Map强制转换为接口或类。在这种情况下，Map的键被解释为方法名称，而值是方法实现。以下示例说明了将映射强制转换为 `Iterator`：

[source,groovy]
----
def map
map = [
  i: 10,
  hasNext: { map.i > 0 },
  next: { map.i-- },
]
def iter = map as Iterator
----

当然这是一个相当人为的例子，但说明了这个概念。你只需要实现那些实际调用的方法，但是如果调用了一个在map中不存在的方法，则会抛出 `MissingMethodException` 或 `UnsupportedOperationException`，具体取决于传递给调用的参数，如下例所示：

[source,groovy]
----
interface X {
    void f()
    void g(int n)
    void h(String s, int n)
}

x = [ f: {println "f called"} ] as X
x.f() // 方法存在
x.g() // 出现 MissingMethodException
x.g(5) // 出现 UnsupportedOperationException
----

异常的类型取决于调用本身：

* `MissingMethodException` 如果调用的参数与接口/类的参数不匹配
* `UnsupportedOperationException` 如果调用的参数匹配接口/类的重载方法之一

=== 字符串到枚举的强转

Groovy允许透明 `String`（或 `GString`）枚举值强转。想象一下，你定义以下枚举：

[source,groovy]
----
enum State {
    up,
    down
}
----

然后你可以为枚举赋值一个字符串而不必使用显式强转：

[source,groovy]
----
State st = 'up'
assert st == State.up
----

也可以使用 `GString` 作为值：

[source,groovy]
----
def val = "up"
State st = "${val}"
assert st == State.up
----

但是，以下这样会抛出运行时错误（`IllegalArgumentException`）：

[source,groovy]
----
State st = 'not an enum value'
----

请注意，也可以在switch语句中使用隐式强转：

[source,groovy]
----
State switchState(State st) {
    switch (st) {
        case 'up':
            return State.down // 显式常量
        case 'down':
            return 'up' // 对返回类型的隐式强转
    }
}
----

特别是，看看 `case` 如何使用字符串常量。但是如果你使用带有 `String` 参数的枚举来调用方法，你仍然必须使用显式强转：

[source,groovy]
----
assert switchState('up' as State) == State.down
assert switchState(State.down) == State.up
----

=== 自定义类型强转

类可以通过实现 `asType` 方法来定义自定义强转策略。使用 `as` 运算符调用自定义强转，并且从不隐式。例如，假设你定义了两个类，`Polar` 和 `Cartesian`，如下例所示：

[source,groovy]
----
class Polar {
    double r
    double phi
}
class Cartesian {
   double x
   double y
}
----

并且你想要从Polar坐标转换为Cartesian坐标。一种方法是在 `Polar` 类中定义 `asType` 方法：

[source,groovy]
----
def asType(Class target) {
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}
----

允许你使用 `as` 强制运算符：

[source,groovy]
----
def sigma = 1E-16
def polar = new Polar(r:1.0,phi:PI/2)
def cartesian = polar as Cartesian
assert abs(cartesian.x-sigma) < sigma
----

总而言之，`Polar` 类看起来像这样：

[source,groovy]
----
class Polar {
    double r
    double phi
    def asType(Class target) {
        if (Cartesian==target) {
            return new Cartesian(x: r*cos(phi), y: r*sin(phi))
        }
    }
}
----

但是也可以在 `Polar` 类之外定义 `asType`，如果你想为你没有源代码的类或“封闭”类定义自定义强转策略，这可能是实用的，例如使用metaClass：

[source,groovy]
----
Polar.metaClass.asType = { Class target ->
    if (Cartesian==target) {
        return new Cartesian(x: r*cos(phi), y: r*sin(phi))
    }
}
----

=== 类字面量vs变量和as运算符

只有在对类有静态引用时才可以使用 `as` 关键字，如下面的代码所示：

[source,groovy]
----
interface Greeter {
    void greet()
}
def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter是其类的静态引用
greeter.greet()
----

但是如果你通过反射获得类，例如通过调用 `Class.forName` 会怎样？

[source,groovy]
----
Class clazz = Class.forName('Greeter')
----

尝试使用带有 `as` 关键字的类的引用将失败：

[source,groovy]
----
greeter = { println 'Hello, Groovy!' } as clazz
// throws:
// unable to resolve class clazz
// @ line 9, column 40.
//   greeter = { println 'Hello, Groovy!' } as clazz
----

它失败了因为 `as` 关键字只适用于类字面量。相反，你需要调用 `asType` 方法：

[source,groovy]
----
greeter = { println 'Hello, Groovy!' }.asType(clazz)
greeter.greet()
----

== 可选性

=== 可选括号

如果至少有一个参数并且没有歧义，方法调用可以省略括号：

[source,groovy]
----
println 'Hello World'
def maximum = Math.max 5, 10
----

没有参数或模糊方法调用的方法调用需要括号：

[source,groovy]
----
println()
println(Math.max(5, 10))
----

=== 可选分号

在Groovy行的末尾分号可以省略，如果该行只包含一个语句。这意味着：

[source,groovy]
----
assert true;
----

可以更方便地写为：

[source,groovy]
----
assert true
----

一行中的多个语句需要用分号分隔它们：

[source,groovy]
----
boolean a = true; assert a
----

=== 可选的return关键字

在Groovy中，返回在方法或闭包的主体中计算的最后一个表达式。这意味着 `return` 关键字是可选的。

[source,groovy]
----
int add(int a, int b) {
    return a+b
}
assert add(1, 2) == 3
----

可简化为：

[source,groovy]
----
int add(int a, int b) {
    a+b
}
assert add(1, 2) == 3
----

=== 可选的public关键字

默认情况下，Groovy类和方法是 `public` 的。因此这个类：

[source,groovy]
----
public class Server {
    public String toString() { "a server" }
}
----

与这个类相同：

[source,groovy]
----
class Server {
    String toString() { "a server" }
}
----

[[semantics.groovy-truth]]
== Groovy真值

Groovy通过应用下面给出的规则来决定表达式是真还是假。

=== 布尔表达式

如果相应的布尔值为 `true`，则为True。

[source,groovy]
----
assert true
assert !false
----

=== 集合和数组

非空集合和数组是真。

[source,groovy]
----
assert [1, 2, 3]
assert ![]
----

=== 匹配器

如果匹配器至少有一个匹配，则为真。

[source,groovy]
----
assert ('a' =~ /a/)
assert !('a' =~ /b/)
----

=== 迭代器和枚举

具有更多元素的迭代器和枚举被强转为真。

[source,groovy]
----
assert [0].iterator()
assert ![].iterator()
Vector v = [0] as Vector
Enumeration enumeration = v.elements()
assert enumeration
enumeration.nextElement()
assert !enumeration
----

=== 映射

非空Maps评估为true。

[source,groovy]
----
assert ['one' : 1]
assert ![:]
----

=== 字符串

非空字符串，GStrings和CharSequences被强转为true。

[source,groovy]
----
assert 'a'
assert !''
def nonEmpty = 'a'
assert "$nonEmpty"
def empty = ''
assert !"$empty"
----

=== 数字

非零数字是真。

[source,groovy]
----
assert 1
assert 3.5
assert !0
----

=== 对象引用

非空对象引用被强转为true。

[source,groovy]
----
assert new Object()
assert !null
----

=== 使用 `asBoolean()` 方法自定义真值

为了自定义groovy是否将对象计算为 `true` 或 `false`，请实现 `asBoolean()` 方法：

[source,groovy]
----
class Color {
    String name

    boolean asBoolean(){
        name == 'green' ? true : false
    }
}
----

Groovy将调用此方法将你的对象强转为布尔值，例如：

[source,groovy]
----
assert new Color(name: 'green')
assert !new Color(name: 'red')
----

== 类型

=== 可选类型

可选类型是即使你没有在变量上放置显式类型，程序也可以正常工作。作为一种动态语言，Groovy自然地实现了该功能，例如当你声明一个变量时：

[source,groovy]
----
String aString = 'foo'                      // <1>
assert aString.toUpperCase()                // <2>
----
<1> `foo` 使用显式类型 `String` 声明
<2> 我们可以在 `String` 上调用 `toUpperCase` 方法

Groovy让你可以这样写：

[source,groovy]
----
def aString = 'foo'                         // <1>
assert aString.toUpperCase()                // <2>
----
<1> 使用 `def` 声明 `foo`
<2> 我们仍然可以调用 `toUpperCase` 方法，因为在运行时被解析为 `String` 类型

所以你在这里使用显式类型并不重要。将此功能与<<semantics.static-type-checking,静态类型检查>>结合使用时尤其有趣，因为类型检查器会执行类型推断。

同样，Groovy没有强制要求在方法中声明参数的类型：

[source,groovy]
----
String concat(String a, String b) {
    a+b
}
assert concat('foo','bar') == 'foobar'
----

可以使用 `def` 作为返回类型和参数类型重写，以便利用鸭子类型，如下例所示：

[source,groovy]
----
def concat(def a, def b) {                              // <1>
    a+b
}
assert concat('foo','bar') == 'foobar'                  // <2>
assert concat(1,2) == 3                                 // <3>
----
<1> 返回类型和参数类型都使用 `def`
<2> 它让用 `String` 调用函数成为可能
<3> 因为定义了 `plus` 方法，所以也可以使用 `int`

建议在这里使用 `def` 关键字来描述一个应该适用于任何类型的方法的意图，但从技术上讲，我们可以使用 `Object` 而结果也是相同的：`def` 是在Groovy中，严格等同于使用 `Object`。

最终，可以从返回类型和参数描述符中完全删除类型。但是如果要从返回类型中删除它，则需要为该方法添加一个显式修饰符，以便编译器从方法声明和方法调用之间的差异中分辨它们，如下例所示：

[source,groovy]
----
private concat(a,b) {                                   // <1>
    a+b
}
assert concat('foo','bar') == 'foobar'                  // <2>
assert concat(1,2) == 3                                 // <3>
----
<1> 如果我们想省略返回类型，则必须显式设置修饰符。
<2> 仍然可以使用 `String` 调用方法
<3> 还有 `int`

省略公共API的方法参数或方法返回值类型通常被认为是不良做法。虽然在局部变量中使用 `def` 并不是真正的问题，因为变量的可见性仅限于方法本身，而在方法参数上设置时，`def` 将在方法签名中转换为 `Object`，这使得用户很难知道这是参数的预期类型。这意味着你应该将此限制为明确依赖于鸭子类型的情况。

[[semantics.static-type-checking]]
=== 静态类型检查

默认情况下，Groovy在编译时执行最少的类型检查。由于它主要是一种动态语言，因此在编译时无法检查静态编译器通常会执行的操作。通过运行时元编程添加的方法可能会改变类或对象的运行时行为。让我们在下面的例子中说明原因：

[source,groovy]
----
class Person {                                                   // <1>
    String firstName
    String lastName
}
def p = new Person(firstName: 'Raymond', lastName: 'Devos')      // <2>
assert p.formattedName == 'Raymond Devos'                        // <3> 
----
<1> `Person` 类只定义了两个属性 `firstName` 和 `lastName`
<2> 我们可以创建一个Person实例
<3> 并调用名为 `formattedName` 的方法

在动态语言中，如上例所示的代码不会抛出任何错误。怎么会这样？在Java中，这通常会在编译时失败。但是，在Groovy中，它不会在编译时失败，如果编码正确，也不会在运行时失败。实际上，为了使其在运行时工作，一种可能性是依赖于运行时元编程。所以只需在 `Person` 类声明后添加这一行就足够了：

[source,groovy]
----
Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }
----

这意味着一般来说，在Groovy中，你不能对超出声明类型的对象类型做出任何假设，即使你知道它，你也无法在编译时确定将调用哪个方法，或者哪个属性将被检索。从编写DSL到测试，它很有趣，本手册的其他部分对此进行了讨论。

但是，如果你的程序不依赖于动态功能并且你来自静态世界（特别是来自Java思维模式），那么在编译时不能捕获这样的“错误”可能会令人惊讶。正如我们在前面的例子中看到的那样，编译器无法确定这是一个错误。为了使其知道它，你必须明确地指示编译器你正在切换到类型检查模式。这可以通过使用 `@groovy.lang.TypeChecked` 注解类或方法来完成。

激活类型检查时，编译器执行更多工作：

* 类型推断已激活，这意味着即使你对局部变量使用 `def`，类型检查器也能够从赋值中推断出变量的类型
* 方法调用在编译时解析，这意味着如果没有在类上声明方法，编译器将抛出错误
* 通常，你将用于在静态语言中查找的所有编译时错误将会出现：找不到方法，找不到属性，方法调用的类型不兼容，数字精度错误，...

在本节中，我们将描述类型检查器在各种情况下的行为，并解释在代码上使用 `@TypeChecked` 的限制。

==== `@TypeChecked` 注解

===== `在编译时激活类型检查`

`groovy.lang.TypeChecked` 注解启用了类型检查。它可以放在一个类上：

[source,groovy]
----
@groovy.transform.TypeChecked
class Calculator {
    int sum(int x, int y) { x+y }
}
----

或一个方法上：

[source,groovy]
----
lass Calculator {
    @groovy.transform.TypeChecked
    int sum(int x, int y) { x+y }
}
----

在第一种情况下，将对带注解的类的所有方法，属性，字段，内部类......进行类型检查，而在第二种情况下，仅对标注类型检查的方法和可能的闭包或匿名内部类进行类型检查。

===== `跳过部分`

可以限制类型检查的范围。例如，如果类被选中，则可以通过使用 `@TypeChecked(TypeCheckingMode.SKIP)` 来指示类型检查器跳过方法：

[source,groovy]
----
import groovy.transform.TypeChecked
import groovy.transform.TypeCheckingMode

@TypeChecked                                        // <1>
class GreetingService {
    String greeting() {                             // <2>
        doGreet()
    }

    @TypeChecked(TypeCheckingMode.SKIP)             // <3>
    private String doGreet() {
        def b = new SentenceBuilder()
        b.Hello.my.name.is.John                     // <4>
        b
    }
}
def s = new GreetingService()
assert s.greeting() == 'Hello my name is John'
----
<1> `GreetingService` 类标记为需类型检查
<2> 所以 `greeting` 方法会自动进行类型检查
<3> 但是 `doGreet` 标有 `SKIP`
<4> 类型检查器不会在这里抱怨缺少属性

在前面的示例中，`SentenceBuilder` 依赖于动态代码。没有真正的 `Hello` 方法或属性，因此类型检查器通常会抱怨并且编译会失败。由于使用构建器的方法使用 `TypeCheckingMode.SKIP` 标记，因此对于此方法将跳过类型检查，因此即使类的其余部分已选中，代码也将进行编译通过。

以下部分描述了Groovy中类型检查的语义。

==== 类型检查赋值

当且仅当以下情况时，可以将类型 `A` 的对象 `o` 赋值给类型为 `T` 的变量：

* `T` 等于 `A`

[source,groovy]
----
Date now = new Date()
----

* 或 `T` 是 `String`，`boolean`，`Boolean` 或 `Class` 之一

[source,groovy]
----
String s = new Date() // 隐式调用toString
Boolean boxed = 'some string'       // Groovy真值
boolean prim = 'some string'        // Groovy真值
Class clazz = 'java.lang.String'    // class强转
----

* 或 `o` 为 `null`，`T` 不是基本类型

[source,groovy]
----
String s = null         // passes
int i = null            // fails
----

* 或 `T` 是数组，`A` 是数组，`A` 的组件类型可分配给 `T` 的组件类型

[source,groovy]
----
int[] i = new int[4]        // passes
int[] i = new String[4]     // fails
----

* 或 `T` 是数组，`A` 是列表，`A` 的组件类型可分配给 `T` 的组件类型

[source,groovy]
----
int[] i = [1,2,3]               // passes
int[] i = [1,2, new Date()]     // fails
----

* 或 `T` 是 `A` 的超类

[source,groovy]
----
AbstractList list = new ArrayList()     // passes
LinkedList list = new ArrayList()       // fails
----

* 或 `T` 是由 `A` 实现的接口

[source,groovy]
----
List list = new ArrayList()             // passes
RandomAccess list = new LinkedList()    // fails
----

* 或者 `T` 或 `A` 是基本类型，它们的装箱类型是可赋值的

[source,groovy]
----
int i = 0
Integer bi = 1
int x = new Integer(123)
double d = new Float(5f)
----

* 或 `T` 继承 `groovy.lang.Closure` 且 `A` 是SAM类型（单一抽象方法类型）

[source,groovy]
----
Runnable r = { println 'Hello' }
interface SAMType {
    int doSomething()
}
SAMType sam = { 123 }
assert sam.doSomething() == 123
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
AbstractSAM c = { 123 }
assert c.calc() == 246
----

* 或 `T` 和 `A` 派生自 `java.lang.Number` 并符合下表

[[semantics.number-assignment]]
.数字类型（java.lang.XXX）
|===
| T | A | 样例

| Double
| 除了BigDecimal或BigInteger之外的任何数字
a| 
[source,groovy]
----
Double d1 = 4d
Double d2 = 4f
Double d3 = 4l
Double d4 = 4i
Double d5 = (short) 4
Double d6 = (byte) 4
----

| Float
| 除BigDecimal，BigInteger或Double之外的任何类型
a| 
[source,groovy]
----
Float f1 = 4f
Float f2 = 4l
Float f3 = 4i
Float f4 = (short) 4
Float f5 = (byte) 4
----

| Long
| 除BigDecimal，BigInteger，Double或Float之外的任何类型
a| 
[source,groovy]
----
Long l1 = 4l
Long l2 = 4i
Long l3 = (short) 4
Long l4 = (byte) 4
----

| Integer
| 除BigDecimal，BigInteger，Double，Float或Long之外的任何类型
a| 
[source,groovy]
----
Integer i1 = 4i
Integer i2 = (short) 4
Integer i3 = (byte) 4
----

| Short
| 除BigDecimal，BigInteger，Double，Float，Long或Integer之外的任何类型
a| 
[source,groovy]
----
Short s1 = (short) 4
Short s2 = (byte) 4
----

| Byte
| Byte
a| 
[source,groovy]
----
Byte b1 = (byte) 4
----
|===

==== 列表和映射构造函数

除了上面的赋值规则之外，如果赋值被视为无效，则在类型检查模式下，如果符合以下情况，则可以将列表或映射字面量 `A` 赋值给类型为 `T` 的变量：

* 赋值是一个变量声明，`A` 是一个列表，`T` 有一个构造函数，其参数与列表中元素的类型相匹配
* 赋值是一个变量声明，`A` 是一个映射，`T` 有一个no-arg构造函数和每个映射键的属性

例如：

[source,groovy]
----
@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person classic = new Person('Ada','Lovelace')
----

你可以使用“列表构造函数”：

[source,groovy]
----
Person list = ['Ada','Lovelace']
----

或“映射构造函数”：

[source,groovy]
----
Person map = [firstName:'Ada', lastName:'Lovelace']
----

如果使用映射构造函数，则会对映射的键执行其他检查，以检查是否定义了同名属性。例如，以下内容将在编译时失败：

[source,groovy]
----
@groovy.transform.TupleConstructor
class Person {
    String firstName
    String lastName
}
Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]    // <1>
----
<1> 类型检查器将在编译时抛出错误 `No such property: age for class: Person`

==== 方法解析

在类型检查模式下，方法在编译时解析。解析按方法名称和参数工作，与方法返回值类型无关。参数类型与遵循这些规则的参数类型相匹配：

当且仅当以下情况时，类型 `A` 的参数 `o` 可用于类型 `T` 的参数：

* `T` 等于 `A`

[source,groovy]
----
int sum(int x, int y) {
    x+y
}
assert sum(3,4) == 7
----

* 或 `T` 是一个字符串，`A` 是一个GString

[source,groovy]
----
String format(String str) {
    "Result: $str"
}
assert format("${3+4}") == "Result: 7"
----

* 或 `o` 为 `null`，`T` 不是基本类型

[source,groovy]
----
String format(int value) {
    "Result: $value"
}
assert format(7) == "Result: 7"
format(null)           // fails
----

* 或 `T` 是数组，`A` 是数组，`A` 的组件类型可分配给 `T` 的组件类型

[source,groovy]
----
String format(String[] values) {
    "Result: ${values.join(' ')}"
}
assert format(['a','b'] as String[]) == "Result: a b"
format([1,2] as int[])              // fails
----

* 或 `T` 是 `A` 的超类

[source,groovy]
----
String format(AbstractList list) {
    list.join(',')
}
format(new ArrayList())              // passes
String format(LinkedList list) {
    list.join(',')
}
format(new ArrayList())              // fails
----

* 或 `T` 是由 `A` 实现的接口

[source,groovy]
----
String format(List list) {
    list.join(',')
}
format(new ArrayList())                  // passes
String format(RandomAccess list) {
    'foo'
}
format(new LinkedList())                 // fails
----

* 或者 `T` 或 `A` 是基本类型，它们的装箱类型是可赋值的

[source,groovy]
----
int sum(int x, Integer y) {
    x+y
}
assert sum(3, new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7
assert sum(new Integer(3), new Integer(4)) == 7
assert sum(new Integer(3), 4) == 7
----

* 或 `T` 继承 `groovy.lang.Closure` 且 `A` 是SAM类型（单一抽象方法类型）

[source,groovy]
----
interface SAMType {
    int doSomething()
}
int twice(SAMType sam) { 2*sam.doSomething() }
assert twice { 123 } == 246
abstract class AbstractSAM {
    int calc() { 2* value() }
    abstract int value()
}
int eightTimes(AbstractSAM sam) { 4*sam.calc() }
assert eightTimes { 123 } == 984
----

* 或者 `T` 和 `A` 派生自 `java.lang.Number` 并且符合与<<semantics.number-assignment,数字赋值>>相同的规则

如果在编译时未找到具有适当名称和参数的方法，则会引发错误。以下示例说明了与“普通”Groovy的区别：

[source,groovy]
----
class MyService {
    void doSomething() {
        printLine 'Do something'            // <1>
    }
}
----
<1> `printLine` 是一个错误，但由于我们处于动态模式，因此在编译时不会捕获错误

上面的示例显示了Groovy能够编译的类。但是，如果你尝试创建 `MyService` 实例并调用 `doSomething` 方法，那么它将在运行时失败，因为 `printLine` 不存在。当然，我们已经展示了Groovy如何使它成为一个完全有效的调用，例如通过捕获 `MethodMissingException` 或实现自定义元类，但如果这种情况并不是你想要的，那么 `@TypeChecked` 也许会派上用场：

[source,groovy]
----
@groovy.transform.TypeChecked
class MyService {
    void doSomething() {
        printLine 'Do something'            // <1>
    }
}
----
<1> `printLine` 出现编译时错误

只需添加 `@TypeChecked` 将触发编译时方法解析。类型检查器将尝试在 `MyService` 类上找到接受 `String` 参数的方法 `printLine`，但找不到。编译失败时会显示以下消息：

[source,groovy]
----
Cannot find matching method MyService#printLine(java.lang.String)
----

理解类型检查器背后的逻辑非常重要：它是一个编译时检查，因此根据定义，类型检查器不知道你执行的任何类型的**运行时**元编程。这意味着如果激活类型检查，那么在没有 `@TypeChecked` 的情况下完全有效的代码也将**不再**编译。如果你想到鸭子类型，尤其如此：

[source,groovy]
----
class Duck {
    void quack() {              // <1>
        println 'Quack!'
    }
}
class QuackingBird {
    void quack() {              // <2>
        println 'Quack!'
    }
}
@groovy.transform.TypeChecked
void accept(quacker) {
    quacker.quack()             // <3>
}
accept(new Duck())              // <4>
----
<1> 我们定义了一个 `Duck` 类，它定义了一个 `quack` 方法
<2> 我们定义另一个 `QuackingBird` 类，它也定义了一个 `quack` 方法
<3> `quacker` 是松散类型的，所以由于该方法是 `@TypeChecked`，我们将获得编译时错误
<4> 即使在非类型检查的Groovy中，这可以通过

有一些可能的解决方法，比如引入一个接口，但基本上，通过激活类型检查，你可以获得类型安全性但是你放弃了该语言的某些功能。希望Groovy引入一些功能，如流类型，以减少类型检查和非类型检查Groovy之间的差距。

==== 类型推断

===== `原则`

使用 `@TypeChecked` 注解代码时，编译器会执行类型推断。它不仅仅依赖于静态类型，而且还使用各种技术来推断变量的类型，返回类型，字面量......，这样即使激活类型检查器，代码仍然保持尽可能干净。

最简单的例子是推断变量的类型：

[source,groovy]
----
def message = 'Welcome to Groovy!'              // <1>
println message.toUpperCase()                   // <2>
println message.upper() // compile time error   // <3>
----
<1> 使用 `def` 关键字声明变量
<2> 类型检查器允许调用 `toUpperCase`
<3> 调用 `upper` 将在编译时失败

可调用 `toUpperCase` 的原因是因为 `message` 的类型被推断为 `String`。

===== `变量vs类型推断中的字段`

值得注意的是，虽然编译器对局部变量执行类型推断，但它**不**对字段执行任何类型的推断，总是回退到**声明**的字段类型。为了说明这一点，我们来看看这个例子：

[source,groovy]
----
class SomeClass {
    def someUntypedField                                                                // <1>
    String someTypedField                                                               // <2>

    void someMethod() {
        someUntypedField = '123'                                                        // <3>
        someUntypedField = someUntypedField.toUpperCase()  // compile-time error        // <4>
    }

    void someSafeMethod() {
        someTypedField = '123'                                                          // <5>
        someTypedField = someTypedField.toUpperCase()                                   // <6>
    }

    void someMethodUsingLocalVariable() {
        def localVariable = '123'                                                       // <7>
        someUntypedField = localVariable.toUpperCase()                                  // <8>
    }
}
----
<1> `someUntypedField` 使用 `def` 作为声明类型
<2> `someTypedField` 使用String作为声明类型
<3> 我们可以为 `someUntypedField` 赋值**任何东西**
<4> 但是在编译时调用 `toUpperCase` 失败，因为该字段没有适当的类型
<5> 我们可以将 `String` 分配给 `String` 类型的字段
<6> 并且这次允许使用 `toUpperCase`
<7> 如果我们将一个 `String` 分配给一个局部变量
<8> 然后在局部变量上可调用 `toUpperCase`

为何如此不同？原因是线程安全。在编译时，我们无法保证字段的类型。任何线程都可以在任何时候访问任何字段，在方法中为某个字段指定了某种类型的变量，并且在之后的行中使用时，另一个线程可能已经更改了字段的内容。局部变量不是这种情况：我们知道它们是否“逃逸”，因此我们可以确保变量的类型随着时间的推移是恒定的（或不是）。请注意，即使字段是final字段，JVM也不保证它，因此无论字段是否是final，类型检查器的行为都是一样的。

这是我们建议使用**有类型**字段的原因之一。由于类型推断，将def用于局部变量是完全正确的，对于字段来说情况并非如此，这些字段也会用作类的公共API，因此类型很重要。

===== `集合类型推断`

Groovy为各种类型的字面量提供了语法。Groovy中有三种本地集合字面量：

* 列表，使用 `[]` 字面量
* 映射，使用 `[:]` 字面量
* 范围，使用 `from..to`（包含）和 `from..<to`（排除）字面量

字面量的推断类型取决于字面量内的元素，如下表所示：

|===
| 字面量 | 推断类型
| `def list = []` | `java.util.List`
| `def list = ['foo','bar']` | `java.util.List<String>`
| `def list = ["${foo}","${bar}"]` | `java.util.List<GString>` 小心，`GString` 不是一个 `String`！
| `def map = [:]` | `java.util.LinkedHashMap`
| `def map1 = [someKey: 'someValue']` +
  `def map2 = ['someKey': 'someValue']` | `java.util.LinkedHashMap<String,String>`
| `def map = ["${someKey}": 'someValue']` | `java.util.LinkedHashMap<GString,String>` 小心，键类型是 `GString`！
| `def intRange = (0..10)` | `groovy.lang.IntRange`
| `def charRange = ('a'..'z')` | `groovy.lang.Range<String>`: 使用边界的类型来推断范围的组件类型
|===

如你所见，除了 `IntRange` 之外，推断类型使用泛型类型来描述集合的内容。如果集合包含不同类型的元素，则类型检查器仍会执行组件的类型推断，但使用<<semantics.least-upper-bound,最小上限>>的概念。

[[semantics.least-upper-bound]]
===== `最小上限`

在Groovy中，`A` 和 `B` 两种类型的__最小上限__被定义为以下类型：

* 超类对应于 `A` 和 `B` 的公共超类
* 接口对应于 `A` 和 `B` 实现的接口
* 如果 `A` 或 `B` 是基本类型且 `A` 不等于 `B`，则 `A` 和 `B` 的最小上限是其装箱类型的最小上限

如果 `A` 和 `B` 只有一个接口，并且它们的公共超类是 `Object`，那么两者的LUB就是公共接口。

最小上限表示可以分配给 `A` 和 `B` 的最小类型。例如，如果 `A` 和 `B` 都是 `String`，那么它们的LUB(least upper bound)也是 `String`。

[source,groovy]
----
class Top {}
class Bottom1 extends Top {}
class Bottom2 extends Top {}

assert leastUpperBound(String, String) == String                    // <1>
assert leastUpperBound(ArrayList, LinkedList) == AbstractList       // <2>
assert leastUpperBound(ArrayList, List) == List                     // <3>
assert leastUpperBound(List, List) == List                          // <4>
assert leastUpperBound(Bottom1, Bottom2) == Top                     // <5>
assert leastUpperBound(List, Serializable) == Object                // <6>
----
<1> `String` 和 `String` 的LUB是 `String`
<2> `ArrayList` 和 `LinkedList` 的LUB是它们公共的超类型 `AbstractList`
<3> `ArrayList` 和 `List` 的LUB是它们的公共接口 `List`
<4> 两个相同接口的LUB是该接口本身
<5> `Bottom1` 和 `Bottom2` 的LUB是它们的超类 `Top`
<6> 两种没有任何公共类型的LUB是 `Object`

在这些示例中，LUB始终表示为普通的JVM支持类型。但是Groovy在内部将LUB表示为一种可能更复杂的类型，并且你将无法使用它来定义变量。为了说明这一点，让我们继续这个例子：

[source,groovy]
----
interface Foo {}
class Top {}
class Bottom extends Top implements Serializable, Foo {}
class SerializableFooImpl implements Serializable, Foo {}
----

`Bottom` 和 `SerializableFooImpl` 的最小上限是什么？它们没有共同的超类（除了 `Object`），但它们共享2个接口（`Serializable` 和 `Foo`），因此它们的最小上限是表示两个接口（`Serializable` 和 `Foo`）的并集的类型。此类型无法在源代码中定义，但Groovy知道它。

在集合类型推断（以及一般的泛型类型推断）的上下文中，这变得很方便，因为组件的类型被推断为最小上限。我们可以在以下示例中说明为什么这很重要：

[source,groovy]
----
interface Greeter { void greet() }                  // <1>
interface Salute { void salute() }                  // <2>

class A implements Greeter, Salute {                // <3>
    void greet() { println "Hello, I'm A!" }
    void salute() { println "Bye from A!" }
}
class B implements Greeter, Salute {                // <4>
    void greet() { println "Hello, I'm B!" }
    void salute() { println "Bye from B!" }
    void exit() { println 'No way!' }               // <5>
}
def list = [new A(), new B()]                       // <6>
list.each {
    it.greet()                                      // <7>
    it.salute()                                     // <8>
    it.exit()                                       // <9>
}
----
<1> `Greeter` 接口定义了一个方法 `greet`
<2> `Salute` 接口定义了一个方法 `salute`
<3> `A` 类实现了 `Greeter` 和 `Salute`，但没有显式的接口继承两者
<4> `B` 同样
<5> 但 `B` 定义了另一个 `exit` 方法
<6> `list` 的类型被推断为“`A` 和 `B` 的LUB列表”
<7> 因此可以通过 `Greeter` 接口调用在 `A` 和 `B` 上定义的 `greet`
<8> 也可以通过 `Salute` 接口调用在 `A` 和 `B` 上定义的 `salute`
<9> 但是调用 `exit` 会出现编译时错误，因为它不属于 `A` 和 `B` 的LUB（仅在 `B` 中定义）

错误消息如下所示：

[source,groovy]
----
[Static type checking] - Cannot find matching method Greeter or Salute#exit()
----

表示 `exit` 方法既没有在 `Greeter` 也没有 `Salute` 上定义，它们是在 `A` 和 `B` 的最小上限中定义的两个接口。

===== `instanceof 推断`

在正常的非类型检查Groovy中，你可以编写如下内容：

[source,groovy]
----
class Greeter {
    String greeting() { 'Hello' }
}

void doSomething(def o) {
    if (o instanceof Greeter) {     // <1>
        println o.greeting()        // <2>
    }
}

doSomething(new Greeter())
----
<1> 使用 `instanceof` 检查保护方法调用
<2> 调用方法

方法调用因动态调度而起作用（该方法在运行时选择）。Java中的等效代码需要在调用 `greeting` 方法之前手动将 `o` 转换为 `Greeter`，因为会在编译时选择方法：

[source,groovy]
----
if (o instanceof Greeter) {
    System.out.println(((Greeter)o).greeting());
}
----

但是，在Groovy中，即使在 `doSomething` 方法上添加 `@TypeChecked`（从而激活类型检查），也不需要强制转换。编译器嵌入了__instanceof推断__使得强制转换可选。

[[semantics.flow-typing]]
===== `流类型`

流类型是Groovy在类型检查模式中的一个重要概念，也是类型推断的扩展。我们的想法是编译器能够在代码流中推断出变量的类型，而不仅仅是在初始化时：

[source,groovy]
----
@groovy.transform.TypeChecked
void flowTyping() {
    def o = 'foo'                       // <1>
    o = o.toUpperCase()                 // <2>
    o = 9d                              // <3>
    o = Math.sqrt(o)                    // <4>
}
----
<1> 首先，`o` 使用 `def` 声明并赋值一个 `String`
<2> 编译器推断 `o` 是一个 `String`，因此允许调用 `toUpperCase`
<3> `o` 被重新赋值为 `double`
<4> 调用 `Math.sqrt` 会通过编译，因为编译器知道此时 `o` 是 `double`

因此类型检查器__能意识__到变量的具体类型随时间变化的事实。特别是，如果你将最后一个赋值替换为：

[source,groovy]
----
o = 9d
o = o.toUpperCase()
----

类型检查器现在将在编译时失败，因为它知道在调用 `toUpperCase` 时 `o` 是 `double`，因此它是类型错误。

重要的是要理解，使用 `def` 声明一个触发类型推断的变量并不是事实不变的。流类型适用于任何类型的**任何**变量。声明具有显式类型的变量仅限制可以赋值给变量的内容：

[source,groovy]
----
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           // <1>
    list = list*.toUpperCase()          // <2>
    list = 'foo'                        // <3>
}
----
<1> `list` 被声明为未经检查的 `List`，并赋值了一个组件类型为 `String` 的列表字面量
<2> 由于流类型的原因，这一行通过了编译：类型检查器知道列表此时是 `List<String>`
<3> 但是你无法将 `String` 赋值给 `List`，因此这是类型检查错误

你还可以注意到，即使声明变量没有泛型信息，类型检查器也知道组件类型是什么。因此，这样的代码将无法编译：

[source,groovy]
----
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List list = ['a','b','c']           // <1>
    list.add(1)                         // <2>
}
----
<1> `list` 被推断为 `List<String>`
<2> 因此，将一个 `int` 添加到 `List<String>` 是产生编译时错误

修复此问题需要在声明中添加显式泛型类型：

[source,groovy]
----
@groovy.transform.TypeChecked
void flowTypingWithExplicitType() {
    List<? extends Serializable> list = []              // <1>
    list.addAll(['a','b','c'])                          // <2>
    list.add(1)                                         // <3> 
}
----
<1> 列表声明为 `List<? extends Serializable>` 并使用空列表初始化
<2> 添加到列表中的元素符合列表的声明类型
<3> 所以允许在 `List<? extends Serializable>` 中添加一个 `int` 值

引入了流类型来减少经典和静态Groovy之间的语义差异。特别要考虑这段代码在Java中的行为：

[source,groovy]
----
public Integer compute(String str) {
    return str.length();
}
public String compute(Object o) {
    return "Nope";
}
// ...
Object string = "Some string";          // <1> 
Object result = compute(string);        // <2>
System.out.println(result);             // <3>
----
<1> `o` 被声明为 `Object` 并赋值了一个 `String`
<2> 我们用 `o` 调用 `compute` 方法
<3> 并打印结果

在Java中，此代码将输出 `Nope`，因为方法选择是在编译时根据**声明**的类型完成的。因此，即使 `o` 在运行时是一个 `String`，它仍然是调用的 `Object` 版本，因为 `o` 已被声明为 `Object`。简而言之，在Java中，声明的类型是最重要的，无论是变量类型，参数类型还是返回类型。

在Groovy中，我们可以写：

[source,groovy]
----
int compute(String string) { string.length() }
String compute(Object o) { "Nope" }
Object o = 'string'
def result = compute(o)
println result
----

但这一次，它将返回 `6`，因为所选择的方法是在**运行时**根据实际参数类型选择的。因此，在运行时，`o` 是一个 `String`，因此使用 `String` 变量的函数。请注意，此行为与类型检查无关，这是Groovy一般工作的方式：动态调度。

在类型检查Groovy中，我们希望确保类型检查器在**编译时**选择和在运行时将选择的相同方法。一般来说，由于该语言的语义，这是不可能的，但是我们可以通过流类型使事情变得更好。使用流类型，在调用 `compute` 方法时，`o` 被推断为 `String`，因此选择采用 `String` 并返回 `int` 版本的函数。这意味着我们可以将方法的返回类型推断为 `int`，而不是 `String`。这对于后续调用和类型安全很重要。

因此，在类型检查Groovy中，流类型是一个非常重要的概念，这也意味着如果应用 `@TypeChecked`，则根据参数的推断类型而不是声明的类型选择方法。这不能确保100％类型安全，因为类型检查器可能选择了错误的方法，但它确保了与动态Groovy最接近的语义。

===== `高级类型推断`

<<semantics.flow-typing,流类型>>和<<semantics.least-upper-bound,最小上限>>推断的组合用于执行高级类型推断并确保在多种情况下的类型安全性。特别是，程序控制结构可能会改变变量的推断类型：

[source,groovy]
----
class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o
if (someCondition) {
    o = new Top()                               // <1> 
} else {
    o = new Bottom()                            // <2>
}
o.methodFromTop()                               // <3>
o.methodFromBottom()  // compilation error      // <4>
----
<1> 如果 `someCondition` 为 `true`，则为 `o` 赋值 `Top`
<2> 如果 `someCondition` 为 `false`，则为 `o` 赋值 `Bottom`
<3> 调用 `methodFromTop` 是安全的
<4> 但是调用 `methodFromBottom` 不是，所以这是一个编译时错误

当类型检查器访问 `if/else` 控制结构时，它会检查在 `if/else` 分支中赋值的所有变量，并计算所有赋值的<<semantics.least-upper-bound,最小上限>>。此类型是 `if/else` 块之后的推断变量的类型，因此在此示例中，`o` 在 `if` 分支中赋值为 `Top`，在 `else` 分支中赋值为 `Bottom`。它们的LUB是 `Top`，因此在条件分支之后，编译器将 `o` 推断为 `Top`。因此，将允许调用 `methodFromTop`，但不允许调用 `methodFromBottom`。

闭包存在相同的推理，特别是闭包共享变量。闭包共享变量是一个变量，它在闭包之外定义，但在闭包内使用，如下例所示：

[source,groovy]
----
def text = 'Hello, world!'                          // <1>
def closure = {
    println text                                    // <2>
}
----
<1> 声明了一个名为 `text` 的变量
<2> `text` 用于闭包内部。它是一个闭包共享变量。

Groovy允许开发人员使用这些变量而不需要它们是final的。这意味着可以在闭包内重新赋值闭包共享变量：

[source,groovy]
----
String result
doSomething { String it ->
    result = "Result: $it"
}
result = result?.toUpperCase()
----

问题是闭包是一个独立的代码块，可以**随时**执行（或不执行）。特别是，例如，`doSomething` 可能是异步的。这意味着闭包的主体不属于主控制流。因此，类型检查器还为每个闭包共享变量计算变量的所有赋值的LUB，并将使用该LUB作为闭包范围之外的推断类型，如下例所示：

[source,groovy]
----
class Top {
   void methodFromTop() {}
}
class Bottom extends Top {
   void methodFromBottom() {}
}
def o = new Top()                               // <1>
Thread.start {
    o = new Bottom()                            // <2>
}
o.methodFromTop()                               // <3>
o.methodFromBottom()  // compilation error      // <4>
----
<1> 一个闭包共享变量，首先被赋值为一个 `Top`
<2> 在闭包内部，它被赋值为一个 `Bottom`
<3> 允许使用 `methodFromTop`
<4> `methodFromBottom` 是一个编译错误

在这里当调用 `methodFromBottom` 时，无法保证在编译时或运行时 `o` 的类型实际上是一个 `Bottom`。它有可能是，但我们无法确定，因为它是异步的。所以类型检查器只允许<<semantics.least-upper-bound,最小上限>>的调用，即 `Top`。

==== 闭包和类型推断

类型检查器对闭包执行特殊的推断，导致一边进行额外检查，一边提升流畅性。

===== `返回类型推断`

类型检查器能够做的第一件事是推断闭包的返回类型。这在以下示例中简单说明：

[source,groovy]
----
@groovy.transform.TypeChecked
int testClosureReturnTypeInference(String arg) {
    def cl = { "Arg: $arg" }                                // <1> 
    def val = cl()                                          // <2> 

    val.length()                                            // <3> 
}
----
<1> 定义了一个闭包，它返回一个字符串（更准确地说是一个 `GString`）
<2> 我们调用闭包并将结果赋给变量
<3> 类型检查器推断闭包将返回一个字符串，因此允许调用 `length()`

如你所见，与显式声明其返回类型的方法不同，不需要声明闭包的返回类型：它的类型是从闭包的主体推断出来的。

===== 闭包与方法

值得注意的是，返回类型推断仅适用于闭包。虽然类型检查器可以在方法上执行相同操作，但实际上这是不可取的：通常，可以覆盖方法，并且不可能确保被调用的方法不是被重写的版本。因此，流类型实际上会认为方法返回一些内容，而实际上，它可能会返回其他内容，如下例所示：

[source,groovy]
----
@TypeChecked
class A {
    def compute() { 'some string' }             // <1>
    def computeFully() {
        compute().toUpperCase()                 // <2>
    }
}
@TypeChecked
class B extends A {
    def compute() { 123 }                       // <3>
}
----
<1> 类 `A` 定义了一个 `compute` 方法，该方法有效地返回一个 `String`
<2> 这将导致编译失败，因为 `compute` 的返回类型是 `def`（又名 `Object`）
<3> 类 `B` 继承类 `A` 并重新定义 `compute`，此类型返回 `int`

如你所见，如果类型检查器依赖于方法的推断返回类型，使用<<semantics.flow-typing,流类型>>，类型检查器可以确定能调用 `toUpperCase`。它实际上是**错误**的，因为子类可以重写 `compute` 并返回不同的对象。这里，`B#compute` 返回一个 `int`，因此在 `B` 实例上调用 `computeFully` 的人会看到运行时错误。编译器通过使用方法声明的返回类型而不是推断的返回类型来防止这种情况发生。

为了保持一致性，**每种**方法的行为都是相同的，即使它们是 `static` 或 `final`。

===== `参数类型推断`

除了返回类型之外，闭包还可以从上下文中推断其参数类型。编译器有两种推断参数类型的方法：

* 通过__隐式SAM类型强转__
* 通过API元数据

为了说明这一点，让我们从一个因为类型检查器无法推断出参数类型，而导致编译失败的示例开始：

[source,groovy]
----
class Person {
    String name
    int age
}

void inviteIf(Person p, Closure<Boolean> predicate) {           // <1>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void failCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)
    inviteIf(p) {                                               // <2>
        it.age >= 18 // No such property: age                   // <3>
    }
}
----
<1> `inviteIf` 方法接受 `Person` 和 `Closure`
<2> 我们使用 `Person` 和 `Closure` 调用它
<3> 然而，`it` 并不是静态已知为 `Person`，编译失败

在这个例子中，闭包体包含 `it.age`。对于动态的，而不是类型检查的代码，这将起作用，因为 `it` 的类型在运行时将是 `Person`。不幸的是，在编译时，只需通过读取 `inviteIf` 的签名无法知道它的类型。

===== `显式闭包参数`

简而言之，类型检查器在 `inviteIf` 方法上没有足够的上下文信息来静态地确定 `it` 的类型。这意味着方法调用需要像这样重写：

[source,groovy]
----
inviteIf(p) { Person it ->                         // <1>         
    it.age >= 18
}
----
<1> `it` 的类型需要明确声明

通过明确声明 `it` 变量的类型，你可以解决此问题并静态检查此代码。

===== `从单抽象方法类型推断出的参数`

对于API或框架设计者，有两种方法可以使用户更加优雅，因此他们不必为闭包参数声明显式类型。第一个也是最简单的方法是用SAM类型替换闭包：

[source,groovy]
----
interface Predicate<On> { boolean apply(On e) }                 // <1>

void inviteIf(Person p, Predicate<Person> predicate) {          // <2>
    if (predicate.apply(p)) {
        // send invite
        // ...
    }
}

@groovy.transform.TypeChecked
void passesCompilation() {
    Person p = new Person(name: 'Gerard', age: 55)

    inviteIf(p) {                                               // <3>
        it.age >= 18                                            // <4>
    }
}
----
<1> 使用 `apply` 方法声明SAM接口
<2> `inviteIf` 现在使用 `Predicate<Person>` 而不是 `Closure<Boolean>`
<3> 没有必要再显式声明它变量的类型
<4> `it.age` 正确编译，它的类型是从 `Predicate#apply` 方法签名推断出来的

通过使用这种技术，我们利用Groovy中__闭包到SAM类型自动强转__特性来实现。你是否应该使用__SAM类型或闭包__的问题实际上取决于你需要做什么。在很多情况下，使用SAM接口就足够了，特别是如果你考虑Java 8中的函数式接口。但是，闭包提供了函数式接口无法访问的功能。特别是，闭包可以有一个委托，所有者可以在被调用之前作为对象（例如，cloned，serialized，curried，...）进行操作。它们还可以支持多个签名（多态）。因此，如果你需要这种操作，最好切换到下面描述的最高级的类型推断注解。

关于闭包参数类型推断需要解决的原始问题，也就是说，静态确定闭包的参数类型而不必显式声明它们是Groovy类型系统继承Java类型系统，不足以描述参数的类型。

===== `@ClosureParams注解`

Groovy提供了一个注解 `@ClosureParams`，旨在完成类型信息。此注解主要针对希望通过提供类型推断元数据来扩展类型检查器功能的框架和API开发人员。如果你的库使用闭包并且你希望获得最高级别的工具支持，这一点非常重要。

让我们通过修复原始示例，介绍 `@ClosureParams` 注解来说明这一点：

[source,groovy]
----
import groovy.transform.stc.ClosureParams
import groovy.transform.stc.FirstParam
void inviteIf(Person p, @ClosureParams(FirstParam) Closure<Boolean> predicate) {        // <1>
    if (predicate.call(p)) {
        // send invite
        // ...
    }
}
inviteIf(p) {                                                                           // <2>
    it.age >= 18
}
----
<1> 闭包参数用 `@ClosureParams` 注解
<2> 没有必要为 `it` 使用显式类型，这是可推断的

`@ClosureParams` 注解最少接受一个参数，该参数被命名为__type hint__。类型提示是一个类，它负责在编译时为闭包完成类型信息。在此示例中，正在使用的类型提示是 `groovy.transform.stc.FirstParam`，它向类型检查器指示闭包将接受一个参数，其类型是方法的第一个参数的类型。在这种情况下，方法的第一个参数是 `Person`，因此它向类型检查器指示闭包的第一个参数实际上是 `Person`。

第二个可选参数是命名选项。它的语义取决于类型提示类。Groovy附带了各种捆绑类型的提示，如下表所示：

.预定义的类型提示
|===
| 类型提示 | 多态? | 描述和示例

| `FirstParam` +
`SecondParam` +
`ThirdParam`
| No
a| 方法的第一个（第二个，第三个）参数类型
[source,groovy]
----
import groovy.transform.stc.FirstParam
void doSomething(String str, @ClosureParams(FirstParam) Closure c) {
    c(str)
}
doSomething('foo') { println it.toUpperCase() }
----

[source,groovy]
----
import groovy.transform.stc.SecondParam
void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {
    c(31*str.hashCode()+seed)
}
withHash('foo', (int)System.currentTimeMillis()) {
    int mod = it%2
}
----

[source,groovy]
----
import groovy.transform.stc.ThirdParam
String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {
    "$prefix${c(o)}$postfix"
}
assert format('foo', 'bar', 'baz') {
    it.toUpperCase()
} == 'fooBAZbar'
----

| `FirstParam.FirstGenericType` +
`SecondParam.FirstGenericType` +
`ThirdParam.FirstGenericType`
| No
a| 方法的第一个（第二个，第三个）参数的第一个泛型类型
[source,groovy]
----
import groovy.transform.stc.FirstParam
public <T> void doSomething(List<T> strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
    strings.each {
        c(it)
    }
}
doSomething(['foo','bar']) { println it.toUpperCase() }
doSomething([1,2,3]) { println(2*it) }
----

所有 `FirstParam`，`SecondParam` 和 `ThirdParam` 类型提示都存在 `SecondGenericType` 和 `ThirdGenericType` 的变体。

| `SimpleType`
| No
a| 闭包参数类型来自 `options` 字符串的类型提示。
[source,groovy]
----
import groovy.transform.stc.SimpleType
public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {
    c('foo',3)
}
doSomething { str, len ->
    assert str.length() == len
}
----

此类型提示支持**单个**签名，并且每个参数都使用完全限定的类型名称或基本类型指定为__options__数组的值。

| `MapEntryOrKeyValue`
| Yes
a| 闭包的专用类型提示，可以工作在 `Map.Entry` 单个参数上，也可以工作在与键和值对应的两个参数上。
[source,groovy]
----
import groovy.transform.stc.MapEntryOrKeyValue
public <K,V> void doSomething(Map<K,V> map, @ClosureParams(MapEntryOrKeyValue) Closure c) {
    // ...
}
doSomething([a: 'A']) { k,v ->
    assert k.toUpperCase() == v.toUpperCase()
}
doSomething([abc: 3]) { e ->
    assert e.key.length() == e.value
}
----

此类型提示**要求**第一个参数是 `Map` 类型，并从映射实际键/值类型中推断闭包参数类型。

| `FromAbstractTypeMethods`
| Yes
a| 从某种类型的抽象方法推断闭包参数类型。为**每个**抽象方法推断签名。
[source,groovy]
----
import groovy.transform.stc.FromAbstractTypeMethods
abstract class Foo {
    abstract void firstSignature(int x, int y)
    abstract void secondSignature(String str)
}
void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {
    // ...
}
doSomething { a, b -> a+b }
doSomething { s -> s.toUpperCase() }
----

如果上面的示例中有多个签名，则类型检查器**只能**在每个方法的参数数量不同时推断出参数的类型。在上面的示例中，`firstSignature` 接受2个参数，`secondSignature` 接受1个参数，因此类型检查器可以根据参数的数量推断参数类型。但请参阅下面讨论的可选解析者类属性。

| `FromString`
| Yes
a| 从 `options` 参数推断闭包参数类型。`options` 参数由逗号分隔的非基本类型数组组成。数组的每个元素对应一个签名，元素中的每个逗号分隔签名的参数。简而言之，这是最通用的类​​型提示，并且 `options` 映射的每个字符串都被**解析**为好像它是一个签名文字。虽然非常强大，但是如果可以的话，必须避免使用此类型提示，因为由于需要解析类型签名，因此会增加编译时间。

接受 `String` 参数的闭包的单个签名：

[source,groovy]
----
import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String"]) Closure cl) {
    // ...
}
doSomething { s -> s.toUpperCase() }
----

一个多态闭包，接受一个 `String` 或一个 `String, Integer`：

[source,groovy]
----
import groovy.transform.stc.FromString
void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {
    // ...
}
doSomething { s -> s.toUpperCase() }
doSomething { s,i -> s.toUpperCase()*i }
----

一个多态闭包，接受一个 `T` 或一对 `T, T`：

[source,groovy]
----
import groovy.transform.stc.FromString
public <T> void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {
    // ...
}
doSomething('foo') { s -> s.toUpperCase() }
doSomething('foo') { s1,s2 -> assert s1.toUpperCase() == s2.toUpperCase() }
----
|===

即使你使用 `FirstParam`，`SecondParam` 或 `ThirdParam` 作为类型提示，它也不严格意味着**将**传递给闭包的参数将是方法调用的第一个（第二个，第三个）参数。它只表示闭包的参数**类型**与方法调用的第一个（第二个，第三个）参数的类型**相同**而已。

简而言之，在接受 `Closure` 的方法上缺少 `@ClosureParams` 注解**不会**使编译失败。如果存在（并且它可以存在于Java源代码以及Groovy源代码中），那么类型检查器具有**更多**信息并且可以执行其他类型推断。这使得此功能对框架开发人员特别有用。

第三个可选参数名为__conflictResolutionStrategy__。它可以引用一个类（从 `ClosureSignatureConflictResolver` 继承），如果在初始推断计算完成后找到多个参数类型，则可以执行其他参数类型的解析。Groovy附带一个默认类型解析器，它不执行任何操作，另一个则选择第一个签名（如果找到多个）。只有在找到多个签名并且设计为后处理器时才会调用解析程序。任何需要注入类型信息的语句都必须传递通过类型提示确定的参数签名之一，然后解析器在返回的候选签名中进行选择。

====== `@DelegatesTo`

类型检查器使用 `@DelegatesTo` 注解来推断委托的类型。它允许API设计者指示编译器什么是委托的类型和委派策略。`@DelegatesTo` 注解将在 {groovyDocBaseUrl}/core-domain-specific-languages.html#section-delegatesto[特定部分]中讨论。

=== 静态编译

==== 动态vs静态

在<<semantics.static-type-checking,类型检查>>部分，我们已经看到，由于 `@TypeChecked` 注解，Groovy提供了可选的类型检查。类型检查器在编译时运行，并执行动态代码的静态分析。无论是否启用了类型检查，程序的行为都完全相同。这意味着 `@TypeChecked` 注解对于程序的语义是中性的。即使可能需要在源代码中添加类型信息以使程序被认为是类型安全的，但最终程序的语义是相同的。

虽然这听起来不错，但实际上存在一个问题：在编译时完成的动态代码的类型检查，如果没有发生特定于运行时的行为才正确。例如，以下程序类型检查通过：

[[semantics.typechecked-defeated]]
[source,groovy]
----
class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.TypeChecked
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
----

有两个 `compute` 方法。一个接受一个 `String` 并返回一个 `int`，另一个接受一个 `int` 并返回一个 `String`。如果你编译它，它被认为是类型安全：`compute('foobar')` 内部调用将返回一个 `int`，并且在此 `int` 上调用 `compute` 将依次返回一个 `String`。

现在，在调用 `test()` 之前，请考虑添加以下行：

[source,groovy]
----
Computer.metaClass.compute = { String str -> new Date() }
----

使用运行时元编程，我们实际上是修改了 `compute(String)` 方法的行为，因此它不会返回提供的参数的长度，而是返回 `Date`。如果执行该程序，它将在运行时失败。由于这行可以从任何地方添加，在任何线程中，类型检查器绝对没有办法静态地确保不会发生这样的事情。简而言之，类型检查器易受猴子补丁。这只是一个例子，但这说明了对动态程序进行静态分析本质上是错误的概念。

Groovy语言为 `@TypeChecked` 提供了一个替代注解，它实际上将确保推断为被调用的方法将在运行时被有效地调用。此注解将Groovy编译器转换为**静态编译器**，其中所有方法调用在编译时解析**并**生成的字节码确保发生这种情况：注解为 `@groovy.transform.CompileStatic`。

[[semantics.compilestatic-annotation]]
==== `@CompileStatic` 注解

可以在任何可以使用 `@TypeChecked` 注解的地方添加 `@CompileStatic` 注解，也就是说在类或方法上。没有必要同时添加 `@TypeChecked` 和 `@CompileStatic`，因为 `@CompileStatic` 执行 `@TypeChecked` 所执行的所有操作，除此之外还会触发静态编译。

让我们以<<semantics.typechecked-defeated,失败的例子>>为例，但这一次让我们用 `@CompileStatic` 替换 `@TypeChecked` 注解：

[source,groovy]
----
class Computer {
    int compute(String str) {
        str.length()
    }
    String compute(int x) {
        String.valueOf(x)
    }
}

@groovy.transform.CompileStatic
void test() {
    def computer = new Computer()
    computer.with {
        assert compute(compute('foobar')) =='6'
    }
}
Computer.metaClass.compute = { String str -> new Date() }
test()
----

这是**唯一**的区别。如果我们执行这个程序，这次没有运行时错误。`test` 方法不受猴子补丁的影响，因为在其体内调用的 `compute` 方法在编译时被链接，因此即使 `Computer` 的元类更改，程序仍然按**类型检查器的预期运行**。

==== 主要好处

在代码中使用 `@CompileStatic` 有几个好处：

* 类型安全
* 对<<semantics.compilestatic-annotation,猴子补丁>>的免疫力
* 性能提升

性能提升取决于你正在执行的程序类型。如果它受I/O限制，静态编译代码和动态代码之间的差异几乎不可察觉。在高CPU密集型代码上，由于生成的字节码与Java等效程序生成的字节码非常接近（如果不相等），因此性能得到极大提高。

使用Groovy的__invokedynamic__版本(JDK 7及以上版本的用户可以访问该版本)，动态代码的性能应该非常接近于静态编译代码的性能。有时，它甚至可以更快！只有一种方法可以确定你应该选择哪个版本：测量。原因是根据你的程序和你使用的JVM，性能可能会有很大差异。特别是，groovy的__invokedynamic__版本对正在使用的JVM版本非常敏感。

== 类型检查扩展

(TODO)

TIP: http://www.groovy-lang.org/semantics.html[原文链接]
