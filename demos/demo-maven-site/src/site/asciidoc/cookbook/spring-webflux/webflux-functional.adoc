[[webflux-fn]]
= 函数式端点

Spring WebFlux包含WebFlux.fn，这是一个轻量级的函数式编程模型，其中的函数用于路由和处理请求，
而契约则是为不变性而设计的。它是基于注解的编程模型的替代方案，但可以在相同的
<<spring-webflux.adoc#webflux-reactive-spring-web>>基础上运行。


[[webflux-fn-overview]]
== 概览

在WebFlux.fn中，HTTP请求由 `HandlerFunction` 处理：该函数接受 `ServerRequest` 并返回延迟的 `ServerResponse`
（即 `Mono<ServerResponse>`）。请求和响应对象都有不可变的契约，这些契约提供对HTTP请求和响应的JDK 8友好访问。
`HandlerFunction` 等效于基于注解的编程模型中 `@RequestMapping` 方法的主体。

传入的请求通过 `RouterFunction` 路由到处理程序函数：该函数接受 `ServerRequest` 并返回延迟的 `HandlerFunction`
（即 `Mono<HandlerFunction>`）。当路由器函数匹配时，返回处理程序函数。否则为空Mono。
`RouterFunction` 等效于 `@RequestMapping` 注解，但主要区别在于路由器函数不仅提供数据，还提供行为。

`RouterFunctions.route()` 提供了一个路由器构建器，可简化路由器的创建过程，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction<ServerResponse> route = route()
	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson)
	.GET("/person", accept(APPLICATION_JSON), handler::listPeople)
	.POST("/person", handler::createPerson)
	.build();


public class PersonHandler {

	// ...

	public Mono<ServerResponse> listPeople(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> createPerson(ServerRequest request) {
		// ...
	}

	public Mono<ServerResponse> getPerson(ServerRequest request) {
		// ...
	}
}
----

运行 `RouterFunction` 的一种方法是将其转换为 `HttpHandler` 并通过内置
<<spring-webflux.adoc#webflux-httphandler,服务器适配器>>之一进行安装：

* `RouterFunctions.toHttpHandler(RouterFunction)`
* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`

大多数应用程序都可以通过WebFlux Java配置运行，请参阅<<webflux-fn-running>>。



[[webflux-fn-handler-functions]]
== HandlerFunction

`ServerRequest` 和 `ServerResponse` 是不可变的接口，它们提供JDK 8友好的HTTP请求和响应访问。
请求和响应都提供对主体流的 http://www.reactive-streams.org[Reactive Streams]背压。请求主体用Reactor `Flux` 或 `Mono` 表示。
响应主体由任何Reactive Streams `Publisher` 组成，包括 `Flux` 和 `Mono`。有关更多信息，请参见
<<spring-webflux.adoc#webflux-reactive-libraries,响应式库>>。


[[webflux-fn-request]]
=== `ServerRequest`

`ServerRequest` 提供对HTTP方法，URI，标头和查询参数的访问，而通过 `body` 方法提供对主体的访问。

下面的示例将请求体提取到 `Mono<String>`：

[source,java]
----
Mono<String> string = request.bodyToMono(String.class);
----

以下示例将主体提取到 `Flux<Person>`（或Kotlin中的 `Flux<Person>`），其中 `Person` 对象从某种序列化形式（例如：JSON或XML）解码：

[source,java]
----
Flux<Person> people = request.bodyToFlux(Person.class);
----

前面的示例是使用更通用的 `ServerRequest.body(BodyExtractor)` 的快捷方式，该请求接受
`BodyExtractor` 函数式策略接口。实用工具类 `BodyExtractors` 提供对许多实例的访问。例如，前面的示例也可以编写如下：

[source,java]
----
Mono<String> string = request.body(BodyExtractors.toMono(String.class));
Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class));
----

下面的示例显示如何访问表单数据：

[source,java]
----
Mono<MultiValueMap<String, String> map = request.formData();
----

以下示例显示了如何以map形式访问multipart数据：

[source,java]
----
Mono<MultiValueMap<String, Part> map = request.multipartData();
----

下面的示例演示如何以流方式一次访问multiparts：

[source,java]
----
Flux<Part> parts = request.body(BodyExtractos.toParts());
----



[[webflux-fn-response]]
=== `ServerResponse`

`ServerResponse` 提供对HTTP响应的访问，并且由于它是不可变的，因此你可以使用 `build` 方法来创建它。
你可以使用构建器来设置响应状态，添加响应头或提供响应体。以下示例使用JSON内容创建200（OK）响应：

[source,java]
----
Mono<Person> person = ...
ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);
----

下面的示例演示如何构建一个具有 `Location` 标头且没有正文的201（CREATED）响应：

[source,java]
----
URI location = ...
ServerResponse.created(location).build();
----

根据所使用的编解码器，可以传递提示参数以自定义主体的序列化或反序列化方式。例如，要指定
https://www.baeldung.com/jackson-json-view-annotation[Jackson JSON视图]：

[source,java]
----
ServerResponse.ok().hint(Jackson2CodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);
----



[[webflux-fn-handler-classes]]
=== 处理程序类

我们可以将处理程序函数编写为lambda，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
HandlerFunction<ServerResponse> helloWorld =
  request -> ServerResponse.ok().body(fromObject("Hello World"));
----

这很方便，但是在应用程序中我们需要多个函数，并且多个内联lambda可能会变得凌乱。
因此，将相关的处理程序函数分组到一个处理程序类中很有用，该类的作用与基于注解的应用程序中的
`@Controller` 相似。例如，以下类公开了响应式类型 `Person` 存储库：


[source,java,indent=0]
[subs="verbatim,quotes"]
----
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.ServerResponse.ok;
import static org.springframework.web.reactive.function.BodyInserters.fromObject;

public class PersonHandler {

	private final PersonRepository repository;

	public PersonHandler(PersonRepository repository) {
		this.repository = repository;
	}

	public Mono<ServerResponse> listPeople(ServerRequest request) { // <1>
		Flux<Person> people = repository.allPeople();
		return ok().contentType(APPLICATION_JSON).body(people, Person.class);
	}

	public Mono<ServerResponse> createPerson(ServerRequest request) { // <2>
		Mono<Person> person = request.bodyToMono(Person.class);
		return ok().build(repository.savePerson(person));
	}

	public Mono<ServerResponse> getPerson(ServerRequest request) { // <3>
		int personId = Integer.valueOf(request.pathVariable("id"));
		return repository.getPerson(personId)
			.flatMap(person -> ok().contentType(APPLICATION_JSON).body(fromObject(person)))
			.switchIfEmpty(ServerResponse.notFound().build());
	}
}
----
<1> `listPeople` 是一个处理函数，它以JSON格式返回存储库中找到的所有 `Person` 对象。
<2> `createPerson` 是一个处理函数，用于存储请求正文中包含的新 `Person`。请注意，`PersonRepository.savePerson(Person)`
返回 `Mono<Void>`：一个空的 `Mono`，当从请求中读取并存储此人时，它将发出完成信号。
因此，当接收到完成信号时（即 `Person` 保存完毕时），我们使用 `build(Publisher<Void>)` 方法发送响应。
<3> `getPerson` 是一个处理程序函数，它返回由 `id` 路径变量标识的单个人。我们从存储库中检索该
`Person` 并创建一个JSON响应（如果找到）。如果未找到，则使用 `switchIfEmpty(Mono<T>)`
返回404 Not Found响应。


[[webflux-fn-handler-validation]]
=== 验证

函数式端点可以使用Spring的 {doc-spring-core}#validation[验证工具]将验证应用于请求体。
例如，给定 `Person` 的自定义Spring {doc-spring-core}#validation[Validator]实现：

====
[source,java,indent=0]
[subs="verbatim,quotes"]
----
public class PersonHandler {

	private final Validator validator = new PersonValidator(); // <1>

	// ...

	public Mono<ServerResponse> createPerson(ServerRequest request) {
		Mono<Person> person = request.bodyToMono(Person.class).doOnNext(this::validate); <2>
		return ok().build(repository.savePerson(person));
	}

	private void validate(Person person) {
		Errors errors = new BeanPropertyBindingResult(body, "person");
		validator.validate(body, errors);
		if (errors.hasErrors) {
			throw new ServerWebInputException(errors.toString()); <3>
		}
	}

----
<1> 创建 `Validator` 实例。
<2> 应用验证。
<3> 引发400响应的异常。
====

处理程序还可以通过基于 `LocalValidatorFactoryBean` 创建和注入全局 `Validator` 实例来使用标准Bean验证API（JSR-303）。
请参阅 {doc-spring-core}#validation-beanvalidation[Spring Validation]。


[[webflux-fn-router-functions]]
== `RouterFunction`

路由器函数用于将请求路由到相应的 `HandlerFunction`。通常，你不是自己编写路由器函数，
而是使用 `RouterFunctions` 实用工具类上的方法来创建一个。`RouterFunctions.route()`（无参数）
为你提供了流式生成器，用于创建路由器函数，而 `RouterFunctions.route(RequestPredicate，HandlerFunction)`
提供了直接创建路由器的方法。

通常，建议使用 `route()` 构建器，因为它为典型的映射方案提供了便捷的快捷方式，而无需难以发现的静态导入。
例如，路由器函数构建器提供了 `GET(String, HandlerFunction)` 方法来为GET请求创建映射，
和 `POST(String, HandlerFunction)` 来为POST请求创建映射。

除了基于HTTP方法的映射外，路由构建器还提供了一种在映射到请求时引入其他谓词的方法。
对于每个HTTP方法，都有一个重载的变体，它以 `RequestPredicate` 作为参数，但是可以表示哪些额外的约束。


[[webflux-fn-predicates]]
=== 谓词

你可以编写自己的 `RequestPredicate`，但是 `RequestPredicates` 实用工具类根据请求路径，HTTP方法，
内容类型等提供许多常用的实现。以下示例使用请求谓词基于 `Accept` 头创建约束：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
RouterFunction<ServerResponse> route = RouterFunctions.route()
	.GET("/hello-world", accept(MediaType.TEXT_PLAIN),
		request -> Response.ok().body(fromObject("Hello World")));
----

你可以使用以下命令组合多个请求谓词：

* `RequestPredicate.and(RequestPredicate)` -- 两者必须匹配。
* `RequestPredicate.or(RequestPredicate)` -- 任何一个匹配即可。

`RequestPredicates` 中的许多谓词都是组合的。例如，`RequestPredicates.GET(String)` 由
`RequestPredicates.method(HttpMethod)` 和 `RequestPredicates.path(String)` 组合。
上面显示的示例还使用了两个请求谓词，因为构建器在内部使用 `RequestPredicates.GET` 并将其与 `accept` 谓词组合在一起。


[[webflux-fn-routes]]
=== 路由

路由器函数按顺序评估：如果第一个路由不匹配，则评估第二个路由，依此类推。
因此，在通用路由之前声明更具体的路由是有意义的。请注意，此行为不同于基于注解的编程模型，在该模型中，将自动选择“最特定”的控制器方法。

使用路由器函数生成器时，所有定义的路由都组成一个 `RouterFunction`，从 `build()` 返回。还有其他方法可以将多个路由器函数组合在一起：

* 在 `RouterFunctions.route()` 构建器上执行 `add(RouterFunction)`
* `RouterFunction.and(RouterFunction)`
* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` --
具有嵌套 `RouterFunctions.route()` 的 `RouterFunction.and()` 的快捷方式。

以下示例显示了四种路由的组合：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
import static org.springframework.http.MediaType.APPLICATION_JSON;
import static org.springframework.web.reactive.function.server.RequestPredicates.*;

PersonRepository repository = ...
PersonHandler handler = new PersonHandler(repository);

RouterFunction<ServerResponse> otherRoute = ...

RouterFunction<ServerResponse> route = route()
	.GET("/person/{id}", accept(APPLICATION_JSON), handler::getPerson) // <1>
	.GET("/person", accept(APPLICATION_JSON), handler::listPeople) // <2>
	.POST("/person", handler::createPerson) // <3>
	.add(otherRoute) // <4>
	.build();
----
<1> 带有与JSON匹配的 `Accept` 标头的 `GET /person/{id}` 被路由到 `PersonHandler.getPerson`
<2> 带有与JSON匹配的 `Accept` 标头的 `GET /person` 被路由到 `PersonHandler.listPeople`
<3> 没有其他谓词的 `POST /person` 被路由到 `PersonHandler.createPerson`，并且
<4> `otherRoute` 是在其他地方创建的路由器函数，并将其添加到构建的路由中。


=== 嵌套路由

一组路由器函数通常具有共享谓词，例如：共享路径。在上面的示例中，共享谓词将是与 `/person` 匹配的路径谓词，由三个路由使用。
使用注解时，你可以通过使用映射到 `/person` 的类级别 `@RequestMapping` 注解来删除此重复项。
在WebFlux.fn中，可以通过路由器函数构建器上的 `path` 方法共享路径谓词。
例如，以上示例的最后几行可以通过使用嵌套路由以以下方式进行改进：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
RouterFunction<ServerResponse> route = route()
	.path("/person", builder -> builder
		.GET("/{id}", accept(APPLICATION_JSON), handler::getPerson)
		.GET("", accept(APPLICATION_JSON), handler::listPeople)
		.POST("/person", handler::createPerson))
	.build();
----

请注意，`path` 的第二个参数是使用路由器构建器的消费者。

尽管基于路径的嵌套是最常见的，但是你可以通过使用构建器上的 `nest` 方法来嵌套在任何种类的谓词上。
上面的内容仍然包含一些以共享的 `Accept`-header 谓词形式出现的重复。通过将 `nest` 方法与 `accept` 一起使用，我们可以进一步改进：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
RouterFunction<ServerResponse> route = route()
	.path("/person", b1 -> b1
		.nest(accept(APPLICATION_JSON), b2 -> b2
			.GET("/{id}", handler::getPerson)
			.GET("", handler::listPeople))
		.POST("/person", handler::createPerson))
	.build();
----


[[webflux-fn-running]]
== 运行服务器

如何在HTTP服务器中运行路由器函数？一个简单的选项是使用以下方法之一将路由器函数转换为 `HttpHandler`：

* `RouterFunctions.toHttpHandler(RouterFunction)`
* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`

然后，可以通过遵循<<spring-webflux.adoc#webflux-httphandler,HttpHandler>>来获取特定于服务器的指令，将返回的
`HttpHandler` 与许多服务器适配器一起使用。

Spring Boot还使用了一个更典型的选项，即通过<<spring-webflux.adoc#webflux-config>>使用基于
<<spring-webflux.adoc#webflux-dispatcher-handler,`DispatcherHandler`>>的设置来运行，
该配置使用Spring配置声明处理请求所需的组件。WebFlux Java配置声明以下基础设施组件以支持函数式端点：

* `RouterFunctionMapping`: 在Spring配置中检测一个或多个 `RouterFunction<?>` bean，通过 `RouterFunction.andOther` 组合它们，
并将请求路由到生成的组合 `RouterFunction`。
* `HandlerFunctionAdapter`: 简单的适配器，使 `DispatcherHandler` 调用映射到请求的 `HandlerFunction`。
* `ServerResponseResultHandler`: 通过调用 `ServerResponse` 的 `writeTo` 方法来处理 `HandlerFunction` 调用的结果。

前面的组件使函数式端点适合于 `DispatcherHandler` 请求处理生命周期，并且（如果有）声明的控制器也可以（可能）与带注解的控制器并排运行。
这也是Spring Boot WebFlux starter启用函数式端点的方式。

以下示例显示了WebFlux Java配置（有关如何运行它，请参见<<spring-webflux.adoc#webflux-dispatcher-handler,DispatcherHandler>>）：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Bean
	public RouterFunction<?> routerFunctionA() {
		// ...
	}

	@Bean
	public RouterFunction<?> routerFunctionB() {
		// ...
	}

	// ...

	@Override
	public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
		// configure message conversion...
	}

	@Override
	public void addCorsMappings(CorsRegistry registry) {
		// configure CORS...
	}

	@Override
	public void configureViewResolvers(ViewResolverRegistry registry) {
		// configure view resolution for HTML rendering...
	}
}
----



[[webflux-fn-handler-filter-function]]
== 过滤处理程序函数

你可以使用路由函数构建器上的 `before`，`after` 或 `filter` 方法来过滤处理程序函数。使用注解，可以通过使用
`@ControllerAdvice`，`ServletFilter` 或同时使用两者来实现类似的功能。该过滤器将应用于构建器构建的所有路由。
这意味着在嵌套路由中定义的过滤器不适用于“顶级”路由。例如，考虑以下示例：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
RouterFunction<ServerResponse> route = route()
	.path("/person", b1 -> b1
		.nest(accept(APPLICATION_JSON), b2 -> b2
			.GET("/{id}", handler::getPerson)
			.GET("", handler::listPeople)
			.before(request -> ServerRequest.from(request) // <1>
				.header("X-RequestHeader", "Value")
				.build()))
		.POST("/person", handler::createPerson))
	.after((request, response) -> logResponse(response)) // <2>
	.build();
----
<1> 添加自定义请求头的 `before` 过滤器仅应用于两个GET路由。
<2> 记录响应的 `after` 过滤器将应用于所有路由，包括嵌套路由。


路由器构建器上的 `filter` 方法采用 `HandlerFilterFunction`：
该函数采用 `ServerRequest` 和 `HandlerFunction` 并返回 `ServerResponse`。处理程序函数参数代表链中的下一个元素。
这通常是路由到的处理程序，但是如果应用了多个，它也可以是另一个过滤器。

现在，我们可以在路由中添加一个简单的安全过滤器，假设我们拥有一个可以确定是否允许特定路径的 `SecurityManager`。
以下示例显示了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----

SecurityManager securityManager = ...

RouterFunction<ServerResponse> route = route()
	.path("/person", b1 -> b1
		.nest(accept(APPLICATION_JSON), b2 -> b2
			.GET("/{id}", handler::getPerson)
			.GET("", handler::listPeople))
		.POST("/person", handler::createPerson))
	.filter((request, next) -> {
		if (securityManager.allowAccessTo(request.path())) {
			return next.handle(request);
		}
		else {
			return ServerResponse.status(UNAUTHORIZED).build();
		}
	})
	.build();
----

前面的示例演示了调用 `next.handle(ServerRequest)` 是可选的。当允许访问时，我们才允许执行处理函数。

除了在路由器函数构建器上使用 `filter` 方法之外，还可以通过 `RouterFunction.filter(HandlerFilterFunction)`
将过滤器应用于现有路由器函数。

NOTE: 通过专用的<<webflux-cors-webfilter,`CorsWebFilter`>>提供对函数式端点的CORS支持。