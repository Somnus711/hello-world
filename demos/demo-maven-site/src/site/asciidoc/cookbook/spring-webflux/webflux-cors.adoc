[[webflux-cors]]
= CORS
[.small]#<<spring-mvc.adoc#mvc-cors,Web MVC>>#

Spring WebFlux使你可以处理CORS（跨源资源共享）。本节介绍如何执行此操作。



[[webflux-cors-intro]]
== 介绍
[.small]#<<spring-mvc.adoc#mvc-cors-intro,Web MVC>>#

出于安全原因，浏览器禁止AJAX调用当前来源以外的资源。
例如，你可以将你的银行帐户放在一个tab中，将evil.com放在另一个tab中。
来自evil.com的脚本不能使用你的凭据向你的银行API发出AJAX请求--例如，从你的帐户中提取资金！

跨域资源共享（CORS）是 http://caniuse.com/#feat=cors[大多数浏览器]实施的 http://www.w3.org/TR/cors/[W3C规范]，
可让你指定授权哪种类型的跨域请求，而不是使用基于IFRAME或JSONP的安全性较低且功能较弱的变通办法。



[[webflux-cors-processing]]
== 处理过程
[.small]#<<spring-mvc.adoc#mvc-cors-processing,Web MVC>>#

CORS规范分为预检，简单和实际请求。要了解CORS的工作原理，你可以阅读
https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[本文]以及其他内容，或者参阅规范以获取更多详细信息。

Spring WebFlux `HandlerMapping` 实现为CORS提供内置支持。
成功将请求映射到处理程序后，`HandlerMapping` 将检查给定请求和处理程序的CORS配置，并采取进一步的措施。
预检请求直接处理，而简单和实际的CORS请求被拦截，验证并设置了所需的CORS响应头。

为了启用跨域请求（即存在 `Origin` 标头，并且与请求的主机不同），你需要具有一些显式声明的CORS配置。
如果找不到匹配的CORS配置，则预检请求将被拒绝。没有将CORS标头添加到简单和实际CORS请求的响应中，因此，浏览器拒绝了它们。

可以使用基于URL模式的 `CorsConfiguration` 映射分别
{api-spring-framework}/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations-java.util.Map-[配置]每个 `HandlerMapping`。
在大多数情况下，应用程序使用WebFlux Java配置声明此类映射，从而导致将单个全局映射传递给所有 `HandlerMapping` 实现。

你可以将 `HandlerMapping` 级别的全局CORS配置与更细粒度的处理程序级别的CORS配置结合使用。
例如，带注解的控制器可以使用类或方法级别的 `@CrossOrigin` 注解（其他处理程序可以实现 `CorsConfigurationSource`）。

全局和本地配置组合的规则通常是相加的--例如，所有全局和所有本地origins。对于仅接受单个值的那些属性
（例如： `allowCredentials` 和 `maxAge`），局部属性值将覆盖全局值。有关更多详细信息，请参见
{api-spring-framework}/web/cors/CorsConfiguration.html#combine-org.springframework.web.cors.CorsConfiguration-[`CorsConfiguration#combine(CorsConfiguration)`]。


[TIP]
====
要从源码中了解更多信息或进行高级自定义，请参阅：

* `CorsConfiguration`
* `CorsProcessor` 和 `DefaultCorsProcessor`
* `AbstractHandlerMapping`
====




[[webflux-cors-controller]]
== `@CrossOrigin`
[.small]#<<spring-mvc.adoc#mvc-cors-controller,Web MVC>>#

{api-spring-framework}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`]
注解启用带注解的控制器方法上的跨域请求，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@RestController
@RequestMapping("/account")
public class AccountController {

	@CrossOrigin
	@GetMapping("/{id}")
	public Mono<Account> retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public Mono<Void> remove(@PathVariable Long id) {
		// ...
	}
}
----

默认情况下，`@CrossOrigin` 允许：

* 所有源。
* 所有头。
* 控制器方法映射到的所有HTTP方法。

默认情况下，`allowedCredentials` 未启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息
（例如：cookie和CSRF tokens），并且仅在适当的地方使用。

`maxAge` 设置为30分钟。

`@CrossOrigin` 在类级别上也受支持，并且被所有方法继承。以下示例指定了一个特定域，并将 `maxAge` 设置为一个小时：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@CrossOrigin(origins = "http://domain2.com", maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

	@GetMapping("/{id}")
	public Mono<Account> retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public Mono<Void> remove(@PathVariable Long id) {
		// ...
	}
}
----

你可以在类和方法级别使用 `@CrossOrigin`，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@CrossOrigin(maxAge = 3600) <1>
@RestController
@RequestMapping("/account")
public class AccountController {

	@CrossOrigin("http://domain2.com") <2>
	@GetMapping("/{id}")
	public Mono<Account> retrieve(@PathVariable Long id) {
		// ...
	}

	@DeleteMapping("/{id}")
	public Mono<Void> remove(@PathVariable Long id) {
		// ...
	}
}
----
<1> 在类级别使用 `@CrossOrigin`。
<2> 在方法级别使用 `@CrossOrigin`。


[[webflux-cors-global]]
== 全局配置
[.small]#<<spring-mvc.adoc#mvc-cors-global,Web MVC>>#

除了细粒度的控制器方法级配置外，你可能还想定义一些全局CORS配置。
你可以在任何 `HandlerMapping` 上分别设置基于URL的 `CorsConfiguration` 映射。
但是，大多数应用程序都使用WebFlux Java配置来执行此操作。

默认情况下，全局配置启用以下功能：

* 所有源。
* 所有头。
* `GET`, `HEAD` 和 `POST` 方法。

默认情况下，`allowedCredentials` 未启用，因为它建立了一个信任级别，可以公开敏感的用户特定信息
（例如：cookie和CSRF tokens），并且仅在适当的地方使用。

`maxAge` 设置为30分钟。

要在WebFlux Java配置中启用CORS，可以使用 `CorsRegistry` 回调，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Configuration
@EnableWebFlux
public class WebConfig implements WebFluxConfigurer {

	@Override
	public void addCorsMappings(CorsRegistry registry) {

		registry.addMapping("/api/**")
			.allowedOrigins("http://domain2.com")
			.allowedMethods("PUT", "DELETE")
			.allowedHeaders("header1", "header2", "header3")
			.exposedHeaders("header1", "header2")
			.allowCredentials(true).maxAge(3600);

		// Add more mappings...
	}
}
----


[[webflux-cors-webfilter]]
== CORS `WebFilter`
[.small]#<<spring-mvc.adoc#mvc-cors-filter,Web MVC>>#

你可以通过内置的 {api-spring-framework}/web/cors/reactive/CorsWebFilter.html[`CorsWebFilter`]
应用CORS支持，该功能非常适合<<webflux-fn,函数式端点>>。

NOTE: 如果你尝试将 `CorsFilter` 与Spring Security一起使用，请记住Spring Security {doc-spring-security}#cors[内置]了对CORS的支持。

要配置过滤器，可以声明一个 `CorsWebFilter` bean并将 `CorsConfigurationSource` 传递给其构造函数，如以下示例所示：

[source,java,indent=0]
[subs="verbatim"]
----
@Bean
CorsWebFilter corsFilter() {

	CorsConfiguration config = new CorsConfiguration();

	// Possibly...
	// config.applyPermitDefaultValues()

	config.setAllowCredentials(true);
	config.addAllowedOrigin("http://domain1.com");
	config.addAllowedHeader("*");
	config.addAllowedMethod("*");

	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	source.registerCorsConfiguration("/**", config);

	return new CorsWebFilter(source);
}
----
